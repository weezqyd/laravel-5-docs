{
    "docs": [
        {
            "location": "/", 
            "text": "Laravel Documentation\n\n\nContribution Guidelines\n\n\nIf you are submitting documentation for the \ncurrent stable release\n, submit it to the corresponding branch. For example, documentation for Laravel 5.1 would be submitted to the \n5.1\n branch. Documentation intended for the next release of Laravel should be submitted to the \nmaster\n branch.", 
            "title": "Home"
        }, 
        {
            "location": "/#laravel-documentation", 
            "text": "", 
            "title": "Laravel Documentation"
        }, 
        {
            "location": "/#contribution-guidelines", 
            "text": "If you are submitting documentation for the  current stable release , submit it to the corresponding branch. For example, documentation for Laravel 5.1 would be submitted to the  5.1  branch. Documentation intended for the next release of Laravel should be submitted to the  master  branch.", 
            "title": "Contribution Guidelines"
        }, 
        {
            "location": "/apis/", 
            "text": "", 
            "title": "Apis"
        }, 
        {
            "location": "/artisan/", 
            "text": "Artisan Console\n\n\n\n\nIntroduction\n\n\nWriting Commands\n\n\nGenerating Commands\n\n\nCommand Structure\n\n\nClosure Commands\n\n\n\n\n\n\nDefining Input Expectations\n\n\nArguments\n\n\nOptions\n\n\nInput Arrays\n\n\nInput Descriptions\n\n\n\n\n\n\nCommand I/O\n\n\nRetrieving Input\n\n\nPrompting For Input\n\n\nWriting Output\n\n\n\n\n\n\nRegistering Commands\n\n\nProgrammatically Executing Commands\n\n\nCalling Commands From Other Commands\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nArtisan is the command-line interface included with Laravel. It provides a number of helpful commands that can assist you while you build your application. To view a list of all available Artisan commands, you may use the \nlist\n command:\n\n\nphp artisan list\n\n\n\n\n\nEvery command also includes a \"help\" screen which displays and describes the command's available arguments and options. To view a help screen, simply precede the name of the command with \nhelp\n:\n\n\nphp artisan help migrate\n\n\n\n\n\nLaravel REPL\n\n\nAll Laravel applications include Tinker, a REPL powered by the \nPsySH\n package. Tinker allows you to interact with your entire Laravel application on the command line, including the Eloquent ORM, jobs, events, and more. To enter the Tinker environment, run the \ntinker\n Artisan command:\n\n\nphp artisan tinker\n\n\n\n\n\n\n\nWriting Commands\n\n\nIn addition to the commands provided with Artisan, you may also build your own custom commands. Commands are typically stored in the \napp/Console/Commands\n directory; however, you are free to choose your own storage location as long as your commands can be loaded by Composer.\n\n\n\n\nGenerating Commands\n\n\nTo create a new command, use the \nmake:command\n Artisan command. This command will create a new command class in the \napp/Console/Commands\n directory. Don't worry if this directory does not exist in your application, since it will be created the first time you run the \nmake:command\n Artisan command. The generated command will include the default set of properties and methods that are present on all commands:\n\n\nphp artisan make:command SendEmails\n\n\n\n\n\nNext, you will need to \nregister the command\n before it can be executed via the Artisan CLI.\n\n\n\n\nCommand Structure\n\n\nAfter generating your command, you should fill in the \nsignature\n and \ndescription\n properties of the class, which will be used when displaying your command on the \nlist\n screen. The \nhandle\n method will be called when your command is executed. You may place your command logic in this method.\n\n\n\n\n{tip} For greater code reuse, it is good practice to keep your console commands light and let them defer to application services to accomplish their tasks. In the example below, note that we inject a service class to do the \"heavy lifting\" of sending the e-mails.\n\n\n\n\nLet's take a look at an example command. Note that we are able to inject any dependencies we need into the command's constructor. The Laravel \nservice container\n will automatically inject all dependencies type-hinted in the constructor:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nConsole\n\\\nCommands\n;\n\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\nuse\n \nApp\n\\\nDripEmailer\n;\n\n\nuse\n \nIlluminate\n\\\nConsole\n\\\nCommand\n;\n\n\n\nclass\n \nSendEmails\n \nextends\n \nCommand\n\n\n{\n\n    \n/**\n\n\n     * The name and signature of the console command.\n\n\n     *\n\n\n     * @var string\n\n\n     */\n\n    \nprotected\n \n$signature\n \n=\n \nemail:send {user}\n;\n\n\n    \n/**\n\n\n     * The console command description.\n\n\n     *\n\n\n     * @var string\n\n\n     */\n\n    \nprotected\n \n$description\n \n=\n \nSend drip e-mails to a user\n;\n\n\n    \n/**\n\n\n     * The drip e-mail service.\n\n\n     *\n\n\n     * @var DripEmailer\n\n\n     */\n\n    \nprotected\n \n$drip\n;\n\n\n    \n/**\n\n\n     * Create a new command instance.\n\n\n     *\n\n\n     * @param  DripEmailer  $drip\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nDripEmailer\n \n$drip\n)\n\n    \n{\n\n        \nparent\n::\n__construct\n();\n\n\n        \n$this\n-\ndrip\n \n=\n \n$drip\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Execute the console command.\n\n\n     *\n\n\n     * @return mixed\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandle\n()\n\n    \n{\n\n        \n$this\n-\ndrip\n-\nsend\n(\nUser\n::\nfind\n(\n$this\n-\nargument\n(\nuser\n)));\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nClosure Commands\n\n\nClosure based commands provide an alternative to defining console commands as classes. In the same way that route Closures are an alternative to controllers, think of command Closures as an alternative to command classes. Within the \ncommands\n method of your \napp/Console/Kernel.php\n file, Laravel loads the \nroutes/console.php\n file:\n\n\n/**\n\n\n * Register the Closure based commands for the application.\n\n\n *\n\n\n * @return void\n\n\n */\n\nprotected\n \nfunction\n \ncommands\n()\n\n\n{\n\n\n    \nrequire\n \nbase_path\n(\nroutes/console.php\n)\n;\n\n\n}\n\n\n\n\n\n\nEven though this file does not define HTTP routes, it defines console based entry points (routes) into your application. Within this file, you may define all of your Closure based routes using the \nArtisan::command\n method. The \ncommand\n method accepts two arguments: the \ncommand signature\n and a Closure which receives the commands arguments and options:\n\n\nArtisan::command(\nbuild \n{\nproject\n}\n, function ($project) \n{\n\n    \n$this\n-\ninfo\n(\nBuilding {$project}!\n);\n\n\n}\n);\n\n\n\n\n\n\nThe Closure is bound to the underlying command instance, so you have full access to all of the helper methods you would typically be able to access on a full command class.\n\n\nType-Hinting Dependencies\n\n\nIn addition to receiving your command's arguments and options, command Closures may also type-hint additional dependencies that you would like resolved out of the \nservice container\n:\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\nuse\n \nApp\n\\\nDripEmailer\n;\n\n\n\nArtisan\n::\ncommand\n(\nemail:send {user}\n,\n \nfunction\n \n(\nDripEmailer\n \n$\ndrip\n,\n \n$\nuser\n)\n \n{\n\n    \n$drip-\nsend(\nUser\n:\n:\nfind\n(\n$\nuser\n));\n\n\n}\n);\n\n\n\n\n\n\nClosure Command Descriptions\n\n\nWhen defining a Closure based command, you may use the \ndescribe\n method to add a description to the command. This description will be displayed when you run the \nphp artisan list\n or \nphp artisan help\n commands:\n\n\nArtisan::command(\nbuild \n{\nproject\n}\n, function ($project) \n{\n\n    \n$this\n-\ninfo\n(\nBuilding {$project}!\n);\n\n\n}\n)-\ndescribe(\nBuild the project\n);\n\n\n\n\n\n\n\n\nDefining Input Expectations\n\n\nWhen writing console commands, it is common to gather input from the user through arguments or options. Laravel makes it very convenient to define the input you expect from the user using the \nsignature\n property on your commands. The \nsignature\n property allows you to define the name, arguments, and options for the command in a single, expressive, route-like syntax.\n\n\n\n\nArguments\n\n\nAll user supplied arguments and options are wrapped in curly braces. In the following example, the command defines one \nrequired\n argument: \nuser\n:\n\n\n/**\n\n\n * The name and signature of the console command.\n\n\n *\n\n\n * @var string\n\n\n */\n\n\nprotected\n \n$\nsignature\n \n=\n \nemail:send {user}\n;\n\n\n\n\n\n\nYou may also make arguments optional and define default values for arguments:\n\n\n// Optional argument...\nemail:send {user?}\n\n// Optional argument with default value...\nemail:send {user=foo}\n\n\n\n\n\n\n\nOptions\n\n\nOptions, like arguments, are another form of user input. Options are prefixed by two hyphens (\n--\n) when they are specified on the command line. There are two types of options: those that receive a value and those that don't. Options that don't receive a value serve as a boolean \"switch\". Let's take a look at an example of this type of option:\n\n\n/**\n\n\n * The name and signature of the console command.\n\n\n *\n\n\n * @var string\n\n\n */\n\n\nprotected\n \n$\nsignature\n \n=\n \nemail:send {user} {--queue}\n;\n\n\n\n\n\n\nIn this example, the \n--queue\n switch may be specified when calling the Artisan command. If the \n--queue\n switch is passed, the value of the option will be \ntrue\n. Otherwise, the value will be \nfalse\n:\n\n\nphp artisan email:send 1 --queue\n\n\n\n\n\n\n\nOptions With Values\n\n\nNext, let's take a look at an option that expects a value. If the user must specify a value for an option, suffix the option name with a \n=\n sign:\n\n\n/**\n\n\n * The name and signature of the console command.\n\n\n *\n\n\n * @var string\n\n\n */\n\n\nprotected\n \n$\nsignature\n \n=\n \nemail:send {user} {--queue=}\n;\n\n\n\n\n\n\nIn this example, the user may pass a value for the option like so:\n\n\nphp artisan email:send 1 --queue=default\n\n\n\n\n\nYou may assign default values to options by specifying the default value after the option name. If no option value is passed by the user, the default value will be used:\n\n\nemail\n:\nsend\n \n{\nuser\n}\n \n{--\nqueue\n=\ndefault\n}\n\n\n\n\n\n\n\n\nOption Shortcuts\n\n\nTo assign a shortcut when defining an option, you may specify it before the option name and use a | delimiter to separate the shortcut from the full option name:\n\n\nemail\n:\nsend\n \n{\nuser\n}\n \n{--\nQ\n|\nqueue\n}\n\n\n\n\n\n\n\n\nInput Arrays\n\n\nIf you would like to define arguments or options to expect array inputs, you may use the \n*\n character. First, let's take a look at an example that specifies an array argument:\n\n\nemail\n:\nsend\n \n{\nuser\n*}\n\n\n\n\n\n\nWhen calling this method, the \nuser\n arguments may be passed in order to the command line. For example, the following command will set the value of \nuser\n to \n['foo', 'bar']\n:\n\n\nphp artisan email:send foo bar\n\n\n\n\n\nWhen defining an option that expects an array input, each option value passed to the command should be prefixed with the option name:\n\n\nemail\n:\nsend\n \n{\nuser\n}\n \n{--\nid\n=*}\n\n\n\nphp\n \nartisan\n \nemail\n:\nsend\n \n--\nid\n=\n1\n \n--\nid\n=\n2\n\n\n\n\n\n\n\n\nInput Descriptions\n\n\nYou may assign descriptions to input arguments and options by separating the parameter from the description using a colon. If you need a little extra room to define your command, feel free to spread the definition across multiple lines:\n\n\n/**\n\n\n * The name and signature of the console command.\n\n\n *\n\n\n * @var string\n\n\n */\n\nprotected\n \n$\nsignature\n \n=\n \nemail:send\n\n\n                        \n{\nuser\n \n:\n \nThe\n \nID\n \nof\n \nthe\n \nuser\n}\n\n\n                        \n{\n--\nqueue\n=\n \n:\n \nWhether\n \nthe\n \njob\n \nshould\n \nbe\n \nqueued\n}\n;\n\n\n\n\n\n\n\n\nCommand I/O\n\n\n\n\nRetrieving Input\n\n\nWhile your command is executing, you will obviously need to access the values for the arguments and options accepted by your command. To do so, you may use the \nargument\n and \noption\n methods:\n\n\n/**\n\n\n * Execute the console command.\n\n\n *\n\n\n * @return mixed\n\n\n */\n\npublic\n \nfunction\n \nhandle\n()\n\n\n{\n\n\n    \n$\nuserId\n \n=\n \n$\nthis\n-\nargument\n(\nuser\n)\n;\n\n\n\n    \n//\n\n\n}\n\n\n\n\n\n\nIf you need to retrieve all of the arguments as an \narray\n, call the \narguments\n method:\n\n\n$arguments = $this-\narguments();\n\n\n\n\n\nOptions may be retrieved just as easily as arguments using the \noption\n method. To retrieve all of the options as an array, call the \noptions\n method:\n\n\n// Retrieve a specific option...\n$queueName = $this-\noption(\nqueue\n);\n\n// Retrieve all options...\n$options = $this-\noptions();\n\n\n\n\n\nIf the argument or option does not exist, \nnull\n will be returned.\n\n\n\n\nPrompting For Input\n\n\nIn addition to displaying output, you may also ask the user to provide input during the execution of your command. The \nask\n method will prompt the user with the given question, accept their input, and then return the user's input back to your command:\n\n\n/**\n\n\n * Execute the console command.\n\n\n *\n\n\n * @return mixed\n\n\n */\n\npublic\n \nfunction\n \nhandle\n()\n\n\n{\n\n\n    \n$\nname\n \n=\n \n$\nthis\n-\nask\n(\nWhat is your name?\n)\n;\n\n\n}\n\n\n\n\n\n\nThe \nsecret\n method is similar to \nask\n, but the user's input will not be visible to them as they type in the console. This method is useful when asking for sensitive information such as a password:\n\n\n$password = $this-\nsecret(\nWhat is the password?\n);\n\n\n\n\n\nAsking For Confirmation\n\n\nIf you need to ask the user for a simple confirmation, you may use the \nconfirm\n method. By default, this method will return \nfalse\n. However, if the user enters \ny\n or \nyes\n in response to the prompt, the method will return \ntrue\n.\n\n\nif ($this-\nconfirm(\nDo you wish to continue?\n)) {\n    //\n}\n\n\n\n\n\nAuto-Completion\n\n\nThe \nanticipate\n method can be used to provide auto-completion for possible choices. The user can still choose any answer, regardless of the auto-completion hints:\n\n\n$name = $this-\nanticipate(\nWhat is your name?\n, [\nTaylor\n, \nDayle\n]);\n\n\n\n\n\nMultiple Choice Questions\n\n\nIf you need to give the user a predefined set of choices, you may use the \nchoice\n method. You may set the default value to be returned if no option is chosen:\n\n\n$name = $this-\nchoice(\nWhat is your name?\n, [\nTaylor\n, \nDayle\n], $default);\n\n\n\n\n\n\n\nWriting Output\n\n\nTo send output to the console, use the \nline\n, \ninfo\n, \ncomment\n, \nquestion\n and \nerror\n methods. Each of these methods will use appropriate ANSI colors for their purpose. For example, let's display some general information to the user. Typically, the \ninfo\n method will display in the console as green text:\n\n\n/**\n\n\n * Execute the console command.\n\n\n *\n\n\n * @return mixed\n\n\n */\n\npublic\n \nfunction\n \nhandle\n()\n\n\n{\n\n\n    \n$\nthis\n-\ninfo\n(\nDisplay this on the screen\n)\n;\n\n\n}\n\n\n\n\n\n\nTo display an error message, use the \nerror\n method. Error message text is typically displayed in red:\n\n\n$this-\nerror(\nSomething went wrong!\n);\n\n\n\n\n\nIf you would like to display plain, uncolored console output, use the \nline\n method:\n\n\n$this-\nline(\nDisplay this on the screen\n);\n\n\n\n\n\nTable Layouts\n\n\nThe \ntable\n method makes it easy to correctly format multiple rows / columns of data. Just pass in the headers and rows to the method. The width and height will be dynamically calculated based on the given data:\n\n\n$\nheaders\n \n=\n \n[\nName\n,\n \nEmail\n]\n;\n\n\n\n$\nusers\n \n=\n \nApp\n\\\nUser\n::\nall\n(\n[\nname\n,\n \nemail\n]\n)\n-\ntoArray\n();\n\n\n\n$\nthis-\ntable\n($\nheaders\n,\n \n$\nusers\n);\n\n\n\n\n\n\nProgress Bars\n\n\nFor long running tasks, it could be helpful to show a progress indicator. Using the output object, we can start, advance and stop the Progress Bar. First, define the total number of steps the process will iterate through. Then, advance the Progress Bar after processing each item:\n\n\n$\nusers\n \n=\n \nApp\n\\\nUser\n::\nall\n();\n\n\n\n$\nbar\n \n=\n \n$\nthis-\noutput-\ncreateProgressBar\n(\ncount\n($\nusers\n));\n\n\n\nforeach\n \n($\nusers\n \nas\n \n$\nuser\n)\n \n{\n\n    \n$this-\nperformTask($user)\n;\n\n\n    \n$bar-\nadvance()\n;\n\n\n}\n\n\n\n$\nbar-\nfinish\n();\n\n\n\n\n\n\nFor more advanced options, check out the \nSymfony Progress Bar component documentation\n.\n\n\n\n\nRegistering Commands\n\n\nOnce your command is finished, you need to register it with Artisan. All commands are registered in the \napp/Console/Kernel.php\n file. Within this file, you will find a list of commands in the \ncommands\n property. To register your command, simply add the command's class name to the list. When Artisan boots, all the commands listed in this property will be resolved by the \nservice container\n and registered with Artisan:\n\n\nprotected $commands = [\n    Commands\\SendEmails::class\n];\n\n\n\n\n\n\n\nProgrammatically Executing Commands\n\n\nSometimes you may wish to execute an Artisan command outside of the CLI. For example, you may wish to fire an Artisan command from a route or controller. You may use the \ncall\n method on the \nArtisan\n facade to accomplish this. The \ncall\n method accepts the name of the command as the first argument, and an array of command parameters as the second argument. The exit code will be returned:\n\n\nRoute::get(\n/foo\n, function () {\n    $exitCode = Artisan::call(\nemail:send\n, [\n        \nuser\n =\n 1, \n--queue\n =\n \ndefault\n\n    ]);\n\n    //\n});\n\n\n\n\n\nUsing the \nqueue\n method on the \nArtisan\n facade, you may even queue Artisan commands so they are processed in the background by your \nqueue workers\n. Before using this method, make sure you have configured your queue and are running a queue listener:\n\n\nRoute::get(\n/foo\n, function () {\n    Artisan::queue(\nemail:send\n, [\n        \nuser\n =\n 1, \n--queue\n =\n \ndefault\n\n    ]);\n\n    //\n});\n\n\n\n\n\nIf you need to specify the value of an option that does not accept string values, such as the \n--force\n flag on the \nmigrate:refresh\n command, you may pass \ntrue\n or \nfalse\n:\n\n\n$exitCode = Artisan::call(\nmigrate:refresh\n, [\n    \n--force\n =\n true,\n]);\n\n\n\n\n\n\n\nCalling Commands From Other Commands\n\n\nSometimes you may wish to call other commands from an existing Artisan command. You may do so using the \ncall\n method. This \ncall\n method accepts the command name and an array of command parameters:\n\n\n/**\n\n\n * Execute the console command.\n\n\n *\n\n\n * @return mixed\n\n\n */\n\npublic\n \nfunction\n \nhandle\n()\n\n\n{\n\n\n    \n$\nthis\n-\ncall\n(\nemail:send\n,\n \n[\n\n\n        \nuser\n \n=\n \n1\n,\n \n--queue\n \n=\n \ndefault\n\n\n    \n]\n)\n;\n\n\n\n    \n//\n\n\n}\n\n\n\n\n\n\nIf you would like to call another console command and suppress all of its output, you may use the \ncallSilent\n method. The \ncallSilent\n method has the same signature as the \ncall\n method:\n\n\n$this-\ncallSilent(\nemail:send\n, [\n    \nuser\n =\n 1, \n--queue\n =\n \ndefault\n\n]);", 
            "title": "Artisan"
        }, 
        {
            "location": "/artisan/#artisan-console", 
            "text": "Introduction  Writing Commands  Generating Commands  Command Structure  Closure Commands    Defining Input Expectations  Arguments  Options  Input Arrays  Input Descriptions    Command I/O  Retrieving Input  Prompting For Input  Writing Output    Registering Commands  Programmatically Executing Commands  Calling Commands From Other Commands", 
            "title": "Artisan Console"
        }, 
        {
            "location": "/artisan/#introduction", 
            "text": "Artisan is the command-line interface included with Laravel. It provides a number of helpful commands that can assist you while you build your application. To view a list of all available Artisan commands, you may use the  list  command:  php artisan list  Every command also includes a \"help\" screen which displays and describes the command's available arguments and options. To view a help screen, simply precede the name of the command with  help :  php artisan help migrate", 
            "title": "Introduction"
        }, 
        {
            "location": "/artisan/#laravel-repl", 
            "text": "All Laravel applications include Tinker, a REPL powered by the  PsySH  package. Tinker allows you to interact with your entire Laravel application on the command line, including the Eloquent ORM, jobs, events, and more. To enter the Tinker environment, run the  tinker  Artisan command:  php artisan tinker", 
            "title": "Laravel REPL"
        }, 
        {
            "location": "/artisan/#writing-commands", 
            "text": "In addition to the commands provided with Artisan, you may also build your own custom commands. Commands are typically stored in the  app/Console/Commands  directory; however, you are free to choose your own storage location as long as your commands can be loaded by Composer.", 
            "title": "Writing Commands"
        }, 
        {
            "location": "/artisan/#generating-commands", 
            "text": "To create a new command, use the  make:command  Artisan command. This command will create a new command class in the  app/Console/Commands  directory. Don't worry if this directory does not exist in your application, since it will be created the first time you run the  make:command  Artisan command. The generated command will include the default set of properties and methods that are present on all commands:  php artisan make:command SendEmails  Next, you will need to  register the command  before it can be executed via the Artisan CLI.", 
            "title": "Generating Commands"
        }, 
        {
            "location": "/artisan/#command-structure", 
            "text": "After generating your command, you should fill in the  signature  and  description  properties of the class, which will be used when displaying your command on the  list  screen. The  handle  method will be called when your command is executed. You may place your command logic in this method.   {tip} For greater code reuse, it is good practice to keep your console commands light and let them defer to application services to accomplish their tasks. In the example below, note that we inject a service class to do the \"heavy lifting\" of sending the e-mails.   Let's take a look at an example command. Note that we are able to inject any dependencies we need into the command's constructor. The Laravel  service container  will automatically inject all dependencies type-hinted in the constructor:  ? php  namespace   App \\ Console \\ Commands ;  use   App \\ User ;  use   App \\ DripEmailer ;  use   Illuminate \\ Console \\ Command ;  class   SendEmails   extends   Command  { \n     /**       * The name and signature of the console command.       *       * @var string       */ \n     protected   $signature   =   email:send {user} ; \n\n     /**       * The console command description.       *       * @var string       */ \n     protected   $description   =   Send drip e-mails to a user ; \n\n     /**       * The drip e-mail service.       *       * @var DripEmailer       */ \n     protected   $drip ; \n\n     /**       * Create a new command instance.       *       * @param  DripEmailer  $drip       * @return void       */ \n     public   function   __construct ( DripEmailer   $drip ) \n     { \n         parent :: __construct (); \n\n         $this - drip   =   $drip ; \n     } \n\n     /**       * Execute the console command.       *       * @return mixed       */ \n     public   function   handle () \n     { \n         $this - drip - send ( User :: find ( $this - argument ( user ))); \n     }  }", 
            "title": "Command Structure"
        }, 
        {
            "location": "/artisan/#closure-commands", 
            "text": "Closure based commands provide an alternative to defining console commands as classes. In the same way that route Closures are an alternative to controllers, think of command Closures as an alternative to command classes. Within the  commands  method of your  app/Console/Kernel.php  file, Laravel loads the  routes/console.php  file:  /**   * Register the Closure based commands for the application.   *   * @return void   */ \nprotected   function   commands ()  {       require   base_path ( routes/console.php ) ;  }   Even though this file does not define HTTP routes, it defines console based entry points (routes) into your application. Within this file, you may define all of your Closure based routes using the  Artisan::command  method. The  command  method accepts two arguments: the  command signature  and a Closure which receives the commands arguments and options:  Artisan::command( build  { project } , function ($project)  { \n     $this - info ( Building {$project}! );  } );   The Closure is bound to the underlying command instance, so you have full access to all of the helper methods you would typically be able to access on a full command class.", 
            "title": "Closure Commands"
        }, 
        {
            "location": "/artisan/#type-hinting-dependencies", 
            "text": "In addition to receiving your command's arguments and options, command Closures may also type-hint additional dependencies that you would like resolved out of the  service container :  use   App \\ User ;  use   App \\ DripEmailer ;  Artisan :: command ( email:send {user} ,   function   ( DripEmailer   $ drip ,   $ user )   { \n     $drip- send( User : : find ( $ user ));  } );", 
            "title": "Type-Hinting Dependencies"
        }, 
        {
            "location": "/artisan/#closure-command-descriptions", 
            "text": "When defining a Closure based command, you may use the  describe  method to add a description to the command. This description will be displayed when you run the  php artisan list  or  php artisan help  commands:  Artisan::command( build  { project } , function ($project)  { \n     $this - info ( Building {$project}! );  } )- describe( Build the project );", 
            "title": "Closure Command Descriptions"
        }, 
        {
            "location": "/artisan/#defining-input-expectations", 
            "text": "When writing console commands, it is common to gather input from the user through arguments or options. Laravel makes it very convenient to define the input you expect from the user using the  signature  property on your commands. The  signature  property allows you to define the name, arguments, and options for the command in a single, expressive, route-like syntax.", 
            "title": "Defining Input Expectations"
        }, 
        {
            "location": "/artisan/#arguments", 
            "text": "All user supplied arguments and options are wrapped in curly braces. In the following example, the command defines one  required  argument:  user :  /**   * The name and signature of the console command.   *   * @var string   */  protected   $ signature   =   email:send {user} ;   You may also make arguments optional and define default values for arguments:  // Optional argument...\nemail:send {user?}\n\n// Optional argument with default value...\nemail:send {user=foo}", 
            "title": "Arguments"
        }, 
        {
            "location": "/artisan/#options", 
            "text": "Options, like arguments, are another form of user input. Options are prefixed by two hyphens ( -- ) when they are specified on the command line. There are two types of options: those that receive a value and those that don't. Options that don't receive a value serve as a boolean \"switch\". Let's take a look at an example of this type of option:  /**   * The name and signature of the console command.   *   * @var string   */  protected   $ signature   =   email:send {user} {--queue} ;   In this example, the  --queue  switch may be specified when calling the Artisan command. If the  --queue  switch is passed, the value of the option will be  true . Otherwise, the value will be  false :  php artisan email:send 1 --queue", 
            "title": "Options"
        }, 
        {
            "location": "/artisan/#options-with-values", 
            "text": "Next, let's take a look at an option that expects a value. If the user must specify a value for an option, suffix the option name with a  =  sign:  /**   * The name and signature of the console command.   *   * @var string   */  protected   $ signature   =   email:send {user} {--queue=} ;   In this example, the user may pass a value for the option like so:  php artisan email:send 1 --queue=default  You may assign default values to options by specifying the default value after the option name. If no option value is passed by the user, the default value will be used:  email : send   { user }   {-- queue = default }", 
            "title": "Options With Values"
        }, 
        {
            "location": "/artisan/#option-shortcuts", 
            "text": "To assign a shortcut when defining an option, you may specify it before the option name and use a | delimiter to separate the shortcut from the full option name:  email : send   { user }   {-- Q | queue }", 
            "title": "Option Shortcuts"
        }, 
        {
            "location": "/artisan/#input-arrays", 
            "text": "If you would like to define arguments or options to expect array inputs, you may use the  *  character. First, let's take a look at an example that specifies an array argument:  email : send   { user *}   When calling this method, the  user  arguments may be passed in order to the command line. For example, the following command will set the value of  user  to  ['foo', 'bar'] :  php artisan email:send foo bar  When defining an option that expects an array input, each option value passed to the command should be prefixed with the option name:  email : send   { user }   {-- id =*}  php   artisan   email : send   -- id = 1   -- id = 2", 
            "title": "Input Arrays"
        }, 
        {
            "location": "/artisan/#input-descriptions", 
            "text": "You may assign descriptions to input arguments and options by separating the parameter from the description using a colon. If you need a little extra room to define your command, feel free to spread the definition across multiple lines:  /**   * The name and signature of the console command.   *   * @var string   */ \nprotected   $ signature   =   email:send                           { user   :   The   ID   of   the   user }                           { -- queue =   :   Whether   the   job   should   be   queued } ;", 
            "title": "Input Descriptions"
        }, 
        {
            "location": "/artisan/#command-io", 
            "text": "", 
            "title": "Command I/O"
        }, 
        {
            "location": "/artisan/#retrieving-input", 
            "text": "While your command is executing, you will obviously need to access the values for the arguments and options accepted by your command. To do so, you may use the  argument  and  option  methods:  /**   * Execute the console command.   *   * @return mixed   */ \npublic   function   handle ()  {       $ userId   =   $ this - argument ( user ) ;       //  }   If you need to retrieve all of the arguments as an  array , call the  arguments  method:  $arguments = $this- arguments();  Options may be retrieved just as easily as arguments using the  option  method. To retrieve all of the options as an array, call the  options  method:  // Retrieve a specific option...\n$queueName = $this- option( queue );\n\n// Retrieve all options...\n$options = $this- options();  If the argument or option does not exist,  null  will be returned.", 
            "title": "Retrieving Input"
        }, 
        {
            "location": "/artisan/#prompting-for-input", 
            "text": "In addition to displaying output, you may also ask the user to provide input during the execution of your command. The  ask  method will prompt the user with the given question, accept their input, and then return the user's input back to your command:  /**   * Execute the console command.   *   * @return mixed   */ \npublic   function   handle ()  {       $ name   =   $ this - ask ( What is your name? ) ;  }   The  secret  method is similar to  ask , but the user's input will not be visible to them as they type in the console. This method is useful when asking for sensitive information such as a password:  $password = $this- secret( What is the password? );", 
            "title": "Prompting For Input"
        }, 
        {
            "location": "/artisan/#asking-for-confirmation", 
            "text": "If you need to ask the user for a simple confirmation, you may use the  confirm  method. By default, this method will return  false . However, if the user enters  y  or  yes  in response to the prompt, the method will return  true .  if ($this- confirm( Do you wish to continue? )) {\n    //\n}", 
            "title": "Asking For Confirmation"
        }, 
        {
            "location": "/artisan/#auto-completion", 
            "text": "The  anticipate  method can be used to provide auto-completion for possible choices. The user can still choose any answer, regardless of the auto-completion hints:  $name = $this- anticipate( What is your name? , [ Taylor ,  Dayle ]);", 
            "title": "Auto-Completion"
        }, 
        {
            "location": "/artisan/#multiple-choice-questions", 
            "text": "If you need to give the user a predefined set of choices, you may use the  choice  method. You may set the default value to be returned if no option is chosen:  $name = $this- choice( What is your name? , [ Taylor ,  Dayle ], $default);", 
            "title": "Multiple Choice Questions"
        }, 
        {
            "location": "/artisan/#writing-output", 
            "text": "To send output to the console, use the  line ,  info ,  comment ,  question  and  error  methods. Each of these methods will use appropriate ANSI colors for their purpose. For example, let's display some general information to the user. Typically, the  info  method will display in the console as green text:  /**   * Execute the console command.   *   * @return mixed   */ \npublic   function   handle ()  {       $ this - info ( Display this on the screen ) ;  }   To display an error message, use the  error  method. Error message text is typically displayed in red:  $this- error( Something went wrong! );  If you would like to display plain, uncolored console output, use the  line  method:  $this- line( Display this on the screen );", 
            "title": "Writing Output"
        }, 
        {
            "location": "/artisan/#table-layouts", 
            "text": "The  table  method makes it easy to correctly format multiple rows / columns of data. Just pass in the headers and rows to the method. The width and height will be dynamically calculated based on the given data:  $ headers   =   [ Name ,   Email ] ;  $ users   =   App \\ User :: all ( [ name ,   email ] ) - toArray ();  $ this- table ($ headers ,   $ users );", 
            "title": "Table Layouts"
        }, 
        {
            "location": "/artisan/#progress-bars", 
            "text": "For long running tasks, it could be helpful to show a progress indicator. Using the output object, we can start, advance and stop the Progress Bar. First, define the total number of steps the process will iterate through. Then, advance the Progress Bar after processing each item:  $ users   =   App \\ User :: all ();  $ bar   =   $ this- output- createProgressBar ( count ($ users ));  foreach   ($ users   as   $ user )   { \n     $this- performTask($user) ; \n\n     $bar- advance() ;  }  $ bar- finish ();   For more advanced options, check out the  Symfony Progress Bar component documentation .", 
            "title": "Progress Bars"
        }, 
        {
            "location": "/artisan/#registering-commands", 
            "text": "Once your command is finished, you need to register it with Artisan. All commands are registered in the  app/Console/Kernel.php  file. Within this file, you will find a list of commands in the  commands  property. To register your command, simply add the command's class name to the list. When Artisan boots, all the commands listed in this property will be resolved by the  service container  and registered with Artisan:  protected $commands = [\n    Commands\\SendEmails::class\n];", 
            "title": "Registering Commands"
        }, 
        {
            "location": "/artisan/#programmatically-executing-commands", 
            "text": "Sometimes you may wish to execute an Artisan command outside of the CLI. For example, you may wish to fire an Artisan command from a route or controller. You may use the  call  method on the  Artisan  facade to accomplish this. The  call  method accepts the name of the command as the first argument, and an array of command parameters as the second argument. The exit code will be returned:  Route::get( /foo , function () {\n    $exitCode = Artisan::call( email:send , [\n         user  =  1,  --queue  =   default \n    ]);\n\n    //\n});  Using the  queue  method on the  Artisan  facade, you may even queue Artisan commands so they are processed in the background by your  queue workers . Before using this method, make sure you have configured your queue and are running a queue listener:  Route::get( /foo , function () {\n    Artisan::queue( email:send , [\n         user  =  1,  --queue  =   default \n    ]);\n\n    //\n});  If you need to specify the value of an option that does not accept string values, such as the  --force  flag on the  migrate:refresh  command, you may pass  true  or  false :  $exitCode = Artisan::call( migrate:refresh , [\n     --force  =  true,\n]);", 
            "title": "Programmatically Executing Commands"
        }, 
        {
            "location": "/artisan/#calling-commands-from-other-commands", 
            "text": "Sometimes you may wish to call other commands from an existing Artisan command. You may do so using the  call  method. This  call  method accepts the command name and an array of command parameters:  /**   * Execute the console command.   *   * @return mixed   */ \npublic   function   handle ()  {       $ this - call ( email:send ,   [           user   =   1 ,   --queue   =   default       ] ) ;       //  }   If you would like to call another console command and suppress all of its output, you may use the  callSilent  method. The  callSilent  method has the same signature as the  call  method:  $this- callSilent( email:send , [\n     user  =  1,  --queue  =   default \n]);", 
            "title": "Calling Commands From Other Commands"
        }, 
        {
            "location": "/authentication/", 
            "text": "Authentication\n\n\n\n\nIntroduction\n\n\nDatabase Considerations\n\n\n\n\n\n\nAuthentication Quickstart\n\n\nRouting\n\n\nViews\n\n\nAuthenticating\n\n\nRetrieving The Authenticated User\n\n\nProtecting Routes\n\n\nLogin Throttling\n\n\n\n\n\n\nManually Authenticating Users\n\n\nRemembering Users\n\n\nOther Authentication Methods\n\n\n\n\n\n\nHTTP Basic Authentication\n\n\nStateless HTTP Basic Authentication\n\n\n\n\n\n\nSocial Authentication\n\n\nAdding Custom Guards\n\n\nAdding Custom User Providers\n\n\nThe User Provider Contract\n\n\nThe Authenticatable Contract\n\n\n\n\n\n\nEvents\n\n\n\n\n\n\nIntroduction\n\n\n\n\n{tip} \nWant to get started fast?\n Just run \nphp artisan make:auth\n and \nphp artisan migrate\n in a fresh Laravel application. Then, navigate your browser to \nhttp://your-app.dev/register\n or any other URL that is assigned to your application. These two commands will take care of scaffolding your entire authentication system!\n\n\n\n\nLaravel makes implementing authentication very simple. In fact, almost everything is configured for you out of the box. The authentication configuration file is located at \nconfig/auth.php\n, which contains several well documented options for tweaking the behavior of the authentication services.\n\n\nAt its core, Laravel's authentication facilities are made up of \"guards\" and \"providers\". Guards define how users are authenticated for each request. For example, Laravel ships with a \nsession\n guard which maintains state using session storage and cookies.\n\n\nProviders define how users are retrieved from your persistent storage. Laravel ships with support for retrieving users using Eloquent and the database query builder. However, you are free to define additional providers as needed for your application.\n\n\nDon't worry if this all sounds confusing now! Many applications will never need to modify the default authentication configuration.\n\n\n\n\nDatabase Considerations\n\n\nBy default, Laravel includes an \nApp\\User\n \nEloquent model\n in your \napp\n directory. This model may be used with the default Eloquent authentication driver. If your application is not using Eloquent, you may use the \ndatabase\n authentication driver which uses the Laravel query builder.\n\n\nWhen building the database schema for the \nApp\\User\n model, make sure the password column is at least 60 characters in length. Maintaining the default string column length of 255 characters would be a good choice.\n\n\nAlso, you should verify that your \nusers\n (or equivalent) table contains a nullable, string \nremember_token\n column of 100 characters. This column will be used to store a token for users that select the \"remember me\" option when logging into your application.\n\n\n\n\nAuthentication Quickstart\n\n\nLaravel ships with several pre-built authentication controllers, which are located in the \nApp\\Http\\Controllers\\Auth\n namespace. The \nRegisterController\n handles new user registration, the \nLoginController\n handles authentication, the \nForgotPasswordController\n handles e-mailing links for resetting passwords, and the \nResetPasswordController\n contains the logic to reset passwords. Each of these controllers uses a trait to include their necessary methods. For many applications, you will not need to modify these controllers at all.\n\n\n\n\nRouting\n\n\nLaravel provides a quick way to scaffold all of the routes and views you need for authentication using one simple command:\n\n\nphp artisan make:auth\n\n\n\n\n\nThis command should be used on fresh applications and will install a layout view, registration and login views, as well as routes for all authentication end-points. A \nHomeController\n will also be generated to handle post-login requests to your application's dashboard.\n\n\n\n\nViews\n\n\nAs mentioned in the previous section, the \nphp artisan make:auth\n command will create all of the views you need for authentication and place them in the \nresources/views/auth\n directory.\n\n\nThe \nmake:auth\n command will also create a \nresources/views/layouts\n directory containing a base layout for your application. All of these views use the Bootstrap CSS framework, but you are free to customize them however you wish.\n\n\n\n\nAuthenticating\n\n\nNow that you have routes and views setup for the included authentication controllers, you are ready to register and authenticate new users for your application! You may simply access your application in a browser since the authentication controllers already contain the logic (via their traits) to authenticate existing users and store new users in the database.\n\n\nPath Customization\n\n\nWhen a user is successfully authenticated, they will be redirected to the \n/home\n URI. You can customize the post-authentication redirect location by defining a \nredirectTo\n property on the \nLoginController\n, \nRegisterController\n, and \nResetPasswordController\n:\n\n\nprotected $redirectTo = \n/\n;\n\n\n\n\n\nIf the redirect path needs custom generation logic you may define a \nredirectTo\n method instead of a \nredirectTo\n property:\n\n\nprotected function redirectTo()\n{\n    return \n/path\n;\n}\n\n\n\n\n\n\n\n{tip} The \nredirectTo\n method will take precedence over the \nredirectTo\n attribute.\n\n\n\n\nUsername Customization\n\n\nBy default, Laravel uses the \nemail\n field for authentication. If you would like to customize this, you may define a \nusername\n method on your \nLoginController\n:\n\n\npublic function username()\n{\n    return \nusername\n;\n}\n\n\n\n\n\nGuard Customization\n\n\nYou may also customize the \"guard\" that is used to authenticate and register users. To get started, define a \nguard\n method on your \nLoginController\n, \nRegisterController\n, and \nResetPasswordController\n. The method should return a guard instance:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nAuth\n;\n\n\n\nprotected\n \nfunction\n \nguard\n()\n\n\n{\n\n    \nreturn\n \nAuth\n:\n:\nguard\n(\nguard-name\n);\n\n\n}\n\n\n\n\n\n\nValidation / Storage Customization\n\n\nTo modify the form fields that are required when a new user registers with your application, or to customize how new users are stored into your database, you may modify the \nRegisterController\n class. This class is responsible for validating and creating new users of your application.\n\n\nThe \nvalidator\n method of the \nRegisterController\n contains the validation rules for new users of the application. You are free to modify this method as you wish.\n\n\nThe \ncreate\n method of the \nRegisterController\n is responsible for creating new \nApp\\User\n records in your database using the \nEloquent ORM\n. You are free to modify this method according to the needs of your database.\n\n\n\n\nRetrieving The Authenticated User\n\n\nYou may access the authenticated user via the \nAuth\n facade:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nAuth\n;\n\n\n\n//\n \nGet\n \nthe\n \ncurrently\n \nauthenticated\n \nuser\n...\n\n\n$\nuser\n \n=\n \nAuth\n::\nuser\n();\n\n\n\n//\n \nGet\n \nthe\n \ncurrently\n \nauthenticated\n \nuser\ns\n \nID\n...\n\n\n$\nid\n \n=\n \nAuth\n::\nid\n();\n\n\n\n\n\n\nAlternatively, once a user is authenticated, you may access the authenticated user via an \nIlluminate\\Http\\Request\n instance. Remember, type-hinted classes will automatically be injected into your controller methods:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\n\nclass\n \nProfileController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Update the user\ns profile.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nupdate\n(\nRequest\n \n$request\n)\n\n    \n{\n\n        \n// $request-\nuser() returns an instance of the authenticated user...\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDetermining If The Current User Is Authenticated\n\n\nTo determine if the user is already logged into your application, you may use the \ncheck\n method on the \nAuth\n facade, which will return \ntrue\n if the user is authenticated:\n\n\nuse Illuminate\\Support\\Facades\\Auth;\n\nif (Auth::check()) {\n    // The user is logged in...\n}\n\n\n\n\n\n\n\n{tip} Even though it is possible to determine if a user is authenticated using the \ncheck\n method, you will typically use a middleware to verify that the user is authenticated before allowing the user access to certain routes / controllers. To learn more about this, check out the documentation on \nprotecting routes\n.\n\n\n\n\n\n\nProtecting Routes\n\n\nRoute middleware\n can be used to only allow authenticated users to access a given route. Laravel ships with an \nauth\n middleware, which is defined at \nIlluminate\\Auth\\Middleware\\Authenticate\n. Since this middleware is already registered in your HTTP kernel, all you need to do is attach the middleware to a route definition:\n\n\nRoute::get(\nprofile\n, function () {\n    // Only authenticated users may enter...\n})-\nmiddleware(\nauth\n);\n\n\n\n\n\nOf course, if you are using \ncontrollers\n, you may call the \nmiddleware\n method from the controller's constructor instead of attaching it in the route definition directly:\n\n\npublic function __construct()\n{\n    $this-\nmiddleware(\nauth\n);\n}\n\n\n\n\n\nSpecifying A Guard\n\n\nWhen attaching the \nauth\n middleware to a route, you may also specify which guard should be used to authenticate the user. The guard specified should correspond to one of the keys in the \nguards\n array of your \nauth.php\n configuration file:\n\n\npublic\n \nfunction\n \n__construct\n()\n\n\n{\n\n    \n$this-\nmiddleware(\nauth\n:\napi\n);\n\n\n}\n\n\n\n\n\n\n\n\nLogin Throttling\n\n\nIf you are using Laravel's built-in \nLoginController\n class, the \nIlluminate\\Foundation\\Auth\\ThrottlesLogins\n trait will already be included in your controller. By default, the user will not be able to login for one minute if they fail to provide the correct credentials after several attempts. The throttling is unique to the user's username / e-mail address and their IP address.\n\n\n\n\nManually Authenticating Users\n\n\nOf course, you are not required to use the authentication controllers included with Laravel. If you choose to remove these controllers, you will need to manage user authentication using the Laravel authentication classes directly. Don't worry, it's a cinch!\n\n\nWe will access Laravel's authentication services via the \nAuth\n \nfacade\n, so we'll need to make sure to import the \nAuth\n facade at the top of the class. Next, let's check out the \nattempt\n method:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nAuth\n;\n\n\n\nclass\n \nLoginController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Handle an authentication attempt.\n\n\n     *\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nauthenticate\n()\n\n    \n{\n\n        \nif\n \n(\nAuth\n::\nattempt\n([\nemail\n \n=\n \n$email\n,\n \npassword\n \n=\n \n$password\n]))\n \n{\n\n            \n// Authentication passed...\n\n            \nreturn\n \nredirect\n()\n-\nintended\n(\ndashboard\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe \nattempt\n method accepts an array of key / value pairs as its first argument. The values in the array will be used to find the user in your database table. So, in the example above, the user will be retrieved by the value of the \nemail\n column. If the user is found, the hashed password stored in the database will be compared with the hashed \npassword\n value passed to the method via the array. If the two hashed passwords match an authenticated session will be started for the user.\n\n\nThe \nattempt\n method will return \ntrue\n if authentication was successful. Otherwise, \nfalse\n will be returned.\n\n\nThe \nintended\n method on the redirector will redirect the user to the URL they were attempting to access before being intercepted by the authentication middleware. A fallback URI may be given to this method in case the intended destination is not available.\n\n\nSpecifying Additional Conditions\n\n\nIf you wish, you also may add extra conditions to the authentication query in addition to the user's e-mail and password. For example, we may verify that user is marked as \"active\":\n\n\nif (Auth::attempt([\nemail\n =\n $email, \npassword\n =\n $password, \nactive\n =\n 1])) {\n    // The user is active, not suspended, and exists.\n}\n\n\n\n\n\n\n\n{note} In these examples, \nemail\n is not a required option, it is merely used as an example. You should use whatever column name corresponds to a \"username\" in your database.\n\n\n\n\nAccessing Specific Guard Instances\n\n\nYou may specify which guard instance you would like to utilize using the \nguard\n method on the \nAuth\n facade. This allows you to manage authentication for separate parts of your application using entirely separate authenticatable models or user tables.\n\n\nThe guard name passed to the \nguard\n method should correspond to one of the guards configured in your \nauth.php\n configuration file:\n\n\nif (Auth::guard(\nadmin\n)-\nattempt($credentials)) {\n    //\n}\n\n\n\n\n\nLogging Out\n\n\nTo log users out of your application, you may use the \nlogout\n method on the \nAuth\n facade. This will clear the authentication information in the user's session:\n\n\nAuth\n::\nlogout\n();\n\n\n\n\n\n\n\n\nRemembering Users\n\n\nIf you would like to provide \"remember me\" functionality in your application, you may pass a boolean value as the second argument to the \nattempt\n method, which will keep the user authenticated indefinitely, or until they manually logout. Of course, your \nusers\n table must include the string \nremember_token\n column, which will be used to store the \"remember me\" token.\n\n\nif (Auth::attempt([\nemail\n =\n $email, \npassword\n =\n $password], $remember)) {\n    // The user is being remembered...\n}\n\n\n\n\n\n\n\n{tip} If you are using the built-in \nLoginController\n that is shipped with Laravel, the proper logic to \"remember\" users is already implemented by the traits used by the controller.\n\n\n\n\nIf you are \"remembering\" users, you may use the \nviaRemember\n method to determine if the user was authenticated using the \"remember me\" cookie:\n\n\nif (Auth::viaRemember()) {\n    //\n}\n\n\n\n\n\n\n\nOther Authentication Methods\n\n\nAuthenticate A User Instance\n\n\nIf you need to log an existing user instance into your application, you may call the \nlogin\n method with the user instance. The given object must be an implementation of the \nIlluminate\\Contracts\\Auth\\Authenticatable\n \ncontract\n. Of course, the \nApp\\User\n model included with Laravel already implements this interface:\n\n\nAuth\n::\nlogin\n($\nuser\n);\n\n\n\n//\n \nLogin\n \nand\n \nremember\n \nthe\n \ngiven\n \nuser\n...\n\n\nAuth\n::\nlogin\n($\nuser\n,\n \ntrue\n);\n\n\n\n\n\n\nOf course, you may specify the guard instance you would like to use:\n\n\nAuth\n::\nguard\n(\nadmin\n)\n-\nlogin\n($\nuser\n);\n\n\n\n\n\n\nAuthenticate A User By ID\n\n\nTo log a user into the application by their ID, you may use the \nloginUsingId\n method. This method simply accepts the primary key of the user you wish to authenticate:\n\n\nAuth\n::\nloginUsingId\n(\n1\n);\n\n\n\n//\n \nLogin\n \nand\n \nremember\n \nthe\n \ngiven\n \nuser\n...\n\n\nAuth\n::\nloginUsingId\n(\n1\n,\n \ntrue\n);\n\n\n\n\n\n\nAuthenticate A User Once\n\n\nYou may use the \nonce\n method to log a user into the application for a single request. No sessions or cookies will be utilized, which means this method may be helpful when building a stateless API:\n\n\nif (Auth::once($credentials)) {\n    //\n}\n\n\n\n\n\n\n\nHTTP Basic Authentication\n\n\nHTTP Basic Authentication\n provides a quick way to authenticate users of your application without setting up a dedicated \"login\" page. To get started, attach the \nauth.basic\n \nmiddleware\n to your route. The \nauth.basic\n middleware is included with the Laravel framework, so you do not need to define it:\n\n\nRoute::get(\nprofile\n, function () {\n    // Only authenticated users may enter...\n})-\nmiddleware(\nauth.basic\n);\n\n\n\n\n\nOnce the middleware has been attached to the route, you will automatically be prompted for credentials when accessing the route in your browser. By default, the \nauth.basic\n middleware will use the \nemail\n column on the user record as the \"username\".\n\n\nA Note On FastCGI\n\n\nIf you are using PHP FastCGI, HTTP Basic authentication may not work correctly out of the box. The following lines should be added to your \n.htaccess\n file:\n\n\nRewriteCond %{HTTP:Authorization} ^(.+)$\nRewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\n\n\n\n\n\n\n\nStateless HTTP Basic Authentication\n\n\nYou may also use HTTP Basic Authentication without setting a user identifier cookie in the session, which is particularly useful for API authentication. To do so, \ndefine a middleware\n that calls the \nonceBasic\n method. If no response is returned by the \nonceBasic\n method, the request may be passed further into the application:\n\n\n?\nphp\n\n\n\nnamespace\n \nIlluminate\n\\\nAuth\n\\\nMiddleware\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nAuth\n;\n\n\n\nclass\n \nAuthenticateOnceWithBasicAuth\n\n\n{\n\n    \n/**\n\n\n     * Handle an incoming request.\n\n\n     *\n\n\n     * @param  \\Illuminate\\Http\\Request  $request\n\n\n     * @param  \\Closure  $next\n\n\n     * @return mixed\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandle\n(\n$request\n,\n \n$next\n)\n\n    \n{\n\n        \nreturn\n \nAuth\n::\nonceBasic\n()\n \n?:\n \n$next\n(\n$request\n);\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\nNext, \nregister the route middleware\n and attach it to a route:\n\n\nRoute::get(\napi/user\n, function () {\n    // Only authenticated users may enter...\n})-\nmiddleware(\nauth.basic.once\n);\n\n\n\n\n\n\n\nAdding Custom Guards\n\n\nYou may define your own authentication guards using the \nextend\n method on the \nAuth\n facade. You should place this call to \nprovider\n within a \nservice provider\n. Since Laravel already ships with an \nAuthServiceProvider\n, we can place the code in that provider:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nApp\n\\\nServices\n\\\nAuth\n\\\nJwtGuard\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nAuth\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nSupport\n\\\nProviders\n\\\nAuthServiceProvider\n \nas\n \nServiceProvider\n;\n\n\n\nclass\n \nAuthServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Register any application authentication / authorization services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \n$this\n-\nregisterPolicies\n();\n\n\n        \nAuth\n::\nextend\n(\njwt\n,\n \nfunction\n \n(\n$app\n,\n \n$name\n,\n \narray\n \n$config\n)\n \n{\n\n            \n// Return an instance of Illuminate\\Contracts\\Auth\\Guard...\n\n\n            \nreturn\n \nnew\n \nJwtGuard\n(\nAuth\n::\ncreateUserProvider\n(\n$config\n[\nprovider\n]));\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAs you can see in the example above, the callback passed to the \nextend\n method should return an implementation of \nIlluminate\\Contracts\\Auth\\Guard\n. This interface contains a few methods you will need to implement to define a custom guard. Once your custom guard has been defined, you may use the guard in the \nguards\n configuration of your \nauth.php\n configuration file:\n\n\nguards\n =\n [\n    \napi\n =\n [\n        \ndriver\n =\n \njwt\n,\n        \nprovider\n =\n \nusers\n,\n    ],\n],\n\n\n\n\n\n\n\nAdding Custom User Providers\n\n\nIf you are not using a traditional relational database to store your users, you will need to extend Laravel with your own authentication user provider. We will use the \nprovider\n method on the \nAuth\n facade to define a custom user provider:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nAuth\n;\n\n\nuse\n \nApp\n\\\nExtensions\n\\\nRiakUserProvider\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\n\nclass\n \nAuthServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Register any application authentication / authorization services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \n$this\n-\nregisterPolicies\n();\n\n\n        \nAuth\n::\nprovider\n(\nriak\n,\n \nfunction\n \n(\n$app\n,\n \narray\n \n$config\n)\n \n{\n\n            \n// Return an instance of Illuminate\\Contracts\\Auth\\UserProvider...\n\n\n            \nreturn\n \nnew\n \nRiakUserProvider\n(\n$app\n-\nmake\n(\nriak.connection\n));\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAfter you have registered the provider using the \nprovider\n method, you may switch to the new user provider in your \nauth.php\n configuration file. First, define a \nprovider\n that uses your new driver:\n\n\nproviders\n =\n [\n    \nusers\n =\n [\n        \ndriver\n =\n \nriak\n,\n    ],\n],\n\n\n\n\n\nFinally, you may use this provider in your \nguards\n configuration:\n\n\nguards\n =\n [\n    \nweb\n =\n [\n        \ndriver\n =\n \nsession\n,\n        \nprovider\n =\n \nusers\n,\n    ],\n],\n\n\n\n\n\n\n\nThe User Provider Contract\n\n\nThe \nIlluminate\\Contracts\\Auth\\UserProvider\n implementations are only responsible for fetching a \nIlluminate\\Contracts\\Auth\\Authenticatable\n implementation out of a persistent storage system, such as MySQL, Riak, etc. These two interfaces allow the Laravel authentication mechanisms to continue functioning regardless of how the user data is stored or what type of class is used to represent it.\n\n\nLet's take a look at the \nIlluminate\\Contracts\\Auth\\UserProvider\n contract:\n\n\n?\nphp\n\n\n\nnamespace\n \nIlluminate\n\\\nContracts\n\\\nAuth\n;\n\n\n\ninterface\n \nUserProvider\n \n{\n\n\n    \npublic\n \nfunction\n \nretrieveById\n(\n$identifier\n);\n\n    \npublic\n \nfunction\n \nretrieveByToken\n(\n$identifier\n,\n \n$token\n);\n\n    \npublic\n \nfunction\n \nupdateRememberToken\n(\nAuthenticatable\n \n$user\n,\n \n$token\n);\n\n    \npublic\n \nfunction\n \nretrieveByCredentials\n(\narray\n \n$credentials\n);\n\n    \npublic\n \nfunction\n \nvalidateCredentials\n(\nAuthenticatable\n \n$user\n,\n \narray\n \n$credentials\n);\n\n\n\n}\n\n\n\n\n\n\nThe \nretrieveById\n function typically receives a key representing the user, such as an auto-incrementing ID from a MySQL database. The \nAuthenticatable\n implementation matching the ID should be retrieved and returned by the method.\n\n\nThe \nretrieveByToken\n function retrieves a user by their unique \n$identifier\n and \"remember me\" \n$token\n, stored in a field \nremember_token\n. As with the previous method, the \nAuthenticatable\n implementation should be returned.\n\n\nThe \nupdateRememberToken\n method updates the \n$user\n field \nremember_token\n with the new \n$token\n. The new token can be either a fresh token, assigned on a successful \"remember me\" login attempt, or \nnull\n when the user is logging out.\n\n\nThe \nretrieveByCredentials\n method receives the array of credentials passed to the \nAuth::attempt\n method when attempting to sign into an application. The method should then \"query\" the underlying persistent storage for the user matching those credentials. Typically, this method will run a query with a \"where\" condition on \n$credentials['username']\n. The method should then return an implementation of \nAuthenticatable\n. \nThis method should not attempt to do any password validation or authentication.\n\n\nThe \nvalidateCredentials\n method should compare the given \n$user\n with the \n$credentials\n to authenticate the user. For example, this method should probably use \nHash::check\n to compare the value of \n$user-\ngetAuthPassword()\n to the value of \n$credentials['password']\n. This method should return \ntrue\n or \nfalse\n indicating on whether the password is valid.\n\n\n\n\nThe Authenticatable Contract\n\n\nNow that we have explored each of the methods on the \nUserProvider\n, let's take a look at the \nAuthenticatable\n contract. Remember, the provider should return implementations of this interface from the \nretrieveById\n and \nretrieveByCredentials\n methods:\n\n\n?\nphp\n\n\n\nnamespace\n \nIlluminate\n\\\nContracts\n\\\nAuth\n;\n\n\n\ninterface\n \nAuthenticatable\n \n{\n\n\n    \npublic\n \nfunction\n \ngetAuthIdentifierName\n();\n\n    \npublic\n \nfunction\n \ngetAuthIdentifier\n();\n\n    \npublic\n \nfunction\n \ngetAuthPassword\n();\n\n    \npublic\n \nfunction\n \ngetRememberToken\n();\n\n    \npublic\n \nfunction\n \nsetRememberToken\n(\n$value\n);\n\n    \npublic\n \nfunction\n \ngetRememberTokenName\n();\n\n\n\n}\n\n\n\n\n\n\nThis interface is simple. The \ngetAuthIdentifierName\n method should return the name of the \"primary key\" field of the user and the \ngetAuthIdentifier\n method should return the \"primary key\" of the user. In a MySQL back-end, again, this would be the auto-incrementing primary key. The \ngetAuthPassword\n should return the user's hashed password. This interface allows the authentication system to work with any User class, regardless of what ORM or storage abstraction layer you are using. By default, Laravel includes a \nUser\n class in the \napp\n directory which implements this interface, so you may consult this class for an implementation example.\n\n\n\n\nEvents\n\n\nLaravel raises a variety of \nevents\n during the authentication process. You may attach listeners to these events in your \nEventServiceProvider\n:\n\n\n/**\n\n\n * The event listener mappings for the application.\n\n\n *\n\n\n * @var array\n\n\n */\n\nprotected\n \n$\nlisten\n \n=\n \n[\n\n\n    \nIlluminate\\Auth\\Events\\Registered\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogRegisteredUser\n,\n\n\n    \n]\n,\n\n\n\n    \nIlluminate\\Auth\\Events\\Attempting\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogAuthenticationAttempt\n,\n\n\n    \n]\n,\n\n\n\n    \nIlluminate\\Auth\\Events\\Authenticated\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogAuthenticated\n,\n\n\n    \n]\n,\n\n\n\n    \nIlluminate\\Auth\\Events\\Login\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogSuccessfulLogin\n,\n\n\n    \n]\n,\n\n\n\n    \nIlluminate\\Auth\\Events\\Failed\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogFailedLogin\n,\n\n\n    \n]\n,\n\n\n\n    \nIlluminate\\Auth\\Events\\Logout\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogSuccessfulLogout\n,\n\n\n    \n]\n,\n\n\n\n    \nIlluminate\\Auth\\Events\\Lockout\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogLockout\n,\n\n\n    \n]\n,\n\n\n];", 
            "title": "Authentication"
        }, 
        {
            "location": "/authentication/#authentication", 
            "text": "Introduction  Database Considerations    Authentication Quickstart  Routing  Views  Authenticating  Retrieving The Authenticated User  Protecting Routes  Login Throttling    Manually Authenticating Users  Remembering Users  Other Authentication Methods    HTTP Basic Authentication  Stateless HTTP Basic Authentication    Social Authentication  Adding Custom Guards  Adding Custom User Providers  The User Provider Contract  The Authenticatable Contract    Events", 
            "title": "Authentication"
        }, 
        {
            "location": "/authentication/#introduction", 
            "text": "{tip}  Want to get started fast?  Just run  php artisan make:auth  and  php artisan migrate  in a fresh Laravel application. Then, navigate your browser to  http://your-app.dev/register  or any other URL that is assigned to your application. These two commands will take care of scaffolding your entire authentication system!   Laravel makes implementing authentication very simple. In fact, almost everything is configured for you out of the box. The authentication configuration file is located at  config/auth.php , which contains several well documented options for tweaking the behavior of the authentication services.  At its core, Laravel's authentication facilities are made up of \"guards\" and \"providers\". Guards define how users are authenticated for each request. For example, Laravel ships with a  session  guard which maintains state using session storage and cookies.  Providers define how users are retrieved from your persistent storage. Laravel ships with support for retrieving users using Eloquent and the database query builder. However, you are free to define additional providers as needed for your application.  Don't worry if this all sounds confusing now! Many applications will never need to modify the default authentication configuration.", 
            "title": "Introduction"
        }, 
        {
            "location": "/authentication/#database-considerations", 
            "text": "By default, Laravel includes an  App\\User   Eloquent model  in your  app  directory. This model may be used with the default Eloquent authentication driver. If your application is not using Eloquent, you may use the  database  authentication driver which uses the Laravel query builder.  When building the database schema for the  App\\User  model, make sure the password column is at least 60 characters in length. Maintaining the default string column length of 255 characters would be a good choice.  Also, you should verify that your  users  (or equivalent) table contains a nullable, string  remember_token  column of 100 characters. This column will be used to store a token for users that select the \"remember me\" option when logging into your application.", 
            "title": "Database Considerations"
        }, 
        {
            "location": "/authentication/#authentication-quickstart", 
            "text": "Laravel ships with several pre-built authentication controllers, which are located in the  App\\Http\\Controllers\\Auth  namespace. The  RegisterController  handles new user registration, the  LoginController  handles authentication, the  ForgotPasswordController  handles e-mailing links for resetting passwords, and the  ResetPasswordController  contains the logic to reset passwords. Each of these controllers uses a trait to include their necessary methods. For many applications, you will not need to modify these controllers at all.", 
            "title": "Authentication Quickstart"
        }, 
        {
            "location": "/authentication/#routing", 
            "text": "Laravel provides a quick way to scaffold all of the routes and views you need for authentication using one simple command:  php artisan make:auth  This command should be used on fresh applications and will install a layout view, registration and login views, as well as routes for all authentication end-points. A  HomeController  will also be generated to handle post-login requests to your application's dashboard.", 
            "title": "Routing"
        }, 
        {
            "location": "/authentication/#views", 
            "text": "As mentioned in the previous section, the  php artisan make:auth  command will create all of the views you need for authentication and place them in the  resources/views/auth  directory.  The  make:auth  command will also create a  resources/views/layouts  directory containing a base layout for your application. All of these views use the Bootstrap CSS framework, but you are free to customize them however you wish.", 
            "title": "Views"
        }, 
        {
            "location": "/authentication/#authenticating", 
            "text": "Now that you have routes and views setup for the included authentication controllers, you are ready to register and authenticate new users for your application! You may simply access your application in a browser since the authentication controllers already contain the logic (via their traits) to authenticate existing users and store new users in the database.", 
            "title": "Authenticating"
        }, 
        {
            "location": "/authentication/#path-customization", 
            "text": "When a user is successfully authenticated, they will be redirected to the  /home  URI. You can customize the post-authentication redirect location by defining a  redirectTo  property on the  LoginController ,  RegisterController , and  ResetPasswordController :  protected $redirectTo =  / ;  If the redirect path needs custom generation logic you may define a  redirectTo  method instead of a  redirectTo  property:  protected function redirectTo()\n{\n    return  /path ;\n}   {tip} The  redirectTo  method will take precedence over the  redirectTo  attribute.", 
            "title": "Path Customization"
        }, 
        {
            "location": "/authentication/#username-customization", 
            "text": "By default, Laravel uses the  email  field for authentication. If you would like to customize this, you may define a  username  method on your  LoginController :  public function username()\n{\n    return  username ;\n}", 
            "title": "Username Customization"
        }, 
        {
            "location": "/authentication/#guard-customization", 
            "text": "You may also customize the \"guard\" that is used to authenticate and register users. To get started, define a  guard  method on your  LoginController ,  RegisterController , and  ResetPasswordController . The method should return a guard instance:  use   Illuminate \\ Support \\ Facades \\ Auth ;  protected   function   guard ()  { \n     return   Auth : : guard ( guard-name );  }", 
            "title": "Guard Customization"
        }, 
        {
            "location": "/authentication/#validation-storage-customization", 
            "text": "To modify the form fields that are required when a new user registers with your application, or to customize how new users are stored into your database, you may modify the  RegisterController  class. This class is responsible for validating and creating new users of your application.  The  validator  method of the  RegisterController  contains the validation rules for new users of the application. You are free to modify this method as you wish.  The  create  method of the  RegisterController  is responsible for creating new  App\\User  records in your database using the  Eloquent ORM . You are free to modify this method according to the needs of your database.", 
            "title": "Validation / Storage Customization"
        }, 
        {
            "location": "/authentication/#retrieving-the-authenticated-user", 
            "text": "You may access the authenticated user via the  Auth  facade:  use   Illuminate \\ Support \\ Facades \\ Auth ;  //   Get   the   currently   authenticated   user ...  $ user   =   Auth :: user ();  //   Get   the   currently   authenticated   user s   ID ...  $ id   =   Auth :: id ();   Alternatively, once a user is authenticated, you may access the authenticated user via an  Illuminate\\Http\\Request  instance. Remember, type-hinted classes will automatically be injected into your controller methods:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Http \\ Request ;  class   ProfileController   extends   Controller  { \n     /**       * Update the user s profile.       *       * @param  Request  $request       * @return Response       */ \n     public   function   update ( Request   $request ) \n     { \n         // $request- user() returns an instance of the authenticated user... \n     }  }", 
            "title": "Retrieving The Authenticated User"
        }, 
        {
            "location": "/authentication/#determining-if-the-current-user-is-authenticated", 
            "text": "To determine if the user is already logged into your application, you may use the  check  method on the  Auth  facade, which will return  true  if the user is authenticated:  use Illuminate\\Support\\Facades\\Auth;\n\nif (Auth::check()) {\n    // The user is logged in...\n}   {tip} Even though it is possible to determine if a user is authenticated using the  check  method, you will typically use a middleware to verify that the user is authenticated before allowing the user access to certain routes / controllers. To learn more about this, check out the documentation on  protecting routes .", 
            "title": "Determining If The Current User Is Authenticated"
        }, 
        {
            "location": "/authentication/#protecting-routes", 
            "text": "Route middleware  can be used to only allow authenticated users to access a given route. Laravel ships with an  auth  middleware, which is defined at  Illuminate\\Auth\\Middleware\\Authenticate . Since this middleware is already registered in your HTTP kernel, all you need to do is attach the middleware to a route definition:  Route::get( profile , function () {\n    // Only authenticated users may enter...\n})- middleware( auth );  Of course, if you are using  controllers , you may call the  middleware  method from the controller's constructor instead of attaching it in the route definition directly:  public function __construct()\n{\n    $this- middleware( auth );\n}", 
            "title": "Protecting Routes"
        }, 
        {
            "location": "/authentication/#specifying-a-guard", 
            "text": "When attaching the  auth  middleware to a route, you may also specify which guard should be used to authenticate the user. The guard specified should correspond to one of the keys in the  guards  array of your  auth.php  configuration file:  public   function   __construct ()  { \n     $this- middleware( auth : api );  }", 
            "title": "Specifying A Guard"
        }, 
        {
            "location": "/authentication/#login-throttling", 
            "text": "If you are using Laravel's built-in  LoginController  class, the  Illuminate\\Foundation\\Auth\\ThrottlesLogins  trait will already be included in your controller. By default, the user will not be able to login for one minute if they fail to provide the correct credentials after several attempts. The throttling is unique to the user's username / e-mail address and their IP address.", 
            "title": "Login Throttling"
        }, 
        {
            "location": "/authentication/#manually-authenticating-users", 
            "text": "Of course, you are not required to use the authentication controllers included with Laravel. If you choose to remove these controllers, you will need to manage user authentication using the Laravel authentication classes directly. Don't worry, it's a cinch!  We will access Laravel's authentication services via the  Auth   facade , so we'll need to make sure to import the  Auth  facade at the top of the class. Next, let's check out the  attempt  method:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Support \\ Facades \\ Auth ;  class   LoginController   extends   Controller  { \n     /**       * Handle an authentication attempt.       *       * @return Response       */ \n     public   function   authenticate () \n     { \n         if   ( Auth :: attempt ([ email   =   $email ,   password   =   $password ]))   { \n             // Authentication passed... \n             return   redirect () - intended ( dashboard ); \n         } \n     }  }   The  attempt  method accepts an array of key / value pairs as its first argument. The values in the array will be used to find the user in your database table. So, in the example above, the user will be retrieved by the value of the  email  column. If the user is found, the hashed password stored in the database will be compared with the hashed  password  value passed to the method via the array. If the two hashed passwords match an authenticated session will be started for the user.  The  attempt  method will return  true  if authentication was successful. Otherwise,  false  will be returned.  The  intended  method on the redirector will redirect the user to the URL they were attempting to access before being intercepted by the authentication middleware. A fallback URI may be given to this method in case the intended destination is not available.", 
            "title": "Manually Authenticating Users"
        }, 
        {
            "location": "/authentication/#specifying-additional-conditions", 
            "text": "If you wish, you also may add extra conditions to the authentication query in addition to the user's e-mail and password. For example, we may verify that user is marked as \"active\":  if (Auth::attempt([ email  =  $email,  password  =  $password,  active  =  1])) {\n    // The user is active, not suspended, and exists.\n}   {note} In these examples,  email  is not a required option, it is merely used as an example. You should use whatever column name corresponds to a \"username\" in your database.", 
            "title": "Specifying Additional Conditions"
        }, 
        {
            "location": "/authentication/#accessing-specific-guard-instances", 
            "text": "You may specify which guard instance you would like to utilize using the  guard  method on the  Auth  facade. This allows you to manage authentication for separate parts of your application using entirely separate authenticatable models or user tables.  The guard name passed to the  guard  method should correspond to one of the guards configured in your  auth.php  configuration file:  if (Auth::guard( admin )- attempt($credentials)) {\n    //\n}", 
            "title": "Accessing Specific Guard Instances"
        }, 
        {
            "location": "/authentication/#logging-out", 
            "text": "To log users out of your application, you may use the  logout  method on the  Auth  facade. This will clear the authentication information in the user's session:  Auth :: logout ();", 
            "title": "Logging Out"
        }, 
        {
            "location": "/authentication/#remembering-users", 
            "text": "If you would like to provide \"remember me\" functionality in your application, you may pass a boolean value as the second argument to the  attempt  method, which will keep the user authenticated indefinitely, or until they manually logout. Of course, your  users  table must include the string  remember_token  column, which will be used to store the \"remember me\" token.  if (Auth::attempt([ email  =  $email,  password  =  $password], $remember)) {\n    // The user is being remembered...\n}   {tip} If you are using the built-in  LoginController  that is shipped with Laravel, the proper logic to \"remember\" users is already implemented by the traits used by the controller.   If you are \"remembering\" users, you may use the  viaRemember  method to determine if the user was authenticated using the \"remember me\" cookie:  if (Auth::viaRemember()) {\n    //\n}", 
            "title": "Remembering Users"
        }, 
        {
            "location": "/authentication/#other-authentication-methods", 
            "text": "", 
            "title": "Other Authentication Methods"
        }, 
        {
            "location": "/authentication/#authenticate-a-user-instance", 
            "text": "If you need to log an existing user instance into your application, you may call the  login  method with the user instance. The given object must be an implementation of the  Illuminate\\Contracts\\Auth\\Authenticatable   contract . Of course, the  App\\User  model included with Laravel already implements this interface:  Auth :: login ($ user );  //   Login   and   remember   the   given   user ...  Auth :: login ($ user ,   true );   Of course, you may specify the guard instance you would like to use:  Auth :: guard ( admin ) - login ($ user );", 
            "title": "Authenticate A User Instance"
        }, 
        {
            "location": "/authentication/#authenticate-a-user-by-id", 
            "text": "To log a user into the application by their ID, you may use the  loginUsingId  method. This method simply accepts the primary key of the user you wish to authenticate:  Auth :: loginUsingId ( 1 );  //   Login   and   remember   the   given   user ...  Auth :: loginUsingId ( 1 ,   true );", 
            "title": "Authenticate A User By ID"
        }, 
        {
            "location": "/authentication/#authenticate-a-user-once", 
            "text": "You may use the  once  method to log a user into the application for a single request. No sessions or cookies will be utilized, which means this method may be helpful when building a stateless API:  if (Auth::once($credentials)) {\n    //\n}", 
            "title": "Authenticate A User Once"
        }, 
        {
            "location": "/authentication/#http-basic-authentication", 
            "text": "HTTP Basic Authentication  provides a quick way to authenticate users of your application without setting up a dedicated \"login\" page. To get started, attach the  auth.basic   middleware  to your route. The  auth.basic  middleware is included with the Laravel framework, so you do not need to define it:  Route::get( profile , function () {\n    // Only authenticated users may enter...\n})- middleware( auth.basic );  Once the middleware has been attached to the route, you will automatically be prompted for credentials when accessing the route in your browser. By default, the  auth.basic  middleware will use the  email  column on the user record as the \"username\".", 
            "title": "HTTP Basic Authentication"
        }, 
        {
            "location": "/authentication/#a-note-on-fastcgi", 
            "text": "If you are using PHP FastCGI, HTTP Basic authentication may not work correctly out of the box. The following lines should be added to your  .htaccess  file:  RewriteCond %{HTTP:Authorization} ^(.+)$\nRewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]", 
            "title": "A Note On FastCGI"
        }, 
        {
            "location": "/authentication/#stateless-http-basic-authentication", 
            "text": "You may also use HTTP Basic Authentication without setting a user identifier cookie in the session, which is particularly useful for API authentication. To do so,  define a middleware  that calls the  onceBasic  method. If no response is returned by the  onceBasic  method, the request may be passed further into the application:  ? php  namespace   Illuminate \\ Auth \\ Middleware ;  use   Illuminate \\ Support \\ Facades \\ Auth ;  class   AuthenticateOnceWithBasicAuth  { \n     /**       * Handle an incoming request.       *       * @param  \\Illuminate\\Http\\Request  $request       * @param  \\Closure  $next       * @return mixed       */ \n     public   function   handle ( $request ,   $next ) \n     { \n         return   Auth :: onceBasic ()   ?:   $next ( $request ); \n     }  }   Next,  register the route middleware  and attach it to a route:  Route::get( api/user , function () {\n    // Only authenticated users may enter...\n})- middleware( auth.basic.once );", 
            "title": "Stateless HTTP Basic Authentication"
        }, 
        {
            "location": "/authentication/#adding-custom-guards", 
            "text": "You may define your own authentication guards using the  extend  method on the  Auth  facade. You should place this call to  provider  within a  service provider . Since Laravel already ships with an  AuthServiceProvider , we can place the code in that provider:  ? php  namespace   App \\ Providers ;  use   App \\ Services \\ Auth \\ JwtGuard ;  use   Illuminate \\ Support \\ Facades \\ Auth ;  use   Illuminate \\ Foundation \\ Support \\ Providers \\ AuthServiceProvider   as   ServiceProvider ;  class   AuthServiceProvider   extends   ServiceProvider  { \n     /**       * Register any application authentication / authorization services.       *       * @return void       */ \n     public   function   boot () \n     { \n         $this - registerPolicies (); \n\n         Auth :: extend ( jwt ,   function   ( $app ,   $name ,   array   $config )   { \n             // Return an instance of Illuminate\\Contracts\\Auth\\Guard... \n\n             return   new   JwtGuard ( Auth :: createUserProvider ( $config [ provider ])); \n         }); \n     }  }   As you can see in the example above, the callback passed to the  extend  method should return an implementation of  Illuminate\\Contracts\\Auth\\Guard . This interface contains a few methods you will need to implement to define a custom guard. Once your custom guard has been defined, you may use the guard in the  guards  configuration of your  auth.php  configuration file:  guards  =  [\n     api  =  [\n         driver  =   jwt ,\n         provider  =   users ,\n    ],\n],", 
            "title": "Adding Custom Guards"
        }, 
        {
            "location": "/authentication/#adding-custom-user-providers", 
            "text": "If you are not using a traditional relational database to store your users, you will need to extend Laravel with your own authentication user provider. We will use the  provider  method on the  Auth  facade to define a custom user provider:  ? php  namespace   App \\ Providers ;  use   Illuminate \\ Support \\ Facades \\ Auth ;  use   App \\ Extensions \\ RiakUserProvider ;  use   Illuminate \\ Support \\ ServiceProvider ;  class   AuthServiceProvider   extends   ServiceProvider  { \n     /**       * Register any application authentication / authorization services.       *       * @return void       */ \n     public   function   boot () \n     { \n         $this - registerPolicies (); \n\n         Auth :: provider ( riak ,   function   ( $app ,   array   $config )   { \n             // Return an instance of Illuminate\\Contracts\\Auth\\UserProvider... \n\n             return   new   RiakUserProvider ( $app - make ( riak.connection )); \n         }); \n     }  }   After you have registered the provider using the  provider  method, you may switch to the new user provider in your  auth.php  configuration file. First, define a  provider  that uses your new driver:  providers  =  [\n     users  =  [\n         driver  =   riak ,\n    ],\n],  Finally, you may use this provider in your  guards  configuration:  guards  =  [\n     web  =  [\n         driver  =   session ,\n         provider  =   users ,\n    ],\n],", 
            "title": "Adding Custom User Providers"
        }, 
        {
            "location": "/authentication/#the-user-provider-contract", 
            "text": "The  Illuminate\\Contracts\\Auth\\UserProvider  implementations are only responsible for fetching a  Illuminate\\Contracts\\Auth\\Authenticatable  implementation out of a persistent storage system, such as MySQL, Riak, etc. These two interfaces allow the Laravel authentication mechanisms to continue functioning regardless of how the user data is stored or what type of class is used to represent it.  Let's take a look at the  Illuminate\\Contracts\\Auth\\UserProvider  contract:  ? php  namespace   Illuminate \\ Contracts \\ Auth ;  interface   UserProvider   { \n\n     public   function   retrieveById ( $identifier ); \n     public   function   retrieveByToken ( $identifier ,   $token ); \n     public   function   updateRememberToken ( Authenticatable   $user ,   $token ); \n     public   function   retrieveByCredentials ( array   $credentials ); \n     public   function   validateCredentials ( Authenticatable   $user ,   array   $credentials );  }   The  retrieveById  function typically receives a key representing the user, such as an auto-incrementing ID from a MySQL database. The  Authenticatable  implementation matching the ID should be retrieved and returned by the method.  The  retrieveByToken  function retrieves a user by their unique  $identifier  and \"remember me\"  $token , stored in a field  remember_token . As with the previous method, the  Authenticatable  implementation should be returned.  The  updateRememberToken  method updates the  $user  field  remember_token  with the new  $token . The new token can be either a fresh token, assigned on a successful \"remember me\" login attempt, or  null  when the user is logging out.  The  retrieveByCredentials  method receives the array of credentials passed to the  Auth::attempt  method when attempting to sign into an application. The method should then \"query\" the underlying persistent storage for the user matching those credentials. Typically, this method will run a query with a \"where\" condition on  $credentials['username'] . The method should then return an implementation of  Authenticatable .  This method should not attempt to do any password validation or authentication.  The  validateCredentials  method should compare the given  $user  with the  $credentials  to authenticate the user. For example, this method should probably use  Hash::check  to compare the value of  $user- getAuthPassword()  to the value of  $credentials['password'] . This method should return  true  or  false  indicating on whether the password is valid.", 
            "title": "The User Provider Contract"
        }, 
        {
            "location": "/authentication/#the-authenticatable-contract", 
            "text": "Now that we have explored each of the methods on the  UserProvider , let's take a look at the  Authenticatable  contract. Remember, the provider should return implementations of this interface from the  retrieveById  and  retrieveByCredentials  methods:  ? php  namespace   Illuminate \\ Contracts \\ Auth ;  interface   Authenticatable   { \n\n     public   function   getAuthIdentifierName (); \n     public   function   getAuthIdentifier (); \n     public   function   getAuthPassword (); \n     public   function   getRememberToken (); \n     public   function   setRememberToken ( $value ); \n     public   function   getRememberTokenName ();  }   This interface is simple. The  getAuthIdentifierName  method should return the name of the \"primary key\" field of the user and the  getAuthIdentifier  method should return the \"primary key\" of the user. In a MySQL back-end, again, this would be the auto-incrementing primary key. The  getAuthPassword  should return the user's hashed password. This interface allows the authentication system to work with any User class, regardless of what ORM or storage abstraction layer you are using. By default, Laravel includes a  User  class in the  app  directory which implements this interface, so you may consult this class for an implementation example.", 
            "title": "The Authenticatable Contract"
        }, 
        {
            "location": "/authentication/#events", 
            "text": "Laravel raises a variety of  events  during the authentication process. You may attach listeners to these events in your  EventServiceProvider :  /**   * The event listener mappings for the application.   *   * @var array   */ \nprotected   $ listen   =   [       Illuminate\\Auth\\Events\\Registered   =   [           App\\Listeners\\LogRegisteredUser ,       ] ,       Illuminate\\Auth\\Events\\Attempting   =   [           App\\Listeners\\LogAuthenticationAttempt ,       ] ,       Illuminate\\Auth\\Events\\Authenticated   =   [           App\\Listeners\\LogAuthenticated ,       ] ,       Illuminate\\Auth\\Events\\Login   =   [           App\\Listeners\\LogSuccessfulLogin ,       ] ,       Illuminate\\Auth\\Events\\Failed   =   [           App\\Listeners\\LogFailedLogin ,       ] ,       Illuminate\\Auth\\Events\\Logout   =   [           App\\Listeners\\LogSuccessfulLogout ,       ] ,       Illuminate\\Auth\\Events\\Lockout   =   [           App\\Listeners\\LogLockout ,       ] ,  ];", 
            "title": "Events"
        }, 
        {
            "location": "/authorization/", 
            "text": "Authorization\n\n\n\n\nIntroduction\n\n\nGates\n\n\nWriting Gates\n\n\nAuthorizing Actions\n\n\n\n\n\n\nCreating Policies\n\n\nGenerating Policies\n\n\nRegistering Policies\n\n\n\n\n\n\nWriting Policies\n\n\nPolicy Methods\n\n\nMethods Without Models\n\n\nPolicy Filters\n\n\n\n\n\n\nAuthorizing Actions Using Policies\n\n\nVia The User Model\n\n\nVia Middleware\n\n\nVia Controller Helpers\n\n\nVia Blade Templates\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nIn addition to providing \nauthentication\n services out of the box, Laravel also provides a simple way to authorize user actions against a given resource. Like authentication, Laravel's approach to authorization is simple, and there are two primary ways of authorizing actions: gates and policies.\n\n\nThink of gates and policies like routes and controllers. Gates provide a simple, Closure based approach to authorization while policies, like controllers, group their logic around a particular model or resource. We'll explore gates first and then examine policies.\n\n\nYou do not need to choose between exclusively using gates or exclusively using policies when building an application. Most applications will most likely contain a mixture of gates and policies, and that is perfectly fine! Gates are most applicable to actions which are not related to any model or resource, such as viewing an administrator dashboard. In contrast, policies should be used when you wish to authorize an action for a particular model or resource.\n\n\n\n\nGates\n\n\n\n\nWriting Gates\n\n\nGates are Closures that determine if a user is authorized to perform a given action and are typically defined in the \nApp\\Providers\\AuthServiceProvider\n class using the \nGate\n facade. Gates always receive a user instance as their first argument, and may optionally receive additional arguments such as a relevant Eloquent model:\n\n\n/**\n\n\n * Register any authentication / authorization services.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n\n    \n$\nthis\n-\nregisterPolicies\n()\n;\n\n\n\n    \nGate\n:\n:\ndefine\n(\nupdate-post\n,\n \nfunction\n \n(\n$\nuser\n,\n \n$\npost\n)\n \n{\n\n\n        \nreturn\n \n$\nuser\n-\nid\n \n==\n \n$\npost\n-\nuser_id\n;\n\n\n    \n}\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nAuthorizing Actions\n\n\nTo authorize an action using gates, you should use the \nallows\n or \ndenies\n methods. Note that you are not required to pass the currently authenticated user to these methods. Laravel will automatically take care of passing the user into the gate Closure:\n\n\nif (Gate::allows(\nupdate-post\n, $post)) {\n    // The current user can update the post...\n}\n\nif (Gate::denies(\nupdate-post\n, $post)) {\n    // The current user can\nt update the post...\n}\n\n\n\n\n\nIf you would like to determine if a particular user is authorized to perform an action, you may use the \nforUser\n method on the \nGate\n facade:\n\n\nif (Gate::forUser($user)-\nallows(\nupdate-post\n, $post)) {\n    // The user can update the post...\n}\n\nif (Gate::forUser($user)-\ndenies(\nupdate-post\n, $post)) {\n    // The user can\nt update the post...\n}\n\n\n\n\n\n\n\nCreating Policies\n\n\n\n\nGenerating Policies\n\n\nPolicies are classes that organize authorization logic around a particular model or resource. For example, if your application is a blog, you may have a \nPost\n model and a corresponding \nPostPolicy\n to authorize user actions such as creating or updating posts.\n\n\nYou may generate a policy using the \nmake:policy\n \nartisan command\n. The generated policy will be placed in the \napp/Policies\n directory. If this directory does not exist in your application, Laravel will create it for you:\n\n\nphp artisan make:policy PostPolicy\n\n\n\n\n\nThe \nmake:policy\n command will generate an empty policy class. If you would like to generate a class with the basic \"CRUD\" policy methods already included in the class, you may specify a \n--model\n when executing the command:\n\n\nphp artisan make:policy PostPolicy --model=Post\n\n\n\n\n\n\n\n{tip} All policies are resolved via the Laravel \nservice container\n, allowing you to type-hint any needed dependencies in the policy's constructor to have them automatically injected.\n\n\n\n\n\n\nRegistering Policies\n\n\nOnce the policy exists, it needs to be registered. The \nAuthServiceProvider\n included with fresh Laravel applications contains a \npolicies\n property which maps your Eloquent models to their corresponding policies. Registering a policy will instruct Laravel which policy to utilize when authorizing actions against a given model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nApp\n\\\nPost\n;\n\n\nuse\n \nApp\n\\\nPolicies\n\\\nPostPolicy\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nGate\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nSupport\n\\\nProviders\n\\\nAuthServiceProvider\n \nas\n \nServiceProvider\n;\n\n\n\nclass\n \nAuthServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * The policy mappings for the application.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$policies\n \n=\n \n[\n\n        \nPost\n::\nclass\n \n=\n \nPostPolicy\n::\nclass\n,\n\n    \n];\n\n\n    \n/**\n\n\n     * Register any application authentication / authorization services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \n$this\n-\nregisterPolicies\n();\n\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nWriting Policies\n\n\n\n\nPolicy Methods\n\n\nOnce the policy has been registered, you may add methods for each action it authorizes. For example, let's define an \nupdate\n method on our \nPostPolicy\n which determines if a given \nUser\n can update a given \nPost\n instance.\n\n\nThe \nupdate\n method will receive a \nUser\n and a \nPost\n instance as its arguments, and should return \ntrue\n or \nfalse\n indicating whether the user is authorized to update the given \nPost\n. So, for this example, let's verify that the user's \nid\n matches the \nuser_id\n on the post:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nPolicies\n;\n\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\nuse\n \nApp\n\\\nPost\n;\n\n\n\nclass\n \nPostPolicy\n\n\n{\n\n    \n/**\n\n\n     * Determine if the given post can be updated by the user.\n\n\n     *\n\n\n     * @param  \\App\\User  $user\n\n\n     * @param  \\App\\Post  $post\n\n\n     * @return bool\n\n\n     */\n\n    \npublic\n \nfunction\n \nupdate\n(\nUser\n \n$user\n,\n \nPost\n \n$post\n)\n\n    \n{\n\n        \nreturn\n \n$user\n-\nid\n \n===\n \n$post\n-\nuser_id\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou may continue to define additional methods on the policy as needed for the various actions it authorizes. For example, you might define \nview\n or \ndelete\n methods to authorize various \nPost\n actions, but remember you are free to give your policy methods any name you like.\n\n\n\n\n{tip} If you used the \n--model\n option when generating your policy via the Artisan console, it will already contain methods for the \nview\n, \ncreate\n, \nupdate\n, and \ndelete\n actions.\n\n\n\n\n\n\nMethods Without Models\n\n\nSome policy methods only receive the currently authenticated user and not an instance of the model they authorize. This situation is most common when authorizing \ncreate\n actions. For example, if you are creating a blog, you may wish to check if a user is authorized to create any posts at all.\n\n\nWhen defining policy methods that will not receive a model instance, such as a \ncreate\n method, it will not receive a model instance. Instead, you should define the method as only expecting the authenticated user:\n\n\n/**\n\n\n * Determine if the given user can create posts.\n\n\n *\n\n\n * @param  \\App\\User  $user\n\n\n * @return bool\n\n\n */\n\npublic\n \nfunction\n \ncreate\n(\nUser\n \n$\nuser\n)\n\n\n{\n\n\n    \n//\n\n\n}\n\n\n\n\n\n\n\n\nPolicy Filters\n\n\nFor certain users, you may wish to authorize all actions within a given policy. To accomplish this, define a \nbefore\n method on the policy. The \nbefore\n method will be executed before any other methods on the policy, giving you an opportunity to authorize the action before the intended policy method is actually called. This feature is most commonly used for authorizing application administrators to perform any action:\n\n\npublic function before($user, $ability)\n{\n    if ($user-\nisSuperAdmin()) {\n        return true;\n    }\n}\n\n\n\n\n\nIf you would like to deny all authorizations for a user you should return \nfalse\n from the \nbefore\n method. If \nnull\n is returned, the authorization will fall through to the policy method.\n\n\n\n\nAuthorizing Actions Using Policies\n\n\n\n\nVia The User Model\n\n\nThe \nUser\n model that is included with your Laravel application includes two helpful methods for authorizing actions: \ncan\n and \ncant\n. The \ncan\n method receives the action you wish to authorize and the relevant model. For example, let's determine if a user is authorized to update a given \nPost\n model:\n\n\nif ($user-\ncan(\nupdate\n, $post)) {\n    //\n}\n\n\n\n\n\nIf a \npolicy is registered\n for the given model, the \ncan\n method will automatically call the appropriate policy and return the boolean result. If no policy is registered for the model, the \ncan\n method will attempt to call the Closure based Gate matching the given action name.\n\n\nActions That Don't Require Models\n\n\nRemember, some actions like \ncreate\n may not require a model instance. In these situations, you may pass a class name to the \ncan\n method. The class name will be used to determine which policy to use when authorizing the action:\n\n\nuse App\\Post;\n\nif ($user-\ncan(\ncreate\n, Post::class)) {\n    // Executes the \ncreate\n method on the relevant policy...\n}\n\n\n\n\n\n\n\nVia Middleware\n\n\nLaravel includes a middleware that can authorize actions before the incoming request even reaches your routes or controllers. By default, the \nIlluminate\\Auth\\Middleware\\Authorize\n middleware is assigned the \ncan\n key in your \nApp\\Http\\Kernel\n class. Let's explore an example of using the \ncan\n middleware to authorize that a user can update a blog post:\n\n\nuse\n \nApp\n\\\nPost\n;\n\n\n\nRoute\n::\nput\n(\n/post/{post}\n,\n \nfunction\n \n(\nPost\n \n$\npost\n)\n \n{\n\n    \n//\n \nThe\n \ncurrent\n \nuser\n \nmay\n \nupdate\n \nthe\n \npost...\n\n\n}\n)\n-\nmiddleware\n(\ncan:update,post\n);\n\n\n\n\n\n\nIn this example, we're passing the \ncan\n middleware two arguments. The first is the name of the action we wish to authorize and the second is the route parameter we wish to pass to the policy method. In this case, since we are using \nimplicit model binding\n, a \nPost\n model will be passed to the policy method. If the user is not authorized to perform the given action, a HTTP response with a \n403\n status code will be generated by the middleware.\n\n\nActions That Don't Require Models\n\n\nAgain, some actions like \ncreate\n may not require a model instance. In these situations, you may pass a class name to the middleware. The class name will be used to determine which policy to use when authorizing the action:\n\n\nRoute\n::\npost\n(\n/post\n,\n \nfunction\n \n()\n \n{\n\n    \n//\n \nThe\n \ncurrent\n \nuser\n \nmay\n \ncreate\n \nposts...\n\n\n}\n)\n-\nmiddleware\n(\ncan:create,App\\Post\n);\n\n\n\n\n\n\n\n\nVia Controller Helpers\n\n\nIn addition to helpful methods provided to the \nUser\n model, Laravel provides a helpful \nauthorize\n method to any of your controllers which extend the \nApp\\Http\\Controllers\\Controller\n base class. Like the \ncan\n method, this method accepts the name of the action you wish to authorize and the relevant model. If the action is not authorized, the \nauthorize\n method will throw an \nIlluminate\\Auth\\Access\\AuthorizationException\n, which the default Laravel exception handler will convert to an HTTP response with a \n403\n status code:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nPost\n;\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nPostController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Update the given blog post.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @param  Post  $post\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nupdate\n(\nRequest\n \n$request\n,\n \nPost\n \n$post\n)\n\n    \n{\n\n        \n$this\n-\nauthorize\n(\nupdate\n,\n \n$post\n);\n\n\n        \n// The current user can update the blog post...\n\n    \n}\n\n\n}\n\n\n\n\n\n\nActions That Don't Require Models\n\n\nAs previously discussed, some actions like \ncreate\n may not require a model instance. In these situations, you may pass a class name to the \nauthorize\n method. The class name will be used to determine which policy to use when authorizing the action:\n\n\n/**\n\n\n * Create a new blog post.\n\n\n *\n\n\n * @param  Request  $request\n\n\n * @return Response\n\n\n */\n\n\npublic\n \nfunction\n \ncreate\n(\nRequest\n \n$\nrequest\n)\n\n\n{\n\n    \n$this-\nauthorize(\ncreate\n,\n \nPost\n:\n:\nclass\n);\n\n\n    \n//\n \nThe\n \ncurrent\n \nuser\n \ncan\n \ncreate\n \nblog\n \nposts...\n\n\n}\n\n\n\n\n\n\n\n\nVia Blade Templates\n\n\nWhen writing Blade templates, you may wish to display a portion of the page only if the user is authorized to perform a given action. For example, you may wish to show an update form for a blog post only if the user can actually update the post. In this situation, you may use the \n@can\n and \n@cannot\n family of directives:\n\n\n@\ncan\n(\nupdate\n,\n \n$\npost\n)\n\n    \n!--\n \nThe\n \nCurrent\n \nUser\n \nCan\n \nUpdate\n \nThe\n \nPost\n \n--\n\n\n@\nelsecan\n(\ncreate\n,\n \n$\npost\n)\n\n    \n!--\n \nThe\n \nCurrent\n \nUser\n \nCan\n \nCreate\n \nNew\n \nPost\n \n--\n\n\n@\nendcan\n\n\n\n@\ncannot\n(\nupdate\n,\n \n$\npost\n)\n\n    \n!--\n \nThe\n \nCurrent\n \nUser\n \nCan\nt\n \nUpdate\n \nThe\n \nPost\n \n--\n\n\n@\nelsecannot\n(\ncreate\n,\n \n$\npost\n)\n\n    \n!--\n \nThe\n \nCurrent\n \nUser\n \nCan\nt\n \nCreate\n \nNew\n \nPost\n \n--\n\n\n@\nendcannot\n\n\n\n\n\n\nThese directives are convenient shortcuts for writing \n@if\n and \n@unless\n statements. The \n@can\n and \n@cannot\n statements above respectively translate to the following statements:\n\n\n@\nif\n \n(\nAuth\n::\nuser\n()\n-\ncan\n(\nupdate\n,\n \n$\npost\n))\n\n    \n!--\n \nThe\n \nCurrent\n \nUser\n \nCan\n \nUpdate\n \nThe\n \nPost\n \n--\n\n\n@\nendif\n\n\n\n@\nunless\n \n(\nAuth\n::\nuser\n()\n-\ncan\n(\nupdate\n,\n \n$\npost\n))\n\n    \n!--\n \nThe\n \nCurrent\n \nUser\n \nCan\nt\n \nUpdate\n \nThe\n \nPost\n \n--\n\n\n@\nendunless\n\n\n\n\n\n\nActions That Don't Require Models\n\n\nLike most of the other authorization methods, you may pass a class name to the \n@can\n and \n@cannot\n directives if the action does not require a model instance:\n\n\n@\ncan\n(\ncreate\n,\n \nPost\n::\nclass\n)\n\n    \n!--\n \nThe\n \nCurrent\n \nUser\n \nCan\n \nCreate\n \nPosts\n \n--\n\n\n@\nendcan\n\n\n\n@\ncannot\n(\ncreate\n,\n \nPost\n::\nclass\n)\n\n    \n!--\n \nThe\n \nCurrent\n \nUser\n \nCan\nt\n \nCreate\n \nPosts\n \n--\n\n\n@\nendcannot", 
            "title": "Authorization"
        }, 
        {
            "location": "/authorization/#authorization", 
            "text": "Introduction  Gates  Writing Gates  Authorizing Actions    Creating Policies  Generating Policies  Registering Policies    Writing Policies  Policy Methods  Methods Without Models  Policy Filters    Authorizing Actions Using Policies  Via The User Model  Via Middleware  Via Controller Helpers  Via Blade Templates", 
            "title": "Authorization"
        }, 
        {
            "location": "/authorization/#introduction", 
            "text": "In addition to providing  authentication  services out of the box, Laravel also provides a simple way to authorize user actions against a given resource. Like authentication, Laravel's approach to authorization is simple, and there are two primary ways of authorizing actions: gates and policies.  Think of gates and policies like routes and controllers. Gates provide a simple, Closure based approach to authorization while policies, like controllers, group their logic around a particular model or resource. We'll explore gates first and then examine policies.  You do not need to choose between exclusively using gates or exclusively using policies when building an application. Most applications will most likely contain a mixture of gates and policies, and that is perfectly fine! Gates are most applicable to actions which are not related to any model or resource, such as viewing an administrator dashboard. In contrast, policies should be used when you wish to authorize an action for a particular model or resource.", 
            "title": "Introduction"
        }, 
        {
            "location": "/authorization/#gates", 
            "text": "", 
            "title": "Gates"
        }, 
        {
            "location": "/authorization/#writing-gates", 
            "text": "Gates are Closures that determine if a user is authorized to perform a given action and are typically defined in the  App\\Providers\\AuthServiceProvider  class using the  Gate  facade. Gates always receive a user instance as their first argument, and may optionally receive additional arguments such as a relevant Eloquent model:  /**   * Register any authentication / authorization services.   *   * @return void   */ \npublic   function   boot ()  {       $ this - registerPolicies () ;       Gate : : define ( update-post ,   function   ( $ user ,   $ post )   {           return   $ user - id   ==   $ post - user_id ;       } ) ;  }", 
            "title": "Writing Gates"
        }, 
        {
            "location": "/authorization/#authorizing-actions", 
            "text": "To authorize an action using gates, you should use the  allows  or  denies  methods. Note that you are not required to pass the currently authenticated user to these methods. Laravel will automatically take care of passing the user into the gate Closure:  if (Gate::allows( update-post , $post)) {\n    // The current user can update the post...\n}\n\nif (Gate::denies( update-post , $post)) {\n    // The current user can t update the post...\n}  If you would like to determine if a particular user is authorized to perform an action, you may use the  forUser  method on the  Gate  facade:  if (Gate::forUser($user)- allows( update-post , $post)) {\n    // The user can update the post...\n}\n\nif (Gate::forUser($user)- denies( update-post , $post)) {\n    // The user can t update the post...\n}", 
            "title": "Authorizing Actions"
        }, 
        {
            "location": "/authorization/#creating-policies", 
            "text": "", 
            "title": "Creating Policies"
        }, 
        {
            "location": "/authorization/#generating-policies", 
            "text": "Policies are classes that organize authorization logic around a particular model or resource. For example, if your application is a blog, you may have a  Post  model and a corresponding  PostPolicy  to authorize user actions such as creating or updating posts.  You may generate a policy using the  make:policy   artisan command . The generated policy will be placed in the  app/Policies  directory. If this directory does not exist in your application, Laravel will create it for you:  php artisan make:policy PostPolicy  The  make:policy  command will generate an empty policy class. If you would like to generate a class with the basic \"CRUD\" policy methods already included in the class, you may specify a  --model  when executing the command:  php artisan make:policy PostPolicy --model=Post   {tip} All policies are resolved via the Laravel  service container , allowing you to type-hint any needed dependencies in the policy's constructor to have them automatically injected.", 
            "title": "Generating Policies"
        }, 
        {
            "location": "/authorization/#registering-policies", 
            "text": "Once the policy exists, it needs to be registered. The  AuthServiceProvider  included with fresh Laravel applications contains a  policies  property which maps your Eloquent models to their corresponding policies. Registering a policy will instruct Laravel which policy to utilize when authorizing actions against a given model:  ? php  namespace   App \\ Providers ;  use   App \\ Post ;  use   App \\ Policies \\ PostPolicy ;  use   Illuminate \\ Support \\ Facades \\ Gate ;  use   Illuminate \\ Foundation \\ Support \\ Providers \\ AuthServiceProvider   as   ServiceProvider ;  class   AuthServiceProvider   extends   ServiceProvider  { \n     /**       * The policy mappings for the application.       *       * @var array       */ \n     protected   $policies   =   [ \n         Post :: class   =   PostPolicy :: class , \n     ]; \n\n     /**       * Register any application authentication / authorization services.       *       * @return void       */ \n     public   function   boot () \n     { \n         $this - registerPolicies (); \n\n         // \n     }  }", 
            "title": "Registering Policies"
        }, 
        {
            "location": "/authorization/#writing-policies", 
            "text": "", 
            "title": "Writing Policies"
        }, 
        {
            "location": "/authorization/#policy-methods", 
            "text": "Once the policy has been registered, you may add methods for each action it authorizes. For example, let's define an  update  method on our  PostPolicy  which determines if a given  User  can update a given  Post  instance.  The  update  method will receive a  User  and a  Post  instance as its arguments, and should return  true  or  false  indicating whether the user is authorized to update the given  Post . So, for this example, let's verify that the user's  id  matches the  user_id  on the post:  ? php  namespace   App \\ Policies ;  use   App \\ User ;  use   App \\ Post ;  class   PostPolicy  { \n     /**       * Determine if the given post can be updated by the user.       *       * @param  \\App\\User  $user       * @param  \\App\\Post  $post       * @return bool       */ \n     public   function   update ( User   $user ,   Post   $post ) \n     { \n         return   $user - id   ===   $post - user_id ; \n     }  }   You may continue to define additional methods on the policy as needed for the various actions it authorizes. For example, you might define  view  or  delete  methods to authorize various  Post  actions, but remember you are free to give your policy methods any name you like.   {tip} If you used the  --model  option when generating your policy via the Artisan console, it will already contain methods for the  view ,  create ,  update , and  delete  actions.", 
            "title": "Policy Methods"
        }, 
        {
            "location": "/authorization/#methods-without-models", 
            "text": "Some policy methods only receive the currently authenticated user and not an instance of the model they authorize. This situation is most common when authorizing  create  actions. For example, if you are creating a blog, you may wish to check if a user is authorized to create any posts at all.  When defining policy methods that will not receive a model instance, such as a  create  method, it will not receive a model instance. Instead, you should define the method as only expecting the authenticated user:  /**   * Determine if the given user can create posts.   *   * @param  \\App\\User  $user   * @return bool   */ \npublic   function   create ( User   $ user )  {       //  }", 
            "title": "Methods Without Models"
        }, 
        {
            "location": "/authorization/#policy-filters", 
            "text": "For certain users, you may wish to authorize all actions within a given policy. To accomplish this, define a  before  method on the policy. The  before  method will be executed before any other methods on the policy, giving you an opportunity to authorize the action before the intended policy method is actually called. This feature is most commonly used for authorizing application administrators to perform any action:  public function before($user, $ability)\n{\n    if ($user- isSuperAdmin()) {\n        return true;\n    }\n}  If you would like to deny all authorizations for a user you should return  false  from the  before  method. If  null  is returned, the authorization will fall through to the policy method.", 
            "title": "Policy Filters"
        }, 
        {
            "location": "/authorization/#authorizing-actions-using-policies", 
            "text": "", 
            "title": "Authorizing Actions Using Policies"
        }, 
        {
            "location": "/authorization/#via-the-user-model", 
            "text": "The  User  model that is included with your Laravel application includes two helpful methods for authorizing actions:  can  and  cant . The  can  method receives the action you wish to authorize and the relevant model. For example, let's determine if a user is authorized to update a given  Post  model:  if ($user- can( update , $post)) {\n    //\n}  If a  policy is registered  for the given model, the  can  method will automatically call the appropriate policy and return the boolean result. If no policy is registered for the model, the  can  method will attempt to call the Closure based Gate matching the given action name.", 
            "title": "Via The User Model"
        }, 
        {
            "location": "/authorization/#actions-that-dont-require-models", 
            "text": "Remember, some actions like  create  may not require a model instance. In these situations, you may pass a class name to the  can  method. The class name will be used to determine which policy to use when authorizing the action:  use App\\Post;\n\nif ($user- can( create , Post::class)) {\n    // Executes the  create  method on the relevant policy...\n}", 
            "title": "Actions That Don't Require Models"
        }, 
        {
            "location": "/authorization/#via-middleware", 
            "text": "Laravel includes a middleware that can authorize actions before the incoming request even reaches your routes or controllers. By default, the  Illuminate\\Auth\\Middleware\\Authorize  middleware is assigned the  can  key in your  App\\Http\\Kernel  class. Let's explore an example of using the  can  middleware to authorize that a user can update a blog post:  use   App \\ Post ;  Route :: put ( /post/{post} ,   function   ( Post   $ post )   { \n     //   The   current   user   may   update   the   post...  } ) - middleware ( can:update,post );   In this example, we're passing the  can  middleware two arguments. The first is the name of the action we wish to authorize and the second is the route parameter we wish to pass to the policy method. In this case, since we are using  implicit model binding , a  Post  model will be passed to the policy method. If the user is not authorized to perform the given action, a HTTP response with a  403  status code will be generated by the middleware.", 
            "title": "Via Middleware"
        }, 
        {
            "location": "/authorization/#actions-that-dont-require-models_1", 
            "text": "Again, some actions like  create  may not require a model instance. In these situations, you may pass a class name to the middleware. The class name will be used to determine which policy to use when authorizing the action:  Route :: post ( /post ,   function   ()   { \n     //   The   current   user   may   create   posts...  } ) - middleware ( can:create,App\\Post );", 
            "title": "Actions That Don't Require Models"
        }, 
        {
            "location": "/authorization/#via-controller-helpers", 
            "text": "In addition to helpful methods provided to the  User  model, Laravel provides a helpful  authorize  method to any of your controllers which extend the  App\\Http\\Controllers\\Controller  base class. Like the  can  method, this method accepts the name of the action you wish to authorize and the relevant model. If the action is not authorized, the  authorize  method will throw an  Illuminate\\Auth\\Access\\AuthorizationException , which the default Laravel exception handler will convert to an HTTP response with a  403  status code:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ Post ;  use   Illuminate \\ Http \\ Request ;  use   App \\ Http \\ Controllers \\ Controller ;  class   PostController   extends   Controller  { \n     /**       * Update the given blog post.       *       * @param  Request  $request       * @param  Post  $post       * @return Response       */ \n     public   function   update ( Request   $request ,   Post   $post ) \n     { \n         $this - authorize ( update ,   $post ); \n\n         // The current user can update the blog post... \n     }  }", 
            "title": "Via Controller Helpers"
        }, 
        {
            "location": "/authorization/#actions-that-dont-require-models_2", 
            "text": "As previously discussed, some actions like  create  may not require a model instance. In these situations, you may pass a class name to the  authorize  method. The class name will be used to determine which policy to use when authorizing the action:  /**   * Create a new blog post.   *   * @param  Request  $request   * @return Response   */  public   function   create ( Request   $ request )  { \n     $this- authorize( create ,   Post : : class ); \n\n     //   The   current   user   can   create   blog   posts...  }", 
            "title": "Actions That Don't Require Models"
        }, 
        {
            "location": "/authorization/#via-blade-templates", 
            "text": "When writing Blade templates, you may wish to display a portion of the page only if the user is authorized to perform a given action. For example, you may wish to show an update form for a blog post only if the user can actually update the post. In this situation, you may use the  @can  and  @cannot  family of directives:  @ can ( update ,   $ post ) \n     !--   The   Current   User   Can   Update   The   Post   --  @ elsecan ( create ,   $ post ) \n     !--   The   Current   User   Can   Create   New   Post   --  @ endcan  @ cannot ( update ,   $ post ) \n     !--   The   Current   User   Can t   Update   The   Post   --  @ elsecannot ( create ,   $ post ) \n     !--   The   Current   User   Can t   Create   New   Post   --  @ endcannot   These directives are convenient shortcuts for writing  @if  and  @unless  statements. The  @can  and  @cannot  statements above respectively translate to the following statements:  @ if   ( Auth :: user () - can ( update ,   $ post )) \n     !--   The   Current   User   Can   Update   The   Post   --  @ endif  @ unless   ( Auth :: user () - can ( update ,   $ post )) \n     !--   The   Current   User   Can t   Update   The   Post   --  @ endunless", 
            "title": "Via Blade Templates"
        }, 
        {
            "location": "/authorization/#actions-that-dont-require-models_3", 
            "text": "Like most of the other authorization methods, you may pass a class name to the  @can  and  @cannot  directives if the action does not require a model instance:  @ can ( create ,   Post :: class ) \n     !--   The   Current   User   Can   Create   Posts   --  @ endcan  @ cannot ( create ,   Post :: class ) \n     !--   The   Current   User   Can t   Create   Posts   --  @ endcannot", 
            "title": "Actions That Don't Require Models"
        }, 
        {
            "location": "/billing/", 
            "text": "Laravel Cashier\n\n\n\n\nIntroduction\n\n\nConfiguration\n\n\nStripe\n\n\nBraintree\n\n\nCurrency Configuration\n\n\n\n\n\n\nSubscriptions\n\n\nCreating Subscriptions\n\n\nChecking Subscription Status\n\n\nChanging Plans\n\n\nSubscription Quantity\n\n\nSubscription Taxes\n\n\nCancelling Subscriptions\n\n\nResuming Subscriptions\n\n\nUpdating Credit Cards\n\n\n\n\n\n\nSubscription Trials\n\n\nWith Credit Card Up Front\n\n\nWithout Credit Card Up Front\n\n\n\n\n\n\nHandling Stripe Webhooks\n\n\nDefining Webhook Event Handlers\n\n\nFailed Subscriptions\n\n\n\n\n\n\nHandling Braintree Webhooks\n\n\nDefining Webhook Event Handlers\n\n\nFailed Subscriptions\n\n\n\n\n\n\nSingle Charges\n\n\nInvoices\n\n\nGenerating Invoice PDFs\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nLaravel Cashier provides an expressive, fluent interface to \nStripe's\n and \nBraintree's\n subscription billing services. It handles almost all of the boilerplate subscription billing code you are dreading writing. In addition to basic subscription management, Cashier can handle coupons, swapping subscription, subscription \"quantities\", cancellation grace periods, and even generate invoice PDFs.\n\n\n\n\n{note} If you're only performing \"one-off\" charges and do not offer subscriptions, you should not use Cashier. Instead, use the Stripe and Braintree SDKs directly.\n\n\n\n\n\n\nConfiguration\n\n\n\n\nStripe\n\n\nComposer\n\n\nFirst, add the Cashier package for Stripe to your \ncomposer.json\n file and run the \ncomposer update\n command:\n\n\nlaravel/cashier\n: \n~7.0\n\n\n\n\n\n\nService Provider\n\n\nNext, register the \nLaravel\\Cashier\\CashierServiceProvider\n \nservice provider\n in your \nconfig/app.php\n configuration file.\n\n\nDatabase Migrations\n\n\nBefore using Cashier, we'll also need to \nprepare the database\n. We need to add several columns to your \nusers\n table and create a new \nsubscriptions\n table to hold all of our customer's subscriptions:\n\n\nSchema::table(\nusers\n, function ($table) {\n    $table-\nstring(\nstripe_id\n)-\nnullable();\n    $table-\nstring(\ncard_brand\n)-\nnullable();\n    $table-\nstring(\ncard_last_four\n)-\nnullable();\n    $table-\ntimestamp(\ntrial_ends_at\n)-\nnullable();\n});\n\nSchema::create(\nsubscriptions\n, function ($table) {\n    $table-\nincrements(\nid\n);\n    $table-\ninteger(\nuser_id\n);\n    $table-\nstring(\nname\n);\n    $table-\nstring(\nstripe_id\n);\n    $table-\nstring(\nstripe_plan\n);\n    $table-\ninteger(\nquantity\n);\n    $table-\ntimestamp(\ntrial_ends_at\n)-\nnullable();\n    $table-\ntimestamp(\nends_at\n)-\nnullable();\n    $table-\ntimestamps();\n});\n\n\n\n\n\nOnce the migrations have been created, run the \nmigrate\n Artisan command.\n\n\nBillable Model\n\n\nNext, add the \nBillable\n trait to your model definition. This trait provides various methods to allow you to perform common billing tasks, such as creating subscriptions, applying coupons, and updating credit card information:\n\n\nuse\n \nLaravel\n\\\nCashier\n\\\nBillable\n;\n\n\n\nclass\n \nUser\n \nextends\n \nAuthenticatable\n\n\n{\n\n    \nuse\n \nBillable\n;\n\n\n}\n\n\n\n\n\n\nAPI Keys\n\n\nFinally, you should configure your Stripe key in your \nservices.php\n configuration file. You can retrieve your Stripe API keys from the Stripe control panel:\n\n\nstripe\n =\n [\n    \nmodel\n  =\n App\\User::class,\n    \nkey\n =\n env(\nSTRIPE_KEY\n),\n    \nsecret\n =\n env(\nSTRIPE_SECRET\n),\n],\n\n\n\n\n\n\n\nBraintree\n\n\nBraintree Caveats\n\n\nFor many operations, the Stripe and Braintree implementations of Cashier function the same. Both services provide subscription billing with credit cards but Braintree also supports payments via PayPal. However, Braintree also lacks some features that are supported by Stripe. You should keep the following in mind when deciding to use Stripe or Braintree:\n\n\n\n- Braintree supports PayPal while Stripe does not.\n- Braintree does not support the `increment` and `decrement` methods on subscriptions. This is a Braintree limitation, not a Cashier limitation.\n- Braintree does not support percentage based discounts. This is a Braintree limitation, not a Cashier limitation.\n\n\n\n\nComposer\n\n\nFirst, add the Cashier package for Braintree to your \ncomposer.json\n file and run the \ncomposer update\n command:\n\n\nlaravel/cashier-braintree\n: \n~2.0\n\n\n\n\n\n\nService Provider\n\n\nNext, register the \nLaravel\\Cashier\\CashierServiceProvider\n \nservice provider\n in your \nconfig/app.php\n configuration file.\n\n\nPlan Credit Coupon\n\n\nBefore using Cashier with Braintree, you will need to define a \nplan-credit\n discount in your Braintree control panel. This discount will be used to properly prorate subscriptions that change from yearly to monthly billing, or from monthly to yearly billing.\n\n\nThe discount amount configured in the Braintree control panel can be any value you wish, as Cashier will simply override the defined amount with our own custom amount each time we apply the coupon. This coupon is needed since Braintree does not natively support prorating subscriptions across subscription frequencies.\n\n\nDatabase Migrations\n\n\nBefore using Cashier, we'll need to \nprepare the database\n. We need to add several columns to your \nusers\n table and create a new \nsubscriptions\n table to hold all of our customer's subscriptions:\n\n\nSchema::table(\nusers\n, function ($table) {\n    $table-\nstring(\nbraintree_id\n)-\nnullable();\n    $table-\nstring(\npaypal_email\n)-\nnullable();\n    $table-\nstring(\ncard_brand\n)-\nnullable();\n    $table-\nstring(\ncard_last_four\n)-\nnullable();\n    $table-\ntimestamp(\ntrial_ends_at\n)-\nnullable();\n});\n\nSchema::create(\nsubscriptions\n, function ($table) {\n    $table-\nincrements(\nid\n);\n    $table-\ninteger(\nuser_id\n);\n    $table-\nstring(\nname\n);\n    $table-\nstring(\nbraintree_id\n);\n    $table-\nstring(\nbraintree_plan\n);\n    $table-\ninteger(\nquantity\n);\n    $table-\ntimestamp(\ntrial_ends_at\n)-\nnullable();\n    $table-\ntimestamp(\nends_at\n)-\nnullable();\n    $table-\ntimestamps();\n});\n\n\n\n\n\nOnce the migrations have been created, simply run the \nmigrate\n Artisan command.\n\n\nBillable Model\n\n\nNext, add the \nBillable\n trait to your model definition:\n\n\nuse\n \nLaravel\n\\\nCashier\n\\\nBillable\n;\n\n\n\nclass\n \nUser\n \nextends\n \nAuthenticatable\n\n\n{\n\n    \nuse\n \nBillable\n;\n\n\n}\n\n\n\n\n\n\nAPI Keys\n\n\nNext, You should configure the following options in your \nservices.php\n file:\n\n\nbraintree\n =\n [\n    \nmodel\n  =\n App\\User::class,\n    \nenvironment\n =\n env(\nBRAINTREE_ENV\n),\n    \nmerchant_id\n =\n env(\nBRAINTREE_MERCHANT_ID\n),\n    \npublic_key\n =\n env(\nBRAINTREE_PUBLIC_KEY\n),\n    \nprivate_key\n =\n env(\nBRAINTREE_PRIVATE_KEY\n),\n],\n\n\n\n\n\nThen you should add the following Braintree SDK calls to your \nAppServiceProvider\n service provider's \nboot\n method:\n\n\n\\\nBraintree_Configuration\n::\nenvironment\n(\nconfig\n(\nservices.braintree.environment\n));\n\n\n\\\nBraintree_Configuration\n::\nmerchantId\n(\nconfig\n(\nservices.braintree.merchant_id\n));\n\n\n\\\nBraintree_Configuration\n::\npublicKey\n(\nconfig\n(\nservices.braintree.public_key\n));\n\n\n\\\nBraintree_Configuration\n::\nprivateKey\n(\nconfig\n(\nservices.braintree.private_key\n));\n\n\n\n\n\n\n\n\nCurrency Configuration\n\n\nThe default Cashier currency is United States Dollars (USD). You can change the default currency by calling the \nCashier::useCurrency\n method from within the \nboot\n method of one of your service providers. The \nuseCurrency\n method accepts two string parameters: the currency and the currency's symbol:\n\n\nuse\n \nLaravel\n\\\nCashier\n\\\nCashier\n;\n\n\n\nCashier\n::\nuseCurrency\n(\neur\n,\n \n\u20ac\n);\n\n\n\n\n\n\n\n\nSubscriptions\n\n\n\n\nCreating Subscriptions\n\n\nTo create a subscription, first retrieve an instance of your billable model, which typically will be an instance of \nApp\\User\n. Once you have retrieved the model instance, you may use the \nnewSubscription\n method to create the model's subscription:\n\n\n$\nuser\n \n=\n \nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nuser-\nnewSubscription\n(\nmain\n,\n \nmonthly\n)\n-\ncreate\n($\nstripeToken\n);\n\n\n\n\n\n\nThe first argument passed to the \nnewSubscription\n method should be the name of the subscription. If your application only offers a single subscription, you might call this \nmain\n or \nprimary\n. The second argument is the specific Stripe / Braintree plan the user is subscribing to. This value should correspond to the plan's identifier in Stripe or Braintree.\n\n\nThe \ncreate\n method will begin the subscription as well as update your database with the customer ID and other relevant billing information.\n\n\nAdditional User Details\n\n\nIf you would like to specify additional customer details, you may do so by passing them as the second argument to the \ncreate\n method:\n\n\n$user-\nnewSubscription(\nmain\n, \nmonthly\n)-\ncreate($stripeToken, [\n    \nemail\n =\n $email,\n]);\n\n\n\n\n\nTo learn more about the additional fields supported by Stripe or Braintree, check out Stripe's \ndocumentation on customer creation\n or the corresponding \nBraintree documentation\n.\n\n\nCoupons\n\n\nIf you would like to apply a coupon when creating the subscription, you may use the \nwithCoupon\n method:\n\n\n$user-\nnewSubscription(\nmain\n, \nmonthly\n)\n     -\nwithCoupon(\ncode\n)\n     -\ncreate($stripeToken);\n\n\n\n\n\n\n\nChecking Subscription Status\n\n\nOnce a user is subscribed to your application, you may easily check their subscription status using a variety of convenient methods. First, the \nsubscribed\n method returns \ntrue\n if the user has an active subscription, even if the subscription is currently within its trial period:\n\n\nif ($user-\nsubscribed(\nmain\n)) {\n    //\n}\n\n\n\n\n\nThe \nsubscribed\n method also makes a great candidate for a \nroute middleware\n, allowing you to filter access to routes and controllers based on the user's subscription status:\n\n\npublic function handle($request, Closure $next)\n{\n    if ($request-\nuser() \n ! $request-\nuser()-\nsubscribed(\nmain\n)) {\n        // This user is not a paying customer...\n        return redirect(\nbilling\n);\n    }\n\n    return $next($request);\n}\n\n\n\n\n\nIf you would like to determine if a user is still within their trial period, you may use the \nonTrial\n method. This method can be useful for displaying a warning to the user that they are still on their trial period:\n\n\nif ($user-\nsubscription(\nmain\n)-\nonTrial()) {\n    //\n}\n\n\n\n\n\nThe \nsubscribedToPlan\n method may be used to determine if the user is subscribed to a given plan based on a given Stripe / Braintree plan ID. In this example, we will determine if the user's \nmain\n subscription is actively subscribed to the \nmonthly\n plan:\n\n\nif ($user-\nsubscribedToPlan(\nmonthly\n, \nmain\n)) {\n    //\n}\n\n\n\n\n\nCancelled Subscription Status\n\n\nTo determine if the user was once an active subscriber, but has cancelled their subscription, you may use the \ncancelled\n method:\n\n\nif ($user-\nsubscription(\nmain\n)-\ncancelled()) {\n    //\n}\n\n\n\n\n\nYou may also determine if a user has cancelled their subscription, but are still on their \"grace period\" until the subscription fully expires. For example, if a user cancels a subscription on March 5th that was originally scheduled to expire on March 10th, the user is on their \"grace period\" until March 10th. Note that the \nsubscribed\n method still returns \ntrue\n during this time:\n\n\nif ($user-\nsubscription(\nmain\n)-\nonGracePeriod()) {\n    //\n}\n\n\n\n\n\n\n\nChanging Plans\n\n\nAfter a user is subscribed to your application, they may occasionally want to change to a new subscription plan. To swap a user to a new subscription, pass the plan's identifier to the \nswap\n method:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nuser-\nsubscription\n(\nmain\n)\n-\nswap\n(\nprovider-plan-id\n);\n\n\n\n\n\n\nIf the user is on trial, the trial period will be maintained. Also, if a \"quantity\" exists for the subscription, that quantity will also be maintained.\n\n\nIf you would like to swap plans and cancel any trial period the user is currently on, you may use the \nskipTrial\n method:\n\n\n$user-\nsubscription(\nmain\n)\n        -\nskipTrial()\n        -\nswap(\nprovider-plan-id\n);\n\n\n\n\n\n\n\nSubscription Quantity\n\n\n\n\n{note} Subscription quantities are only supported by the Stripe edition of Cashier. Braintree does not have a feature that corresponds to Stripe's \"quantity\".\n\n\n\n\nSometimes subscriptions are affected by \"quantity\". For example, your application might charge $10 per month \nper user\n on an account. To easily increment or decrement your subscription quantity, use the \nincrementQuantity\n and \ndecrementQuantity\n methods:\n\n\n$\nuser\n \n=\n \nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nuser-\nsubscription\n(\nmain\n)\n-\nincrementQuantity\n();\n\n\n\n//\n \nAdd\n \nfive\n \nto\n \nthe\n \nsubscription\ns current quantity...\n\n\n$user-\nsubscription(\nmain\n)-\nincrementQuantity(5);\n\n\n\n$user-\nsubscription(\nmain\n)-\ndecrementQuantity();\n\n\n\n// Subtract five to the subscription\ns\n \ncurrent\n \nquantity\n...\n\n\n$\nuser-\nsubscription\n(\nmain\n)\n-\ndecrementQuantity\n(\n5\n);\n\n\n\n\n\n\nAlternatively, you may set a specific quantity using the \nupdateQuantity\n method:\n\n\n$user-\nsubscription(\nmain\n)-\nupdateQuantity(10);\n\n\n\n\n\nFor more information on subscription quantities, consult the \nStripe documentation\n.\n\n\n\n\nSubscription Taxes\n\n\nTo specify the tax percentage a user pays on a subscription, implement the \ntaxPercentage\n method on your billable model, and return a numeric value between 0 and 100, with no more than 2 decimal places.\n\n\npublic function taxPercentage() {\n    return 20;\n}\n\n\n\n\n\nThe \ntaxPercentage\n method enables you to apply a tax rate on a model-by-model basis, which may be helpful for a user base that spans multiple countries and tax rates.\n\n\n\n\n{note} The \ntaxPercentage\n method only applies to subscription charges. If you use Cashier to make \"one off\" charges, you will need to manually specify the tax rate at that time.\n\n\n\n\n\n\nCancelling Subscriptions\n\n\nTo cancel a subscription, simply call the \ncancel\n method on the user's subscription:\n\n\n$user-\nsubscription(\nmain\n)-\ncancel();\n\n\n\n\n\nWhen a subscription is cancelled, Cashier will automatically set the \nends_at\n column in your database. This column is used to know when the \nsubscribed\n method should begin returning \nfalse\n. For example, if a customer cancels a subscription on March 1st, but the subscription was not scheduled to end until March 5th, the \nsubscribed\n method will continue to return \ntrue\n until March 5th.\n\n\nYou may determine if a user has cancelled their subscription but are still on their \"grace period\" using the \nonGracePeriod\n method:\n\n\nif ($user-\nsubscription(\nmain\n)-\nonGracePeriod()) {\n    //\n}\n\n\n\n\n\nIf you wish to cancel a subscription immediately, call the \ncancelNow\n method on the user's subscription:\n\n\n$user-\nsubscription(\nmain\n)-\ncancelNow();\n\n\n\n\n\n\n\nResuming Subscriptions\n\n\nIf a user has cancelled their subscription and you wish to resume it, use the \nresume\n method. The user \nmust\n still be on their grace period in order to resume a subscription:\n\n\n$user-\nsubscription(\nmain\n)-\nresume();\n\n\n\n\n\nIf the user cancels a subscription and then resumes that subscription before the subscription has fully expired, they will not be billed immediately. Instead, their subscription will simply be re-activated, and they will be billed on the original billing cycle.\n\n\n\n\nUpdating Credit Cards\n\n\nThe \nupdateCard\n method may be used to update a customer's credit card information. This method accepts a Stripe token and will assign the new credit card as the default billing source:\n\n\n$user-\nupdateCard($stripeToken);\n\n\n\n\n\n\n\nSubscription Trials\n\n\n\n\nWith Credit Card Up Front\n\n\nIf you would like to offer trial periods to your customers while still collecting payment method information up front, You should use the \ntrialDays\n method when creating your subscriptions:\n\n\n$\nuser\n \n=\n \nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nuser-\nnewSubscription\n(\nmain\n,\n \nmonthly\n)\n\n            \n-\ntrialDays\n(\n10\n)\n\n            \n-\ncreate\n($\nstripeToken\n);\n\n\n\n\n\n\nThis method will set the trial period ending date on the subscription record within the database, as well as instruct Stripe / Braintree to not begin billing the customer until after this date.\n\n\n\n\n{note} If the customer's subscription is not cancelled before the trial ending date they will be charged as soon as the trial expires, so you should be sure to notify your users of their trial ending date.\n\n\n\n\nYou may determine if the user is within their trial period using either the \nonTrial\n method of the user instance, or the \nonTrial\n method of the subscription instance. The two examples below are identical:\n\n\nif ($user-\nonTrial(\nmain\n)) {\n    //\n}\n\nif ($user-\nsubscription(\nmain\n)-\nonTrial()) {\n    //\n}\n\n\n\n\n\n\n\nWithout Credit Card Up Front\n\n\nIf you would like to offer trial periods without collecting the user's payment method information up front, you may simply set the \ntrial_ends_at\n column on the user record to your desired trial ending date. This is typically done during user registration:\n\n\n$user = User::create([\n    // Populate other user properties...\n    \ntrial_ends_at\n =\n Carbon::now()-\naddDays(10),\n]);\n\n\n\n\n\n\n\n{note}  Be sure to add a \ndate mutator\n for \ntrial_ends_at\n to your model definition.\n\n\n\n\nCashier refers to this type of trial as a \"generic trial\", since it is not attached to any existing subscription. The \nonTrial\n method on the \nUser\n instance will return \ntrue\n if the current date is not past the value of \ntrial_ends_at\n:\n\n\nif ($user-\nonTrial()) {\n    // User is within their trial period...\n}\n\n\n\n\n\nYou may also use the \nonGenericTrial\n method if you wish to know specifically that the user is within their \"generic\" trial period and has not created an actual subscription yet:\n\n\nif ($user-\nonGenericTrial()) {\n    // User is within their \ngeneric\n trial period...\n}\n\n\n\n\n\nOnce you are ready to create an actual subscription for the user, you may use the \nnewSubscription\n method as usual:\n\n\n$\nuser\n \n=\n \nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nuser-\nnewSubscription\n(\nmain\n,\n \nmonthly\n)\n-\ncreate\n($\nstripeToken\n);\n\n\n\n\n\n\n\n\nHandling Stripe Webhooks\n\n\nBoth Stripe and Braintree can notify your application of a variety of events via webhooks. To handle Stripe webhooks, define a route that points to Cashier's webhook controller. This controller will handle all incoming webhook requests and dispatch them to the proper controller method:\n\n\nRoute::post(\n    \nstripe/webhook\n,\n    \n\\Laravel\\Cashier\\Http\\Controllers\\WebhookController@handleWebhook\n\n);\n\n\n\n\n\n\n\n{note} Once you have registered your route, be sure to configure the webhook URL in your Stripe control panel settings.\n\n\n\n\nBy default, this controller will automatically handle cancelling subscriptions that have too many failed charges (as defined by your Stripe settings); however, as we'll soon discover, you can extend this controller to handle any webhook event you like.\n\n\nWebhooks \n CSRF Protection\n\n\nSince Stripe webhooks need to bypass Laravel's \nCSRF protection\n, be sure to list the URI as an exception in your \nVerifyCsrfToken\n middleware or list the route outside of the \nweb\n middleware group:\n\n\nprotected $except = [\n    \nstripe/*\n,\n];\n\n\n\n\n\n\n\nDefining Webhook Event Handlers\n\n\nCashier automatically handles subscription cancellation on failed charges, but if you have additional Stripe webhook events you would like to handle, simply extend the Webhook controller. Your method names should correspond to Cashier's expected convention, specifically, methods should be prefixed with \nhandle\n and the \"camel case\" name of the Stripe webhook you wish to handle. For example, if you wish to handle the \ninvoice.payment_succeeded\n webhook, you should add a \nhandleInvoicePaymentSucceeded\n method to the controller:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nLaravel\n\\\nCashier\n\\\nHttp\n\\\nControllers\n\\\nWebhookController\n \nas\n \nCashierController\n;\n\n\n\nclass\n \nWebhookController\n \nextends\n \nCashierController\n\n\n{\n\n    \n/**\n\n\n     * Handle a Stripe webhook.\n\n\n     *\n\n\n     * @param  array  $payload\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandleInvoicePaymentSucceeded\n(\n$payload\n)\n\n    \n{\n\n        \n// Handle The Event\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nFailed Subscriptions\n\n\nWhat if a customer's credit card expires? No worries - Cashier includes a Webhook controller that can easily cancel the customer's subscription for you. As noted above, all you need to do is point a route to the controller:\n\n\nRoute::post(\n    \nstripe/webhook\n,\n    \n\\Laravel\\Cashier\\Http\\Controllers\\WebhookController@handleWebhook\n\n);\n\n\n\n\n\nThat's it! Failed payments will be captured and handled by the controller. The controller will cancel the customer's subscription when Stripe determines the subscription has failed (normally after three failed payment attempts).\n\n\n\n\nHandling Braintree Webhooks\n\n\nBoth Stripe and Braintree can notify your application of a variety of events via webhooks. To handle Braintree webhooks, define a route that points to Cashier's webhook controller. This controller will handle all incoming webhook requests and dispatch them to the proper controller method:\n\n\nRoute::post(\n    \nbraintree/webhook\n,\n    \n\\Laravel\\Cashier\\Http\\Controllers\\WebhookController@handleWebhook\n\n);\n\n\n\n\n\n\n\n{note} Once you have registered your route, be sure to configure the webhook URL in your Braintree control panel settings.\n\n\n\n\nBy default, this controller will automatically handle cancelling subscriptions that have too many failed charges (as defined by your Braintree settings); however, as we'll soon discover, you can extend this controller to handle any webhook event you like.\n\n\nWebhooks \n CSRF Protection\n\n\nSince Braintree webhooks need to bypass Laravel's \nCSRF protection\n, be sure to list the URI as an exception in your \nVerifyCsrfToken\n middleware or list the route outside of the \nweb\n middleware group:\n\n\nprotected $except = [\n    \nbraintree/*\n,\n];\n\n\n\n\n\n\n\nDefining Webhook Event Handlers\n\n\nCashier automatically handles subscription cancellation on failed charges, but if you have additional Braintree webhook events you would like to handle, simply extend the Webhook controller. Your method names should correspond to Cashier's expected convention, specifically, methods should be prefixed with \nhandle\n and the \"camel case\" name of the Braintree webhook you wish to handle. For example, if you wish to handle the \ndispute_opened\n webhook, you should add a \nhandleDisputeOpened\n method to the controller:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nBraintree\n\\\nWebhookNotification\n;\n\n\nuse\n \nLaravel\n\\\nCashier\n\\\nHttp\n\\\nControllers\n\\\nWebhookController\n \nas\n \nCashierController\n;\n\n\n\nclass\n \nWebhookController\n \nextends\n \nCashierController\n\n\n{\n\n    \n/**\n\n\n     * Handle a Braintree webhook.\n\n\n     *\n\n\n     * @param  WebhookNotification  $webhook\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandleDisputeOpened\n(\nWebhookNotification\n \n$notification\n)\n\n    \n{\n\n        \n// Handle The Event\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nFailed Subscriptions\n\n\nWhat if a customer's credit card expires? No worries - Cashier includes a Webhook controller that can easily cancel the customer's subscription for you. Just point a route to the controller:\n\n\nRoute::post(\n    \nbraintree/webhook\n,\n    \n\\Laravel\\Cashier\\Http\\Controllers\\WebhookController@handleWebhook\n\n);\n\n\n\n\n\nThat's it! Failed payments will be captured and handled by the controller. The controller will cancel the customer's subscription when Braintree determines the subscription has failed (normally after three failed payment attempts). Don't forget: you will need to configure the webhook URI in your Braintree control panel settings.\n\n\n\n\nSingle Charges\n\n\nSimple Charge\n\n\n\n\n{note} When using Stripe, the \ncharge\n method accepts the amount you would like to charge in the \nlowest denominator of the currency used by your application\n. However, when using Braintree, you should pass the full dollar amount to the \ncharge\n method:\n\n\n\n\nIf you would like to make a \"one off\" charge against a subscribed customer's credit card, you may use the \ncharge\n method on a billable model instance.\n\n\n// Stripe Accepts Charges In Cents...\n$user-\ncharge(100);\n\n// Braintree Accepts Charges In Dollars...\n$user-\ncharge(1);\n\n\n\n\n\nThe \ncharge\n method accepts an array as its second argument, allowing you to pass any options you wish to the underlying Stripe / Braintree charge creation. Consult the Stripe or Braintree documentation regarding the options available to you when creating charges:\n\n\n$user-\ncharge(100, [\n    \ncustom_option\n =\n $value,\n]);\n\n\n\n\n\nThe \ncharge\n method will throw an exception if the charge fails. If the charge is successful, the full Stripe / Braintree response will be returned from the method:\n\n\ntry {\n    $response = $user-\ncharge(100);\n} catch (Exception $e) {\n    //\n}\n\n\n\n\n\nCharge With Invoice\n\n\nSometimes you may need to make a one-time charge but also generate an invoice for the charge so that you may offer a PDF receipt to your customer. The \ninvoiceFor\n method lets you do just that. For example, let's invoice the customer $5.00 for a \"One Time Fee\":\n\n\n// Stripe Accepts Charges In Cents...\n$user-\ninvoiceFor(\nOne Time Fee\n, 500);\n\n// Braintree Accepts Charges In Dollars...\n$user-\ninvoiceFor(\nOne Time Fee\n, 5);\n\n\n\n\n\nThe invoice will be charged immediately against the user's credit card. The \ninvoiceFor\n method also accepts an array as its third argument, allowing you to pass any options you wish to the underlying Stripe / Braintree charge creation:\n\n\n$user-\ninvoiceFor(\nOne Time Fee\n, 500, [\n    \ncustom-option\n =\n $value,\n]);\n\n\n\n\n\n\n\n{note} The \ninvoiceFor\n method will create a Stripe invoice which will retry failed billing attempts. If you do not want invoices to retry failed charges, you will need to close them using the Stripe API after the first failed charge.\n\n\n\n\n\n\nInvoices\n\n\nYou may easily retrieve an array of a billable model's invoices using the \ninvoices\n method:\n\n\n$invoices = $user-\ninvoices();\n\n// Include pending invoices in the results...\n$invoices = $user-\ninvoicesIncludingPending();\n\n\n\n\n\nWhen listing the invoices for the customer, you may use the invoice's helper methods to display the relevant invoice information. For example, you may wish to list every invoice in a table, allowing the user to easily download any of them:\n\n\ntable\n\n    \n@\nforeach\n \n(\n$\ninvoices\n \nas\n \n$\ninvoice\n)\n\n        \ntr\n\n            \ntd\n{{\n \n$\ninvoice\n-\ndate\n()\n-\ntoFormattedDateString\n()\n \n}}\n/\ntd\n\n            \ntd\n{{\n \n$\ninvoice\n-\ntotal\n()\n \n}}\n/\ntd\n\n            \ntd\na\n \nhref\n=\n/user/invoice/{{ $invoice-\nid }}\nDownload\n/\na\n/\ntd\n\n        \n/\ntr\n\n    \n@\nendforeach\n\n\n/\ntable\n\n\n\n\n\n\n\n\nGenerating Invoice PDFs\n\n\nBefore generating invoice PDFs, you need to install the \ndompdf\n PHP library:\n\n\ncomposer require dompdf/dompdf\n\n\n\n\n\nThen, from within a route or controller, use the \ndownloadInvoice\n method to generate a PDF download of the invoice. This method will automatically generate the proper HTTP response to send the download to the browser:\n\n\nuse Illuminate\\Http\\Request;\n\nRoute::get(\nuser/invoice/{invoice}\n, function (Request $request, $invoiceId) {\n    return $request-\nuser()-\ndownloadInvoice($invoiceId, [\n        \nvendor\n  =\n \nYour Company\n,\n        \nproduct\n =\n \nYour Product\n,\n    ]);\n});", 
            "title": "Billing"
        }, 
        {
            "location": "/billing/#laravel-cashier", 
            "text": "Introduction  Configuration  Stripe  Braintree  Currency Configuration    Subscriptions  Creating Subscriptions  Checking Subscription Status  Changing Plans  Subscription Quantity  Subscription Taxes  Cancelling Subscriptions  Resuming Subscriptions  Updating Credit Cards    Subscription Trials  With Credit Card Up Front  Without Credit Card Up Front    Handling Stripe Webhooks  Defining Webhook Event Handlers  Failed Subscriptions    Handling Braintree Webhooks  Defining Webhook Event Handlers  Failed Subscriptions    Single Charges  Invoices  Generating Invoice PDFs", 
            "title": "Laravel Cashier"
        }, 
        {
            "location": "/billing/#introduction", 
            "text": "Laravel Cashier provides an expressive, fluent interface to  Stripe's  and  Braintree's  subscription billing services. It handles almost all of the boilerplate subscription billing code you are dreading writing. In addition to basic subscription management, Cashier can handle coupons, swapping subscription, subscription \"quantities\", cancellation grace periods, and even generate invoice PDFs.   {note} If you're only performing \"one-off\" charges and do not offer subscriptions, you should not use Cashier. Instead, use the Stripe and Braintree SDKs directly.", 
            "title": "Introduction"
        }, 
        {
            "location": "/billing/#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/billing/#stripe", 
            "text": "", 
            "title": "Stripe"
        }, 
        {
            "location": "/billing/#composer", 
            "text": "First, add the Cashier package for Stripe to your  composer.json  file and run the  composer update  command:  laravel/cashier :  ~7.0", 
            "title": "Composer"
        }, 
        {
            "location": "/billing/#service-provider", 
            "text": "Next, register the  Laravel\\Cashier\\CashierServiceProvider   service provider  in your  config/app.php  configuration file.", 
            "title": "Service Provider"
        }, 
        {
            "location": "/billing/#database-migrations", 
            "text": "Before using Cashier, we'll also need to  prepare the database . We need to add several columns to your  users  table and create a new  subscriptions  table to hold all of our customer's subscriptions:  Schema::table( users , function ($table) {\n    $table- string( stripe_id )- nullable();\n    $table- string( card_brand )- nullable();\n    $table- string( card_last_four )- nullable();\n    $table- timestamp( trial_ends_at )- nullable();\n});\n\nSchema::create( subscriptions , function ($table) {\n    $table- increments( id );\n    $table- integer( user_id );\n    $table- string( name );\n    $table- string( stripe_id );\n    $table- string( stripe_plan );\n    $table- integer( quantity );\n    $table- timestamp( trial_ends_at )- nullable();\n    $table- timestamp( ends_at )- nullable();\n    $table- timestamps();\n});  Once the migrations have been created, run the  migrate  Artisan command.", 
            "title": "Database Migrations"
        }, 
        {
            "location": "/billing/#billable-model", 
            "text": "Next, add the  Billable  trait to your model definition. This trait provides various methods to allow you to perform common billing tasks, such as creating subscriptions, applying coupons, and updating credit card information:  use   Laravel \\ Cashier \\ Billable ;  class   User   extends   Authenticatable  { \n     use   Billable ;  }", 
            "title": "Billable Model"
        }, 
        {
            "location": "/billing/#api-keys", 
            "text": "Finally, you should configure your Stripe key in your  services.php  configuration file. You can retrieve your Stripe API keys from the Stripe control panel:  stripe  =  [\n     model   =  App\\User::class,\n     key  =  env( STRIPE_KEY ),\n     secret  =  env( STRIPE_SECRET ),\n],", 
            "title": "API Keys"
        }, 
        {
            "location": "/billing/#braintree", 
            "text": "", 
            "title": "Braintree"
        }, 
        {
            "location": "/billing/#braintree-caveats", 
            "text": "For many operations, the Stripe and Braintree implementations of Cashier function the same. Both services provide subscription billing with credit cards but Braintree also supports payments via PayPal. However, Braintree also lacks some features that are supported by Stripe. You should keep the following in mind when deciding to use Stripe or Braintree:  \n- Braintree supports PayPal while Stripe does not.\n- Braintree does not support the `increment` and `decrement` methods on subscriptions. This is a Braintree limitation, not a Cashier limitation.\n- Braintree does not support percentage based discounts. This is a Braintree limitation, not a Cashier limitation.", 
            "title": "Braintree Caveats"
        }, 
        {
            "location": "/billing/#composer_1", 
            "text": "First, add the Cashier package for Braintree to your  composer.json  file and run the  composer update  command:  laravel/cashier-braintree :  ~2.0", 
            "title": "Composer"
        }, 
        {
            "location": "/billing/#service-provider_1", 
            "text": "Next, register the  Laravel\\Cashier\\CashierServiceProvider   service provider  in your  config/app.php  configuration file.", 
            "title": "Service Provider"
        }, 
        {
            "location": "/billing/#plan-credit-coupon", 
            "text": "Before using Cashier with Braintree, you will need to define a  plan-credit  discount in your Braintree control panel. This discount will be used to properly prorate subscriptions that change from yearly to monthly billing, or from monthly to yearly billing.  The discount amount configured in the Braintree control panel can be any value you wish, as Cashier will simply override the defined amount with our own custom amount each time we apply the coupon. This coupon is needed since Braintree does not natively support prorating subscriptions across subscription frequencies.", 
            "title": "Plan Credit Coupon"
        }, 
        {
            "location": "/billing/#database-migrations_1", 
            "text": "Before using Cashier, we'll need to  prepare the database . We need to add several columns to your  users  table and create a new  subscriptions  table to hold all of our customer's subscriptions:  Schema::table( users , function ($table) {\n    $table- string( braintree_id )- nullable();\n    $table- string( paypal_email )- nullable();\n    $table- string( card_brand )- nullable();\n    $table- string( card_last_four )- nullable();\n    $table- timestamp( trial_ends_at )- nullable();\n});\n\nSchema::create( subscriptions , function ($table) {\n    $table- increments( id );\n    $table- integer( user_id );\n    $table- string( name );\n    $table- string( braintree_id );\n    $table- string( braintree_plan );\n    $table- integer( quantity );\n    $table- timestamp( trial_ends_at )- nullable();\n    $table- timestamp( ends_at )- nullable();\n    $table- timestamps();\n});  Once the migrations have been created, simply run the  migrate  Artisan command.", 
            "title": "Database Migrations"
        }, 
        {
            "location": "/billing/#billable-model_1", 
            "text": "Next, add the  Billable  trait to your model definition:  use   Laravel \\ Cashier \\ Billable ;  class   User   extends   Authenticatable  { \n     use   Billable ;  }", 
            "title": "Billable Model"
        }, 
        {
            "location": "/billing/#api-keys_1", 
            "text": "Next, You should configure the following options in your  services.php  file:  braintree  =  [\n     model   =  App\\User::class,\n     environment  =  env( BRAINTREE_ENV ),\n     merchant_id  =  env( BRAINTREE_MERCHANT_ID ),\n     public_key  =  env( BRAINTREE_PUBLIC_KEY ),\n     private_key  =  env( BRAINTREE_PRIVATE_KEY ),\n],  Then you should add the following Braintree SDK calls to your  AppServiceProvider  service provider's  boot  method:  \\ Braintree_Configuration :: environment ( config ( services.braintree.environment ));  \\ Braintree_Configuration :: merchantId ( config ( services.braintree.merchant_id ));  \\ Braintree_Configuration :: publicKey ( config ( services.braintree.public_key ));  \\ Braintree_Configuration :: privateKey ( config ( services.braintree.private_key ));", 
            "title": "API Keys"
        }, 
        {
            "location": "/billing/#currency-configuration", 
            "text": "The default Cashier currency is United States Dollars (USD). You can change the default currency by calling the  Cashier::useCurrency  method from within the  boot  method of one of your service providers. The  useCurrency  method accepts two string parameters: the currency and the currency's symbol:  use   Laravel \\ Cashier \\ Cashier ;  Cashier :: useCurrency ( eur ,   \u20ac );", 
            "title": "Currency Configuration"
        }, 
        {
            "location": "/billing/#subscriptions", 
            "text": "", 
            "title": "Subscriptions"
        }, 
        {
            "location": "/billing/#creating-subscriptions", 
            "text": "To create a subscription, first retrieve an instance of your billable model, which typically will be an instance of  App\\User . Once you have retrieved the model instance, you may use the  newSubscription  method to create the model's subscription:  $ user   =   User :: find ( 1 );  $ user- newSubscription ( main ,   monthly ) - create ($ stripeToken );   The first argument passed to the  newSubscription  method should be the name of the subscription. If your application only offers a single subscription, you might call this  main  or  primary . The second argument is the specific Stripe / Braintree plan the user is subscribing to. This value should correspond to the plan's identifier in Stripe or Braintree.  The  create  method will begin the subscription as well as update your database with the customer ID and other relevant billing information.", 
            "title": "Creating Subscriptions"
        }, 
        {
            "location": "/billing/#additional-user-details", 
            "text": "If you would like to specify additional customer details, you may do so by passing them as the second argument to the  create  method:  $user- newSubscription( main ,  monthly )- create($stripeToken, [\n     email  =  $email,\n]);  To learn more about the additional fields supported by Stripe or Braintree, check out Stripe's  documentation on customer creation  or the corresponding  Braintree documentation .", 
            "title": "Additional User Details"
        }, 
        {
            "location": "/billing/#coupons", 
            "text": "If you would like to apply a coupon when creating the subscription, you may use the  withCoupon  method:  $user- newSubscription( main ,  monthly )\n     - withCoupon( code )\n     - create($stripeToken);", 
            "title": "Coupons"
        }, 
        {
            "location": "/billing/#checking-subscription-status", 
            "text": "Once a user is subscribed to your application, you may easily check their subscription status using a variety of convenient methods. First, the  subscribed  method returns  true  if the user has an active subscription, even if the subscription is currently within its trial period:  if ($user- subscribed( main )) {\n    //\n}  The  subscribed  method also makes a great candidate for a  route middleware , allowing you to filter access to routes and controllers based on the user's subscription status:  public function handle($request, Closure $next)\n{\n    if ($request- user()   ! $request- user()- subscribed( main )) {\n        // This user is not a paying customer...\n        return redirect( billing );\n    }\n\n    return $next($request);\n}  If you would like to determine if a user is still within their trial period, you may use the  onTrial  method. This method can be useful for displaying a warning to the user that they are still on their trial period:  if ($user- subscription( main )- onTrial()) {\n    //\n}  The  subscribedToPlan  method may be used to determine if the user is subscribed to a given plan based on a given Stripe / Braintree plan ID. In this example, we will determine if the user's  main  subscription is actively subscribed to the  monthly  plan:  if ($user- subscribedToPlan( monthly ,  main )) {\n    //\n}", 
            "title": "Checking Subscription Status"
        }, 
        {
            "location": "/billing/#cancelled-subscription-status", 
            "text": "To determine if the user was once an active subscriber, but has cancelled their subscription, you may use the  cancelled  method:  if ($user- subscription( main )- cancelled()) {\n    //\n}  You may also determine if a user has cancelled their subscription, but are still on their \"grace period\" until the subscription fully expires. For example, if a user cancels a subscription on March 5th that was originally scheduled to expire on March 10th, the user is on their \"grace period\" until March 10th. Note that the  subscribed  method still returns  true  during this time:  if ($user- subscription( main )- onGracePeriod()) {\n    //\n}", 
            "title": "Cancelled Subscription Status"
        }, 
        {
            "location": "/billing/#changing-plans", 
            "text": "After a user is subscribed to your application, they may occasionally want to change to a new subscription plan. To swap a user to a new subscription, pass the plan's identifier to the  swap  method:  $ user   =   App \\ User :: find ( 1 );  $ user- subscription ( main ) - swap ( provider-plan-id );   If the user is on trial, the trial period will be maintained. Also, if a \"quantity\" exists for the subscription, that quantity will also be maintained.  If you would like to swap plans and cancel any trial period the user is currently on, you may use the  skipTrial  method:  $user- subscription( main )\n        - skipTrial()\n        - swap( provider-plan-id );", 
            "title": "Changing Plans"
        }, 
        {
            "location": "/billing/#subscription-quantity", 
            "text": "{note} Subscription quantities are only supported by the Stripe edition of Cashier. Braintree does not have a feature that corresponds to Stripe's \"quantity\".   Sometimes subscriptions are affected by \"quantity\". For example, your application might charge $10 per month  per user  on an account. To easily increment or decrement your subscription quantity, use the  incrementQuantity  and  decrementQuantity  methods:  $ user   =   User :: find ( 1 );  $ user- subscription ( main ) - incrementQuantity ();  //   Add   five   to   the   subscription s current quantity...  $user- subscription( main )- incrementQuantity(5);  $user- subscription( main )- decrementQuantity();  // Subtract five to the subscription s   current   quantity ...  $ user- subscription ( main ) - decrementQuantity ( 5 );   Alternatively, you may set a specific quantity using the  updateQuantity  method:  $user- subscription( main )- updateQuantity(10);  For more information on subscription quantities, consult the  Stripe documentation .", 
            "title": "Subscription Quantity"
        }, 
        {
            "location": "/billing/#subscription-taxes", 
            "text": "To specify the tax percentage a user pays on a subscription, implement the  taxPercentage  method on your billable model, and return a numeric value between 0 and 100, with no more than 2 decimal places.  public function taxPercentage() {\n    return 20;\n}  The  taxPercentage  method enables you to apply a tax rate on a model-by-model basis, which may be helpful for a user base that spans multiple countries and tax rates.   {note} The  taxPercentage  method only applies to subscription charges. If you use Cashier to make \"one off\" charges, you will need to manually specify the tax rate at that time.", 
            "title": "Subscription Taxes"
        }, 
        {
            "location": "/billing/#cancelling-subscriptions", 
            "text": "To cancel a subscription, simply call the  cancel  method on the user's subscription:  $user- subscription( main )- cancel();  When a subscription is cancelled, Cashier will automatically set the  ends_at  column in your database. This column is used to know when the  subscribed  method should begin returning  false . For example, if a customer cancels a subscription on March 1st, but the subscription was not scheduled to end until March 5th, the  subscribed  method will continue to return  true  until March 5th.  You may determine if a user has cancelled their subscription but are still on their \"grace period\" using the  onGracePeriod  method:  if ($user- subscription( main )- onGracePeriod()) {\n    //\n}  If you wish to cancel a subscription immediately, call the  cancelNow  method on the user's subscription:  $user- subscription( main )- cancelNow();", 
            "title": "Cancelling Subscriptions"
        }, 
        {
            "location": "/billing/#resuming-subscriptions", 
            "text": "If a user has cancelled their subscription and you wish to resume it, use the  resume  method. The user  must  still be on their grace period in order to resume a subscription:  $user- subscription( main )- resume();  If the user cancels a subscription and then resumes that subscription before the subscription has fully expired, they will not be billed immediately. Instead, their subscription will simply be re-activated, and they will be billed on the original billing cycle.", 
            "title": "Resuming Subscriptions"
        }, 
        {
            "location": "/billing/#updating-credit-cards", 
            "text": "The  updateCard  method may be used to update a customer's credit card information. This method accepts a Stripe token and will assign the new credit card as the default billing source:  $user- updateCard($stripeToken);", 
            "title": "Updating Credit Cards"
        }, 
        {
            "location": "/billing/#subscription-trials", 
            "text": "", 
            "title": "Subscription Trials"
        }, 
        {
            "location": "/billing/#with-credit-card-up-front", 
            "text": "If you would like to offer trial periods to your customers while still collecting payment method information up front, You should use the  trialDays  method when creating your subscriptions:  $ user   =   User :: find ( 1 );  $ user- newSubscription ( main ,   monthly ) \n             - trialDays ( 10 ) \n             - create ($ stripeToken );   This method will set the trial period ending date on the subscription record within the database, as well as instruct Stripe / Braintree to not begin billing the customer until after this date.   {note} If the customer's subscription is not cancelled before the trial ending date they will be charged as soon as the trial expires, so you should be sure to notify your users of their trial ending date.   You may determine if the user is within their trial period using either the  onTrial  method of the user instance, or the  onTrial  method of the subscription instance. The two examples below are identical:  if ($user- onTrial( main )) {\n    //\n}\n\nif ($user- subscription( main )- onTrial()) {\n    //\n}", 
            "title": "With Credit Card Up Front"
        }, 
        {
            "location": "/billing/#without-credit-card-up-front", 
            "text": "If you would like to offer trial periods without collecting the user's payment method information up front, you may simply set the  trial_ends_at  column on the user record to your desired trial ending date. This is typically done during user registration:  $user = User::create([\n    // Populate other user properties...\n     trial_ends_at  =  Carbon::now()- addDays(10),\n]);   {note}  Be sure to add a  date mutator  for  trial_ends_at  to your model definition.   Cashier refers to this type of trial as a \"generic trial\", since it is not attached to any existing subscription. The  onTrial  method on the  User  instance will return  true  if the current date is not past the value of  trial_ends_at :  if ($user- onTrial()) {\n    // User is within their trial period...\n}  You may also use the  onGenericTrial  method if you wish to know specifically that the user is within their \"generic\" trial period and has not created an actual subscription yet:  if ($user- onGenericTrial()) {\n    // User is within their  generic  trial period...\n}  Once you are ready to create an actual subscription for the user, you may use the  newSubscription  method as usual:  $ user   =   User :: find ( 1 );  $ user- newSubscription ( main ,   monthly ) - create ($ stripeToken );", 
            "title": "Without Credit Card Up Front"
        }, 
        {
            "location": "/billing/#handling-stripe-webhooks", 
            "text": "Both Stripe and Braintree can notify your application of a variety of events via webhooks. To handle Stripe webhooks, define a route that points to Cashier's webhook controller. This controller will handle all incoming webhook requests and dispatch them to the proper controller method:  Route::post(\n     stripe/webhook ,\n     \\Laravel\\Cashier\\Http\\Controllers\\WebhookController@handleWebhook \n);   {note} Once you have registered your route, be sure to configure the webhook URL in your Stripe control panel settings.   By default, this controller will automatically handle cancelling subscriptions that have too many failed charges (as defined by your Stripe settings); however, as we'll soon discover, you can extend this controller to handle any webhook event you like.", 
            "title": "Handling Stripe Webhooks"
        }, 
        {
            "location": "/billing/#webhooks-csrf-protection", 
            "text": "Since Stripe webhooks need to bypass Laravel's  CSRF protection , be sure to list the URI as an exception in your  VerifyCsrfToken  middleware or list the route outside of the  web  middleware group:  protected $except = [\n     stripe/* ,\n];", 
            "title": "Webhooks &amp; CSRF Protection"
        }, 
        {
            "location": "/billing/#defining-webhook-event-handlers", 
            "text": "Cashier automatically handles subscription cancellation on failed charges, but if you have additional Stripe webhook events you would like to handle, simply extend the Webhook controller. Your method names should correspond to Cashier's expected convention, specifically, methods should be prefixed with  handle  and the \"camel case\" name of the Stripe webhook you wish to handle. For example, if you wish to handle the  invoice.payment_succeeded  webhook, you should add a  handleInvoicePaymentSucceeded  method to the controller:  ? php  namespace   App \\ Http \\ Controllers ;  use   Laravel \\ Cashier \\ Http \\ Controllers \\ WebhookController   as   CashierController ;  class   WebhookController   extends   CashierController  { \n     /**       * Handle a Stripe webhook.       *       * @param  array  $payload       * @return Response       */ \n     public   function   handleInvoicePaymentSucceeded ( $payload ) \n     { \n         // Handle The Event \n     }  }", 
            "title": "Defining Webhook Event Handlers"
        }, 
        {
            "location": "/billing/#failed-subscriptions", 
            "text": "What if a customer's credit card expires? No worries - Cashier includes a Webhook controller that can easily cancel the customer's subscription for you. As noted above, all you need to do is point a route to the controller:  Route::post(\n     stripe/webhook ,\n     \\Laravel\\Cashier\\Http\\Controllers\\WebhookController@handleWebhook \n);  That's it! Failed payments will be captured and handled by the controller. The controller will cancel the customer's subscription when Stripe determines the subscription has failed (normally after three failed payment attempts).", 
            "title": "Failed Subscriptions"
        }, 
        {
            "location": "/billing/#handling-braintree-webhooks", 
            "text": "Both Stripe and Braintree can notify your application of a variety of events via webhooks. To handle Braintree webhooks, define a route that points to Cashier's webhook controller. This controller will handle all incoming webhook requests and dispatch them to the proper controller method:  Route::post(\n     braintree/webhook ,\n     \\Laravel\\Cashier\\Http\\Controllers\\WebhookController@handleWebhook \n);   {note} Once you have registered your route, be sure to configure the webhook URL in your Braintree control panel settings.   By default, this controller will automatically handle cancelling subscriptions that have too many failed charges (as defined by your Braintree settings); however, as we'll soon discover, you can extend this controller to handle any webhook event you like.", 
            "title": "Handling Braintree Webhooks"
        }, 
        {
            "location": "/billing/#webhooks-csrf-protection_1", 
            "text": "Since Braintree webhooks need to bypass Laravel's  CSRF protection , be sure to list the URI as an exception in your  VerifyCsrfToken  middleware or list the route outside of the  web  middleware group:  protected $except = [\n     braintree/* ,\n];", 
            "title": "Webhooks &amp; CSRF Protection"
        }, 
        {
            "location": "/billing/#defining-webhook-event-handlers_1", 
            "text": "Cashier automatically handles subscription cancellation on failed charges, but if you have additional Braintree webhook events you would like to handle, simply extend the Webhook controller. Your method names should correspond to Cashier's expected convention, specifically, methods should be prefixed with  handle  and the \"camel case\" name of the Braintree webhook you wish to handle. For example, if you wish to handle the  dispute_opened  webhook, you should add a  handleDisputeOpened  method to the controller:  ? php  namespace   App \\ Http \\ Controllers ;  use   Braintree \\ WebhookNotification ;  use   Laravel \\ Cashier \\ Http \\ Controllers \\ WebhookController   as   CashierController ;  class   WebhookController   extends   CashierController  { \n     /**       * Handle a Braintree webhook.       *       * @param  WebhookNotification  $webhook       * @return Response       */ \n     public   function   handleDisputeOpened ( WebhookNotification   $notification ) \n     { \n         // Handle The Event \n     }  }", 
            "title": "Defining Webhook Event Handlers"
        }, 
        {
            "location": "/billing/#failed-subscriptions_1", 
            "text": "What if a customer's credit card expires? No worries - Cashier includes a Webhook controller that can easily cancel the customer's subscription for you. Just point a route to the controller:  Route::post(\n     braintree/webhook ,\n     \\Laravel\\Cashier\\Http\\Controllers\\WebhookController@handleWebhook \n);  That's it! Failed payments will be captured and handled by the controller. The controller will cancel the customer's subscription when Braintree determines the subscription has failed (normally after three failed payment attempts). Don't forget: you will need to configure the webhook URI in your Braintree control panel settings.", 
            "title": "Failed Subscriptions"
        }, 
        {
            "location": "/billing/#single-charges", 
            "text": "", 
            "title": "Single Charges"
        }, 
        {
            "location": "/billing/#simple-charge", 
            "text": "{note} When using Stripe, the  charge  method accepts the amount you would like to charge in the  lowest denominator of the currency used by your application . However, when using Braintree, you should pass the full dollar amount to the  charge  method:   If you would like to make a \"one off\" charge against a subscribed customer's credit card, you may use the  charge  method on a billable model instance.  // Stripe Accepts Charges In Cents...\n$user- charge(100);\n\n// Braintree Accepts Charges In Dollars...\n$user- charge(1);  The  charge  method accepts an array as its second argument, allowing you to pass any options you wish to the underlying Stripe / Braintree charge creation. Consult the Stripe or Braintree documentation regarding the options available to you when creating charges:  $user- charge(100, [\n     custom_option  =  $value,\n]);  The  charge  method will throw an exception if the charge fails. If the charge is successful, the full Stripe / Braintree response will be returned from the method:  try {\n    $response = $user- charge(100);\n} catch (Exception $e) {\n    //\n}", 
            "title": "Simple Charge"
        }, 
        {
            "location": "/billing/#charge-with-invoice", 
            "text": "Sometimes you may need to make a one-time charge but also generate an invoice for the charge so that you may offer a PDF receipt to your customer. The  invoiceFor  method lets you do just that. For example, let's invoice the customer $5.00 for a \"One Time Fee\":  // Stripe Accepts Charges In Cents...\n$user- invoiceFor( One Time Fee , 500);\n\n// Braintree Accepts Charges In Dollars...\n$user- invoiceFor( One Time Fee , 5);  The invoice will be charged immediately against the user's credit card. The  invoiceFor  method also accepts an array as its third argument, allowing you to pass any options you wish to the underlying Stripe / Braintree charge creation:  $user- invoiceFor( One Time Fee , 500, [\n     custom-option  =  $value,\n]);   {note} The  invoiceFor  method will create a Stripe invoice which will retry failed billing attempts. If you do not want invoices to retry failed charges, you will need to close them using the Stripe API after the first failed charge.", 
            "title": "Charge With Invoice"
        }, 
        {
            "location": "/billing/#invoices", 
            "text": "You may easily retrieve an array of a billable model's invoices using the  invoices  method:  $invoices = $user- invoices();\n\n// Include pending invoices in the results...\n$invoices = $user- invoicesIncludingPending();  When listing the invoices for the customer, you may use the invoice's helper methods to display the relevant invoice information. For example, you may wish to list every invoice in a table, allowing the user to easily download any of them:  table \n     @ foreach   ( $ invoices   as   $ invoice ) \n         tr \n             td {{   $ invoice - date () - toFormattedDateString ()   }} / td \n             td {{   $ invoice - total ()   }} / td \n             td a   href = /user/invoice/{{ $invoice- id }} Download / a / td \n         / tr \n     @ endforeach  / table", 
            "title": "Invoices"
        }, 
        {
            "location": "/billing/#generating-invoice-pdfs", 
            "text": "Before generating invoice PDFs, you need to install the  dompdf  PHP library:  composer require dompdf/dompdf  Then, from within a route or controller, use the  downloadInvoice  method to generate a PDF download of the invoice. This method will automatically generate the proper HTTP response to send the download to the browser:  use Illuminate\\Http\\Request;\n\nRoute::get( user/invoice/{invoice} , function (Request $request, $invoiceId) {\n    return $request- user()- downloadInvoice($invoiceId, [\n         vendor   =   Your Company ,\n         product  =   Your Product ,\n    ]);\n});", 
            "title": "Generating Invoice PDFs"
        }, 
        {
            "location": "/blade/", 
            "text": "Blade Templates\n\n\n\n\nIntroduction\n\n\nTemplate Inheritance\n\n\nDefining A Layout\n\n\nExtending A Layout\n\n\n\n\n\n\nComponents \n Slots\n\n\nDisplaying Data\n\n\nBlade \n JavaScript Frameworks\n\n\n\n\n\n\nControl Structures\n\n\nIf Statements\n\n\nLoops\n\n\nThe Loop Variable\n\n\nComments\n\n\nPHP\n\n\n\n\n\n\nIncluding Sub-Views\n\n\nRendering Views For Collections\n\n\n\n\n\n\nStacks\n\n\nService Injection\n\n\nExtending Blade\n\n\n\n\n\n\nIntroduction\n\n\nBlade is the simple, yet powerful templating engine provided with Laravel. Unlike other popular PHP templating engines, Blade does not restrict you from using plain PHP code in your views. In fact, all Blade views are compiled into plain PHP code and cached until they are modified, meaning Blade adds essentially zero overhead to your application. Blade view files use the \n.blade.php\n file extension and are typically stored in the \nresources/views\n directory.\n\n\n\n\nTemplate Inheritance\n\n\n\n\nDefining A Layout\n\n\nTwo of the primary benefits of using Blade are \ntemplate inheritance\n and \nsections\n. To get started, let's take a look at a simple example. First, we will examine a \"master\" page layout. Since most web applications maintain the same general layout across various pages, it's convenient to define this layout as a single Blade view:\n\n\n!-- Stored in resources/views/layouts/app.blade.php --\n\n\n\nhtml\n\n    \nhead\n\n        \ntitle\nApp Name - @yield(\ntitle\n)\n/title\n\n    \n/head\n\n    \nbody\n\n        @section(\nsidebar\n)\n            This is the master sidebar.\n        @show\n\n        \ndiv\n \nclass=\ncontainer\n\n            @yield(\ncontent\n)\n        \n/div\n\n    \n/body\n\n\n/html\n\n\n\n\n\n\nAs you can see, this file contains typical HTML mark-up. However, take note of the \n@section\n and \n@yield\n directives. The \n@section\n directive, as the name implies, defines a section of content, while the \n@yield\n directive is used to display the contents of a given section.\n\n\nNow that we have defined a layout for our application, let's define a child page that inherits the layout.\n\n\n\n\nExtending A Layout\n\n\nWhen defining a child view, use the Blade \n@extends\n directive to specify which layout the child view should \"inherit\". Views which extend a Blade layout may inject content into the layout's sections using \n@section\n directives. Remember, as seen in the example above, the contents of these sections will be displayed in the layout using \n@yield\n:\n\n\n!--\n \nStored\n \nin\n \nresources\n/\nviews\n/\nchild\n.\nblade\n.\nphp\n \n--\n\n\n\n@\nextends\n(\nlayouts\n.\napp\n)\n\n\n\n@\nsection\n(\ntitle\n,\n \nPage\n \nTitle\n)\n\n\n\n@\nsection\n(\nsidebar\n)\n\n    \n@@\nparent\n\n\n    \np\nThis\n \nis\n \nappended\n \nto\n \nthe\n \nmaster\n \nsidebar\n.\n/\np\n\n\n@\nendsection\n\n\n\n@\nsection\n(\ncontent\n)\n\n    \np\nThis\n \nis\n \nmy\n \nbody\n \ncontent\n.\n/\np\n\n\n@\nendsection\n\n\n\n\n\n\nIn this example, the \nsidebar\n section is utilizing the \n@@parent\n directive to append (rather than overwriting) content to the layout's sidebar. The \n@@parent\n directive will be replaced by the content of the layout when the view is rendered.\n\n\nBlade views may be returned from routes using the global \nview\n helper:\n\n\nRoute::get(\nblade\n, function () {\n    return view(\nchild\n);\n});\n\n\n\n\n\n\n\nComponents \n Slots\n\n\nComponents and slots provide similar benefits to sections and layouts; however, some may find the mental model of components and slots easier to understand. First, let's imagine a reusable \"alert\" component we would like to reuse throughout our application:\n\n\n!-- /resources/views/alert.blade.php --\n\n\n\ndiv\n \nclass=\nalert alert-danger\n\n    \n{{\n \n$\nslot\n \n}}\n\n\n/div\n\n\n\n\n\n\nThe \n{{ $slot }}\n variable will contain the content we wish to inject into the component. Now, to construct this component, we can use the \n@component\n Blade directive:\n\n\n@\ncomponent\n(\nalert\n)\n\n    \nstrong\nWhoops\n!\n/\nstrong\n \nSomething\n \nwent\n \nwrong\n!\n\n\n@\nendcomponent\n\n\n\n\n\n\nSometimes it is helpful to define multiple slots for a component. Let's modify our alert component to allow for the injection of a \"title\". Named slots may be displayed by simply \"echoing\" the variable that matches their name:\n\n\n!-- /resources/views/alert.blade.php --\n\n\n\ndiv\n \nclass=\nalert alert-danger\n\n    \ndiv\n \nclass=\nalert-title\n{{\n \n$\ntitle\n \n}}\n/div\n\n\n    \n{{\n \n$\nslot\n \n}}\n\n\n/div\n\n\n\n\n\n\nNow, we can inject content into the named slot using the \n@slot\n directive. Any content not within a \n@slot\n directive will be passed to the component in the \n$slot\n variable:\n\n\n@\ncomponent\n(\nalert\n)\n\n    \n@\nslot\n(\ntitle\n)\n\n        \nForbidden\n\n    \n@\nendslot\n\n\n    \nYou\n \nare\n \nnot\n \nallowed\n \nto\n \naccess\n \nthis\n \nresource\n!\n\n\n@\nendcomponent\n\n\n\n\n\n\nPassing Additional Data To Components\n\n\nSometimes you may need to pass additional data to a component. For this reason, you can pass an array of data as the second argument to the \n@component\n directive. All of the data will be made available to the component template as variables:\n\n\n@\ncomponent\n(\nalert\n,\n \n[\nfoo\n \n=\n \nbar\n])\n\n    \n...\n\n\n@\nendcomponent\n\n\n\n\n\n\n\n\nDisplaying Data\n\n\nYou may display data passed to your Blade views by wrapping the variable in curly braces. For example, given the following route:\n\n\nRoute::get(\ngreeting\n, function () {\n    return view(\nwelcome\n, [\nname\n =\n \nSamantha\n]);\n});\n\n\n\n\n\nYou may display the contents of the \nname\n variable like so:\n\n\nHello, \n{{\n \n$\nname\n \n}}\n.\n\n\n\n\n\n\nOf course, you are not limited to displaying the contents of the variables passed to the view. You may also echo the results of any PHP function. In fact, you can put any PHP code you wish inside of a Blade echo statement:\n\n\nThe current UNIX timestamp is \n{{\n \ntime\n()\n \n}}\n.\n\n\n\n\n\n\n\n\n{note} Blade \n{{ }}\n statements are automatically sent through PHP's \nhtmlentities\n function to prevent XSS attacks.\n\n\n\n\nEchoing Data If It Exists\n\n\nSometimes you may wish to echo a variable, but you aren't sure if the variable has been set. You can do this using PHP's null coalescing operator:\n\n\n{{\n \n$\nname\n \n??\n \nDefault\n \n}}\n\n\n\n\n\n\nIn this example, if the \n$name\n variable exists, its value will be displayed. However, if it does not exist, the word \nDefault\n will be displayed.\n\n\nDisplaying Unescaped Data\n\n\nBy default, Blade \n{{ }}\n statements are automatically sent through PHP's \nhtmlentities\n function to prevent XSS attacks. If you do not want your data to be escaped, you may use the following syntax:\n\n\nHello, {!! $name !!}.\n\n\n\n\n\n\n\n{note} Be very careful when echoing content that is supplied by users of your application. Always use the escaped, double curly brace syntax to prevent XSS attacks when displaying user supplied data.\n\n\n\n\n\n\nBlade \n JavaScript Frameworks\n\n\nSince many JavaScript frameworks also use \"curly\" braces to indicate a given expression should be displayed in the browser, you may use the \n@\n symbol to inform the Blade rendering engine an expression should remain untouched. For example:\n\n\nh1\nLaravel\n/h1\n\n\nHello, @\n{{\n \nname\n \n}}\n.\n\n\n\n\n\nIn this example, the \n@\n symbol will be removed by Blade; however, \n{{ name }}\n expression will remain untouched by the Blade engine, allowing it to instead be rendered by your JavaScript framework.\n\n\nThe \n@verbatim\n Directive\n\n\nIf you are displaying JavaScript variables in a large portion of your template, you may wrap the HTML in the \n@verbatim\n directive so that you do not have to prefix each Blade echo statement with an \n@\n symbol:\n\n\n@\nverbatim\n\n    \ndiv\n \nclass\n=\ncontainer\n\n        \nHello\n,\n \n{{\n \nname\n \n}}.\n\n    \n/\ndiv\n\n\n@\nendverbatim\n\n\n\n\n\n\n\n\nControl Structures\n\n\nIn addition to template inheritance and displaying data, Blade also provides convenient shortcuts for common PHP control structures, such as conditional statements and loops. These shortcuts provide a very clean, terse way of working with PHP control structures, while also remaining familiar to their PHP counterparts.\n\n\n\n\nIf Statements\n\n\nYou may construct \nif\n statements using the \n@if\n, \n@elseif\n, \n@else\n, and \n@endif\n directives. These directives function identically to their PHP counterparts:\n\n\n@\nif\n \n(\ncount\n(\n$\nrecords\n)\n \n===\n \n1\n)\n\n    \nI\n \nhave\n \none\n \nrecord\n!\n\n\n@\nelseif\n \n(\ncount\n(\n$\nrecords\n)\n \n \n1\n)\n\n    \nI\n \nhave\n \nmultiple\n \nrecords\n!\n\n\n@\nelse\n\n    \nI\n \ndon\nt\n \nhave\n \nany\n \nrecords\n!\n\n\n@\nendif\n\n\n\n\n\n\nFor convenience, Blade also provides an \n@unless\n directive:\n\n\n@\nunless\n \n(\nAuth\n::\ncheck\n())\n\n    \nYou\n \nare\n \nnot\n \nsigned\n \nin\n.\n\n\n@\nendunless\n\n\n\n\n\n\n\n\nLoops\n\n\nIn addition to conditional statements, Blade provides simple directives for working with PHP's loop structures. Again, each of these directives functions identically to their PHP counterparts:\n\n\n@\nfor\n \n(\n$\ni\n \n=\n \n0\n;\n \n$\ni\n \n \n10\n;\n \n$\ni\n++\n)\n\n    \nThe\n \ncurrent\n \nvalue\n \nis\n \n{{\n \n$\ni\n \n}}\n\n\n@\nendfor\n\n\n\n@\nforeach\n \n(\n$\nusers\n \nas\n \n$\nuser\n)\n\n    \np\nThis\n \nis\n \nuser\n \n{{\n \n$\nuser\n-\nid\n \n}}\n/\np\n\n\n@\nendforeach\n\n\n\n@\nforelse\n \n(\n$\nusers\n \nas\n \n$\nuser\n)\n\n    \nli\n{{\n \n$\nuser\n-\nname\n \n}}\n/\nli\n\n\n@\nempty\n\n    \np\nNo\n \nusers\n/\np\n\n\n@\nendforelse\n\n\n\n@\nwhile\n \n(\ntrue\n)\n\n    \np\nI\nm\n \nlooping\n \nforever\n.\n/\np\n\n\n@\nendwhile\n\n\n\n\n\n\n\n\n{tip} When looping, you may use the \nloop variable\n to gain valuable information about the loop, such as whether you are in the first or last iteration through the loop.\n\n\n\n\nWhen using loops you may also end the loop or skip the current iteration:\n\n\n@\nforeach\n \n(\n$\nusers\n \nas\n \n$\nuser\n)\n\n    \n@\nif\n \n(\n$\nuser\n-\ntype\n \n==\n \n1\n)\n\n        \n@\ncontinue\n\n    \n@\nendif\n\n\n    \nli\n{{\n \n$\nuser\n-\nname\n \n}}\n/\nli\n\n\n    \n@\nif\n \n(\n$\nuser\n-\nnumber\n \n==\n \n5\n)\n\n        \n@\nbreak\n\n    \n@\nendif\n\n\n@\nendforeach\n\n\n\n\n\n\nYou may also include the condition with the directive declaration in one line:\n\n\n@\nforeach\n \n(\n$\nusers\n \nas\n \n$\nuser\n)\n\n    \n@\ncontinue\n(\n$\nuser\n-\ntype\n \n==\n \n1\n)\n\n\n    \nli\n{{\n \n$\nuser\n-\nname\n \n}}\n/\nli\n\n\n    \n@\nbreak\n(\n$\nuser\n-\nnumber\n \n==\n \n5\n)\n\n\n@\nendforeach\n\n\n\n\n\n\n\n\nThe Loop Variable\n\n\nWhen looping, a \n$loop\n variable will be available inside of your loop. This variable provides access to some useful bits of information such as the current loop index and whether this is the first or last iteration through the loop:\n\n\n@\nforeach\n \n(\n$\nusers\n \nas\n \n$\nuser\n)\n\n    \n@\nif\n \n(\n$\nloop\n-\nfirst\n)\n\n        \nThis\n \nis\n \nthe\n \nfirst\n \niteration\n.\n\n    \n@\nendif\n\n\n    \n@\nif\n \n(\n$\nloop\n-\nlast\n)\n\n        \nThis\n \nis\n \nthe\n \nlast\n \niteration\n.\n\n    \n@\nendif\n\n\n    \np\nThis\n \nis\n \nuser\n \n{{\n \n$\nuser\n-\nid\n \n}}\n/\np\n\n\n@\nendforeach\n\n\n\n\n\n\nIf you are in a nested loop, you may access the parent loop's \n$loop\n variable via the \nparent\n property:\n\n\n@\nforeach\n \n(\n$\nusers\n \nas\n \n$\nuser\n)\n\n    \n@\nforeach\n \n(\n$\nuser\n-\nposts\n \nas\n \n$\npost\n)\n\n        \n@\nif\n \n(\n$\nloop\n-\nparent\n-\nfirst\n)\n\n            \nThis\n \nis\n \nfirst\n \niteration\n \nof\n \nthe\n \nparent\n \nloop\n.\n\n        \n@\nendif\n\n    \n@\nendforeach\n\n\n@\nendforeach\n\n\n\n\n\n\nThe \n$loop\n variable also contains a variety of other useful properties:\n\n\n\n\n\n\n\n\nProperty\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$loop-\nindex\n\n\nThe index of the current loop iteration (starts at 0).\n\n\n\n\n\n\n$loop-\niteration\n\n\nThe current loop iteration (starts at 1).\n\n\n\n\n\n\n$loop-\nremaining\n\n\nThe iteration remaining in the loop.\n\n\n\n\n\n\n$loop-\ncount\n\n\nThe total number of items in the array being iterated.\n\n\n\n\n\n\n$loop-\nfirst\n\n\nWhether this is the first iteration through the loop.\n\n\n\n\n\n\n$loop-\nlast\n\n\nWhether this is the last iteration through the loop.\n\n\n\n\n\n\n$loop-\ndepth\n\n\nThe nesting level of the current loop.\n\n\n\n\n\n\n$loop-\nparent\n\n\nWhen in a nested loop, the parent's loop variable.\n\n\n\n\n\n\n\n\n\n\nComments\n\n\nBlade also allows you to define comments in your views. However, unlike HTML comments, Blade comments are not included in the HTML returned by your application:\n\n\n{{\n--\n \nThis\n \ncomment\n \nwill\n \nnot\n \nbe\n \npresent\n \nin\n \nthe\n \nrendered\n \nHTML\n \n-\n-\n}}\n\n\n\n\n\n\n\n\nPHP\n\n\nIn some situations, it's useful to embed PHP code into your views. You can use the Blade \n@php\n directive to execute a block of plain PHP within your template:\n\n\n@\nphp\n\n    \n//\n\n\n@\nendphp\n\n\n\n\n\n\n\n\n{tip} While Blade provides this feature, using it frequently may be a signal that you have too much logic embedded within your template.\n\n\n\n\n\n\nIncluding Sub-Views\n\n\nBlade's \n@include\n directive allows you to include a Blade view from within another view. All variables that are available to the parent view will be made available to the included view:\n\n\ndiv\n\n    @include(\nshared.errors\n)\n\n    \nform\n\n        \n!-- Form Contents --\n\n    \n/form\n\n\n/div\n\n\n\n\n\n\nEven though the included view will inherit all data available in the parent view, you may also pass an array of extra data to the included view:\n\n\n@include(\nview.name\n, [\nsome\n =\n \ndata\n])\n\n\n\n\n\nOf course, if you attempt to \n@include\n a view which does not exist, Laravel will throw an error. If you would like to include a view that may or may not be present, you should use the \n@includeIf\n directive:\n\n\n@includeIf(\nview.name\n, [\nsome\n =\n \ndata\n])\n\n\n\n\n\n\n\n{note} You should avoid using the \n__DIR__\n and \n__FILE__\n constants in your Blade views, since they will refer to the location of the cached, compiled view.\n\n\n\n\n\n\nRendering Views For Collections\n\n\nYou may combine loops and includes into one line with Blade's \n@each\n directive:\n\n\n@each(\nview.name\n, $jobs, \njob\n)\n\n\n\n\n\nThe first argument is the view partial to render for each element in the array or collection. The second argument is the array or collection you wish to iterate over, while the third argument is the variable name that will be assigned to the current iteration within the view. So, for example, if you are iterating over an array of \njobs\n, typically you will want to access each job as a \njob\n variable within your view partial. The key for the current iteration will be available as the \nkey\n variable within your view partial.\n\n\nYou may also pass a fourth argument to the \n@each\n directive. This argument determines the view that will be rendered if the given array is empty.\n\n\n@each(\nview.name\n, $jobs, \njob\n, \nview.empty\n)\n\n\n\n\n\n\n\nStacks\n\n\nBlade allows you to push to named stacks which can be rendered somewhere else in another view or layout. This can be particularly useful for specifying any JavaScript libraries required by your child views:\n\n\n@\npush\n(\nscripts\n)\n\n    \nscript\n \nsrc\n=\n/example.js\n/\nscript\n\n\n@\nendpush\n\n\n\n\n\n\nYou may push to a stack as many times as needed. To render the complete stack contents, pass the name of the stack to the \n@stack\n directive:\n\n\nhead\n\n    \n!-- Head Contents --\n\n\n    @stack(\nscripts\n)\n\n/head\n\n\n\n\n\n\n\n\nService Injection\n\n\nThe \n@inject\n directive may be used to retrieve a service from the Laravel \nservice container\n. The first argument passed to \n@inject\n is the name of the variable the service will be placed into, while the second argument is the class or interface name of the service you wish to resolve:\n\n\n@inject(\nmetrics\n, \nApp\\Services\\MetricsService\n)\n\n\ndiv\n\n    Monthly Revenue: \n{{\n \n$\nmetrics-\nmonthlyRevenue\n()\n \n}}\n.\n\n/div\n\n\n\n\n\n\n\n\nExtending Blade\n\n\nBlade allows you to define your own custom directives using the \ndirective\n method. When the Blade compiler encounters the custom directive, it will call the provided callback with the expression that the directive contains.\n\n\nThe following example creates a \n@datetime($var)\n directive which formats a given \n$var\n, which should be an instance of \nDateTime\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nBlade\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\n\nclass\n \nAppServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Perform post-registration booting of services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nBlade\n::\ndirective\n(\ndatetime\n,\n \nfunction\n \n(\n$expression\n)\n \n{\n\n            \nreturn\n \n?php echo ($expression)-\nformat(\nm/d/Y H:i\n); ?\n;\n\n        \n});\n\n    \n}\n\n\n    \n/**\n\n\n     * Register bindings in the container.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAs you can see, we will chain the \nformat\n method onto whatever expression is passed into the directive. So, in this example, the final PHP generated by this directive will be:\n\n\n?php\n \necho\n \n(\n$var\n)\n-\nformat\n(\nm/d/Y H:i\n);\n \n?\n\n\n\n\n\n\n\n\n{note} After updating the logic of a Blade directive, you will need to delete all of the cached Blade views. The cached Blade views may be removed using the \nview:clear\n Artisan command.", 
            "title": "Blade"
        }, 
        {
            "location": "/blade/#blade-templates", 
            "text": "Introduction  Template Inheritance  Defining A Layout  Extending A Layout    Components   Slots  Displaying Data  Blade   JavaScript Frameworks    Control Structures  If Statements  Loops  The Loop Variable  Comments  PHP    Including Sub-Views  Rendering Views For Collections    Stacks  Service Injection  Extending Blade", 
            "title": "Blade Templates"
        }, 
        {
            "location": "/blade/#introduction", 
            "text": "Blade is the simple, yet powerful templating engine provided with Laravel. Unlike other popular PHP templating engines, Blade does not restrict you from using plain PHP code in your views. In fact, all Blade views are compiled into plain PHP code and cached until they are modified, meaning Blade adds essentially zero overhead to your application. Blade view files use the  .blade.php  file extension and are typically stored in the  resources/views  directory.", 
            "title": "Introduction"
        }, 
        {
            "location": "/blade/#template-inheritance", 
            "text": "", 
            "title": "Template Inheritance"
        }, 
        {
            "location": "/blade/#defining-a-layout", 
            "text": "Two of the primary benefits of using Blade are  template inheritance  and  sections . To get started, let's take a look at a simple example. First, we will examine a \"master\" page layout. Since most web applications maintain the same general layout across various pages, it's convenient to define this layout as a single Blade view:  !-- Stored in resources/views/layouts/app.blade.php --  html \n     head \n         title App Name - @yield( title ) /title \n     /head \n     body \n        @section( sidebar )\n            This is the master sidebar.\n        @show\n\n         div   class= container \n            @yield( content )\n         /div \n     /body  /html   As you can see, this file contains typical HTML mark-up. However, take note of the  @section  and  @yield  directives. The  @section  directive, as the name implies, defines a section of content, while the  @yield  directive is used to display the contents of a given section.  Now that we have defined a layout for our application, let's define a child page that inherits the layout.", 
            "title": "Defining A Layout"
        }, 
        {
            "location": "/blade/#extending-a-layout", 
            "text": "When defining a child view, use the Blade  @extends  directive to specify which layout the child view should \"inherit\". Views which extend a Blade layout may inject content into the layout's sections using  @section  directives. Remember, as seen in the example above, the contents of these sections will be displayed in the layout using  @yield :  !--   Stored   in   resources / views / child . blade . php   --  @ extends ( layouts . app )  @ section ( title ,   Page   Title )  @ section ( sidebar ) \n     @@ parent \n\n     p This   is   appended   to   the   master   sidebar . / p  @ endsection  @ section ( content ) \n     p This   is   my   body   content . / p  @ endsection   In this example, the  sidebar  section is utilizing the  @@parent  directive to append (rather than overwriting) content to the layout's sidebar. The  @@parent  directive will be replaced by the content of the layout when the view is rendered.  Blade views may be returned from routes using the global  view  helper:  Route::get( blade , function () {\n    return view( child );\n});", 
            "title": "Extending A Layout"
        }, 
        {
            "location": "/blade/#components-slots", 
            "text": "Components and slots provide similar benefits to sections and layouts; however, some may find the mental model of components and slots easier to understand. First, let's imagine a reusable \"alert\" component we would like to reuse throughout our application:  !-- /resources/views/alert.blade.php --  div   class= alert alert-danger \n     {{   $ slot   }}  /div   The  {{ $slot }}  variable will contain the content we wish to inject into the component. Now, to construct this component, we can use the  @component  Blade directive:  @ component ( alert ) \n     strong Whoops ! / strong   Something   went   wrong !  @ endcomponent   Sometimes it is helpful to define multiple slots for a component. Let's modify our alert component to allow for the injection of a \"title\". Named slots may be displayed by simply \"echoing\" the variable that matches their name:  !-- /resources/views/alert.blade.php --  div   class= alert alert-danger \n     div   class= alert-title {{   $ title   }} /div \n\n     {{   $ slot   }}  /div   Now, we can inject content into the named slot using the  @slot  directive. Any content not within a  @slot  directive will be passed to the component in the  $slot  variable:  @ component ( alert ) \n     @ slot ( title ) \n         Forbidden \n     @ endslot \n\n     You   are   not   allowed   to   access   this   resource !  @ endcomponent", 
            "title": "Components &amp; Slots"
        }, 
        {
            "location": "/blade/#passing-additional-data-to-components", 
            "text": "Sometimes you may need to pass additional data to a component. For this reason, you can pass an array of data as the second argument to the  @component  directive. All of the data will be made available to the component template as variables:  @ component ( alert ,   [ foo   =   bar ]) \n     ...  @ endcomponent", 
            "title": "Passing Additional Data To Components"
        }, 
        {
            "location": "/blade/#displaying-data", 
            "text": "You may display data passed to your Blade views by wrapping the variable in curly braces. For example, given the following route:  Route::get( greeting , function () {\n    return view( welcome , [ name  =   Samantha ]);\n});  You may display the contents of the  name  variable like so:  Hello,  {{   $ name   }} .   Of course, you are not limited to displaying the contents of the variables passed to the view. You may also echo the results of any PHP function. In fact, you can put any PHP code you wish inside of a Blade echo statement:  The current UNIX timestamp is  {{   time ()   }} .    {note} Blade  {{ }}  statements are automatically sent through PHP's  htmlentities  function to prevent XSS attacks.", 
            "title": "Displaying Data"
        }, 
        {
            "location": "/blade/#echoing-data-if-it-exists", 
            "text": "Sometimes you may wish to echo a variable, but you aren't sure if the variable has been set. You can do this using PHP's null coalescing operator:  {{   $ name   ??   Default   }}   In this example, if the  $name  variable exists, its value will be displayed. However, if it does not exist, the word  Default  will be displayed.", 
            "title": "Echoing Data If It Exists"
        }, 
        {
            "location": "/blade/#displaying-unescaped-data", 
            "text": "By default, Blade  {{ }}  statements are automatically sent through PHP's  htmlentities  function to prevent XSS attacks. If you do not want your data to be escaped, you may use the following syntax:  Hello, {!! $name !!}.   {note} Be very careful when echoing content that is supplied by users of your application. Always use the escaped, double curly brace syntax to prevent XSS attacks when displaying user supplied data.", 
            "title": "Displaying Unescaped Data"
        }, 
        {
            "location": "/blade/#blade-javascript-frameworks", 
            "text": "Since many JavaScript frameworks also use \"curly\" braces to indicate a given expression should be displayed in the browser, you may use the  @  symbol to inform the Blade rendering engine an expression should remain untouched. For example:  h1 Laravel /h1 \n\nHello, @ {{   name   }} .  In this example, the  @  symbol will be removed by Blade; however,  {{ name }}  expression will remain untouched by the Blade engine, allowing it to instead be rendered by your JavaScript framework.", 
            "title": "Blade &amp; JavaScript Frameworks"
        }, 
        {
            "location": "/blade/#the-verbatim-directive", 
            "text": "If you are displaying JavaScript variables in a large portion of your template, you may wrap the HTML in the  @verbatim  directive so that you do not have to prefix each Blade echo statement with an  @  symbol:  @ verbatim \n     div   class = container \n         Hello ,   {{   name   }}. \n     / div  @ endverbatim", 
            "title": "The @verbatim Directive"
        }, 
        {
            "location": "/blade/#control-structures", 
            "text": "In addition to template inheritance and displaying data, Blade also provides convenient shortcuts for common PHP control structures, such as conditional statements and loops. These shortcuts provide a very clean, terse way of working with PHP control structures, while also remaining familiar to their PHP counterparts.", 
            "title": "Control Structures"
        }, 
        {
            "location": "/blade/#if-statements", 
            "text": "You may construct  if  statements using the  @if ,  @elseif ,  @else , and  @endif  directives. These directives function identically to their PHP counterparts:  @ if   ( count ( $ records )   ===   1 ) \n     I   have   one   record !  @ elseif   ( count ( $ records )     1 ) \n     I   have   multiple   records !  @ else \n     I   don t   have   any   records !  @ endif   For convenience, Blade also provides an  @unless  directive:  @ unless   ( Auth :: check ()) \n     You   are   not   signed   in .  @ endunless", 
            "title": "If Statements"
        }, 
        {
            "location": "/blade/#loops", 
            "text": "In addition to conditional statements, Blade provides simple directives for working with PHP's loop structures. Again, each of these directives functions identically to their PHP counterparts:  @ for   ( $ i   =   0 ;   $ i     10 ;   $ i ++ ) \n     The   current   value   is   {{   $ i   }}  @ endfor  @ foreach   ( $ users   as   $ user ) \n     p This   is   user   {{   $ user - id   }} / p  @ endforeach  @ forelse   ( $ users   as   $ user ) \n     li {{   $ user - name   }} / li  @ empty \n     p No   users / p  @ endforelse  @ while   ( true ) \n     p I m   looping   forever . / p  @ endwhile    {tip} When looping, you may use the  loop variable  to gain valuable information about the loop, such as whether you are in the first or last iteration through the loop.   When using loops you may also end the loop or skip the current iteration:  @ foreach   ( $ users   as   $ user ) \n     @ if   ( $ user - type   ==   1 ) \n         @ continue \n     @ endif \n\n     li {{   $ user - name   }} / li \n\n     @ if   ( $ user - number   ==   5 ) \n         @ break \n     @ endif  @ endforeach   You may also include the condition with the directive declaration in one line:  @ foreach   ( $ users   as   $ user ) \n     @ continue ( $ user - type   ==   1 ) \n\n     li {{   $ user - name   }} / li \n\n     @ break ( $ user - number   ==   5 )  @ endforeach", 
            "title": "Loops"
        }, 
        {
            "location": "/blade/#the-loop-variable", 
            "text": "When looping, a  $loop  variable will be available inside of your loop. This variable provides access to some useful bits of information such as the current loop index and whether this is the first or last iteration through the loop:  @ foreach   ( $ users   as   $ user ) \n     @ if   ( $ loop - first ) \n         This   is   the   first   iteration . \n     @ endif \n\n     @ if   ( $ loop - last ) \n         This   is   the   last   iteration . \n     @ endif \n\n     p This   is   user   {{   $ user - id   }} / p  @ endforeach   If you are in a nested loop, you may access the parent loop's  $loop  variable via the  parent  property:  @ foreach   ( $ users   as   $ user ) \n     @ foreach   ( $ user - posts   as   $ post ) \n         @ if   ( $ loop - parent - first ) \n             This   is   first   iteration   of   the   parent   loop . \n         @ endif \n     @ endforeach  @ endforeach   The  $loop  variable also contains a variety of other useful properties:     Property  Description      $loop- index  The index of the current loop iteration (starts at 0).    $loop- iteration  The current loop iteration (starts at 1).    $loop- remaining  The iteration remaining in the loop.    $loop- count  The total number of items in the array being iterated.    $loop- first  Whether this is the first iteration through the loop.    $loop- last  Whether this is the last iteration through the loop.    $loop- depth  The nesting level of the current loop.    $loop- parent  When in a nested loop, the parent's loop variable.", 
            "title": "The Loop Variable"
        }, 
        {
            "location": "/blade/#comments", 
            "text": "Blade also allows you to define comments in your views. However, unlike HTML comments, Blade comments are not included in the HTML returned by your application:  {{ --   This   comment   will   not   be   present   in   the   rendered   HTML   - - }}", 
            "title": "Comments"
        }, 
        {
            "location": "/blade/#php", 
            "text": "In some situations, it's useful to embed PHP code into your views. You can use the Blade  @php  directive to execute a block of plain PHP within your template:  @ php \n     //  @ endphp    {tip} While Blade provides this feature, using it frequently may be a signal that you have too much logic embedded within your template.", 
            "title": "PHP"
        }, 
        {
            "location": "/blade/#including-sub-views", 
            "text": "Blade's  @include  directive allows you to include a Blade view from within another view. All variables that are available to the parent view will be made available to the included view:  div \n    @include( shared.errors )\n\n     form \n         !-- Form Contents -- \n     /form  /div   Even though the included view will inherit all data available in the parent view, you may also pass an array of extra data to the included view:  @include( view.name , [ some  =   data ])  Of course, if you attempt to  @include  a view which does not exist, Laravel will throw an error. If you would like to include a view that may or may not be present, you should use the  @includeIf  directive:  @includeIf( view.name , [ some  =   data ])   {note} You should avoid using the  __DIR__  and  __FILE__  constants in your Blade views, since they will refer to the location of the cached, compiled view.", 
            "title": "Including Sub-Views"
        }, 
        {
            "location": "/blade/#rendering-views-for-collections", 
            "text": "You may combine loops and includes into one line with Blade's  @each  directive:  @each( view.name , $jobs,  job )  The first argument is the view partial to render for each element in the array or collection. The second argument is the array or collection you wish to iterate over, while the third argument is the variable name that will be assigned to the current iteration within the view. So, for example, if you are iterating over an array of  jobs , typically you will want to access each job as a  job  variable within your view partial. The key for the current iteration will be available as the  key  variable within your view partial.  You may also pass a fourth argument to the  @each  directive. This argument determines the view that will be rendered if the given array is empty.  @each( view.name , $jobs,  job ,  view.empty )", 
            "title": "Rendering Views For Collections"
        }, 
        {
            "location": "/blade/#stacks", 
            "text": "Blade allows you to push to named stacks which can be rendered somewhere else in another view or layout. This can be particularly useful for specifying any JavaScript libraries required by your child views:  @ push ( scripts ) \n     script   src = /example.js / script  @ endpush   You may push to a stack as many times as needed. To render the complete stack contents, pass the name of the stack to the  @stack  directive:  head \n     !-- Head Contents -- \n\n    @stack( scripts ) /head", 
            "title": "Stacks"
        }, 
        {
            "location": "/blade/#service-injection", 
            "text": "The  @inject  directive may be used to retrieve a service from the Laravel  service container . The first argument passed to  @inject  is the name of the variable the service will be placed into, while the second argument is the class or interface name of the service you wish to resolve:  @inject( metrics ,  App\\Services\\MetricsService ) div \n    Monthly Revenue:  {{   $ metrics- monthlyRevenue ()   }} . /div", 
            "title": "Service Injection"
        }, 
        {
            "location": "/blade/#extending-blade", 
            "text": "Blade allows you to define your own custom directives using the  directive  method. When the Blade compiler encounters the custom directive, it will call the provided callback with the expression that the directive contains.  The following example creates a  @datetime($var)  directive which formats a given  $var , which should be an instance of  DateTime :  ? php  namespace   App \\ Providers ;  use   Illuminate \\ Support \\ Facades \\ Blade ;  use   Illuminate \\ Support \\ ServiceProvider ;  class   AppServiceProvider   extends   ServiceProvider  { \n     /**       * Perform post-registration booting of services.       *       * @return void       */ \n     public   function   boot () \n     { \n         Blade :: directive ( datetime ,   function   ( $expression )   { \n             return   ?php echo ($expression)- format( m/d/Y H:i ); ? ; \n         }); \n     } \n\n     /**       * Register bindings in the container.       *       * @return void       */ \n     public   function   register () \n     { \n         // \n     }  }   As you can see, we will chain the  format  method onto whatever expression is passed into the directive. So, in this example, the final PHP generated by this directive will be:  ?php   echo   ( $var ) - format ( m/d/Y H:i );   ?    {note} After updating the logic of a Blade directive, you will need to delete all of the cached Blade views. The cached Blade views may be removed using the  view:clear  Artisan command.", 
            "title": "Extending Blade"
        }, 
        {
            "location": "/broadcasting/", 
            "text": "Event Broadcasting\n\n\n\n\nIntroduction\n\n\nConfiguration\n\n\nDriver Prerequisites\n\n\n\n\n\n\nConcept Overview\n\n\nUsing An Example Application\n\n\n\n\n\n\nDefining Broadcast Events\n\n\nBroadcast Name\n\n\nBroadcast Data\n\n\nBroadcast Queue\n\n\n\n\n\n\nAuthorizing Channels\n\n\nDefining Authorization Routes\n\n\nDefining Authorization Callbacks\n\n\n\n\n\n\nBroadcasting Events\n\n\nOnly To Others\n\n\n\n\n\n\nReceiving Broadcasts\n\n\nInstalling Laravel Echo\n\n\nListening For Events\n\n\nLeaving A Channel\n\n\nNamespaces\n\n\n\n\n\n\nPresence Channels\n\n\nAuthorizing Presence Channels\n\n\nJoining Presence Channels\n\n\nBroadcasting To Presence Channels\n\n\n\n\n\n\nClient Events\n\n\nNotifications\n\n\n\n\n\n\nIntroduction\n\n\nIn many modern web applications, WebSockets are used to implement realtime, live-updating user interfaces. When some data is updated on the server, a message is typically sent over a WebSocket connection to be handled by the client. This provides a more robust, efficient alternative to continually polling your application for changes.\n\n\nTo assist you in building these types of applications, Laravel makes it easy to \"broadcast\" your \nevents\n over a WebSocket connection. Broadcasting your Laravel events allows you to share the same event names between your server-side code and your client-side JavaScript application.\n\n\n\n\n{tip} Before diving into event broadcasting, make sure you have read all of the documentation regarding Laravel \nevents and listeners\n.\n\n\n\n\n\n\nConfiguration\n\n\nAll of your application's event broadcasting configuration is stored in the \nconfig/broadcasting.php\n configuration file. Laravel supports several broadcast drivers out of the box: \nPusher\n, \nRedis\n, and a \nlog\n driver for local development and debugging. Additionally, a \nnull\n driver is included which allows you to totally disable broadcasting. A configuration example is included for each of these drivers in the \nconfig/broadcasting.php\n configuration file.\n\n\nBroadcast Service Provider\n\n\nBefore broadcasting any events, you will first need to register the \nApp\\Providers\\BroadcastServiceProvider\n. In fresh Laravel applications, you only need to uncomment this provider in the \nproviders\n array of your \nconfig/app.php\n configuration file. This provider will allow you to register the broadcast authorization routes and callbacks.\n\n\nCSRF Token\n\n\nLaravel Echo\n will need access to the current session's CSRF token. If available, Echo will pull the token from the \nLaravel.csrfToken\n JavaScript object. This object is defined in the \nresources/views/layouts/app.blade.php\n layout that is created if you run the \nmake:auth\n Artisan command. If you are not using this layout, you may define a \nmeta\n tag in your application's \nhead\n HTML element:\n\n\nmeta name=\ncsrf-token\n content=\n{{\n \ncsrf_token\n()\n \n}}\n\n\n\n\n\n\n\n\nDriver Prerequisites\n\n\nPusher\n\n\nIf you are broadcasting your events over \nPusher\n, you should install the Pusher PHP SDK using the Composer package manager:\n\n\ncomposer require pusher/pusher-php-server\n\n\n\n\n\nNext, you should configure your Pusher credentials in the \nconfig/broadcasting.php\n configuration file. An example Pusher configuration is already included in this file, allowing you to quickly specify your Pusher key, secret, and application ID. The \nconfig/broadcasting.php\n file's \npusher\n configuration also allows you to specify additional \noptions\n that are supported by Pusher, such as the cluster:\n\n\noptions\n =\n [\n    \ncluster\n =\n \neu\n,\n    \nencrypted\n =\n true\n],\n\n\n\n\n\nWhen using Pusher and \nLaravel Echo\n, you should specify \npusher\n as your desired broadcaster when instantiating the Echo instance in your \nresources/assets/js/bootstrap.js\n file:\n\n\nimport\n \nEcho\n \nfrom\n \nlaravel-echo\n\n\n\nwindow\n.\nEcho\n \n=\n \nnew\n \nEcho\n({\n\n    \nbroadcaster\n:\n \npusher\n,\n\n    \nkey\n:\n \nyour-pusher-key\n\n\n});\n\n\n\n\n\n\nRedis\n\n\nIf you are using the Redis broadcaster, you should install the Predis library:\n\n\ncomposer require predis/predis\n\n\n\n\n\nThe Redis broadcaster will broadcast messages using Redis' pub / sub feature; however, you will need to pair this with a WebSocket server that can receive the messages from Redis and broadcast them to your WebSocket channels.\n\n\nWhen the Redis broadcaster publishes an event, it will be published on the event's specified channel names and the payload will be a JSON encoded string containing the event name, a \ndata\n payload, and the user that generated the event's socket ID (if applicable).\n\n\nSocket.IO\n\n\nIf you are going to pair the Redis broadcaster with a Socket.IO server, you will need to include the Socket.IO JavaScript client library in your application's \nhead\n HTML element. When the Socket.IO server is started, it will automatically expose the client JavaScript library at a standard URL. For example, if you are running the Socket.IO server on the same domain as your web application, you may access the client library like so:\n\n\nscript\n \nsrc=\n//\n{{\n \nRequest\n::\ngetHost\n()\n \n}}\n:6001/socket.io/socket.io.js\n/script\n\n\n\n\n\n\nNext, you will need to instantiate Echo with the \nsocket.io\n connector and a \nhost\n.\n\n\nimport\n \nEcho\n \nfrom\n \nlaravel-echo\n\n\n\nwindow\n.\nEcho\n \n=\n \nnew\n \nEcho\n({\n\n    \nbroadcaster\n:\n \nsocket.io\n,\n\n    \nhost\n:\n \nwindow\n.\nlocation\n.\nhostname\n \n+\n \n:6001\n\n\n});\n\n\n\n\n\n\nFinally, you will need to run a compatible Socket.IO server. Laravel does not include a Socket.IO server implementation; however, a community driven Socket.IO server is currently maintained at the \ntlaverdure/laravel-echo-server\n GitHub repository.\n\n\nQueue Prerequisites\n\n\nBefore broadcasting events, you will also need to configure and run a \nqueue listener\n. All event broadcasting is done via queued jobs so that the response time of your application is not seriously affected.\n\n\n\n\nConcept Overview\n\n\nLaravel's event broadcasting allows you to broadcast your server-side Laravel events to your client-side JavaScript application using a driver-based approach to WebSockets. Currently, Laravel ships with \nPusher\n and Redis drivers. The events may be easily consumed on the client-side using the \nLaravel Echo\n Javascript package.\n\n\nEvents are broadcast over \"channels\", which may be specified as public or private. Any visitor to your application may subscribe to a public channel without any authentication or authorization; however, in order to subscribe to a private channel, a user must be authenticated and authorized to listen on that channel.\n\n\n\n\nUsing An Example Application\n\n\nBefore diving into each component of event broadcasting, let's take a high level overview using an e-commerce store as an example. We won't discuss the details of configuring \nPusher\n or \nLaravel Echo\n since that will be discussed in detail in other sections of this documentation.\n\n\nIn our application, let's assume we have a page that allows users to view the shipping status for their orders. Let's also assume that a \nShippingStatusUpdated\n event is fired when a shipping status update is processed by the application:\n\n\nevent(new ShippingStatusUpdated($update));\n\n\n\n\n\nThe \nShouldBroadcast\n Interface\n\n\nWhen a user is viewing one of their orders, we don't want them to have to refresh the page to view status updates. Instead, we want to broadcast the updates to the application as they are created. So, we need to mark the \nShippingStatusUpdated\n event with the \nShouldBroadcast\n interface. This will instruct Laravel to broadcast the event when it is fired:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nEvents\n;\n\n\n\nuse\n \nIlluminate\n\\\nBroadcasting\n\\\nChannel\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nSerializesModels\n;\n\n\nuse\n \nIlluminate\n\\\nBroadcasting\n\\\nPrivateChannel\n;\n\n\nuse\n \nIlluminate\n\\\nBroadcasting\n\\\nPresenceChannel\n;\n\n\nuse\n \nIlluminate\n\\\nBroadcasting\n\\\nInteractsWithSockets\n;\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nBroadcasting\n\\\nShouldBroadcast\n;\n\n\n\nclass\n \nShippingStatusUpdated\n \nimplements\n \nShouldBroadcast\n\n\n{\n\n    \n/**\n\n\n     * Information about the shipping status update.\n\n\n     *\n\n\n     * @var string\n\n\n     */\n\n    \npublic\n \n$update\n;\n\n\n}\n\n\n\n\n\n\nThe \nShouldBroadcast\n interface requires our event to define a \nbroadcastOn\n method. This method is responsible for returning the channels that the event should broadcast on. An empty stub of this method is already defined on generated event classes, so we only need to fill in its details. We only want the creator of the order to be able to view status updates, so we will broadcast the event on a private channel that is tied to the order:\n\n\n/**\n\n\n * Get the channels the event should broadcast on.\n\n\n *\n\n\n * @return array\n\n\n */\n\npublic\n \nfunction\n \nbroadcastOn\n()\n\n\n{\n\n\n    \nreturn\n \nnew\n \nPrivateChannel\n(\norder.\n.\n$\nthis\n-\nupdate\n-\norder_id\n)\n;\n\n\n}\n\n\n\n\n\n\nAuthorizing Channels\n\n\nRemember, users must be authorized to listen on private channels. We may define our channel authorization rules in the \nroutes/channels.php\n file. In this example, we need to verify that any user attempting to listen on the private \norder.1\n channel is actually the creator of the order:\n\n\nBroadcast\n::\nchannel\n(\norder.{orderId}\n,\n \nfunction\n \n($\nuser\n,\n \n$\norderId\n)\n \n{\n\n    \nreturn\n \n$user-\nid\n \n===\n \nOrder\n:\n:\nfindOrNew\n(\n$\norderId\n)\n-\nuser_id\n;\n\n\n}\n);\n\n\n\n\n\n\nThe \nchannel\n method accepts two arguments: the name of the channel and a callback which returns \ntrue\n or \nfalse\n indicating whether the user is authorized to listen on the channel.\n\n\nAll authorization callbacks receive the currently authenticated user as their first argument and any additional wildcard parameters as their subsequent arguments. In this example, we are using the \n{orderId}\n placeholder to indicate that the \"ID\" portion of the channel name is a wildcard.\n\n\nListening For Event Broadcasts\n\n\nNext, all that remains is to listen for the event in our JavaScript application. We can do this using Laravel Echo. First, we'll use the \nprivate\n method to subscribe to the private channel. Then, we may use the \nlisten\n method to listen for the \nShippingStatusUpdated\n event. By default, all of the event's public properties will be included on the broadcast event:\n\n\nEcho.private(`order.\n${\norderId\n}\n`)\n    .listen(\nShippingStatusUpdated\n, (e) =\n {\n        console.log(e.update);\n    });\n\n\n\n\n\n\n\nDefining Broadcast Events\n\n\nTo inform Laravel that a given event should be broadcast, implement the \nIlluminate\\Contracts\\Broadcasting\\ShouldBroadcast\n interface on the event class. This interface is already imported into all event classes generated by the framework so you may easily add it to any of your events.\n\n\nThe \nShouldBroadcast\n interface requires you to implement a single method: \nbroadcastOn\n. The \nbroadcastOn\n method should return a channel or array of channels that the event should broadcast on. The channels should be instances of \nChannel\n, \nPrivateChannel\n, or \nPresenceChannel\n. Instances of \nChannel\n represent public channels that any user may subscribe to, while \nPrivateChannels\n and \nPresenceChannels\n represent private channels that require \nchannel authorization\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nEvents\n;\n\n\n\nuse\n \nIlluminate\n\\\nBroadcasting\n\\\nChannel\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nSerializesModels\n;\n\n\nuse\n \nIlluminate\n\\\nBroadcasting\n\\\nPrivateChannel\n;\n\n\nuse\n \nIlluminate\n\\\nBroadcasting\n\\\nPresenceChannel\n;\n\n\nuse\n \nIlluminate\n\\\nBroadcasting\n\\\nInteractsWithSockets\n;\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nBroadcasting\n\\\nShouldBroadcast\n;\n\n\n\nclass\n \nServerCreated\n \nimplements\n \nShouldBroadcast\n\n\n{\n\n    \nuse\n \nSerializesModels\n;\n\n\n    \npublic\n \n$user\n;\n\n\n    \n/**\n\n\n     * Create a new event instance.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nUser\n \n$user\n)\n\n    \n{\n\n        \n$this\n-\nuser\n \n=\n \n$user\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Get the channels the event should broadcast on.\n\n\n     *\n\n\n     * @return Channel|array\n\n\n     */\n\n    \npublic\n \nfunction\n \nbroadcastOn\n()\n\n    \n{\n\n        \nreturn\n \nnew\n \nPrivateChannel\n(\nuser.\n.\n$this\n-\nuser\n-\nid\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThen, you only need to \nfire the event\n as you normally would. Once the event has been fired, a \nqueued job\n will automatically broadcast the event over your specified broadcast driver.\n\n\n\n\nBroadcast Name\n\n\nBy default, Laravel will broadcast the event using the event's class name. However, you may customize the broadcast name by defining a \nbroadcastAs\n method on the event:\n\n\n/**\n\n\n * The event\ns broadcast name.\n\n\n *\n\n\n * @return string\n\n\n */\n\npublic\n \nfunction\n \nbroadcastAs\n()\n\n\n{\n\n\n    \nreturn\n \nserver.created\n;\n\n\n}\n\n\n\n\n\n\n\n\nBroadcast Data\n\n\nWhen an event is broadcast, all of its \npublic\n properties are automatically serialized and broadcast as the event's payload, allowing you to access any of its public data from your JavaScript application. So, for example, if your event has a single public \n$user\n property that contains an Eloquent model, the event's broadcast payload would be:\n\n\n{\n    \nuser\n: {\n        \nid\n: 1,\n        \nname\n: \nPatrick Stewart\n\n        ...\n    }\n}\n\n\n\n\n\nHowever, if you wish to have more fine-grained control over your broadcast payload, you may add a \nbroadcastWith\n method to your event. This method should return the array of data that you wish to broadcast as the event payload:\n\n\n/**\n\n\n * Get the data to broadcast.\n\n\n *\n\n\n * @return array\n\n\n */\n\npublic\n \nfunction\n \nbroadcastWith\n()\n\n\n{\n\n\n    \nreturn\n \n[\nid\n \n=\n \n$\nthis\n-\nuser\n-\nid\n];\n\n\n}\n\n\n\n\n\n\n\n\nBroadcast Queue\n\n\nBy default, each broadcast event is placed on the default queue for the default queue connection specified in your \nqueue.php\n configuration file. You may customize the queue used by the broadcaster by defining a \nbroadcastQueue\n property on your event class. This property should specify the name of the queue you wish to use when broadcasting:\n\n\n/**\n\n\n * The name of the queue on which to place the event.\n\n\n *\n\n\n * @var string\n\n\n */\n\npublic\n \n$\nbroadcastQueue\n \n=\n \nyour-queue-name\n;\n\n\n\n\n\n\n\n\nAuthorizing Channels\n\n\nPrivate channels require you to authorize that the currently authenticated user can actually listen on the channel. This is accomplished by making an HTTP request to your Laravel application with the channel name and allowing your application to determine if the user can listen on that channel. When using \nLaravel Echo\n, the HTTP request to authorize subscriptions to private channels will be made automatically; however, you do need to define the proper routes to respond to these requests.\n\n\n\n\nDefining Authorization Routes\n\n\nThankfully, Laravel makes it easy to define the routes to respond to channel authorization requests. In the \nBroadcastServiceProvider\n included with your Laravel application, you will see a call to the \nBroadcast::routes\n method. This method will register the \n/broadcasting/auth\n route to handle authorization requests:\n\n\nBroadcast\n::\nroutes\n();\n\n\n\n\n\n\nThe \nBroadcast::routes\n method will automatically place its routes within the \nweb\n middleware group; however, you may pass an array of route attributes to the method if you would like to customize the assigned attributes:\n\n\nBroadcast\n::\nroutes\n($\nattributes\n);\n\n\n\n\n\n\n\n\nDefining Authorization Callbacks\n\n\nNext, we need to define the logic that will actually perform the channel authorization. This is done in the \nroutes/channels.php\n file that is included with your application. In this file, you may use the \nBroadcast::channel\n method to register channel authorization callbacks:\n\n\nBroadcast\n::\nchannel\n(\norder.{orderId}\n,\n \nfunction\n \n($\nuser\n,\n \n$\norderId\n)\n \n{\n\n    \nreturn\n \n$user-\nid\n \n===\n \nOrder\n:\n:\nfindOrNew\n(\n$\norderId\n)\n-\nuser_id\n;\n\n\n}\n);\n\n\n\n\n\n\nThe \nchannel\n method accepts two arguments: the name of the channel and a callback which returns \ntrue\n or \nfalse\n indicating whether the user is authorized to listen on the channel.\n\n\nAll authorization callbacks receive the currently authenticated user as their first argument and any additional wildcard parameters as their subsequent arguments. In this example, we are using the \n{orderId}\n placeholder to indicate that the \"ID\" portion of the channel name is a wildcard.\n\n\nAuthorization Callback Model Binding\n\n\nJust like HTTP routes, channel routes may also take advantage of implicit and explicit \nroute model binding\n. For example, instead of receiving the string or numeric order ID, you may request an actual \nOrder\n model instance:\n\n\nuse App\\Order;\n\nBroadcast::channel(\norder.{order}\n, function ($user, Order $order) {\n    return $user-\nid === $order-\nuser_id;\n});\n\n\n\n\n\n\n\nBroadcasting Events\n\n\nOnce you have defined an event and marked it with the \nShouldBroadcast\n interface, you only need to fire the event using the \nevent\n function. The event dispatcher will notice that the event is marked with the \nShouldBroadcast\n interface and will queue the event for broadcasting:\n\n\nevent(new ShippingStatusUpdated($update));\n\n\n\n\n\n\n\nOnly To Others\n\n\nWhen building an application that utilizes event broadcasting, you may substitute the \nevent\n function with the \nbroadcast\n function. Like the \nevent\n function, the \nbroadcast\n function dispatches the event to your server-side listeners:\n\n\nbroadcast(new ShippingStatusUpdated($update));\n\n\n\n\n\nHowever, the \nbroadcast\n function also exposes the \ntoOthers\n method which allows you to exclude the current user from the broadcast's recipients:\n\n\nbroadcast(new ShippingStatusUpdated($update))-\ntoOthers();\n\n\n\n\n\nTo better understand when you may want to use the \ntoOthers\n method, let's imagine a task list application where a user may create a new task by entering a task name. To create a task, your application might make a request to a \n/task\n end-point which broadcasts the task's creation and returns a JSON representation of the new task. When your JavaScript application receives the response from the end-point, it might directly insert the new task into its task list like so:\n\n\naxios.post(\n/task\n, task)\n    .then((response) =\n {\n        this.tasks.push(response.data);\n    });\n\n\n\n\n\nHowever, remember that we also broadcast the task's creation. If your JavaScript application is listening for this event in order to add tasks to the task list, you will have duplicate tasks in your list: one from the end-point and one from the broadcast.\n\n\nYou may solve this by using the \ntoOthers\n method to instruct the broadcaster to not broadcast the event to the current user.\n\n\nConfiguration\n\n\nWhen you initialize a Laravel Echo instance, a socket ID is assigned to the connection. If you are using \nVue\n and \nAxios\n, the socket ID will automatically be attached to every outgoing request as a \nX-Socket-ID\n header. Then, when you call the \ntoOthers\n method, Laravel will extract the socket ID from the header and instruct the broadcaster to not broadcast to any connections with that socket ID.\n\n\nIf you are not using Vue and Axios, you will need to manually configure your JavaScript application to send the \nX-Socket-ID\n header. You may retrieve the socket ID using the \nEcho.socketId\n method:\n\n\nvar socketId = Echo.socketId();\n\n\n\n\n\n\n\nReceiving Broadcasts\n\n\n\n\nInstalling Laravel Echo\n\n\nLaravel Echo is a JavaScript library that makes it painless to subscribe to channels and listen for events broadcast by Laravel. You may install Echo via the NPM package manager. In this example, we will also install the \npusher-js\n package since we will be using the Pusher broadcaster:\n\n\nnpm install --save laravel-echo pusher-js\n\n\n\n\n\nOnce Echo is installed, you are ready to create a fresh Echo instance in your application's JavaScript. A great place to do this is at the bottom of the \nresources/assets/js/bootstrap.js\n file that is included with the Laravel framework:\n\n\nimport\n \nEcho\n \nfrom\n \nlaravel-echo\n\n\n\nwindow\n.\nEcho\n \n=\n \nnew\n \nEcho\n({\n\n    \nbroadcaster\n:\n \npusher\n,\n\n    \nkey\n:\n \nyour-pusher-key\n\n\n});\n\n\n\n\n\n\nWhen creating an Echo instance that uses the \npusher\n connector, you may also specify a \ncluster\n as well as whether the connection should be encrypted:\n\n\nwindow.Echo = new Echo({\n    broadcaster: \npusher\n,\n    key: \nyour-pusher-key\n,\n    cluster: \neu\n,\n    encrypted: true\n});\n\n\n\n\n\n\n\nListening For Events\n\n\nOnce you have installed and instantiated Echo, you are ready to start listening for event broadcasts. First, use the \nchannel\n method to retrieve an instance of a channel, then call the \nlisten\n method to listen for a specified event:\n\n\nEcho.channel(\norders\n)\n    .listen(\nOrderShipped\n, (e) =\n {\n        console.log(e.order.name);\n    });\n\n\n\n\n\nIf you would like to listen for events on a private channel, use the \nprivate\n method instead. You may continue to chain calls to the \nlisten\n method to listen for multiple events on a single channel:\n\n\nEcho.private(\norders\n)\n    .listen(...)\n    .listen(...)\n    .listen(...);\n\n\n\n\n\n\n\nLeaving A Channel\n\n\nTo leave a channel, you may call the \nleave\n method on your Echo instance:\n\n\nEcho.leave(\norders\n);\n\n\n\n\n\n\n\nNamespaces\n\n\nYou may have noticed in the examples above that we did not specify the full namespace for the event classes. This is because Echo will automatically assume the events are located in the \nApp\\Events\n namespace. However, you may configure the root namespace when you instantiate Echo by passing a \nnamespace\n configuration option:\n\n\nwindow.Echo = new Echo({\n    broadcaster: \npusher\n,\n    key: \nyour-pusher-key\n,\n    namespace: \nApp.Other.Namespace\n\n});\n\n\n\n\n\nAlternatively, you may prefix event classes with a \n.\n when subscribing to them using Echo. This will allow you to always specify the fully-qualified class name:\n\n\nEcho.channel(\norders\n)\n    .listen(\n.Namespace.Event.Class\n, (e) =\n {\n        //\n    });\n\n\n\n\n\n\n\nPresence Channels\n\n\nPresence channels build on the security of private channels while exposing the additional feature of awareness of who is subscribed to the channel. This makes it easy to build powerful, collaborative application features such as notifying users when another user is viewing the same page.\n\n\n\n\nAuthorizing Presence Channels\n\n\nAll presence channels are also private channels; therefore, users must be \nauthorized to access them\n. However, when defining authorization callbacks for presence channels, you will not return \ntrue\n if the user is authorized to join the channel. Instead, you should return an array of data about the user.\n\n\nThe data returned by the authorization callback will be made available to the presence channel event listeners in your JavaScript application. If the user is not authorized to join the presence channel, you should return \nfalse\n or \nnull\n:\n\n\nBroadcast::channel(\nchat.*\n, function ($user, $roomId) {\n    if ($user-\ncanJoinRoom($roomId)) {\n        return [\nid\n =\n $user-\nid, \nname\n =\n $user-\nname];\n    }\n});\n\n\n\n\n\n\n\nJoining Presence Channels\n\n\nTo join a presence channel, you may use Echo's \njoin\n method. The \njoin\n method will return a \nPresenceChannel\n implementation which, along with exposing the \nlisten\n method, allows you to subscribe to the \nhere\n, \njoining\n, and \nleaving\n events.\n\n\nEcho.join(`chat.\n${\nroomId\n}\n`)\n    .here((users) =\n {\n        //\n    })\n    .joining((user) =\n {\n        console.log(user.name);\n    })\n    .leaving((user) =\n {\n        console.log(user.name);\n    });\n\n\n\n\n\nThe \nhere\n callback will be executed immediately once the channel is joined successfully, and will receive an array containing the user information for all of the other users currently subscribed to the channel. The \njoining\n method will be executed when a new user joins a channel, while the \nleaving\n method will be executed when a user leaves the channel.\n\n\n\n\nBroadcasting To Presence Channels\n\n\nPresence channels may receive events just like public or private channels. Using the example of a chatroom, we may want to broadcast \nNewMessage\n events to the room's presence channel. To do so, we'll return an instance of \nPresenceChannel\n from the event's \nbroadcastOn\n method:\n\n\n/**\n\n\n * Get the channels the event should broadcast on.\n\n\n *\n\n\n * @return Channel|array\n\n\n */\n\npublic\n \nfunction\n \nbroadcastOn\n()\n\n\n{\n\n\n    \nreturn\n \nnew\n \nPresenceChannel\n(\nroom.\n.\n$\nthis\n-\nmessage\n-\nroom_id\n)\n;\n\n\n}\n\n\n\n\n\n\nLike public or private events, presence channel events may be broadcast using the \nbroadcast\n function. As with other events, you may use the \ntoOthers\n method to exclude the current user from receiving the broadcast:\n\n\nbroadcast(new NewMessage($message));\n\nbroadcast(new NewMessage($message))-\ntoOthers();\n\n\n\n\n\nYou may listen for the join event via Echo's \nlisten\n method:\n\n\nEcho.join(`chat.\n${\nroomId\n}\n`)\n    .here(...)\n    .joining(...)\n    .leaving(...)\n    .listen(\nNewMessage\n, (e) =\n {\n        //\n    });\n\n\n\n\n\n\n\nClient Events\n\n\nSometimes you may wish to broadcast an event to other connected clients without hitting your Laravel application at all. This can be particularly useful for things like \"typing\" notifications, where you want to alert users of your application that another user is typing a message on a given screen. To broadcast client events, you may use Echo's \nwhisper\n method:\n\n\nEcho.channel(\nchat\n)\n    .whisper(\ntyping\n, {\n        name: this.user.name\n    });\n\n\n\n\n\nTo listen for client events, you may use the \nlistenForWhisper\n method:\n\n\nEcho.channel(\nchat\n)\n    .listenForWhisper(\ntyping\n, (e) =\n {\n        console.log(e.name);\n    });\n\n\n\n\n\n\n\nNotifications\n\n\nBy pairing event broadcasting with \nnotifications\n, your JavaScript application may receive new notifications as they occur without needing to refresh the page. First, be sure to read over the documentation on using \nthe broadcast notification channel\n.\n\n\nOnce you have configured a notification to use the broadcast channel, you may listen for the broadcast events using Echo's \nnotification\n method. Remember, the channel name should match the class name of the entity receiving the notifications:\n\n\nEcho.private(`App.User.\n${\nuserId\n}\n`)\n    .notification((notification) =\n {\n        console.log(notification.type);\n    });\n\n\n\n\n\nIn this example, all notifications sent to \nApp\\User\n instances via the \nbroadcast\n channel would be received by the callback. A channel authorization callback for the \nApp.User.{id}\n channel is included in the default \nBroadcastServiceProvider\n that ships with the Laravel framework.", 
            "title": "Broadcasting"
        }, 
        {
            "location": "/broadcasting/#event-broadcasting", 
            "text": "Introduction  Configuration  Driver Prerequisites    Concept Overview  Using An Example Application    Defining Broadcast Events  Broadcast Name  Broadcast Data  Broadcast Queue    Authorizing Channels  Defining Authorization Routes  Defining Authorization Callbacks    Broadcasting Events  Only To Others    Receiving Broadcasts  Installing Laravel Echo  Listening For Events  Leaving A Channel  Namespaces    Presence Channels  Authorizing Presence Channels  Joining Presence Channels  Broadcasting To Presence Channels    Client Events  Notifications", 
            "title": "Event Broadcasting"
        }, 
        {
            "location": "/broadcasting/#introduction", 
            "text": "In many modern web applications, WebSockets are used to implement realtime, live-updating user interfaces. When some data is updated on the server, a message is typically sent over a WebSocket connection to be handled by the client. This provides a more robust, efficient alternative to continually polling your application for changes.  To assist you in building these types of applications, Laravel makes it easy to \"broadcast\" your  events  over a WebSocket connection. Broadcasting your Laravel events allows you to share the same event names between your server-side code and your client-side JavaScript application.   {tip} Before diving into event broadcasting, make sure you have read all of the documentation regarding Laravel  events and listeners .", 
            "title": "Introduction"
        }, 
        {
            "location": "/broadcasting/#configuration", 
            "text": "All of your application's event broadcasting configuration is stored in the  config/broadcasting.php  configuration file. Laravel supports several broadcast drivers out of the box:  Pusher ,  Redis , and a  log  driver for local development and debugging. Additionally, a  null  driver is included which allows you to totally disable broadcasting. A configuration example is included for each of these drivers in the  config/broadcasting.php  configuration file.", 
            "title": "Configuration"
        }, 
        {
            "location": "/broadcasting/#broadcast-service-provider", 
            "text": "Before broadcasting any events, you will first need to register the  App\\Providers\\BroadcastServiceProvider . In fresh Laravel applications, you only need to uncomment this provider in the  providers  array of your  config/app.php  configuration file. This provider will allow you to register the broadcast authorization routes and callbacks.", 
            "title": "Broadcast Service Provider"
        }, 
        {
            "location": "/broadcasting/#csrf-token", 
            "text": "Laravel Echo  will need access to the current session's CSRF token. If available, Echo will pull the token from the  Laravel.csrfToken  JavaScript object. This object is defined in the  resources/views/layouts/app.blade.php  layout that is created if you run the  make:auth  Artisan command. If you are not using this layout, you may define a  meta  tag in your application's  head  HTML element:  meta name= csrf-token  content= {{   csrf_token ()   }}", 
            "title": "CSRF Token"
        }, 
        {
            "location": "/broadcasting/#driver-prerequisites", 
            "text": "", 
            "title": "Driver Prerequisites"
        }, 
        {
            "location": "/broadcasting/#pusher", 
            "text": "If you are broadcasting your events over  Pusher , you should install the Pusher PHP SDK using the Composer package manager:  composer require pusher/pusher-php-server  Next, you should configure your Pusher credentials in the  config/broadcasting.php  configuration file. An example Pusher configuration is already included in this file, allowing you to quickly specify your Pusher key, secret, and application ID. The  config/broadcasting.php  file's  pusher  configuration also allows you to specify additional  options  that are supported by Pusher, such as the cluster:  options  =  [\n     cluster  =   eu ,\n     encrypted  =  true\n],  When using Pusher and  Laravel Echo , you should specify  pusher  as your desired broadcaster when instantiating the Echo instance in your  resources/assets/js/bootstrap.js  file:  import   Echo   from   laravel-echo  window . Echo   =   new   Echo ({ \n     broadcaster :   pusher , \n     key :   your-pusher-key  });", 
            "title": "Pusher"
        }, 
        {
            "location": "/broadcasting/#redis", 
            "text": "If you are using the Redis broadcaster, you should install the Predis library:  composer require predis/predis  The Redis broadcaster will broadcast messages using Redis' pub / sub feature; however, you will need to pair this with a WebSocket server that can receive the messages from Redis and broadcast them to your WebSocket channels.  When the Redis broadcaster publishes an event, it will be published on the event's specified channel names and the payload will be a JSON encoded string containing the event name, a  data  payload, and the user that generated the event's socket ID (if applicable).", 
            "title": "Redis"
        }, 
        {
            "location": "/broadcasting/#socketio", 
            "text": "If you are going to pair the Redis broadcaster with a Socket.IO server, you will need to include the Socket.IO JavaScript client library in your application's  head  HTML element. When the Socket.IO server is started, it will automatically expose the client JavaScript library at a standard URL. For example, if you are running the Socket.IO server on the same domain as your web application, you may access the client library like so:  script   src= // {{   Request :: getHost ()   }} :6001/socket.io/socket.io.js /script   Next, you will need to instantiate Echo with the  socket.io  connector and a  host .  import   Echo   from   laravel-echo  window . Echo   =   new   Echo ({ \n     broadcaster :   socket.io , \n     host :   window . location . hostname   +   :6001  });   Finally, you will need to run a compatible Socket.IO server. Laravel does not include a Socket.IO server implementation; however, a community driven Socket.IO server is currently maintained at the  tlaverdure/laravel-echo-server  GitHub repository.", 
            "title": "Socket.IO"
        }, 
        {
            "location": "/broadcasting/#queue-prerequisites", 
            "text": "Before broadcasting events, you will also need to configure and run a  queue listener . All event broadcasting is done via queued jobs so that the response time of your application is not seriously affected.", 
            "title": "Queue Prerequisites"
        }, 
        {
            "location": "/broadcasting/#concept-overview", 
            "text": "Laravel's event broadcasting allows you to broadcast your server-side Laravel events to your client-side JavaScript application using a driver-based approach to WebSockets. Currently, Laravel ships with  Pusher  and Redis drivers. The events may be easily consumed on the client-side using the  Laravel Echo  Javascript package.  Events are broadcast over \"channels\", which may be specified as public or private. Any visitor to your application may subscribe to a public channel without any authentication or authorization; however, in order to subscribe to a private channel, a user must be authenticated and authorized to listen on that channel.", 
            "title": "Concept Overview"
        }, 
        {
            "location": "/broadcasting/#using-an-example-application", 
            "text": "Before diving into each component of event broadcasting, let's take a high level overview using an e-commerce store as an example. We won't discuss the details of configuring  Pusher  or  Laravel Echo  since that will be discussed in detail in other sections of this documentation.  In our application, let's assume we have a page that allows users to view the shipping status for their orders. Let's also assume that a  ShippingStatusUpdated  event is fired when a shipping status update is processed by the application:  event(new ShippingStatusUpdated($update));", 
            "title": "Using An Example Application"
        }, 
        {
            "location": "/broadcasting/#the-shouldbroadcast-interface", 
            "text": "When a user is viewing one of their orders, we don't want them to have to refresh the page to view status updates. Instead, we want to broadcast the updates to the application as they are created. So, we need to mark the  ShippingStatusUpdated  event with the  ShouldBroadcast  interface. This will instruct Laravel to broadcast the event when it is fired:  ? php  namespace   App \\ Events ;  use   Illuminate \\ Broadcasting \\ Channel ;  use   Illuminate \\ Queue \\ SerializesModels ;  use   Illuminate \\ Broadcasting \\ PrivateChannel ;  use   Illuminate \\ Broadcasting \\ PresenceChannel ;  use   Illuminate \\ Broadcasting \\ InteractsWithSockets ;  use   Illuminate \\ Contracts \\ Broadcasting \\ ShouldBroadcast ;  class   ShippingStatusUpdated   implements   ShouldBroadcast  { \n     /**       * Information about the shipping status update.       *       * @var string       */ \n     public   $update ;  }   The  ShouldBroadcast  interface requires our event to define a  broadcastOn  method. This method is responsible for returning the channels that the event should broadcast on. An empty stub of this method is already defined on generated event classes, so we only need to fill in its details. We only want the creator of the order to be able to view status updates, so we will broadcast the event on a private channel that is tied to the order:  /**   * Get the channels the event should broadcast on.   *   * @return array   */ \npublic   function   broadcastOn ()  {       return   new   PrivateChannel ( order. . $ this - update - order_id ) ;  }", 
            "title": "The ShouldBroadcast Interface"
        }, 
        {
            "location": "/broadcasting/#authorizing-channels", 
            "text": "Remember, users must be authorized to listen on private channels. We may define our channel authorization rules in the  routes/channels.php  file. In this example, we need to verify that any user attempting to listen on the private  order.1  channel is actually the creator of the order:  Broadcast :: channel ( order.{orderId} ,   function   ($ user ,   $ orderId )   { \n     return   $user- id   ===   Order : : findOrNew ( $ orderId ) - user_id ;  } );   The  channel  method accepts two arguments: the name of the channel and a callback which returns  true  or  false  indicating whether the user is authorized to listen on the channel.  All authorization callbacks receive the currently authenticated user as their first argument and any additional wildcard parameters as their subsequent arguments. In this example, we are using the  {orderId}  placeholder to indicate that the \"ID\" portion of the channel name is a wildcard.", 
            "title": "Authorizing Channels"
        }, 
        {
            "location": "/broadcasting/#listening-for-event-broadcasts", 
            "text": "Next, all that remains is to listen for the event in our JavaScript application. We can do this using Laravel Echo. First, we'll use the  private  method to subscribe to the private channel. Then, we may use the  listen  method to listen for the  ShippingStatusUpdated  event. By default, all of the event's public properties will be included on the broadcast event:  Echo.private(`order. ${ orderId } `)\n    .listen( ShippingStatusUpdated , (e) =  {\n        console.log(e.update);\n    });", 
            "title": "Listening For Event Broadcasts"
        }, 
        {
            "location": "/broadcasting/#defining-broadcast-events", 
            "text": "To inform Laravel that a given event should be broadcast, implement the  Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast  interface on the event class. This interface is already imported into all event classes generated by the framework so you may easily add it to any of your events.  The  ShouldBroadcast  interface requires you to implement a single method:  broadcastOn . The  broadcastOn  method should return a channel or array of channels that the event should broadcast on. The channels should be instances of  Channel ,  PrivateChannel , or  PresenceChannel . Instances of  Channel  represent public channels that any user may subscribe to, while  PrivateChannels  and  PresenceChannels  represent private channels that require  channel authorization :  ? php  namespace   App \\ Events ;  use   Illuminate \\ Broadcasting \\ Channel ;  use   Illuminate \\ Queue \\ SerializesModels ;  use   Illuminate \\ Broadcasting \\ PrivateChannel ;  use   Illuminate \\ Broadcasting \\ PresenceChannel ;  use   Illuminate \\ Broadcasting \\ InteractsWithSockets ;  use   Illuminate \\ Contracts \\ Broadcasting \\ ShouldBroadcast ;  class   ServerCreated   implements   ShouldBroadcast  { \n     use   SerializesModels ; \n\n     public   $user ; \n\n     /**       * Create a new event instance.       *       * @return void       */ \n     public   function   __construct ( User   $user ) \n     { \n         $this - user   =   $user ; \n     } \n\n     /**       * Get the channels the event should broadcast on.       *       * @return Channel|array       */ \n     public   function   broadcastOn () \n     { \n         return   new   PrivateChannel ( user. . $this - user - id ); \n     }  }   Then, you only need to  fire the event  as you normally would. Once the event has been fired, a  queued job  will automatically broadcast the event over your specified broadcast driver.", 
            "title": "Defining Broadcast Events"
        }, 
        {
            "location": "/broadcasting/#broadcast-name", 
            "text": "By default, Laravel will broadcast the event using the event's class name. However, you may customize the broadcast name by defining a  broadcastAs  method on the event:  /**   * The event s broadcast name.   *   * @return string   */ \npublic   function   broadcastAs ()  {       return   server.created ;  }", 
            "title": "Broadcast Name"
        }, 
        {
            "location": "/broadcasting/#broadcast-data", 
            "text": "When an event is broadcast, all of its  public  properties are automatically serialized and broadcast as the event's payload, allowing you to access any of its public data from your JavaScript application. So, for example, if your event has a single public  $user  property that contains an Eloquent model, the event's broadcast payload would be:  {\n     user : {\n         id : 1,\n         name :  Patrick Stewart \n        ...\n    }\n}  However, if you wish to have more fine-grained control over your broadcast payload, you may add a  broadcastWith  method to your event. This method should return the array of data that you wish to broadcast as the event payload:  /**   * Get the data to broadcast.   *   * @return array   */ \npublic   function   broadcastWith ()  {       return   [ id   =   $ this - user - id ];  }", 
            "title": "Broadcast Data"
        }, 
        {
            "location": "/broadcasting/#broadcast-queue", 
            "text": "By default, each broadcast event is placed on the default queue for the default queue connection specified in your  queue.php  configuration file. You may customize the queue used by the broadcaster by defining a  broadcastQueue  property on your event class. This property should specify the name of the queue you wish to use when broadcasting:  /**   * The name of the queue on which to place the event.   *   * @var string   */ \npublic   $ broadcastQueue   =   your-queue-name ;", 
            "title": "Broadcast Queue"
        }, 
        {
            "location": "/broadcasting/#authorizing-channels_1", 
            "text": "Private channels require you to authorize that the currently authenticated user can actually listen on the channel. This is accomplished by making an HTTP request to your Laravel application with the channel name and allowing your application to determine if the user can listen on that channel. When using  Laravel Echo , the HTTP request to authorize subscriptions to private channels will be made automatically; however, you do need to define the proper routes to respond to these requests.", 
            "title": "Authorizing Channels"
        }, 
        {
            "location": "/broadcasting/#defining-authorization-routes", 
            "text": "Thankfully, Laravel makes it easy to define the routes to respond to channel authorization requests. In the  BroadcastServiceProvider  included with your Laravel application, you will see a call to the  Broadcast::routes  method. This method will register the  /broadcasting/auth  route to handle authorization requests:  Broadcast :: routes ();   The  Broadcast::routes  method will automatically place its routes within the  web  middleware group; however, you may pass an array of route attributes to the method if you would like to customize the assigned attributes:  Broadcast :: routes ($ attributes );", 
            "title": "Defining Authorization Routes"
        }, 
        {
            "location": "/broadcasting/#defining-authorization-callbacks", 
            "text": "Next, we need to define the logic that will actually perform the channel authorization. This is done in the  routes/channels.php  file that is included with your application. In this file, you may use the  Broadcast::channel  method to register channel authorization callbacks:  Broadcast :: channel ( order.{orderId} ,   function   ($ user ,   $ orderId )   { \n     return   $user- id   ===   Order : : findOrNew ( $ orderId ) - user_id ;  } );   The  channel  method accepts two arguments: the name of the channel and a callback which returns  true  or  false  indicating whether the user is authorized to listen on the channel.  All authorization callbacks receive the currently authenticated user as their first argument and any additional wildcard parameters as their subsequent arguments. In this example, we are using the  {orderId}  placeholder to indicate that the \"ID\" portion of the channel name is a wildcard.", 
            "title": "Defining Authorization Callbacks"
        }, 
        {
            "location": "/broadcasting/#authorization-callback-model-binding", 
            "text": "Just like HTTP routes, channel routes may also take advantage of implicit and explicit  route model binding . For example, instead of receiving the string or numeric order ID, you may request an actual  Order  model instance:  use App\\Order;\n\nBroadcast::channel( order.{order} , function ($user, Order $order) {\n    return $user- id === $order- user_id;\n});", 
            "title": "Authorization Callback Model Binding"
        }, 
        {
            "location": "/broadcasting/#broadcasting-events", 
            "text": "Once you have defined an event and marked it with the  ShouldBroadcast  interface, you only need to fire the event using the  event  function. The event dispatcher will notice that the event is marked with the  ShouldBroadcast  interface and will queue the event for broadcasting:  event(new ShippingStatusUpdated($update));", 
            "title": "Broadcasting Events"
        }, 
        {
            "location": "/broadcasting/#only-to-others", 
            "text": "When building an application that utilizes event broadcasting, you may substitute the  event  function with the  broadcast  function. Like the  event  function, the  broadcast  function dispatches the event to your server-side listeners:  broadcast(new ShippingStatusUpdated($update));  However, the  broadcast  function also exposes the  toOthers  method which allows you to exclude the current user from the broadcast's recipients:  broadcast(new ShippingStatusUpdated($update))- toOthers();  To better understand when you may want to use the  toOthers  method, let's imagine a task list application where a user may create a new task by entering a task name. To create a task, your application might make a request to a  /task  end-point which broadcasts the task's creation and returns a JSON representation of the new task. When your JavaScript application receives the response from the end-point, it might directly insert the new task into its task list like so:  axios.post( /task , task)\n    .then((response) =  {\n        this.tasks.push(response.data);\n    });  However, remember that we also broadcast the task's creation. If your JavaScript application is listening for this event in order to add tasks to the task list, you will have duplicate tasks in your list: one from the end-point and one from the broadcast.  You may solve this by using the  toOthers  method to instruct the broadcaster to not broadcast the event to the current user.", 
            "title": "Only To Others"
        }, 
        {
            "location": "/broadcasting/#configuration_1", 
            "text": "When you initialize a Laravel Echo instance, a socket ID is assigned to the connection. If you are using  Vue  and  Axios , the socket ID will automatically be attached to every outgoing request as a  X-Socket-ID  header. Then, when you call the  toOthers  method, Laravel will extract the socket ID from the header and instruct the broadcaster to not broadcast to any connections with that socket ID.  If you are not using Vue and Axios, you will need to manually configure your JavaScript application to send the  X-Socket-ID  header. You may retrieve the socket ID using the  Echo.socketId  method:  var socketId = Echo.socketId();", 
            "title": "Configuration"
        }, 
        {
            "location": "/broadcasting/#receiving-broadcasts", 
            "text": "", 
            "title": "Receiving Broadcasts"
        }, 
        {
            "location": "/broadcasting/#installing-laravel-echo", 
            "text": "Laravel Echo is a JavaScript library that makes it painless to subscribe to channels and listen for events broadcast by Laravel. You may install Echo via the NPM package manager. In this example, we will also install the  pusher-js  package since we will be using the Pusher broadcaster:  npm install --save laravel-echo pusher-js  Once Echo is installed, you are ready to create a fresh Echo instance in your application's JavaScript. A great place to do this is at the bottom of the  resources/assets/js/bootstrap.js  file that is included with the Laravel framework:  import   Echo   from   laravel-echo  window . Echo   =   new   Echo ({ \n     broadcaster :   pusher , \n     key :   your-pusher-key  });   When creating an Echo instance that uses the  pusher  connector, you may also specify a  cluster  as well as whether the connection should be encrypted:  window.Echo = new Echo({\n    broadcaster:  pusher ,\n    key:  your-pusher-key ,\n    cluster:  eu ,\n    encrypted: true\n});", 
            "title": "Installing Laravel Echo"
        }, 
        {
            "location": "/broadcasting/#listening-for-events", 
            "text": "Once you have installed and instantiated Echo, you are ready to start listening for event broadcasts. First, use the  channel  method to retrieve an instance of a channel, then call the  listen  method to listen for a specified event:  Echo.channel( orders )\n    .listen( OrderShipped , (e) =  {\n        console.log(e.order.name);\n    });  If you would like to listen for events on a private channel, use the  private  method instead. You may continue to chain calls to the  listen  method to listen for multiple events on a single channel:  Echo.private( orders )\n    .listen(...)\n    .listen(...)\n    .listen(...);", 
            "title": "Listening For Events"
        }, 
        {
            "location": "/broadcasting/#leaving-a-channel", 
            "text": "To leave a channel, you may call the  leave  method on your Echo instance:  Echo.leave( orders );", 
            "title": "Leaving A Channel"
        }, 
        {
            "location": "/broadcasting/#namespaces", 
            "text": "You may have noticed in the examples above that we did not specify the full namespace for the event classes. This is because Echo will automatically assume the events are located in the  App\\Events  namespace. However, you may configure the root namespace when you instantiate Echo by passing a  namespace  configuration option:  window.Echo = new Echo({\n    broadcaster:  pusher ,\n    key:  your-pusher-key ,\n    namespace:  App.Other.Namespace \n});  Alternatively, you may prefix event classes with a  .  when subscribing to them using Echo. This will allow you to always specify the fully-qualified class name:  Echo.channel( orders )\n    .listen( .Namespace.Event.Class , (e) =  {\n        //\n    });", 
            "title": "Namespaces"
        }, 
        {
            "location": "/broadcasting/#presence-channels", 
            "text": "Presence channels build on the security of private channels while exposing the additional feature of awareness of who is subscribed to the channel. This makes it easy to build powerful, collaborative application features such as notifying users when another user is viewing the same page.", 
            "title": "Presence Channels"
        }, 
        {
            "location": "/broadcasting/#authorizing-presence-channels", 
            "text": "All presence channels are also private channels; therefore, users must be  authorized to access them . However, when defining authorization callbacks for presence channels, you will not return  true  if the user is authorized to join the channel. Instead, you should return an array of data about the user.  The data returned by the authorization callback will be made available to the presence channel event listeners in your JavaScript application. If the user is not authorized to join the presence channel, you should return  false  or  null :  Broadcast::channel( chat.* , function ($user, $roomId) {\n    if ($user- canJoinRoom($roomId)) {\n        return [ id  =  $user- id,  name  =  $user- name];\n    }\n});", 
            "title": "Authorizing Presence Channels"
        }, 
        {
            "location": "/broadcasting/#joining-presence-channels", 
            "text": "To join a presence channel, you may use Echo's  join  method. The  join  method will return a  PresenceChannel  implementation which, along with exposing the  listen  method, allows you to subscribe to the  here ,  joining , and  leaving  events.  Echo.join(`chat. ${ roomId } `)\n    .here((users) =  {\n        //\n    })\n    .joining((user) =  {\n        console.log(user.name);\n    })\n    .leaving((user) =  {\n        console.log(user.name);\n    });  The  here  callback will be executed immediately once the channel is joined successfully, and will receive an array containing the user information for all of the other users currently subscribed to the channel. The  joining  method will be executed when a new user joins a channel, while the  leaving  method will be executed when a user leaves the channel.", 
            "title": "Joining Presence Channels"
        }, 
        {
            "location": "/broadcasting/#broadcasting-to-presence-channels", 
            "text": "Presence channels may receive events just like public or private channels. Using the example of a chatroom, we may want to broadcast  NewMessage  events to the room's presence channel. To do so, we'll return an instance of  PresenceChannel  from the event's  broadcastOn  method:  /**   * Get the channels the event should broadcast on.   *   * @return Channel|array   */ \npublic   function   broadcastOn ()  {       return   new   PresenceChannel ( room. . $ this - message - room_id ) ;  }   Like public or private events, presence channel events may be broadcast using the  broadcast  function. As with other events, you may use the  toOthers  method to exclude the current user from receiving the broadcast:  broadcast(new NewMessage($message));\n\nbroadcast(new NewMessage($message))- toOthers();  You may listen for the join event via Echo's  listen  method:  Echo.join(`chat. ${ roomId } `)\n    .here(...)\n    .joining(...)\n    .leaving(...)\n    .listen( NewMessage , (e) =  {\n        //\n    });", 
            "title": "Broadcasting To Presence Channels"
        }, 
        {
            "location": "/broadcasting/#client-events", 
            "text": "Sometimes you may wish to broadcast an event to other connected clients without hitting your Laravel application at all. This can be particularly useful for things like \"typing\" notifications, where you want to alert users of your application that another user is typing a message on a given screen. To broadcast client events, you may use Echo's  whisper  method:  Echo.channel( chat )\n    .whisper( typing , {\n        name: this.user.name\n    });  To listen for client events, you may use the  listenForWhisper  method:  Echo.channel( chat )\n    .listenForWhisper( typing , (e) =  {\n        console.log(e.name);\n    });", 
            "title": "Client Events"
        }, 
        {
            "location": "/broadcasting/#notifications", 
            "text": "By pairing event broadcasting with  notifications , your JavaScript application may receive new notifications as they occur without needing to refresh the page. First, be sure to read over the documentation on using  the broadcast notification channel .  Once you have configured a notification to use the broadcast channel, you may listen for the broadcast events using Echo's  notification  method. Remember, the channel name should match the class name of the entity receiving the notifications:  Echo.private(`App.User. ${ userId } `)\n    .notification((notification) =  {\n        console.log(notification.type);\n    });  In this example, all notifications sent to  App\\User  instances via the  broadcast  channel would be received by the callback. A channel authorization callback for the  App.User.{id}  channel is included in the default  BroadcastServiceProvider  that ships with the Laravel framework.", 
            "title": "Notifications"
        }, 
        {
            "location": "/cache/", 
            "text": "Cache\n\n\n\n\nConfiguration\n\n\nDriver Prerequisites\n\n\n\n\n\n\nCache Usage\n\n\nObtaining A Cache Instance\n\n\nRetrieving Items From The Cache\n\n\nStoring Items In The Cache\n\n\nRemoving Items From The Cache\n\n\nThe Cache Helper\n\n\n\n\n\n\nCache Tags\n\n\nStoring Tagged Cache Items\n\n\nAccessing Tagged Cache Items\n\n\nRemoving Tagged Cache Items\n\n\n\n\n\n\nAdding Custom Cache Drivers\n\n\nWriting The Driver\n\n\nRegistering The Driver\n\n\n\n\n\n\nEvents\n\n\n\n\n\n\nConfiguration\n\n\nLaravel provides an expressive, unified API for various caching backends. The cache configuration is located at \nconfig/cache.php\n. In this file you may specify which cache driver you would like used by default throughout your application. Laravel supports popular caching backends like \nMemcached\n and \nRedis\n out of the box.\n\n\nThe cache configuration file also contains various other options, which are documented within the file, so make sure to read over these options. By default, Laravel is configured to use the \nfile\n cache driver, which stores the serialized, cached objects in the filesystem. For larger applications, it is recommended that you use a more robust driver such as Memcached or Redis. You may even configure multiple cache configurations for the same driver.\n\n\n\n\nDriver Prerequisites\n\n\nDatabase\n\n\nWhen using the \ndatabase\n cache driver, you will need to setup a table to contain the cache items. You'll find an example \nSchema\n declaration for the table below:\n\n\nSchema::create(\ncache\n, function ($table) {\n    $table-\nstring(\nkey\n)-\nunique();\n    $table-\ntext(\nvalue\n);\n    $table-\ninteger(\nexpiration\n);\n});\n\n\n\n\n\n\n\n{tip} You may also use the \nphp artisan cache:table\n Artisan command to generate a migration with the proper schema.\n\n\n\n\nMemcached\n\n\nUsing the Memcached driver requires the \nMemcached PECL package\n to be installed. You may list all of your Memcached servers in the \nconfig/cache.php\n configuration file:\n\n\nmemcached\n =\n [\n    [\n        \nhost\n =\n \n127.0.0.1\n,\n        \nport\n =\n 11211,\n        \nweight\n =\n 100\n    ],\n],\n\n\n\n\n\nYou may also set the \nhost\n option to a UNIX socket path. If you do this, the \nport\n option should be set to \n0\n:\n\n\nmemcached\n =\n [\n    [\n        \nhost\n =\n \n/var/run/memcached/memcached.sock\n,\n        \nport\n =\n 0,\n        \nweight\n =\n 100\n    ],\n],\n\n\n\n\n\nRedis\n\n\nBefore using a Redis cache with Laravel, you will need to either install the \npredis/predis\n package (~1.0) via Composer or install the PhpRedis PHP extension via PECL.\n\n\nFor more information on configuring Redis, consult its \nLaravel documentation page\n.\n\n\n\n\nCache Usage\n\n\n\n\nObtaining A Cache Instance\n\n\nThe \nIlluminate\\Contracts\\Cache\\Factory\n and \nIlluminate\\Contracts\\Cache\\Repository\n \ncontracts\n provide access to Laravel's cache services. The \nFactory\n contract provides access to all cache drivers defined for your application. The \nRepository\n contract is typically an implementation of the default cache driver for your application as specified by your \ncache\n configuration file.\n\n\nHowever, you may also use the \nCache\n facade, which is what we will use throughout this documentation. The \nCache\n facade provides convenient, terse access to the underlying implementations of the Laravel cache contracts:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nCache\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Show a list of all users of the application.\n\n\n     *\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nindex\n()\n\n    \n{\n\n        \n$value\n \n=\n \nCache\n::\nget\n(\nkey\n);\n\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAccessing Multiple Cache Stores\n\n\nUsing the \nCache\n facade, you may access various cache stores via the \nstore\n method. The key passed to the \nstore\n method should correspond to one of the stores listed in the \nstores\n configuration array in your \ncache\n configuration file:\n\n\n$\nvalue\n \n=\n \nCache\n::\nstore\n(\nfile\n)\n-\nget\n(\nfoo\n);\n\n\n\nCache\n::\nstore\n(\nredis\n)\n-\nput\n(\nbar\n,\n \nbaz\n,\n \n10\n);\n\n\n\n\n\n\n\n\nRetrieving Items From The Cache\n\n\nThe \nget\n method on the \nCache\n facade is used to retrieve items from the cache. If the item does not exist in the cache, \nnull\n will be returned. If you wish, you may pass a second argument to the \nget\n method specifying the default value you wish to be returned if the item doesn't exist:\n\n\n$\nvalue\n \n=\n \nCache\n::\nget\n(\nkey\n);\n\n\n\n$\nvalue\n \n=\n \nCache\n::\nget\n(\nkey\n,\n \ndefault\n);\n\n\n\n\n\n\nYou may even pass a \nClosure\n as the default value. The result of the \nClosure\n will be returned if the specified item does not exist in the cache. Passing a Closure allows you to defer the retrieval of default values from a database or other external service:\n\n\n$\nvalue\n \n=\n \nCache\n::\nget\n(\nkey\n,\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \nDB\n:\n:\ntable\n(\n...\n)\n-\nget\n();\n\n\n}\n);\n\n\n\n\n\n\nChecking For Item Existence\n\n\nThe \nhas\n method may be used to determine if an item exists in the cache. This method will return \nfalse\n if the value is \nnull\n or \nfalse\n:\n\n\nif (Cache::has(\nkey\n)) {\n    //\n}\n\n\n\n\n\nIncrementing / Decrementing Values\n\n\nThe \nincrement\n and \ndecrement\n methods may be used to adjust the value of integer items in the cache. Both of these methods accept an optional second argument indicating the amount by which to increment or decrement the item's value:\n\n\nCache\n::\nincrement\n(\nkey\n);\n\n\nCache\n::\nincrement\n(\nkey\n,\n \n$\namount\n);\n\n\nCache\n::\ndecrement\n(\nkey\n);\n\n\nCache\n::\ndecrement\n(\nkey\n,\n \n$\namount\n);\n\n\n\n\n\n\nRetrieve \n Store\n\n\nSometimes you may wish to retrieve an item from the cache, but also store a default value if the requested item doesn't exist. For example, you may wish to retrieve all users from the cache or, if they don't exist, retrieve them from the database and add them to the cache. You may do this using the \nCache::remember\n method:\n\n\n$\nvalue\n \n=\n \nCache\n::\nremember\n(\nusers\n,\n \n$\nminutes\n,\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \nDB\n:\n:\ntable\n(\nusers\n)\n-\nget\n();\n\n\n}\n);\n\n\n\n\n\n\nIf the item does not exist in the cache, the \nClosure\n passed to the \nremember\n method will be executed and its result will be placed in the cache.\n\n\nRetrieve \n Delete\n\n\nIf you need to retrieve an item from the cache and then delete the item, you may use the \npull\n method. Like the \nget\n method, \nnull\n will be returned if the item does not exist in the cache:\n\n\n$\nvalue\n \n=\n \nCache\n::\npull\n(\nkey\n);\n\n\n\n\n\n\n\n\nStoring Items In The Cache\n\n\nYou may use the \nput\n method on the \nCache\n facade to store items in the cache. When you place an item in the cache, you need to specify the number of minutes for which the value should be cached:\n\n\nCache\n::\nput\n(\nkey\n,\n \nvalue\n,\n \n$\nminutes\n);\n\n\n\n\n\n\nInstead of passing the number of minutes as an integer, you may also pass a \nDateTime\n instance representing the expiration time of the cached item:\n\n\n$\nexpiresAt\n \n=\n \nCarbon\n::\nnow\n()\n-\naddMinutes\n(\n10\n);\n\n\n\nCache\n::\nput\n(\nkey\n,\n \nvalue\n,\n \n$\nexpiresAt\n);\n\n\n\n\n\n\nStore If Not Present\n\n\nThe \nadd\n method will only add the item to the cache if it does not already exist in the cache store. The method will return \ntrue\n if the item is actually added to the cache. Otherwise, the method will return \nfalse\n:\n\n\nCache\n::\nadd\n(\nkey\n,\n \nvalue\n,\n \n$\nminutes\n);\n\n\n\n\n\n\nStoring Items Forever\n\n\nThe \nforever\n method may be used to store an item in the cache permanently. Since these items will not expire, they must be manually removed from the cache using the \nforget\n method:\n\n\nCache\n::\nforever\n(\nkey\n,\n \nvalue\n);\n\n\n\n\n\n\n\n\n{tip} If you are using the Memcached driver, items that are stored \"forever\" may be removed when the cache reaches its size limit.\n\n\n\n\n\n\nRemoving Items From The Cache\n\n\nYou may remove items from the cache using the \nforget\n method:\n\n\nCache\n::\nforget\n(\nkey\n);\n\n\n\n\n\n\nYou may clear the entire cache using the \nflush\n method:\n\n\nCache\n::\nflush\n();\n\n\n\n\n\n\n\n\n{note} Flushing the cache does not respect the cache prefix and will remove all entries from the cache. Consider this carefully when clearing a cache which is shared by other applications.\n\n\n\n\n\n\nThe Cache Helper\n\n\nIn addition to using the \nCache\n facade or \ncache contract\n, you may also use the global \ncache\n function to retrieve and store data via the cache. When the \ncache\n function is called with a single, string argument, it will return the value of the given key:\n\n\n$value = cache(\nkey\n);\n\n\n\n\n\nIf you provide an array of key / value pairs and an expiration time to the function, it will store values in the cache for the specified duration:\n\n\ncache\n(\n[\nkey\n \n=\n \nvalue\n]\n,\n \n$\nminutes\n);\n\n\n\ncache\n(\n[\nkey\n \n=\n \nvalue\n]\n,\n \nCarbon\n::\nnow\n()\n-\naddSeconds\n(\n10\n));\n\n\n\n\n\n\n\n\n{tip} When testing call to the global \ncache\n function, you may use the \nCache::shouldReceive\n method just as if you were \ntesting a facade\n.\n\n\n\n\n\n\nCache Tags\n\n\n\n\n{note} Cache tags are not supported when using the \nfile\n or \ndatabase\n cache drivers. Furthermore, when using multiple tags with caches that are stored \"forever\", performance will be best with a driver such as \nmemcached\n, which automatically purges stale records.\n\n\n\n\n\n\nStoring Tagged Cache Items\n\n\nCache tags allow you to tag related items in the cache and then flush all cached values that have been assigned a given tag. You may access a tagged cache by passing in an ordered array of tag names. For example, let's access a tagged cache and \nput\n value in the cache:\n\n\nCache\n::\ntags\n(\n[\npeople\n,\n \nartists\n]\n)\n-\nput\n(\nJohn\n,\n \n$\njohn\n,\n \n$\nminutes\n);\n\n\n\nCache\n::\ntags\n(\n[\npeople\n,\n \nauthors\n]\n)\n-\nput\n(\nAnne\n,\n \n$\nanne\n,\n \n$\nminutes\n);\n\n\n\n\n\n\n\n\nAccessing Tagged Cache Items\n\n\nTo retrieve a tagged cache item, pass the same ordered list of tags to the \ntags\n method and then call the \nget\n method with the key you wish to retrieve:\n\n\n$\njohn\n \n=\n \nCache\n::\ntags\n(\n[\npeople\n,\n \nartists\n]\n)\n-\nget\n(\nJohn\n);\n\n\n\n$\nanne\n \n=\n \nCache\n::\ntags\n(\n[\npeople\n,\n \nauthors\n]\n)\n-\nget\n(\nAnne\n);\n\n\n\n\n\n\n\n\nRemoving Tagged Cache Items\n\n\nYou may flush all items that are assigned a tag or list of tags. For example, this statement would remove all caches tagged with either \npeople\n, \nauthors\n, or both. So, both \nAnne\n and \nJohn\n would be removed from the cache:\n\n\nCache\n::\ntags\n(\n[\npeople\n,\n \nauthors\n]\n)\n-\nflush\n();\n\n\n\n\n\n\nIn contrast, this statement would remove only caches tagged with \nauthors\n, so \nAnne\n would be removed, but not \nJohn\n:\n\n\nCache\n::\ntags\n(\nauthors\n)\n-\nflush\n();\n\n\n\n\n\n\n\n\nAdding Custom Cache Drivers\n\n\n\n\nWriting The Driver\n\n\nTo create our custom cache driver, we first need to implement the \nIlluminate\\Contracts\\Cache\\Store\n \ncontract\n contract. So, a MongoDB cache implementation would look something like this:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nExtensions\n;\n\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nCache\n\\\nStore\n;\n\n\n\nclass\n \nMongoStore\n \nimplements\n \nStore\n\n\n{\n\n    \npublic\n \nfunction\n \nget\n(\n$key\n)\n \n{}\n\n    \npublic\n \nfunction\n \nmany\n(\narray\n \n$keys\n);\n\n    \npublic\n \nfunction\n \nput\n(\n$key\n,\n \n$value\n,\n \n$minutes\n)\n \n{}\n\n    \npublic\n \nfunction\n \nputMany\n(\narray\n \n$values\n,\n \n$minutes\n);\n\n    \npublic\n \nfunction\n \nincrement\n(\n$key\n,\n \n$value\n \n=\n \n1\n)\n \n{}\n\n    \npublic\n \nfunction\n \ndecrement\n(\n$key\n,\n \n$value\n \n=\n \n1\n)\n \n{}\n\n    \npublic\n \nfunction\n \nforever\n(\n$key\n,\n \n$value\n)\n \n{}\n\n    \npublic\n \nfunction\n \nforget\n(\n$key\n)\n \n{}\n\n    \npublic\n \nfunction\n \nflush() {\n}\n\n    \npublic\n \nfunction\n \ngetPrefix() {\n}\n\n\n}\n\n\n\n\n\n\nWe just need to implement each of these methods using a MongoDB connection. For an example of how to implement each of these methods, take a look at the \nIlluminate\\Cache\\MemcachedStore\n in the framework source code. Once our implementation is complete, we can finish our custom driver registration.\n\n\nCache\n::\nextend\n(\nmongo\n,\n \nfunction\n \n($\napp\n)\n \n{\n\n    \nreturn\n \nCache\n:\n:\nrepository\n(\nnew\n \nMongoStore\n);\n\n\n}\n);\n\n\n\n\n\n\n\n\n{tip} If you're wondering where to put your custom cache driver code, you could create an \nExtensions\n namespace within your \napp\n directory. However, keep in mind that Laravel does not have a rigid application structure and you are free to organize your application according to your preferences.\n\n\n\n\n\n\nRegistering The Driver\n\n\nTo register the custom cache driver with Laravel, we will use the \nextend\n method on the \nCache\n facade. The call to \nCache::extend\n could be done in the \nboot\n method of the default \nApp\\Providers\\AppServiceProvider\n that ships with fresh Laravel applications, or you may create your own service provider to house the extension - just don't forget to register the provider in the \nconfig/app.php\n provider array:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nApp\n\\\nExtensions\n\\\nMongoStore\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nCache\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\n\nclass\n \nCacheServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Perform post-registration booting of services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nCache\n::\nextend\n(\nmongo\n,\n \nfunction\n \n(\n$app\n)\n \n{\n\n            \nreturn\n \nCache\n::\nrepository\n(\nnew\n \nMongoStore\n);\n\n        \n});\n\n    \n}\n\n\n    \n/**\n\n\n     * Register bindings in the container.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe first argument passed to the \nextend\n method is the name of the driver. This will correspond to your \ndriver\n option in the \nconfig/cache.php\n configuration file. The second argument is a Closure that should return an \nIlluminate\\Cache\\Repository\n instance. The Closure will be passed an \n$app\n instance, which is an instance of the \nservice container\n.\n\n\nOnce your extension is registered, simply update your \nconfig/cache.php\n configuration file's \ndriver\n option to the name of your extension.\n\n\n\n\nEvents\n\n\nTo execute code on every cache operation, you may listen for the \nevents\n fired by the cache. Typically, you should place these event listeners within your \nEventServiceProvider\n:\n\n\n/**\n\n\n * The event listener mappings for the application.\n\n\n *\n\n\n * @var array\n\n\n */\n\nprotected\n \n$\nlisten\n \n=\n \n[\n\n\n    \nIlluminate\\Cache\\Events\\CacheHit\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogCacheHit\n,\n\n\n    \n]\n,\n\n\n\n    \nIlluminate\\Cache\\Events\\CacheMissed\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogCacheMissed\n,\n\n\n    \n]\n,\n\n\n\n    \nIlluminate\\Cache\\Events\\KeyForgotten\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogKeyForgotten\n,\n\n\n    \n]\n,\n\n\n\n    \nIlluminate\\Cache\\Events\\KeyWritten\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogKeyWritten\n,\n\n\n    \n]\n,\n\n\n];", 
            "title": "Cache"
        }, 
        {
            "location": "/cache/#cache", 
            "text": "Configuration  Driver Prerequisites    Cache Usage  Obtaining A Cache Instance  Retrieving Items From The Cache  Storing Items In The Cache  Removing Items From The Cache  The Cache Helper    Cache Tags  Storing Tagged Cache Items  Accessing Tagged Cache Items  Removing Tagged Cache Items    Adding Custom Cache Drivers  Writing The Driver  Registering The Driver    Events", 
            "title": "Cache"
        }, 
        {
            "location": "/cache/#configuration", 
            "text": "Laravel provides an expressive, unified API for various caching backends. The cache configuration is located at  config/cache.php . In this file you may specify which cache driver you would like used by default throughout your application. Laravel supports popular caching backends like  Memcached  and  Redis  out of the box.  The cache configuration file also contains various other options, which are documented within the file, so make sure to read over these options. By default, Laravel is configured to use the  file  cache driver, which stores the serialized, cached objects in the filesystem. For larger applications, it is recommended that you use a more robust driver such as Memcached or Redis. You may even configure multiple cache configurations for the same driver.", 
            "title": "Configuration"
        }, 
        {
            "location": "/cache/#driver-prerequisites", 
            "text": "", 
            "title": "Driver Prerequisites"
        }, 
        {
            "location": "/cache/#database", 
            "text": "When using the  database  cache driver, you will need to setup a table to contain the cache items. You'll find an example  Schema  declaration for the table below:  Schema::create( cache , function ($table) {\n    $table- string( key )- unique();\n    $table- text( value );\n    $table- integer( expiration );\n});   {tip} You may also use the  php artisan cache:table  Artisan command to generate a migration with the proper schema.", 
            "title": "Database"
        }, 
        {
            "location": "/cache/#memcached", 
            "text": "Using the Memcached driver requires the  Memcached PECL package  to be installed. You may list all of your Memcached servers in the  config/cache.php  configuration file:  memcached  =  [\n    [\n         host  =   127.0.0.1 ,\n         port  =  11211,\n         weight  =  100\n    ],\n],  You may also set the  host  option to a UNIX socket path. If you do this, the  port  option should be set to  0 :  memcached  =  [\n    [\n         host  =   /var/run/memcached/memcached.sock ,\n         port  =  0,\n         weight  =  100\n    ],\n],", 
            "title": "Memcached"
        }, 
        {
            "location": "/cache/#redis", 
            "text": "Before using a Redis cache with Laravel, you will need to either install the  predis/predis  package (~1.0) via Composer or install the PhpRedis PHP extension via PECL.  For more information on configuring Redis, consult its  Laravel documentation page .", 
            "title": "Redis"
        }, 
        {
            "location": "/cache/#cache-usage", 
            "text": "", 
            "title": "Cache Usage"
        }, 
        {
            "location": "/cache/#obtaining-a-cache-instance", 
            "text": "The  Illuminate\\Contracts\\Cache\\Factory  and  Illuminate\\Contracts\\Cache\\Repository   contracts  provide access to Laravel's cache services. The  Factory  contract provides access to all cache drivers defined for your application. The  Repository  contract is typically an implementation of the default cache driver for your application as specified by your  cache  configuration file.  However, you may also use the  Cache  facade, which is what we will use throughout this documentation. The  Cache  facade provides convenient, terse access to the underlying implementations of the Laravel cache contracts:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Support \\ Facades \\ Cache ;  class   UserController   extends   Controller  { \n     /**       * Show a list of all users of the application.       *       * @return Response       */ \n     public   function   index () \n     { \n         $value   =   Cache :: get ( key ); \n\n         // \n     }  }", 
            "title": "Obtaining A Cache Instance"
        }, 
        {
            "location": "/cache/#accessing-multiple-cache-stores", 
            "text": "Using the  Cache  facade, you may access various cache stores via the  store  method. The key passed to the  store  method should correspond to one of the stores listed in the  stores  configuration array in your  cache  configuration file:  $ value   =   Cache :: store ( file ) - get ( foo );  Cache :: store ( redis ) - put ( bar ,   baz ,   10 );", 
            "title": "Accessing Multiple Cache Stores"
        }, 
        {
            "location": "/cache/#retrieving-items-from-the-cache", 
            "text": "The  get  method on the  Cache  facade is used to retrieve items from the cache. If the item does not exist in the cache,  null  will be returned. If you wish, you may pass a second argument to the  get  method specifying the default value you wish to be returned if the item doesn't exist:  $ value   =   Cache :: get ( key );  $ value   =   Cache :: get ( key ,   default );   You may even pass a  Closure  as the default value. The result of the  Closure  will be returned if the specified item does not exist in the cache. Passing a Closure allows you to defer the retrieval of default values from a database or other external service:  $ value   =   Cache :: get ( key ,   function   ()   { \n     return   DB : : table ( ... ) - get ();  } );", 
            "title": "Retrieving Items From The Cache"
        }, 
        {
            "location": "/cache/#checking-for-item-existence", 
            "text": "The  has  method may be used to determine if an item exists in the cache. This method will return  false  if the value is  null  or  false :  if (Cache::has( key )) {\n    //\n}", 
            "title": "Checking For Item Existence"
        }, 
        {
            "location": "/cache/#incrementing-decrementing-values", 
            "text": "The  increment  and  decrement  methods may be used to adjust the value of integer items in the cache. Both of these methods accept an optional second argument indicating the amount by which to increment or decrement the item's value:  Cache :: increment ( key );  Cache :: increment ( key ,   $ amount );  Cache :: decrement ( key );  Cache :: decrement ( key ,   $ amount );", 
            "title": "Incrementing / Decrementing Values"
        }, 
        {
            "location": "/cache/#retrieve-store", 
            "text": "Sometimes you may wish to retrieve an item from the cache, but also store a default value if the requested item doesn't exist. For example, you may wish to retrieve all users from the cache or, if they don't exist, retrieve them from the database and add them to the cache. You may do this using the  Cache::remember  method:  $ value   =   Cache :: remember ( users ,   $ minutes ,   function   ()   { \n     return   DB : : table ( users ) - get ();  } );   If the item does not exist in the cache, the  Closure  passed to the  remember  method will be executed and its result will be placed in the cache.", 
            "title": "Retrieve &amp; Store"
        }, 
        {
            "location": "/cache/#retrieve-delete", 
            "text": "If you need to retrieve an item from the cache and then delete the item, you may use the  pull  method. Like the  get  method,  null  will be returned if the item does not exist in the cache:  $ value   =   Cache :: pull ( key );", 
            "title": "Retrieve &amp; Delete"
        }, 
        {
            "location": "/cache/#storing-items-in-the-cache", 
            "text": "You may use the  put  method on the  Cache  facade to store items in the cache. When you place an item in the cache, you need to specify the number of minutes for which the value should be cached:  Cache :: put ( key ,   value ,   $ minutes );   Instead of passing the number of minutes as an integer, you may also pass a  DateTime  instance representing the expiration time of the cached item:  $ expiresAt   =   Carbon :: now () - addMinutes ( 10 );  Cache :: put ( key ,   value ,   $ expiresAt );", 
            "title": "Storing Items In The Cache"
        }, 
        {
            "location": "/cache/#store-if-not-present", 
            "text": "The  add  method will only add the item to the cache if it does not already exist in the cache store. The method will return  true  if the item is actually added to the cache. Otherwise, the method will return  false :  Cache :: add ( key ,   value ,   $ minutes );", 
            "title": "Store If Not Present"
        }, 
        {
            "location": "/cache/#storing-items-forever", 
            "text": "The  forever  method may be used to store an item in the cache permanently. Since these items will not expire, they must be manually removed from the cache using the  forget  method:  Cache :: forever ( key ,   value );    {tip} If you are using the Memcached driver, items that are stored \"forever\" may be removed when the cache reaches its size limit.", 
            "title": "Storing Items Forever"
        }, 
        {
            "location": "/cache/#removing-items-from-the-cache", 
            "text": "You may remove items from the cache using the  forget  method:  Cache :: forget ( key );   You may clear the entire cache using the  flush  method:  Cache :: flush ();    {note} Flushing the cache does not respect the cache prefix and will remove all entries from the cache. Consider this carefully when clearing a cache which is shared by other applications.", 
            "title": "Removing Items From The Cache"
        }, 
        {
            "location": "/cache/#the-cache-helper", 
            "text": "In addition to using the  Cache  facade or  cache contract , you may also use the global  cache  function to retrieve and store data via the cache. When the  cache  function is called with a single, string argument, it will return the value of the given key:  $value = cache( key );  If you provide an array of key / value pairs and an expiration time to the function, it will store values in the cache for the specified duration:  cache ( [ key   =   value ] ,   $ minutes );  cache ( [ key   =   value ] ,   Carbon :: now () - addSeconds ( 10 ));    {tip} When testing call to the global  cache  function, you may use the  Cache::shouldReceive  method just as if you were  testing a facade .", 
            "title": "The Cache Helper"
        }, 
        {
            "location": "/cache/#cache-tags", 
            "text": "{note} Cache tags are not supported when using the  file  or  database  cache drivers. Furthermore, when using multiple tags with caches that are stored \"forever\", performance will be best with a driver such as  memcached , which automatically purges stale records.", 
            "title": "Cache Tags"
        }, 
        {
            "location": "/cache/#storing-tagged-cache-items", 
            "text": "Cache tags allow you to tag related items in the cache and then flush all cached values that have been assigned a given tag. You may access a tagged cache by passing in an ordered array of tag names. For example, let's access a tagged cache and  put  value in the cache:  Cache :: tags ( [ people ,   artists ] ) - put ( John ,   $ john ,   $ minutes );  Cache :: tags ( [ people ,   authors ] ) - put ( Anne ,   $ anne ,   $ minutes );", 
            "title": "Storing Tagged Cache Items"
        }, 
        {
            "location": "/cache/#accessing-tagged-cache-items", 
            "text": "To retrieve a tagged cache item, pass the same ordered list of tags to the  tags  method and then call the  get  method with the key you wish to retrieve:  $ john   =   Cache :: tags ( [ people ,   artists ] ) - get ( John );  $ anne   =   Cache :: tags ( [ people ,   authors ] ) - get ( Anne );", 
            "title": "Accessing Tagged Cache Items"
        }, 
        {
            "location": "/cache/#removing-tagged-cache-items", 
            "text": "You may flush all items that are assigned a tag or list of tags. For example, this statement would remove all caches tagged with either  people ,  authors , or both. So, both  Anne  and  John  would be removed from the cache:  Cache :: tags ( [ people ,   authors ] ) - flush ();   In contrast, this statement would remove only caches tagged with  authors , so  Anne  would be removed, but not  John :  Cache :: tags ( authors ) - flush ();", 
            "title": "Removing Tagged Cache Items"
        }, 
        {
            "location": "/cache/#adding-custom-cache-drivers", 
            "text": "", 
            "title": "Adding Custom Cache Drivers"
        }, 
        {
            "location": "/cache/#writing-the-driver", 
            "text": "To create our custom cache driver, we first need to implement the  Illuminate\\Contracts\\Cache\\Store   contract  contract. So, a MongoDB cache implementation would look something like this:  ? php  namespace   App \\ Extensions ;  use   Illuminate \\ Contracts \\ Cache \\ Store ;  class   MongoStore   implements   Store  { \n     public   function   get ( $key )   {} \n     public   function   many ( array   $keys ); \n     public   function   put ( $key ,   $value ,   $minutes )   {} \n     public   function   putMany ( array   $values ,   $minutes ); \n     public   function   increment ( $key ,   $value   =   1 )   {} \n     public   function   decrement ( $key ,   $value   =   1 )   {} \n     public   function   forever ( $key ,   $value )   {} \n     public   function   forget ( $key )   {} \n     public   function   flush() { } \n     public   function   getPrefix() { }  }   We just need to implement each of these methods using a MongoDB connection. For an example of how to implement each of these methods, take a look at the  Illuminate\\Cache\\MemcachedStore  in the framework source code. Once our implementation is complete, we can finish our custom driver registration.  Cache :: extend ( mongo ,   function   ($ app )   { \n     return   Cache : : repository ( new   MongoStore );  } );    {tip} If you're wondering where to put your custom cache driver code, you could create an  Extensions  namespace within your  app  directory. However, keep in mind that Laravel does not have a rigid application structure and you are free to organize your application according to your preferences.", 
            "title": "Writing The Driver"
        }, 
        {
            "location": "/cache/#registering-the-driver", 
            "text": "To register the custom cache driver with Laravel, we will use the  extend  method on the  Cache  facade. The call to  Cache::extend  could be done in the  boot  method of the default  App\\Providers\\AppServiceProvider  that ships with fresh Laravel applications, or you may create your own service provider to house the extension - just don't forget to register the provider in the  config/app.php  provider array:  ? php  namespace   App \\ Providers ;  use   App \\ Extensions \\ MongoStore ;  use   Illuminate \\ Support \\ Facades \\ Cache ;  use   Illuminate \\ Support \\ ServiceProvider ;  class   CacheServiceProvider   extends   ServiceProvider  { \n     /**       * Perform post-registration booting of services.       *       * @return void       */ \n     public   function   boot () \n     { \n         Cache :: extend ( mongo ,   function   ( $app )   { \n             return   Cache :: repository ( new   MongoStore ); \n         }); \n     } \n\n     /**       * Register bindings in the container.       *       * @return void       */ \n     public   function   register () \n     { \n         // \n     }  }   The first argument passed to the  extend  method is the name of the driver. This will correspond to your  driver  option in the  config/cache.php  configuration file. The second argument is a Closure that should return an  Illuminate\\Cache\\Repository  instance. The Closure will be passed an  $app  instance, which is an instance of the  service container .  Once your extension is registered, simply update your  config/cache.php  configuration file's  driver  option to the name of your extension.", 
            "title": "Registering The Driver"
        }, 
        {
            "location": "/cache/#events", 
            "text": "To execute code on every cache operation, you may listen for the  events  fired by the cache. Typically, you should place these event listeners within your  EventServiceProvider :  /**   * The event listener mappings for the application.   *   * @var array   */ \nprotected   $ listen   =   [       Illuminate\\Cache\\Events\\CacheHit   =   [           App\\Listeners\\LogCacheHit ,       ] ,       Illuminate\\Cache\\Events\\CacheMissed   =   [           App\\Listeners\\LogCacheMissed ,       ] ,       Illuminate\\Cache\\Events\\KeyForgotten   =   [           App\\Listeners\\LogKeyForgotten ,       ] ,       Illuminate\\Cache\\Events\\KeyWritten   =   [           App\\Listeners\\LogKeyWritten ,       ] ,  ];", 
            "title": "Events"
        }, 
        {
            "location": "/collections/", 
            "text": "Collections\n\n\n\n\nIntroduction\n\n\nCreating Collections\n\n\n\n\n\n\nAvailable Methods\n\n\nHigher Order Messages\n\n\n\n\n\n\nIntroduction\n\n\nThe \nIlluminate\\Support\\Collection\n class provides a fluent, convenient wrapper for working with arrays of data. For example, check out the following code. We'll use the \ncollect\n helper to create a new collection instance from the array, run the \nstrtoupper\n function on each element, and then remove all empty elements:\n\n\n$collection = collect([\ntaylor\n, \nabigail\n, null])-\nmap(function ($name) {\n    return strtoupper($name);\n})\n-\nreject(function ($name) {\n    return empty($name);\n});\n\n\n\n\n\nAs you can see, the \nCollection\n class allows you to chain its methods to perform fluent mapping and reducing of the underlying array. In general, collections are immutable, meaning every \nCollection\n method returns an entirely new \nCollection\n instance.\n\n\n\n\nCreating Collections\n\n\nAs mentioned above, the \ncollect\n helper returns a new \nIlluminate\\Support\\Collection\n instance for the given array. So, creating a collection is as simple as:\n\n\n$collection = collect([1, 2, 3]);\n\n\n\n\n\n\n\n{tip} The results of \nEloquent\n queries are always returned as \nCollection\n instances.\n\n\n\n\n\n\nAvailable Methods\n\n\nFor the remainder of this documentation, we'll discuss each method available on the \nCollection\n class. Remember, all of these methods may be chained to fluently manipulating the underlying array. Furthermore, almost every method returns a new \nCollection\n instance, allowing you to preserve the original copy of the collection when necessary:\n\n\n\n    #collection-method-list > p {\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    #collection-method-list a {\n        display: block;\n    }\n\n\n\n\n\n\n[all](#method-all)\n[avg](#method-avg)\n[chunk](#method-chunk)\n[collapse](#method-collapse)\n[combine](#method-combine)\n[contains](#method-contains)\n[count](#method-count)\n[diff](#method-diff)\n[diffKeys](#method-diffkeys)\n[each](#method-each)\n[every](#method-every)\n[except](#method-except)\n[filter](#method-filter)\n[first](#method-first)\n[flatMap](#method-flatmap)\n[flatten](#method-flatten)\n[flip](#method-flip)\n[forget](#method-forget)\n[forPage](#method-forpage)\n[get](#method-get)\n[groupBy](#method-groupby)\n[has](#method-has)\n[implode](#method-implode)\n[intersect](#method-intersect)\n[isEmpty](#method-isempty)\n[keyBy](#method-keyby)\n[keys](#method-keys)\n[last](#method-last)\n[map](#method-map)\n[mapWithKeys](#method-mapwithkeys)\n[max](#method-max)\n[merge](#method-merge)\n[min](#method-min)\n[nth](#method-nth)\n[only](#method-only)\n[partition](#method-partition)\n[pipe](#method-pipe)\n[pluck](#method-pluck)\n[pop](#method-pop)\n[prepend](#method-prepend)\n[pull](#method-pull)\n[push](#method-push)\n[put](#method-put)\n[random](#method-random)\n[reduce](#method-reduce)\n[reject](#method-reject)\n[reverse](#method-reverse)\n[search](#method-search)\n[shift](#method-shift)\n[shuffle](#method-shuffle)\n[slice](#method-slice)\n[sort](#method-sort)\n[sortBy](#method-sortby)\n[sortByDesc](#method-sortbydesc)\n[splice](#method-splice)\n[split](#method-split)\n[sum](#method-sum)\n[take](#method-take)\n[toArray](#method-toarray)\n[toJson](#method-tojson)\n[transform](#method-transform)\n[union](#method-union)\n[unique](#method-unique)\n[values](#method-values)\n[when](#method-when)\n[where](#method-where)\n[whereStrict](#method-wherestrict)\n[whereIn](#method-wherein)\n[whereInStrict](#method-whereinstrict)\n[zip](#method-zip)\n\n\n\n\n\n\n\nMethod Listing\n\n\n\n    #collection-method code {\n        font-size: 14px;\n    }\n\n    #collection-method:not(.first-collection-method) {\n        margin-top: 50px;\n    }\n\n\n\n\n\n\nall()\n {#collection-method .first-collection-method}\n\n\nThe \nall\n method returns the underlying array represented by the collection:\n\n\ncollect([1, 2, 3])-\nall();\n\n// [1, 2, 3]\n\n\n\n\n\n\n\navg()\n {#collection-method}\n\n\nThe \navg\n method returns the average of all items in the collection:\n\n\ncollect([1, 2, 3, 4, 5])-\navg();\n\n// 3\n\n\n\n\n\nIf the collection contains nested arrays or objects, you should pass a key to use for determining which values to calculate the average:\n\n\n$collection = collect([\n    [\nname\n =\n \nJavaScript: The Good Parts\n, \npages\n =\n 176],\n    [\nname\n =\n \nJavaScript: The Definitive Guide\n, \npages\n =\n 1096],\n]);\n\n$collection-\navg(\npages\n);\n\n// 636\n\n\n\n\n\n\n\nchunk()\n {#collection-method}\n\n\nThe \nchunk\n method breaks the collection into multiple, smaller collections of a given size:\n\n\n$collection = collect([1, 2, 3, 4, 5, 6, 7]);\n\n$chunks = $collection-\nchunk(4);\n\n$chunks-\ntoArray();\n\n// [[1, 2, 3, 4], [5, 6, 7]]\n\n\n\n\n\nThis method is especially useful in \nviews\n when working with a grid system such as \nBootstrap\n. Imagine you have a collection of \nEloquent\n models you want to display in a grid:\n\n\n@\nforeach\n \n(\n$\nproducts\n-\nchunk\n(\n3\n)\n \nas\n \n$\nchunk\n)\n\n    \ndiv\n \nclass\n=\nrow\n\n        \n@\nforeach\n \n(\n$\nchunk\n \nas\n \n$\nproduct\n)\n\n            \ndiv\n \nclass\n=\ncol-xs-4\n{{\n \n$\nproduct\n-\nname\n \n}}\n/\ndiv\n\n        \n@\nendforeach\n\n    \n/\ndiv\n\n\n@\nendforeach\n\n\n\n\n\n\n\n\ncollapse()\n {#collection-method}\n\n\nThe \ncollapse\n method collapses a collection of arrays into a single, flat collection:\n\n\n$collection = collect([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);\n\n$collapsed = $collection-\ncollapse();\n\n$collapsed-\nall();\n\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\n\n\n\ncombine()\n {#collection-method}\n\n\nThe \ncombine\n method combines the keys of the collection with the values of another array or collection:\n\n\n$collection = collect([\nname\n, \nage\n]);\n\n$combined = $collection-\ncombine([\nGeorge\n, 29]);\n\n$combined-\nall();\n\n// [\nname\n =\n \nGeorge\n, \nage\n =\n 29]\n\n\n\n\n\n\n\ncontains()\n {#collection-method}\n\n\nThe \ncontains\n method determines whether the collection contains a given item:\n\n\n$collection = collect([\nname\n =\n \nDesk\n, \nprice\n =\n 100]);\n\n$collection-\ncontains(\nDesk\n);\n\n// true\n\n$collection-\ncontains(\nNew York\n);\n\n// false\n\n\n\n\n\nYou may also pass a key / value pair to the \ncontains\n method, which will determine if the given pair exists in the collection:\n\n\n$collection = collect([\n    [\nproduct\n =\n \nDesk\n, \nprice\n =\n 200],\n    [\nproduct\n =\n \nChair\n, \nprice\n =\n 100],\n]);\n\n$collection-\ncontains(\nproduct\n, \nBookcase\n);\n\n// false\n\n\n\n\n\nFinally, you may also pass a callback to the \ncontains\n method to perform your own truth test:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$collection-\ncontains(function ($value, $key) {\n    return $value \n 5;\n});\n\n// false\n\n\n\n\n\n\n\ncount()\n {#collection-method}\n\n\nThe \ncount\n method returns the total number of items in the collection:\n\n\n$collection = collect([1, 2, 3, 4]);\n\n$collection-\ncount();\n\n// 4\n\n\n\n\n\n\n\ndiff()\n {#collection-method}\n\n\nThe \ndiff\n method compares the collection against another collection or a plain PHP \narray\n based on its values. This method will return the values in the original collection that are not present in the given collection:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$diff = $collection-\ndiff([2, 4, 6, 8]);\n\n$diff-\nall();\n\n// [1, 3, 5]\n\n\n\n\n\n\n\ndiffKeys()\n {#collection-method}\n\n\nThe \ndiffKeys\n method compares the collection against another collection or a plain PHP \narray\n based on its keys. This method will return the key / value pairs in the original collection that are not present in the given collection:\n\n\n$collection = collect([\n    \none\n =\n 10,\n    \ntwo\n =\n 20,\n    \nthree\n =\n 30,\n    \nfour\n =\n 40,\n    \nfive\n =\n 50,\n]);\n\n$diff = $collection-\ndiffKeys([\n    \ntwo\n =\n 2,\n    \nfour\n =\n 4,\n    \nsix\n =\n 6,\n    \neight\n =\n 8,\n]);\n\n$diff-\nall();\n\n// [\none\n =\n 10, \nthree\n =\n 30, \nfive\n =\n 50]\n\n\n\n\n\n\n\neach()\n {#collection-method}\n\n\nThe \neach\n method iterates over the items in the collection and passes each item to a callback:\n\n\n$collection = $collection-\neach(function ($item, $key) {\n    //\n});\n\n\n\n\n\nIf you would like to stop iterating through the items, you may return \nfalse\n from your callback:\n\n\n$collection = $collection-\neach(function ($item, $key) {\n    if (/* some condition */) {\n        return false;\n    }\n});\n\n\n\n\n\n\n\nevery()\n {#collection-method}\n\n\nThe \nevery\n method may be used to verify that all elements of a collection pass a given truth test:\n\n\ncollect([1, 2, 3, 4])-\nevery(function ($value, $key) {\n    return $value \n 2;\n});\n\n// false\n\n\n\n\n\n\n\nexcept()\n {#collection-method}\n\n\nThe \nexcept\n method returns all items in the collection except for those with the specified keys:\n\n\n$collection = collect([\nproduct_id\n =\n 1, \nprice\n =\n 100, \ndiscount\n =\n false]);\n\n$filtered = $collection-\nexcept([\nprice\n, \ndiscount\n]);\n\n$filtered-\nall();\n\n// [\nproduct_id\n =\n 1]\n\n\n\n\n\nFor the inverse of \nexcept\n, see the \nonly\n method.\n\n\n\n\nfilter()\n {#collection-method}\n\n\nThe \nfilter\n method filters the collection using the given callback, keeping only those items that pass a given truth test:\n\n\n$collection = collect([1, 2, 3, 4]);\n\n$filtered = $collection-\nfilter(function ($value, $key) {\n    return $value \n 2;\n});\n\n$filtered-\nall();\n\n// [3, 4]\n\n\n\n\n\nIf no callback is supplied, all entries of the collection that are equivalent to \nfalse\n will be removed:\n\n\n$collection = collect([1, 2, 3, null, false, \n, 0, []]);\n\n$collection-\nfilter()-\nall();\n\n// [1, 2, 3]\n\n\n\n\n\nFor the inverse of \nfilter\n, see the \nreject\n method.\n\n\n\n\nfirst()\n {#collection-method}\n\n\nThe \nfirst\n method returns the first element in the collection that passes a given truth test:\n\n\ncollect([1, 2, 3, 4])-\nfirst(function ($value, $key) {\n    return $value \n 2;\n});\n\n// 3\n\n\n\n\n\nYou may also call the \nfirst\n method with no arguments to get the first element in the collection. If the collection is empty, \nnull\n is returned:\n\n\ncollect([1, 2, 3, 4])-\nfirst();\n\n// 1\n\n\n\n\n\n\n\nflatMap()\n {#collection-method}\n\n\nThe \nflatMap\n method iterates through the collection and passes each value to the given callback. The callback is free to modify the item and return it, thus forming a new collection of modified items. Then, the array is flattened by a level:\n\n\n$collection = collect([\n    [\nname\n =\n \nSally\n],\n    [\nschool\n =\n \nArkansas\n],\n    [\nage\n =\n 28]\n]);\n\n$flattened = $collection-\nflatMap(function ($values) {\n    return array_map(\nstrtoupper\n, $values);\n});\n\n$flattened-\nall();\n\n// [\nname\n =\n \nSALLY\n, \nschool\n =\n \nARKANSAS\n, \nage\n =\n \n28\n];\n\n\n\n\n\n\n\nflatten()\n {#collection-method}\n\n\nThe \nflatten\n method flattens a multi-dimensional collection into a single dimension:\n\n\n$collection = collect([\nname\n =\n \ntaylor\n, \nlanguages\n =\n [\nphp\n, \njavascript\n]]);\n\n$flattened = $collection-\nflatten();\n\n$flattened-\nall();\n\n// [\ntaylor\n, \nphp\n, \njavascript\n];\n\n\n\n\n\nYou may optionally pass the function a \"depth\" argument:\n\n\n$collection = collect([\n    \nApple\n =\n [\n        [\nname\n =\n \niPhone 6S\n, \nbrand\n =\n \nApple\n],\n    ],\n    \nSamsung\n =\n [\n        [\nname\n =\n \nGalaxy S7\n, \nbrand\n =\n \nSamsung\n]\n    ],\n]);\n\n$products = $collection-\nflatten(1);\n\n$products-\nvalues()-\nall();\n\n/*\n    [\n        [\nname\n =\n \niPhone 6S\n, \nbrand\n =\n \nApple\n],\n        [\nname\n =\n \nGalaxy S7\n, \nbrand\n =\n \nSamsung\n],\n    ]\n*/\n\n\n\n\n\nIn this example, calling \nflatten\n without providing the depth would have also flattened the nested arrays, resulting in \n['iPhone 6S', 'Apple', 'Galaxy S7', 'Samsung']\n. Providing a depth allows you to restrict the levels of nested arrays that will be flattened.\n\n\n\n\nflip()\n {#collection-method}\n\n\nThe \nflip\n method swaps the collection's keys with their corresponding values:\n\n\n$collection = collect([\nname\n =\n \ntaylor\n, \nframework\n =\n \nlaravel\n]);\n\n$flipped = $collection-\nflip();\n\n$flipped-\nall();\n\n// [\ntaylor\n =\n \nname\n, \nlaravel\n =\n \nframework\n]\n\n\n\n\n\n\n\nforget()\n {#collection-method}\n\n\nThe \nforget\n method removes an item from the collection by its key:\n\n\n$collection = collect([\nname\n =\n \ntaylor\n, \nframework\n =\n \nlaravel\n]);\n\n$collection-\nforget(\nname\n);\n\n$collection-\nall();\n\n// [\nframework\n =\n \nlaravel\n]\n\n\n\n\n\n\n\n{note} Unlike most other collection methods, \nforget\n does not return a new modified collection; it modifies the collection it is called on.\n\n\n\n\n\n\nforPage()\n {#collection-method}\n\n\nThe \nforPage\n method returns a new collection containing the items that would be present on a given page number. The method accepts the page number as its first argument and the number of items to show per page as its second argument:\n\n\n$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\n$chunk = $collection-\nforPage(2, 3);\n\n$chunk-\nall();\n\n// [4, 5, 6]\n\n\n\n\n\n\n\nget()\n {#collection-method}\n\n\nThe \nget\n method returns the item at a given key. If the key does not exist, \nnull\n is returned:\n\n\n$collection = collect([\nname\n =\n \ntaylor\n, \nframework\n =\n \nlaravel\n]);\n\n$value = $collection-\nget(\nname\n);\n\n// taylor\n\n\n\n\n\nYou may optionally pass a default value as the second argument:\n\n\n$collection = collect([\nname\n =\n \ntaylor\n, \nframework\n =\n \nlaravel\n]);\n\n$value = $collection-\nget(\nfoo\n, \ndefault-value\n);\n\n// default-value\n\n\n\n\n\nYou may even pass a callback as the default value. The result of the callback will be returned if the specified key does not exist:\n\n\n$collection-\nget(\nemail\n, function () {\n    return \ndefault-value\n;\n});\n\n// default-value\n\n\n\n\n\n\n\ngroupBy()\n {#collection-method}\n\n\nThe \ngroupBy\n method groups the collection's items by a given key:\n\n\n$collection = collect([\n    [\naccount_id\n =\n \naccount-x10\n, \nproduct\n =\n \nChair\n],\n    [\naccount_id\n =\n \naccount-x10\n, \nproduct\n =\n \nBookcase\n],\n    [\naccount_id\n =\n \naccount-x11\n, \nproduct\n =\n \nDesk\n],\n]);\n\n$grouped = $collection-\ngroupBy(\naccount_id\n);\n\n$grouped-\ntoArray();\n\n/*\n    [\n        \naccount-x10\n =\n [\n            [\naccount_id\n =\n \naccount-x10\n, \nproduct\n =\n \nChair\n],\n            [\naccount_id\n =\n \naccount-x10\n, \nproduct\n =\n \nBookcase\n],\n        ],\n        \naccount-x11\n =\n [\n            [\naccount_id\n =\n \naccount-x11\n, \nproduct\n =\n \nDesk\n],\n        ],\n    ]\n*/\n\n\n\n\n\nIn addition to passing a string \nkey\n, you may also pass a callback. The callback should return the value you wish to key the group by:\n\n\n$grouped = $collection-\ngroupBy(function ($item, $key) {\n    return substr($item[\naccount_id\n], -3);\n});\n\n$grouped-\ntoArray();\n\n/*\n    [\n        \nx10\n =\n [\n            [\naccount_id\n =\n \naccount-x10\n, \nproduct\n =\n \nChair\n],\n            [\naccount_id\n =\n \naccount-x10\n, \nproduct\n =\n \nBookcase\n],\n        ],\n        \nx11\n =\n [\n            [\naccount_id\n =\n \naccount-x11\n, \nproduct\n =\n \nDesk\n],\n        ],\n    ]\n*/\n\n\n\n\n\n\n\nhas()\n {#collection-method}\n\n\nThe \nhas\n method determines if a given key exists in the collection:\n\n\n$collection = collect([\naccount_id\n =\n 1, \nproduct\n =\n \nDesk\n]);\n\n$collection-\nhas(\nproduct\n);\n\n// true\n\n\n\n\n\n\n\nimplode()\n {#collection-method}\n\n\nThe \nimplode\n method joins the items in a collection. Its arguments depend on the type of items in the collection. If the collection contains arrays or objects, you should pass the key of the attributes you wish to join, and the \"glue\" string you wish to place between the values:\n\n\n$collection = collect([\n    [\naccount_id\n =\n 1, \nproduct\n =\n \nDesk\n],\n    [\naccount_id\n =\n 2, \nproduct\n =\n \nChair\n],\n]);\n\n$collection-\nimplode(\nproduct\n, \n, \n);\n\n// Desk, Chair\n\n\n\n\n\nIf the collection contains simple strings or numeric values, simply pass the \"glue\" as the only argument to the method:\n\n\ncollect([1, 2, 3, 4, 5])-\nimplode(\n-\n);\n\n// \n1-2-3-4-5\n\n\n\n\n\n\n\n\nintersect()\n {#collection-method}\n\n\nThe \nintersect\n method removes any values from the original collection that are not present in the given \narray\n or collection. The resulting collection will preserve the original collection's keys:\n\n\n$collection = collect([\nDesk\n, \nSofa\n, \nChair\n]);\n\n$intersect = $collection-\nintersect([\nDesk\n, \nChair\n, \nBookcase\n]);\n\n$intersect-\nall();\n\n// [0 =\n \nDesk\n, 2 =\n \nChair\n]\n\n\n\n\n\n\n\nisEmpty()\n {#collection-method}\n\n\nThe \nisEmpty\n method returns \ntrue\n if the collection is empty; otherwise, \nfalse\n is returned:\n\n\ncollect([])-\nisEmpty();\n\n// true\n\n\n\n\n\n\n\nkeyBy()\n {#collection-method}\n\n\nThe \nkeyBy\n method keys the collection by the given key. If multiple items have the same key, only the last one will appear in the new collection:\n\n\n$collection = collect([\n    [\nproduct_id\n =\n \nprod-100\n, \nname\n =\n \ndesk\n],\n    [\nproduct_id\n =\n \nprod-200\n, \nname\n =\n \nchair\n],\n]);\n\n$keyed = $collection-\nkeyBy(\nproduct_id\n);\n\n$keyed-\nall();\n\n/*\n    [\n        \nprod-100\n =\n [\nproduct_id\n =\n \nprod-100\n, \nname\n =\n \nDesk\n],\n        \nprod-200\n =\n [\nproduct_id\n =\n \nprod-200\n, \nname\n =\n \nChair\n],\n    ]\n*/\n\n\n\n\n\nYou may also pass a callback to the method. The callback should return the value to key the collection by:\n\n\n$keyed = $collection-\nkeyBy(function ($item) {\n    return strtoupper($item[\nproduct_id\n]);\n});\n\n$keyed-\nall();\n\n/*\n    [\n        \nPROD-100\n =\n [\nproduct_id\n =\n \nprod-100\n, \nname\n =\n \nDesk\n],\n        \nPROD-200\n =\n [\nproduct_id\n =\n \nprod-200\n, \nname\n =\n \nChair\n],\n    ]\n*/\n\n\n\n\n\n\n\nkeys()\n {#collection-method}\n\n\nThe \nkeys\n method returns all of the collection's keys:\n\n\n$collection = collect([\n    \nprod-100\n =\n [\nproduct_id\n =\n \nprod-100\n, \nname\n =\n \nDesk\n],\n    \nprod-200\n =\n [\nproduct_id\n =\n \nprod-200\n, \nname\n =\n \nChair\n],\n]);\n\n$keys = $collection-\nkeys();\n\n$keys-\nall();\n\n// [\nprod-100\n, \nprod-200\n]\n\n\n\n\n\n\n\nlast()\n {#collection-method}\n\n\nThe \nlast\n method returns the last element in the collection that passes a given truth test:\n\n\ncollect([1, 2, 3, 4])-\nlast(function ($value, $key) {\n    return $value \n 3;\n});\n\n// 2\n\n\n\n\n\nYou may also call the \nlast\n method with no arguments to get the last element in the collection. If the collection is empty, \nnull\n is returned:\n\n\ncollect([1, 2, 3, 4])-\nlast();\n\n// 4\n\n\n\n\n\n\n\nmap()\n {#collection-method}\n\n\nThe \nmap\n method iterates through the collection and passes each value to the given callback. The callback is free to modify the item and return it, thus forming a new collection of modified items:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$multiplied = $collection-\nmap(function ($item, $key) {\n    return $item * 2;\n});\n\n$multiplied-\nall();\n\n// [2, 4, 6, 8, 10]\n\n\n\n\n\n\n\n{note} Like most other collection methods, \nmap\n returns a new collection instance; it does not modify the collection it is called on. If you want to transform the original collection, use the \ntransform\n method.\n\n\n\n\n\n\nmapWithKeys()\n {#collection-method}\n\n\nThe \nmapWithKeys\n method iterates through the collection and passes each value to the given callback. The callback should return an associative array containing a single key / value pair:\n\n\n$collection = collect([\n    [\n        \nname\n =\n \nJohn\n,\n        \ndepartment\n =\n \nSales\n,\n        \nemail\n =\n \njohn@example.com\n\n    ],\n    [\n        \nname\n =\n \nJane\n,\n        \ndepartment\n =\n \nMarketing\n,\n        \nemail\n =\n \njane@example.com\n\n    ]\n]);\n\n$keyed = $collection-\nmapWithKeys(function ($item) {\n    return [$item[\nemail\n] =\n $item[\nname\n]];\n});\n\n$keyed-\nall();\n\n/*\n    [\n        \njohn@example.com\n =\n \nJohn\n,\n        \njane@example.com\n =\n \nJane\n,\n    ]\n*/\n\n\n\n\n\n\n\nmax()\n {#collection-method}\n\n\nThe \nmax\n method returns the maximum value of a given key:\n\n\n$max = collect([[\nfoo\n =\n 10], [\nfoo\n =\n 20]])-\nmax(\nfoo\n);\n\n// 20\n\n$max = collect([1, 2, 3, 4, 5])-\nmax();\n\n// 5\n\n\n\n\n\n\n\nmerge()\n {#collection-method}\n\n\nThe \nmerge\n method merges the given array with the original collection. If a string key in the given array matches a string key in the original collection, the given array's value will overwrite the value in the original collection:\n\n\n$collection = collect([\nproduct_id\n =\n 1, \nprice\n =\n 100]);\n\n$merged = $collection-\nmerge([\nprice\n =\n 200, \ndiscount\n =\n false]);\n\n$merged-\nall();\n\n// [\nproduct_id\n =\n 1, \nprice\n =\n 200, \ndiscount\n =\n false]\n\n\n\n\n\nIf the given array's keys are numeric, the values will be appended to the end of the collection:\n\n\n$collection = collect([\nDesk\n, \nChair\n]);\n\n$merged = $collection-\nmerge([\nBookcase\n, \nDoor\n]);\n\n$merged-\nall();\n\n// [\nDesk\n, \nChair\n, \nBookcase\n, \nDoor\n]\n\n\n\n\n\n\n\nmin()\n {#collection-method}\n\n\nThe \nmin\n method returns the minimum value of a given key:\n\n\n$min = collect([[\nfoo\n =\n 10], [\nfoo\n =\n 20]])-\nmin(\nfoo\n);\n\n// 10\n\n$min = collect([1, 2, 3, 4, 5])-\nmin();\n\n// 1\n\n\n\n\n\n\n\nnth()\n {#collection-method}\n\n\nThe \nnth\n method creates a new collection consisting of every n-th element:\n\n\n$collection = collect([\na\n, \nb\n, \nc\n, \nd\n, \ne\n, \nf\n]);\n\n$collection-\nnth(4);\n\n// [\na\n, \ne\n]\n\n\n\n\n\nYou may optionally pass an offset as the second argument:\n\n\n$collection-\nnth(4, 1);\n\n// [\nb\n, \nf\n]\n\n\n\n\n\n\n\nonly()\n {#collection-method}\n\n\nThe \nonly\n method returns the items in the collection with the specified keys:\n\n\n$collection = collect([\nproduct_id\n =\n 1, \nname\n =\n \nDesk\n, \nprice\n =\n 100, \ndiscount\n =\n false]);\n\n$filtered = $collection-\nonly([\nproduct_id\n, \nname\n]);\n\n$filtered-\nall();\n\n// [\nproduct_id\n =\n 1, \nname\n =\n \nDesk\n]\n\n\n\n\n\nFor the inverse of \nonly\n, see the \nexcept\n method.\n\n\n\n\npartition()\n {#collection-method}\n\n\nThe \npartition\n method may be combined with the \nlist\n PHP function to separate elements that pass a given truth test from those that do not:\n\n\n$collection = collect([1, 2, 3, 4, 5, 6]);\n\nlist($underThree, $aboveThree) = $collection-\npartition(function ($i) {\n    return $i \n 3;\n});\n\n\n\n\n\n\n\npipe()\n {#collection-method}\n\n\nThe \npipe\n method passes the collection to the given callback and returns the result:\n\n\n$collection = collect([1, 2, 3]);\n\n$piped = $collection-\npipe(function ($collection) {\n    return $collection-\nsum();\n});\n\n// 6\n\n\n\n\n\n\n\npluck()\n {#collection-method}\n\n\nThe \npluck\n method retrieves all of the values for a given key:\n\n\n$collection = collect([\n    [\nproduct_id\n =\n \nprod-100\n, \nname\n =\n \nDesk\n],\n    [\nproduct_id\n =\n \nprod-200\n, \nname\n =\n \nChair\n],\n]);\n\n$plucked = $collection-\npluck(\nname\n);\n\n$plucked-\nall();\n\n// [\nDesk\n, \nChair\n]\n\n\n\n\n\nYou may also specify how you wish the resulting collection to be keyed:\n\n\n$plucked = $collection-\npluck(\nname\n, \nproduct_id\n);\n\n$plucked-\nall();\n\n// [\nprod-100\n =\n \nDesk\n, \nprod-200\n =\n \nChair\n]\n\n\n\n\n\n\n\npop()\n {#collection-method}\n\n\nThe \npop\n method removes and returns the last item from the collection:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$collection-\npop();\n\n// 5\n\n$collection-\nall();\n\n// [1, 2, 3, 4]\n\n\n\n\n\n\n\nprepend()\n {#collection-method}\n\n\nThe \nprepend\n method adds an item to the beginning of the collection:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$collection-\nprepend(0);\n\n$collection-\nall();\n\n// [0, 1, 2, 3, 4, 5]\n\n\n\n\n\nYou may also pass a second argument to set the key of the prepended item:\n\n\n$collection = collect([\none\n =\n 1, \ntwo\n =\n 2]);\n\n$collection-\nprepend(0, \nzero\n);\n\n$collection-\nall();\n\n// [\nzero\n =\n 0, \none\n =\n 1, \ntwo\n =\n 2]\n\n\n\n\n\n\n\npull()\n {#collection-method}\n\n\nThe \npull\n method removes and returns an item from the collection by its key:\n\n\n$collection = collect([\nproduct_id\n =\n \nprod-100\n, \nname\n =\n \nDesk\n]);\n\n$collection-\npull(\nname\n);\n\n// \nDesk\n\n\n$collection-\nall();\n\n// [\nproduct_id\n =\n \nprod-100\n]\n\n\n\n\n\n\n\npush()\n {#collection-method}\n\n\nThe \npush\n method appends an item to the end of the collection:\n\n\n$collection = collect([1, 2, 3, 4]);\n\n$collection-\npush(5);\n\n$collection-\nall();\n\n// [1, 2, 3, 4, 5]\n\n\n\n\n\n\n\nput()\n {#collection-method}\n\n\nThe \nput\n method sets the given key and value in the collection:\n\n\n$collection = collect([\nproduct_id\n =\n 1, \nname\n =\n \nDesk\n]);\n\n$collection-\nput(\nprice\n, 100);\n\n$collection-\nall();\n\n// [\nproduct_id\n =\n 1, \nname\n =\n \nDesk\n, \nprice\n =\n 100]\n\n\n\n\n\n\n\nrandom()\n {#collection-method}\n\n\nThe \nrandom\n method returns a random item from the collection:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$collection-\nrandom();\n\n// 4 - (retrieved randomly)\n\n\n\n\n\nYou may optionally pass an integer to \nrandom\n to specify how many items you would like to randomly retrieve. A collection of items is always returned when explicitly passing the number of items you wish to receive:\n\n\n$random = $collection-\nrandom(3);\n\n$random-\nall();\n\n// [2, 4, 5] - (retrieved randomly)\n\n\n\n\n\n\n\nreduce()\n {#collection-method}\n\n\nThe \nreduce\n method reduces the collection to a single value, passing the result of each iteration into the subsequent iteration:\n\n\n$collection = collect([1, 2, 3]);\n\n$total = $collection-\nreduce(function ($carry, $item) {\n    return $carry + $item;\n});\n\n// 6\n\n\n\n\n\nThe value for \n$carry\n on the first iteration is \nnull\n; however, you may specify its initial value by passing a second argument to \nreduce\n:\n\n\n$collection-\nreduce(function ($carry, $item) {\n    return $carry + $item;\n}, 4);\n\n// 10\n\n\n\n\n\n\n\nreject()\n {#collection-method}\n\n\nThe \nreject\n method filters the collection using the given callback. The callback should return \ntrue\n if the item should be removed from the resulting collection:\n\n\n$collection = collect([1, 2, 3, 4]);\n\n$filtered = $collection-\nreject(function ($value, $key) {\n    return $value \n 2;\n});\n\n$filtered-\nall();\n\n// [1, 2]\n\n\n\n\n\nFor the inverse of the \nreject\n method, see the \nfilter\n method.\n\n\n\n\nreverse()\n {#collection-method}\n\n\nThe \nreverse\n method reverses the order of the collection's items:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$reversed = $collection-\nreverse();\n\n$reversed-\nall();\n\n// [5, 4, 3, 2, 1]\n\n\n\n\n\n\n\nsearch()\n {#collection-method}\n\n\nThe \nsearch\n method searches the collection for the given value and returns its key if found. If the item is not found, \nfalse\n is returned.\n\n\n$collection = collect([2, 4, 6, 8]);\n\n$collection-\nsearch(4);\n\n// 1\n\n\n\n\n\nThe search is done using a \"loose\" comparison, meaning a string with an integer value will be considered equal to an integer of the same value. To use strict comparison, pass \ntrue\n as the second argument to the method:\n\n\n$collection-\nsearch(\n4\n, true);\n\n// false\n\n\n\n\n\nAlternatively, you may pass in your own callback to search for the first item that passes your truth test:\n\n\n$collection-\nsearch(function ($item, $key) {\n    return $item \n 5;\n});\n\n// 2\n\n\n\n\n\n\n\nshift()\n {#collection-method}\n\n\nThe \nshift\n method removes and returns the first item from the collection:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$collection-\nshift();\n\n// 1\n\n$collection-\nall();\n\n// [2, 3, 4, 5]\n\n\n\n\n\n\n\nshuffle()\n {#collection-method}\n\n\nThe \nshuffle\n method randomly shuffles the items in the collection:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$shuffled = $collection-\nshuffle();\n\n$shuffled-\nall();\n\n// [3, 2, 5, 1, 4] // (generated randomly)\n\n\n\n\n\n\n\nslice()\n {#collection-method}\n\n\nThe \nslice\n method returns a slice of the collection starting at the given index:\n\n\n$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n\n$slice = $collection-\nslice(4);\n\n$slice-\nall();\n\n// [5, 6, 7, 8, 9, 10]\n\n\n\n\n\nIf you would like to limit the size of the returned slice, pass the desired size as the second argument to the method:\n\n\n$slice = $collection-\nslice(4, 2);\n\n$slice-\nall();\n\n// [5, 6]\n\n\n\n\n\nThe returned slice will preserve keys by default. If you do not wish to preserve the original keys, you can use the \nvalues\n method to reindex them.\n\n\n\n\nsort()\n {#collection-method}\n\n\nThe \nsort\n method sorts the collection. The sorted collection keeps the original array keys, so in this example we'll use the \nvalues\n method to reset the keys to consecutively numbered indexes:\n\n\n$collection = collect([5, 3, 1, 2, 4]);\n\n$sorted = $collection-\nsort();\n\n$sorted-\nvalues()-\nall();\n\n// [1, 2, 3, 4, 5]\n\n\n\n\n\nIf your sorting needs are more advanced, you may pass a callback to \nsort\n with your own algorithm. Refer to the PHP documentation on \nusort\n, which is what the collection's \nsort\n method calls under the hood.\n\n\n\n\n{tip} If you need to sort a collection of nested arrays or objects, see the \nsortBy\n and \nsortByDesc\n methods.\n\n\n\n\n\n\nsortBy()\n {#collection-method}\n\n\nThe \nsortBy\n method sorts the collection by the given key. The sorted collection keeps the original array keys, so in this example we'll use the \nvalues\n method to reset the keys to consecutively numbered indexes:\n\n\n$collection = collect([\n    [\nname\n =\n \nDesk\n, \nprice\n =\n 200],\n    [\nname\n =\n \nChair\n, \nprice\n =\n 100],\n    [\nname\n =\n \nBookcase\n, \nprice\n =\n 150],\n]);\n\n$sorted = $collection-\nsortBy(\nprice\n);\n\n$sorted-\nvalues()-\nall();\n\n/*\n    [\n        [\nname\n =\n \nChair\n, \nprice\n =\n 100],\n        [\nname\n =\n \nBookcase\n, \nprice\n =\n 150],\n        [\nname\n =\n \nDesk\n, \nprice\n =\n 200],\n    ]\n*/\n\n\n\n\n\nYou can also pass your own callback to determine how to sort the collection values:\n\n\n$collection = collect([\n    [\nname\n =\n \nDesk\n, \ncolors\n =\n [\nBlack\n, \nMahogany\n]],\n    [\nname\n =\n \nChair\n, \ncolors\n =\n [\nBlack\n]],\n    [\nname\n =\n \nBookcase\n, \ncolors\n =\n [\nRed\n, \nBeige\n, \nBrown\n]],\n]);\n\n$sorted = $collection-\nsortBy(function ($product, $key) {\n    return count($product[\ncolors\n]);\n});\n\n$sorted-\nvalues()-\nall();\n\n/*\n    [\n        [\nname\n =\n \nChair\n, \ncolors\n =\n [\nBlack\n]],\n        [\nname\n =\n \nDesk\n, \ncolors\n =\n [\nBlack\n, \nMahogany\n]],\n        [\nname\n =\n \nBookcase\n, \ncolors\n =\n [\nRed\n, \nBeige\n, \nBrown\n]],\n    ]\n*/\n\n\n\n\n\n\n\nsortByDesc()\n {#collection-method}\n\n\nThis method has the same signature as the \nsortBy\n method, but will sort the collection in the opposite order.\n\n\n\n\nsplice()\n {#collection-method}\n\n\nThe \nsplice\n method removes and returns a slice of items starting at the specified index:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$chunk = $collection-\nsplice(2);\n\n$chunk-\nall();\n\n// [3, 4, 5]\n\n$collection-\nall();\n\n// [1, 2]\n\n\n\n\n\nYou may pass a second argument to limit the size of the resulting chunk:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$chunk = $collection-\nsplice(2, 1);\n\n$chunk-\nall();\n\n// [3]\n\n$collection-\nall();\n\n// [1, 2, 4, 5]\n\n\n\n\n\nIn addition, you can pass a third argument containing the new items to replace the items removed from the collection:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$chunk = $collection-\nsplice(2, 1, [10, 11]);\n\n$chunk-\nall();\n\n// [3]\n\n$collection-\nall();\n\n// [1, 2, 10, 11, 4, 5]\n\n\n\n\n\n\n\nsplit()\n {#collection-method}\n\n\nThe \nsplit\n method breaks a collection into the given number of groups:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$groups = $collection-\nsplit(3);\n\n$groups-\ntoArray();\n\n// [[1, 2], [3, 4], [5]]\n\n\n\n\n\n\n\nsum()\n {#collection-method}\n\n\nThe \nsum\n method returns the sum of all items in the collection:\n\n\ncollect([1, 2, 3, 4, 5])-\nsum();\n\n// 15\n\n\n\n\n\nIf the collection contains nested arrays or objects, you should pass a key to use for determining which values to sum:\n\n\n$collection = collect([\n    [\nname\n =\n \nJavaScript: The Good Parts\n, \npages\n =\n 176],\n    [\nname\n =\n \nJavaScript: The Definitive Guide\n, \npages\n =\n 1096],\n]);\n\n$collection-\nsum(\npages\n);\n\n// 1272\n\n\n\n\n\nIn addition, you may pass your own callback to determine which values of the collection to sum:\n\n\n$collection = collect([\n    [\nname\n =\n \nChair\n, \ncolors\n =\n [\nBlack\n]],\n    [\nname\n =\n \nDesk\n, \ncolors\n =\n [\nBlack\n, \nMahogany\n]],\n    [\nname\n =\n \nBookcase\n, \ncolors\n =\n [\nRed\n, \nBeige\n, \nBrown\n]],\n]);\n\n$collection-\nsum(function ($product) {\n    return count($product[\ncolors\n]);\n});\n\n// 6\n\n\n\n\n\n\n\ntake()\n {#collection-method}\n\n\nThe \ntake\n method returns a new collection with the specified number of items:\n\n\n$collection = collect([0, 1, 2, 3, 4, 5]);\n\n$chunk = $collection-\ntake(3);\n\n$chunk-\nall();\n\n// [0, 1, 2]\n\n\n\n\n\nYou may also pass a negative integer to take the specified amount of items from the end of the collection:\n\n\n$collection = collect([0, 1, 2, 3, 4, 5]);\n\n$chunk = $collection-\ntake(-2);\n\n$chunk-\nall();\n\n// [4, 5]\n\n\n\n\n\n\n\ntoArray()\n {#collection-method}\n\n\nThe \ntoArray\n method converts the collection into a plain PHP \narray\n. If the collection's values are \nEloquent\n models, the models will also be converted to arrays:\n\n\n$collection = collect([\nname\n =\n \nDesk\n, \nprice\n =\n 200]);\n\n$collection-\ntoArray();\n\n/*\n    [\n        [\nname\n =\n \nDesk\n, \nprice\n =\n 200],\n    ]\n*/\n\n\n\n\n\n\n\n{note} \ntoArray\n also converts all of the collection's nested objects to an array. If you want to get the raw underlying array, use the \nall\n method instead.\n\n\n\n\n\n\ntoJson()\n {#collection-method}\n\n\nThe \ntoJson\n method converts the collection into JSON:\n\n\n$collection = collect([\nname\n =\n \nDesk\n, \nprice\n =\n 200]);\n\n$collection-\ntoJson();\n\n// \n{\nname\n:\nDesk\n, \nprice\n:200}\n\n\n\n\n\n\n\n\ntransform()\n {#collection-method}\n\n\nThe \ntransform\n method iterates over the collection and calls the given callback with each item in the collection. The items in the collection will be replaced by the values returned by the callback:\n\n\n$collection = collect([1, 2, 3, 4, 5]);\n\n$collection-\ntransform(function ($item, $key) {\n    return $item * 2;\n});\n\n$collection-\nall();\n\n// [2, 4, 6, 8, 10]\n\n\n\n\n\n\n\n{note} Unlike most other collection methods, \ntransform\n modifies the collection itself. If you wish to create a new collection instead, use the \nmap\n method.\n\n\n\n\n\n\nunion()\n {#collection-method}\n\n\nThe \nunion\n method adds the given array to the collection. If the given array contains keys that are already in the original collection, the original collection's values will be preferred:\n\n\n$collection = collect([1 =\n [\na\n], 2 =\n [\nb\n]]);\n\n$union = $collection-\nunion([3 =\n [\nc\n], 1 =\n [\nb\n]]);\n\n$union-\nall();\n\n// [1 =\n [\na\n], 2 =\n [\nb\n], 3 =\n [\nc\n]]\n\n\n\n\n\n\n\nunique()\n {#collection-method}\n\n\nThe \nunique\n method returns all of the unique items in the collection. The returned collection keeps the original array keys, so in this example we'll use the \nvalues\n method to reset the keys to consecutively numbered indexes:\n\n\n$collection = collect([1, 1, 2, 2, 3, 4, 2]);\n\n$unique = $collection-\nunique();\n\n$unique-\nvalues()-\nall();\n\n// [1, 2, 3, 4]\n\n\n\n\n\nWhen dealing with nested arrays or objects, you may specify the key used to determine uniqueness:\n\n\n$collection = collect([\n    [\nname\n =\n \niPhone 6\n, \nbrand\n =\n \nApple\n, \ntype\n =\n \nphone\n],\n    [\nname\n =\n \niPhone 5\n, \nbrand\n =\n \nApple\n, \ntype\n =\n \nphone\n],\n    [\nname\n =\n \nApple Watch\n, \nbrand\n =\n \nApple\n, \ntype\n =\n \nwatch\n],\n    [\nname\n =\n \nGalaxy S6\n, \nbrand\n =\n \nSamsung\n, \ntype\n =\n \nphone\n],\n    [\nname\n =\n \nGalaxy Gear\n, \nbrand\n =\n \nSamsung\n, \ntype\n =\n \nwatch\n],\n]);\n\n$unique = $collection-\nunique(\nbrand\n);\n\n$unique-\nvalues()-\nall();\n\n/*\n    [\n        [\nname\n =\n \niPhone 6\n, \nbrand\n =\n \nApple\n, \ntype\n =\n \nphone\n],\n        [\nname\n =\n \nGalaxy S6\n, \nbrand\n =\n \nSamsung\n, \ntype\n =\n \nphone\n],\n    ]\n*/\n\n\n\n\n\nYou may also pass your own callback to determine item uniqueness:\n\n\n$unique = $collection-\nunique(function ($item) {\n    return $item[\nbrand\n].$item[\ntype\n];\n});\n\n$unique-\nvalues()-\nall();\n\n/*\n    [\n        [\nname\n =\n \niPhone 6\n, \nbrand\n =\n \nApple\n, \ntype\n =\n \nphone\n],\n        [\nname\n =\n \nApple Watch\n, \nbrand\n =\n \nApple\n, \ntype\n =\n \nwatch\n],\n        [\nname\n =\n \nGalaxy S6\n, \nbrand\n =\n \nSamsung\n, \ntype\n =\n \nphone\n],\n        [\nname\n =\n \nGalaxy Gear\n, \nbrand\n =\n \nSamsung\n, \ntype\n =\n \nwatch\n],\n    ]\n*/\n\n\n\n\n\n\n\nvalues()\n {#collection-method}\n\n\nThe \nvalues\n method returns a new collection with the keys reset to consecutive integers:\n\n\n$collection = collect([\n    10 =\n [\nproduct\n =\n \nDesk\n, \nprice\n =\n 200],\n    11 =\n [\nproduct\n =\n \nDesk\n, \nprice\n =\n 200]\n]);\n\n$values = $collection-\nvalues();\n\n$values-\nall();\n\n/*\n    [\n        0 =\n [\nproduct\n =\n \nDesk\n, \nprice\n =\n 200],\n        1 =\n [\nproduct\n =\n \nDesk\n, \nprice\n =\n 200],\n    ]\n*/\n\n\n\n\n\n\n\nwhen()\n {#collection-method}\n\n\nThe \nwhen\n method will execute the given callback when the first argument given to the method evaluates to \ntrue\n:\n\n\n$collection = collect([1, 2, 3]);\n\n$collection-\nwhen(true, function ($collection) {\n    return $collection-\npush(4);\n});\n\n$collection-\nall();\n\n// [1, 2, 3, 4]\n\n\n\n\n\n\n\nwhere()\n {#collection-method}\n\n\nThe \nwhere\n method filters the collection by a given key / value pair:\n\n\n$collection = collect([\n    [\nproduct\n =\n \nDesk\n, \nprice\n =\n 200],\n    [\nproduct\n =\n \nChair\n, \nprice\n =\n 100],\n    [\nproduct\n =\n \nBookcase\n, \nprice\n =\n 150],\n    [\nproduct\n =\n \nDoor\n, \nprice\n =\n 100],\n]);\n\n$filtered = $collection-\nwhere(\nprice\n, 100);\n\n$filtered-\nall();\n\n/*\n[\n    [\nproduct\n =\n \nChair\n, \nprice\n =\n 100],\n    [\nproduct\n =\n \nDoor\n, \nprice\n =\n 100],\n]\n*/\n\n\n\n\n\nThe \nwhere\n method uses loose comparisons when checking item values. Use the \nwhereStrict\n method to filter using \"strict\" comparisons.\n\n\n\n\nwhereStrict()\n {#collection-method}\n\n\nThis method has the same signature as the \nwhere\n method; however, all values are compared using \"strict\" comparisons.\n\n\n\n\nwhereIn()\n {#collection-method}\n\n\nThe \nwhereIn\n method filters the collection by a given key / value contained within the given array.\n\n\n$collection = collect([\n    [\nproduct\n =\n \nDesk\n, \nprice\n =\n 200],\n    [\nproduct\n =\n \nChair\n, \nprice\n =\n 100],\n    [\nproduct\n =\n \nBookcase\n, \nprice\n =\n 150],\n    [\nproduct\n =\n \nDoor\n, \nprice\n =\n 100],\n]);\n\n$filtered = $collection-\nwhereIn(\nprice\n, [150, 200]);\n\n$filtered-\nall();\n\n/*\n[\n    [\nproduct\n =\n \nBookcase\n, \nprice\n =\n 150],\n    [\nproduct\n =\n \nDesk\n, \nprice\n =\n 200],\n]\n*/\n\n\n\n\n\nThe \nwhereIn\n method uses \"loose\" comparisons when checking item values. Use the \nwhereInStrict\n method to filter using strict comparisons.\n\n\n\n\nwhereInStrict()\n {#collection-method}\n\n\nThis method has the same signature as the \nwhereIn\n method; however, all values are compared using strict comparisons.\n\n\n\n\nzip()\n {#collection-method}\n\n\nThe \nzip\n method merges together the values of the given array with the values of the original collection at the corresponding index:\n\n\n$collection = collect([\nChair\n, \nDesk\n]);\n\n$zipped = $collection-\nzip([100, 200]);\n\n$zipped-\nall();\n\n// [[\nChair\n, 100], [\nDesk\n, 200]]\n\n\n\n\n\n\n\nHigher Order Messages\n\n\nCollections also provide support for \"higher order messages\", which are short-cuts for performing common actions on collections. The collection methods that provide higher order messages are: \ncontains\n, \neach\n, \nevery\n, \nfilter\n, \nfirst\n, \nmap\n, \npartition\n, \nreject\n, \nsortBy\n, \nsortByDesc\n, and \nsum\n.\n\n\nEach higher order message can be accessed as a dynamic property on a collection instance. For instance, let's use the \neach\n higher order message to call a method on each object within a collection:\n\n\n$\nusers\n \n=\n \nUser\n::\nwhere\n(\nvotes\n,\n \n,\n \n500\n)\n-\nget\n();\n\n\n\n$\nusers-\neach-\nmarkAsVip\n();\n\n\n\n\n\n\nLikewise, we can use the \nsum\n higher order message to gather the total number of \"votes\" for a collection of users:\n\n\n$\nusers\n \n=\n \nUser\n::\nwhere\n(\ngroup\n,\n \nDevelopment\n)\n-\nget\n();\n\n\n\nreturn\n \n$\nusers-\nsum-\nvotes\n;", 
            "title": "Collections"
        }, 
        {
            "location": "/collections/#collections", 
            "text": "Introduction  Creating Collections    Available Methods  Higher Order Messages", 
            "title": "Collections"
        }, 
        {
            "location": "/collections/#introduction", 
            "text": "The  Illuminate\\Support\\Collection  class provides a fluent, convenient wrapper for working with arrays of data. For example, check out the following code. We'll use the  collect  helper to create a new collection instance from the array, run the  strtoupper  function on each element, and then remove all empty elements:  $collection = collect([ taylor ,  abigail , null])- map(function ($name) {\n    return strtoupper($name);\n})\n- reject(function ($name) {\n    return empty($name);\n});  As you can see, the  Collection  class allows you to chain its methods to perform fluent mapping and reducing of the underlying array. In general, collections are immutable, meaning every  Collection  method returns an entirely new  Collection  instance.", 
            "title": "Introduction"
        }, 
        {
            "location": "/collections/#creating-collections", 
            "text": "As mentioned above, the  collect  helper returns a new  Illuminate\\Support\\Collection  instance for the given array. So, creating a collection is as simple as:  $collection = collect([1, 2, 3]);   {tip} The results of  Eloquent  queries are always returned as  Collection  instances.", 
            "title": "Creating Collections"
        }, 
        {
            "location": "/collections/#available-methods", 
            "text": "For the remainder of this documentation, we'll discuss each method available on the  Collection  class. Remember, all of these methods may be chained to fluently manipulating the underlying array. Furthermore, almost every method returns a new  Collection  instance, allowing you to preserve the original copy of the collection when necessary:  \n    #collection-method-list > p {\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    #collection-method-list a {\n        display: block;\n    }  \n\n[all](#method-all)\n[avg](#method-avg)\n[chunk](#method-chunk)\n[collapse](#method-collapse)\n[combine](#method-combine)\n[contains](#method-contains)\n[count](#method-count)\n[diff](#method-diff)\n[diffKeys](#method-diffkeys)\n[each](#method-each)\n[every](#method-every)\n[except](#method-except)\n[filter](#method-filter)\n[first](#method-first)\n[flatMap](#method-flatmap)\n[flatten](#method-flatten)\n[flip](#method-flip)\n[forget](#method-forget)\n[forPage](#method-forpage)\n[get](#method-get)\n[groupBy](#method-groupby)\n[has](#method-has)\n[implode](#method-implode)\n[intersect](#method-intersect)\n[isEmpty](#method-isempty)\n[keyBy](#method-keyby)\n[keys](#method-keys)\n[last](#method-last)\n[map](#method-map)\n[mapWithKeys](#method-mapwithkeys)\n[max](#method-max)\n[merge](#method-merge)\n[min](#method-min)\n[nth](#method-nth)\n[only](#method-only)\n[partition](#method-partition)\n[pipe](#method-pipe)\n[pluck](#method-pluck)\n[pop](#method-pop)\n[prepend](#method-prepend)\n[pull](#method-pull)\n[push](#method-push)\n[put](#method-put)\n[random](#method-random)\n[reduce](#method-reduce)\n[reject](#method-reject)\n[reverse](#method-reverse)\n[search](#method-search)\n[shift](#method-shift)\n[shuffle](#method-shuffle)\n[slice](#method-slice)\n[sort](#method-sort)\n[sortBy](#method-sortby)\n[sortByDesc](#method-sortbydesc)\n[splice](#method-splice)\n[split](#method-split)\n[sum](#method-sum)\n[take](#method-take)\n[toArray](#method-toarray)\n[toJson](#method-tojson)\n[transform](#method-transform)\n[union](#method-union)\n[unique](#method-unique)\n[values](#method-values)\n[when](#method-when)\n[where](#method-where)\n[whereStrict](#method-wherestrict)\n[whereIn](#method-wherein)\n[whereInStrict](#method-whereinstrict)\n[zip](#method-zip)", 
            "title": "Available Methods"
        }, 
        {
            "location": "/collections/#method-listing", 
            "text": "#collection-method code {\n        font-size: 14px;\n    }\n\n    #collection-method:not(.first-collection-method) {\n        margin-top: 50px;\n    }", 
            "title": "Method Listing"
        }, 
        {
            "location": "/collections/#all-collection-method-first-collection-method", 
            "text": "The  all  method returns the underlying array represented by the collection:  collect([1, 2, 3])- all();\n\n// [1, 2, 3]", 
            "title": "all() {#collection-method .first-collection-method}"
        }, 
        {
            "location": "/collections/#avg-collection-method", 
            "text": "The  avg  method returns the average of all items in the collection:  collect([1, 2, 3, 4, 5])- avg();\n\n// 3  If the collection contains nested arrays or objects, you should pass a key to use for determining which values to calculate the average:  $collection = collect([\n    [ name  =   JavaScript: The Good Parts ,  pages  =  176],\n    [ name  =   JavaScript: The Definitive Guide ,  pages  =  1096],\n]);\n\n$collection- avg( pages );\n\n// 636", 
            "title": "avg() {#collection-method}"
        }, 
        {
            "location": "/collections/#chunk-collection-method", 
            "text": "The  chunk  method breaks the collection into multiple, smaller collections of a given size:  $collection = collect([1, 2, 3, 4, 5, 6, 7]);\n\n$chunks = $collection- chunk(4);\n\n$chunks- toArray();\n\n// [[1, 2, 3, 4], [5, 6, 7]]  This method is especially useful in  views  when working with a grid system such as  Bootstrap . Imagine you have a collection of  Eloquent  models you want to display in a grid:  @ foreach   ( $ products - chunk ( 3 )   as   $ chunk ) \n     div   class = row \n         @ foreach   ( $ chunk   as   $ product ) \n             div   class = col-xs-4 {{   $ product - name   }} / div \n         @ endforeach \n     / div  @ endforeach", 
            "title": "chunk() {#collection-method}"
        }, 
        {
            "location": "/collections/#collapse-collection-method", 
            "text": "The  collapse  method collapses a collection of arrays into a single, flat collection:  $collection = collect([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);\n\n$collapsed = $collection- collapse();\n\n$collapsed- all();\n\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]", 
            "title": "collapse() {#collection-method}"
        }, 
        {
            "location": "/collections/#combine-collection-method", 
            "text": "The  combine  method combines the keys of the collection with the values of another array or collection:  $collection = collect([ name ,  age ]);\n\n$combined = $collection- combine([ George , 29]);\n\n$combined- all();\n\n// [ name  =   George ,  age  =  29]", 
            "title": "combine() {#collection-method}"
        }, 
        {
            "location": "/collections/#contains-collection-method", 
            "text": "The  contains  method determines whether the collection contains a given item:  $collection = collect([ name  =   Desk ,  price  =  100]);\n\n$collection- contains( Desk );\n\n// true\n\n$collection- contains( New York );\n\n// false  You may also pass a key / value pair to the  contains  method, which will determine if the given pair exists in the collection:  $collection = collect([\n    [ product  =   Desk ,  price  =  200],\n    [ product  =   Chair ,  price  =  100],\n]);\n\n$collection- contains( product ,  Bookcase );\n\n// false  Finally, you may also pass a callback to the  contains  method to perform your own truth test:  $collection = collect([1, 2, 3, 4, 5]);\n\n$collection- contains(function ($value, $key) {\n    return $value   5;\n});\n\n// false", 
            "title": "contains() {#collection-method}"
        }, 
        {
            "location": "/collections/#count-collection-method", 
            "text": "The  count  method returns the total number of items in the collection:  $collection = collect([1, 2, 3, 4]);\n\n$collection- count();\n\n// 4", 
            "title": "count() {#collection-method}"
        }, 
        {
            "location": "/collections/#diff-collection-method", 
            "text": "The  diff  method compares the collection against another collection or a plain PHP  array  based on its values. This method will return the values in the original collection that are not present in the given collection:  $collection = collect([1, 2, 3, 4, 5]);\n\n$diff = $collection- diff([2, 4, 6, 8]);\n\n$diff- all();\n\n// [1, 3, 5]", 
            "title": "diff() {#collection-method}"
        }, 
        {
            "location": "/collections/#diffkeys-collection-method", 
            "text": "The  diffKeys  method compares the collection against another collection or a plain PHP  array  based on its keys. This method will return the key / value pairs in the original collection that are not present in the given collection:  $collection = collect([\n     one  =  10,\n     two  =  20,\n     three  =  30,\n     four  =  40,\n     five  =  50,\n]);\n\n$diff = $collection- diffKeys([\n     two  =  2,\n     four  =  4,\n     six  =  6,\n     eight  =  8,\n]);\n\n$diff- all();\n\n// [ one  =  10,  three  =  30,  five  =  50]", 
            "title": "diffKeys() {#collection-method}"
        }, 
        {
            "location": "/collections/#each-collection-method", 
            "text": "The  each  method iterates over the items in the collection and passes each item to a callback:  $collection = $collection- each(function ($item, $key) {\n    //\n});  If you would like to stop iterating through the items, you may return  false  from your callback:  $collection = $collection- each(function ($item, $key) {\n    if (/* some condition */) {\n        return false;\n    }\n});", 
            "title": "each() {#collection-method}"
        }, 
        {
            "location": "/collections/#every-collection-method", 
            "text": "The  every  method may be used to verify that all elements of a collection pass a given truth test:  collect([1, 2, 3, 4])- every(function ($value, $key) {\n    return $value   2;\n});\n\n// false", 
            "title": "every() {#collection-method}"
        }, 
        {
            "location": "/collections/#except-collection-method", 
            "text": "The  except  method returns all items in the collection except for those with the specified keys:  $collection = collect([ product_id  =  1,  price  =  100,  discount  =  false]);\n\n$filtered = $collection- except([ price ,  discount ]);\n\n$filtered- all();\n\n// [ product_id  =  1]  For the inverse of  except , see the  only  method.", 
            "title": "except() {#collection-method}"
        }, 
        {
            "location": "/collections/#filter-collection-method", 
            "text": "The  filter  method filters the collection using the given callback, keeping only those items that pass a given truth test:  $collection = collect([1, 2, 3, 4]);\n\n$filtered = $collection- filter(function ($value, $key) {\n    return $value   2;\n});\n\n$filtered- all();\n\n// [3, 4]  If no callback is supplied, all entries of the collection that are equivalent to  false  will be removed:  $collection = collect([1, 2, 3, null, false,  , 0, []]);\n\n$collection- filter()- all();\n\n// [1, 2, 3]  For the inverse of  filter , see the  reject  method.", 
            "title": "filter() {#collection-method}"
        }, 
        {
            "location": "/collections/#first-collection-method", 
            "text": "The  first  method returns the first element in the collection that passes a given truth test:  collect([1, 2, 3, 4])- first(function ($value, $key) {\n    return $value   2;\n});\n\n// 3  You may also call the  first  method with no arguments to get the first element in the collection. If the collection is empty,  null  is returned:  collect([1, 2, 3, 4])- first();\n\n// 1", 
            "title": "first() {#collection-method}"
        }, 
        {
            "location": "/collections/#flatmap-collection-method", 
            "text": "The  flatMap  method iterates through the collection and passes each value to the given callback. The callback is free to modify the item and return it, thus forming a new collection of modified items. Then, the array is flattened by a level:  $collection = collect([\n    [ name  =   Sally ],\n    [ school  =   Arkansas ],\n    [ age  =  28]\n]);\n\n$flattened = $collection- flatMap(function ($values) {\n    return array_map( strtoupper , $values);\n});\n\n$flattened- all();\n\n// [ name  =   SALLY ,  school  =   ARKANSAS ,  age  =   28 ];", 
            "title": "flatMap() {#collection-method}"
        }, 
        {
            "location": "/collections/#flatten-collection-method", 
            "text": "The  flatten  method flattens a multi-dimensional collection into a single dimension:  $collection = collect([ name  =   taylor ,  languages  =  [ php ,  javascript ]]);\n\n$flattened = $collection- flatten();\n\n$flattened- all();\n\n// [ taylor ,  php ,  javascript ];  You may optionally pass the function a \"depth\" argument:  $collection = collect([\n     Apple  =  [\n        [ name  =   iPhone 6S ,  brand  =   Apple ],\n    ],\n     Samsung  =  [\n        [ name  =   Galaxy S7 ,  brand  =   Samsung ]\n    ],\n]);\n\n$products = $collection- flatten(1);\n\n$products- values()- all();\n\n/*\n    [\n        [ name  =   iPhone 6S ,  brand  =   Apple ],\n        [ name  =   Galaxy S7 ,  brand  =   Samsung ],\n    ]\n*/  In this example, calling  flatten  without providing the depth would have also flattened the nested arrays, resulting in  ['iPhone 6S', 'Apple', 'Galaxy S7', 'Samsung'] . Providing a depth allows you to restrict the levels of nested arrays that will be flattened.", 
            "title": "flatten() {#collection-method}"
        }, 
        {
            "location": "/collections/#flip-collection-method", 
            "text": "The  flip  method swaps the collection's keys with their corresponding values:  $collection = collect([ name  =   taylor ,  framework  =   laravel ]);\n\n$flipped = $collection- flip();\n\n$flipped- all();\n\n// [ taylor  =   name ,  laravel  =   framework ]", 
            "title": "flip() {#collection-method}"
        }, 
        {
            "location": "/collections/#forget-collection-method", 
            "text": "The  forget  method removes an item from the collection by its key:  $collection = collect([ name  =   taylor ,  framework  =   laravel ]);\n\n$collection- forget( name );\n\n$collection- all();\n\n// [ framework  =   laravel ]   {note} Unlike most other collection methods,  forget  does not return a new modified collection; it modifies the collection it is called on.", 
            "title": "forget() {#collection-method}"
        }, 
        {
            "location": "/collections/#forpage-collection-method", 
            "text": "The  forPage  method returns a new collection containing the items that would be present on a given page number. The method accepts the page number as its first argument and the number of items to show per page as its second argument:  $collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\n$chunk = $collection- forPage(2, 3);\n\n$chunk- all();\n\n// [4, 5, 6]", 
            "title": "forPage() {#collection-method}"
        }, 
        {
            "location": "/collections/#get-collection-method", 
            "text": "The  get  method returns the item at a given key. If the key does not exist,  null  is returned:  $collection = collect([ name  =   taylor ,  framework  =   laravel ]);\n\n$value = $collection- get( name );\n\n// taylor  You may optionally pass a default value as the second argument:  $collection = collect([ name  =   taylor ,  framework  =   laravel ]);\n\n$value = $collection- get( foo ,  default-value );\n\n// default-value  You may even pass a callback as the default value. The result of the callback will be returned if the specified key does not exist:  $collection- get( email , function () {\n    return  default-value ;\n});\n\n// default-value", 
            "title": "get() {#collection-method}"
        }, 
        {
            "location": "/collections/#groupby-collection-method", 
            "text": "The  groupBy  method groups the collection's items by a given key:  $collection = collect([\n    [ account_id  =   account-x10 ,  product  =   Chair ],\n    [ account_id  =   account-x10 ,  product  =   Bookcase ],\n    [ account_id  =   account-x11 ,  product  =   Desk ],\n]);\n\n$grouped = $collection- groupBy( account_id );\n\n$grouped- toArray();\n\n/*\n    [\n         account-x10  =  [\n            [ account_id  =   account-x10 ,  product  =   Chair ],\n            [ account_id  =   account-x10 ,  product  =   Bookcase ],\n        ],\n         account-x11  =  [\n            [ account_id  =   account-x11 ,  product  =   Desk ],\n        ],\n    ]\n*/  In addition to passing a string  key , you may also pass a callback. The callback should return the value you wish to key the group by:  $grouped = $collection- groupBy(function ($item, $key) {\n    return substr($item[ account_id ], -3);\n});\n\n$grouped- toArray();\n\n/*\n    [\n         x10  =  [\n            [ account_id  =   account-x10 ,  product  =   Chair ],\n            [ account_id  =   account-x10 ,  product  =   Bookcase ],\n        ],\n         x11  =  [\n            [ account_id  =   account-x11 ,  product  =   Desk ],\n        ],\n    ]\n*/", 
            "title": "groupBy() {#collection-method}"
        }, 
        {
            "location": "/collections/#has-collection-method", 
            "text": "The  has  method determines if a given key exists in the collection:  $collection = collect([ account_id  =  1,  product  =   Desk ]);\n\n$collection- has( product );\n\n// true", 
            "title": "has() {#collection-method}"
        }, 
        {
            "location": "/collections/#implode-collection-method", 
            "text": "The  implode  method joins the items in a collection. Its arguments depend on the type of items in the collection. If the collection contains arrays or objects, you should pass the key of the attributes you wish to join, and the \"glue\" string you wish to place between the values:  $collection = collect([\n    [ account_id  =  1,  product  =   Desk ],\n    [ account_id  =  2,  product  =   Chair ],\n]);\n\n$collection- implode( product ,  ,  );\n\n// Desk, Chair  If the collection contains simple strings or numeric values, simply pass the \"glue\" as the only argument to the method:  collect([1, 2, 3, 4, 5])- implode( - );\n\n//  1-2-3-4-5", 
            "title": "implode() {#collection-method}"
        }, 
        {
            "location": "/collections/#intersect-collection-method", 
            "text": "The  intersect  method removes any values from the original collection that are not present in the given  array  or collection. The resulting collection will preserve the original collection's keys:  $collection = collect([ Desk ,  Sofa ,  Chair ]);\n\n$intersect = $collection- intersect([ Desk ,  Chair ,  Bookcase ]);\n\n$intersect- all();\n\n// [0 =   Desk , 2 =   Chair ]", 
            "title": "intersect() {#collection-method}"
        }, 
        {
            "location": "/collections/#isempty-collection-method", 
            "text": "The  isEmpty  method returns  true  if the collection is empty; otherwise,  false  is returned:  collect([])- isEmpty();\n\n// true", 
            "title": "isEmpty() {#collection-method}"
        }, 
        {
            "location": "/collections/#keyby-collection-method", 
            "text": "The  keyBy  method keys the collection by the given key. If multiple items have the same key, only the last one will appear in the new collection:  $collection = collect([\n    [ product_id  =   prod-100 ,  name  =   desk ],\n    [ product_id  =   prod-200 ,  name  =   chair ],\n]);\n\n$keyed = $collection- keyBy( product_id );\n\n$keyed- all();\n\n/*\n    [\n         prod-100  =  [ product_id  =   prod-100 ,  name  =   Desk ],\n         prod-200  =  [ product_id  =   prod-200 ,  name  =   Chair ],\n    ]\n*/  You may also pass a callback to the method. The callback should return the value to key the collection by:  $keyed = $collection- keyBy(function ($item) {\n    return strtoupper($item[ product_id ]);\n});\n\n$keyed- all();\n\n/*\n    [\n         PROD-100  =  [ product_id  =   prod-100 ,  name  =   Desk ],\n         PROD-200  =  [ product_id  =   prod-200 ,  name  =   Chair ],\n    ]\n*/", 
            "title": "keyBy() {#collection-method}"
        }, 
        {
            "location": "/collections/#keys-collection-method", 
            "text": "The  keys  method returns all of the collection's keys:  $collection = collect([\n     prod-100  =  [ product_id  =   prod-100 ,  name  =   Desk ],\n     prod-200  =  [ product_id  =   prod-200 ,  name  =   Chair ],\n]);\n\n$keys = $collection- keys();\n\n$keys- all();\n\n// [ prod-100 ,  prod-200 ]", 
            "title": "keys() {#collection-method}"
        }, 
        {
            "location": "/collections/#last-collection-method", 
            "text": "The  last  method returns the last element in the collection that passes a given truth test:  collect([1, 2, 3, 4])- last(function ($value, $key) {\n    return $value   3;\n});\n\n// 2  You may also call the  last  method with no arguments to get the last element in the collection. If the collection is empty,  null  is returned:  collect([1, 2, 3, 4])- last();\n\n// 4", 
            "title": "last() {#collection-method}"
        }, 
        {
            "location": "/collections/#map-collection-method", 
            "text": "The  map  method iterates through the collection and passes each value to the given callback. The callback is free to modify the item and return it, thus forming a new collection of modified items:  $collection = collect([1, 2, 3, 4, 5]);\n\n$multiplied = $collection- map(function ($item, $key) {\n    return $item * 2;\n});\n\n$multiplied- all();\n\n// [2, 4, 6, 8, 10]   {note} Like most other collection methods,  map  returns a new collection instance; it does not modify the collection it is called on. If you want to transform the original collection, use the  transform  method.", 
            "title": "map() {#collection-method}"
        }, 
        {
            "location": "/collections/#mapwithkeys-collection-method", 
            "text": "The  mapWithKeys  method iterates through the collection and passes each value to the given callback. The callback should return an associative array containing a single key / value pair:  $collection = collect([\n    [\n         name  =   John ,\n         department  =   Sales ,\n         email  =   john@example.com \n    ],\n    [\n         name  =   Jane ,\n         department  =   Marketing ,\n         email  =   jane@example.com \n    ]\n]);\n\n$keyed = $collection- mapWithKeys(function ($item) {\n    return [$item[ email ] =  $item[ name ]];\n});\n\n$keyed- all();\n\n/*\n    [\n         john@example.com  =   John ,\n         jane@example.com  =   Jane ,\n    ]\n*/", 
            "title": "mapWithKeys() {#collection-method}"
        }, 
        {
            "location": "/collections/#max-collection-method", 
            "text": "The  max  method returns the maximum value of a given key:  $max = collect([[ foo  =  10], [ foo  =  20]])- max( foo );\n\n// 20\n\n$max = collect([1, 2, 3, 4, 5])- max();\n\n// 5", 
            "title": "max() {#collection-method}"
        }, 
        {
            "location": "/collections/#merge-collection-method", 
            "text": "The  merge  method merges the given array with the original collection. If a string key in the given array matches a string key in the original collection, the given array's value will overwrite the value in the original collection:  $collection = collect([ product_id  =  1,  price  =  100]);\n\n$merged = $collection- merge([ price  =  200,  discount  =  false]);\n\n$merged- all();\n\n// [ product_id  =  1,  price  =  200,  discount  =  false]  If the given array's keys are numeric, the values will be appended to the end of the collection:  $collection = collect([ Desk ,  Chair ]);\n\n$merged = $collection- merge([ Bookcase ,  Door ]);\n\n$merged- all();\n\n// [ Desk ,  Chair ,  Bookcase ,  Door ]", 
            "title": "merge() {#collection-method}"
        }, 
        {
            "location": "/collections/#min-collection-method", 
            "text": "The  min  method returns the minimum value of a given key:  $min = collect([[ foo  =  10], [ foo  =  20]])- min( foo );\n\n// 10\n\n$min = collect([1, 2, 3, 4, 5])- min();\n\n// 1", 
            "title": "min() {#collection-method}"
        }, 
        {
            "location": "/collections/#nth-collection-method", 
            "text": "The  nth  method creates a new collection consisting of every n-th element:  $collection = collect([ a ,  b ,  c ,  d ,  e ,  f ]);\n\n$collection- nth(4);\n\n// [ a ,  e ]  You may optionally pass an offset as the second argument:  $collection- nth(4, 1);\n\n// [ b ,  f ]", 
            "title": "nth() {#collection-method}"
        }, 
        {
            "location": "/collections/#only-collection-method", 
            "text": "The  only  method returns the items in the collection with the specified keys:  $collection = collect([ product_id  =  1,  name  =   Desk ,  price  =  100,  discount  =  false]);\n\n$filtered = $collection- only([ product_id ,  name ]);\n\n$filtered- all();\n\n// [ product_id  =  1,  name  =   Desk ]  For the inverse of  only , see the  except  method.", 
            "title": "only() {#collection-method}"
        }, 
        {
            "location": "/collections/#partition-collection-method", 
            "text": "The  partition  method may be combined with the  list  PHP function to separate elements that pass a given truth test from those that do not:  $collection = collect([1, 2, 3, 4, 5, 6]);\n\nlist($underThree, $aboveThree) = $collection- partition(function ($i) {\n    return $i   3;\n});", 
            "title": "partition() {#collection-method}"
        }, 
        {
            "location": "/collections/#pipe-collection-method", 
            "text": "The  pipe  method passes the collection to the given callback and returns the result:  $collection = collect([1, 2, 3]);\n\n$piped = $collection- pipe(function ($collection) {\n    return $collection- sum();\n});\n\n// 6", 
            "title": "pipe() {#collection-method}"
        }, 
        {
            "location": "/collections/#pluck-collection-method", 
            "text": "The  pluck  method retrieves all of the values for a given key:  $collection = collect([\n    [ product_id  =   prod-100 ,  name  =   Desk ],\n    [ product_id  =   prod-200 ,  name  =   Chair ],\n]);\n\n$plucked = $collection- pluck( name );\n\n$plucked- all();\n\n// [ Desk ,  Chair ]  You may also specify how you wish the resulting collection to be keyed:  $plucked = $collection- pluck( name ,  product_id );\n\n$plucked- all();\n\n// [ prod-100  =   Desk ,  prod-200  =   Chair ]", 
            "title": "pluck() {#collection-method}"
        }, 
        {
            "location": "/collections/#pop-collection-method", 
            "text": "The  pop  method removes and returns the last item from the collection:  $collection = collect([1, 2, 3, 4, 5]);\n\n$collection- pop();\n\n// 5\n\n$collection- all();\n\n// [1, 2, 3, 4]", 
            "title": "pop() {#collection-method}"
        }, 
        {
            "location": "/collections/#prepend-collection-method", 
            "text": "The  prepend  method adds an item to the beginning of the collection:  $collection = collect([1, 2, 3, 4, 5]);\n\n$collection- prepend(0);\n\n$collection- all();\n\n// [0, 1, 2, 3, 4, 5]  You may also pass a second argument to set the key of the prepended item:  $collection = collect([ one  =  1,  two  =  2]);\n\n$collection- prepend(0,  zero );\n\n$collection- all();\n\n// [ zero  =  0,  one  =  1,  two  =  2]", 
            "title": "prepend() {#collection-method}"
        }, 
        {
            "location": "/collections/#pull-collection-method", 
            "text": "The  pull  method removes and returns an item from the collection by its key:  $collection = collect([ product_id  =   prod-100 ,  name  =   Desk ]);\n\n$collection- pull( name );\n\n//  Desk \n\n$collection- all();\n\n// [ product_id  =   prod-100 ]", 
            "title": "pull() {#collection-method}"
        }, 
        {
            "location": "/collections/#push-collection-method", 
            "text": "The  push  method appends an item to the end of the collection:  $collection = collect([1, 2, 3, 4]);\n\n$collection- push(5);\n\n$collection- all();\n\n// [1, 2, 3, 4, 5]", 
            "title": "push() {#collection-method}"
        }, 
        {
            "location": "/collections/#put-collection-method", 
            "text": "The  put  method sets the given key and value in the collection:  $collection = collect([ product_id  =  1,  name  =   Desk ]);\n\n$collection- put( price , 100);\n\n$collection- all();\n\n// [ product_id  =  1,  name  =   Desk ,  price  =  100]", 
            "title": "put() {#collection-method}"
        }, 
        {
            "location": "/collections/#random-collection-method", 
            "text": "The  random  method returns a random item from the collection:  $collection = collect([1, 2, 3, 4, 5]);\n\n$collection- random();\n\n// 4 - (retrieved randomly)  You may optionally pass an integer to  random  to specify how many items you would like to randomly retrieve. A collection of items is always returned when explicitly passing the number of items you wish to receive:  $random = $collection- random(3);\n\n$random- all();\n\n// [2, 4, 5] - (retrieved randomly)", 
            "title": "random() {#collection-method}"
        }, 
        {
            "location": "/collections/#reduce-collection-method", 
            "text": "The  reduce  method reduces the collection to a single value, passing the result of each iteration into the subsequent iteration:  $collection = collect([1, 2, 3]);\n\n$total = $collection- reduce(function ($carry, $item) {\n    return $carry + $item;\n});\n\n// 6  The value for  $carry  on the first iteration is  null ; however, you may specify its initial value by passing a second argument to  reduce :  $collection- reduce(function ($carry, $item) {\n    return $carry + $item;\n}, 4);\n\n// 10", 
            "title": "reduce() {#collection-method}"
        }, 
        {
            "location": "/collections/#reject-collection-method", 
            "text": "The  reject  method filters the collection using the given callback. The callback should return  true  if the item should be removed from the resulting collection:  $collection = collect([1, 2, 3, 4]);\n\n$filtered = $collection- reject(function ($value, $key) {\n    return $value   2;\n});\n\n$filtered- all();\n\n// [1, 2]  For the inverse of the  reject  method, see the  filter  method.", 
            "title": "reject() {#collection-method}"
        }, 
        {
            "location": "/collections/#reverse-collection-method", 
            "text": "The  reverse  method reverses the order of the collection's items:  $collection = collect([1, 2, 3, 4, 5]);\n\n$reversed = $collection- reverse();\n\n$reversed- all();\n\n// [5, 4, 3, 2, 1]", 
            "title": "reverse() {#collection-method}"
        }, 
        {
            "location": "/collections/#search-collection-method", 
            "text": "The  search  method searches the collection for the given value and returns its key if found. If the item is not found,  false  is returned.  $collection = collect([2, 4, 6, 8]);\n\n$collection- search(4);\n\n// 1  The search is done using a \"loose\" comparison, meaning a string with an integer value will be considered equal to an integer of the same value. To use strict comparison, pass  true  as the second argument to the method:  $collection- search( 4 , true);\n\n// false  Alternatively, you may pass in your own callback to search for the first item that passes your truth test:  $collection- search(function ($item, $key) {\n    return $item   5;\n});\n\n// 2", 
            "title": "search() {#collection-method}"
        }, 
        {
            "location": "/collections/#shift-collection-method", 
            "text": "The  shift  method removes and returns the first item from the collection:  $collection = collect([1, 2, 3, 4, 5]);\n\n$collection- shift();\n\n// 1\n\n$collection- all();\n\n// [2, 3, 4, 5]", 
            "title": "shift() {#collection-method}"
        }, 
        {
            "location": "/collections/#shuffle-collection-method", 
            "text": "The  shuffle  method randomly shuffles the items in the collection:  $collection = collect([1, 2, 3, 4, 5]);\n\n$shuffled = $collection- shuffle();\n\n$shuffled- all();\n\n// [3, 2, 5, 1, 4] // (generated randomly)", 
            "title": "shuffle() {#collection-method}"
        }, 
        {
            "location": "/collections/#slice-collection-method", 
            "text": "The  slice  method returns a slice of the collection starting at the given index:  $collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n\n$slice = $collection- slice(4);\n\n$slice- all();\n\n// [5, 6, 7, 8, 9, 10]  If you would like to limit the size of the returned slice, pass the desired size as the second argument to the method:  $slice = $collection- slice(4, 2);\n\n$slice- all();\n\n// [5, 6]  The returned slice will preserve keys by default. If you do not wish to preserve the original keys, you can use the  values  method to reindex them.", 
            "title": "slice() {#collection-method}"
        }, 
        {
            "location": "/collections/#sort-collection-method", 
            "text": "The  sort  method sorts the collection. The sorted collection keeps the original array keys, so in this example we'll use the  values  method to reset the keys to consecutively numbered indexes:  $collection = collect([5, 3, 1, 2, 4]);\n\n$sorted = $collection- sort();\n\n$sorted- values()- all();\n\n// [1, 2, 3, 4, 5]  If your sorting needs are more advanced, you may pass a callback to  sort  with your own algorithm. Refer to the PHP documentation on  usort , which is what the collection's  sort  method calls under the hood.   {tip} If you need to sort a collection of nested arrays or objects, see the  sortBy  and  sortByDesc  methods.", 
            "title": "sort() {#collection-method}"
        }, 
        {
            "location": "/collections/#sortby-collection-method", 
            "text": "The  sortBy  method sorts the collection by the given key. The sorted collection keeps the original array keys, so in this example we'll use the  values  method to reset the keys to consecutively numbered indexes:  $collection = collect([\n    [ name  =   Desk ,  price  =  200],\n    [ name  =   Chair ,  price  =  100],\n    [ name  =   Bookcase ,  price  =  150],\n]);\n\n$sorted = $collection- sortBy( price );\n\n$sorted- values()- all();\n\n/*\n    [\n        [ name  =   Chair ,  price  =  100],\n        [ name  =   Bookcase ,  price  =  150],\n        [ name  =   Desk ,  price  =  200],\n    ]\n*/  You can also pass your own callback to determine how to sort the collection values:  $collection = collect([\n    [ name  =   Desk ,  colors  =  [ Black ,  Mahogany ]],\n    [ name  =   Chair ,  colors  =  [ Black ]],\n    [ name  =   Bookcase ,  colors  =  [ Red ,  Beige ,  Brown ]],\n]);\n\n$sorted = $collection- sortBy(function ($product, $key) {\n    return count($product[ colors ]);\n});\n\n$sorted- values()- all();\n\n/*\n    [\n        [ name  =   Chair ,  colors  =  [ Black ]],\n        [ name  =   Desk ,  colors  =  [ Black ,  Mahogany ]],\n        [ name  =   Bookcase ,  colors  =  [ Red ,  Beige ,  Brown ]],\n    ]\n*/", 
            "title": "sortBy() {#collection-method}"
        }, 
        {
            "location": "/collections/#sortbydesc-collection-method", 
            "text": "This method has the same signature as the  sortBy  method, but will sort the collection in the opposite order.", 
            "title": "sortByDesc() {#collection-method}"
        }, 
        {
            "location": "/collections/#splice-collection-method", 
            "text": "The  splice  method removes and returns a slice of items starting at the specified index:  $collection = collect([1, 2, 3, 4, 5]);\n\n$chunk = $collection- splice(2);\n\n$chunk- all();\n\n// [3, 4, 5]\n\n$collection- all();\n\n// [1, 2]  You may pass a second argument to limit the size of the resulting chunk:  $collection = collect([1, 2, 3, 4, 5]);\n\n$chunk = $collection- splice(2, 1);\n\n$chunk- all();\n\n// [3]\n\n$collection- all();\n\n// [1, 2, 4, 5]  In addition, you can pass a third argument containing the new items to replace the items removed from the collection:  $collection = collect([1, 2, 3, 4, 5]);\n\n$chunk = $collection- splice(2, 1, [10, 11]);\n\n$chunk- all();\n\n// [3]\n\n$collection- all();\n\n// [1, 2, 10, 11, 4, 5]", 
            "title": "splice() {#collection-method}"
        }, 
        {
            "location": "/collections/#split-collection-method", 
            "text": "The  split  method breaks a collection into the given number of groups:  $collection = collect([1, 2, 3, 4, 5]);\n\n$groups = $collection- split(3);\n\n$groups- toArray();\n\n// [[1, 2], [3, 4], [5]]", 
            "title": "split() {#collection-method}"
        }, 
        {
            "location": "/collections/#sum-collection-method", 
            "text": "The  sum  method returns the sum of all items in the collection:  collect([1, 2, 3, 4, 5])- sum();\n\n// 15  If the collection contains nested arrays or objects, you should pass a key to use for determining which values to sum:  $collection = collect([\n    [ name  =   JavaScript: The Good Parts ,  pages  =  176],\n    [ name  =   JavaScript: The Definitive Guide ,  pages  =  1096],\n]);\n\n$collection- sum( pages );\n\n// 1272  In addition, you may pass your own callback to determine which values of the collection to sum:  $collection = collect([\n    [ name  =   Chair ,  colors  =  [ Black ]],\n    [ name  =   Desk ,  colors  =  [ Black ,  Mahogany ]],\n    [ name  =   Bookcase ,  colors  =  [ Red ,  Beige ,  Brown ]],\n]);\n\n$collection- sum(function ($product) {\n    return count($product[ colors ]);\n});\n\n// 6", 
            "title": "sum() {#collection-method}"
        }, 
        {
            "location": "/collections/#take-collection-method", 
            "text": "The  take  method returns a new collection with the specified number of items:  $collection = collect([0, 1, 2, 3, 4, 5]);\n\n$chunk = $collection- take(3);\n\n$chunk- all();\n\n// [0, 1, 2]  You may also pass a negative integer to take the specified amount of items from the end of the collection:  $collection = collect([0, 1, 2, 3, 4, 5]);\n\n$chunk = $collection- take(-2);\n\n$chunk- all();\n\n// [4, 5]", 
            "title": "take() {#collection-method}"
        }, 
        {
            "location": "/collections/#toarray-collection-method", 
            "text": "The  toArray  method converts the collection into a plain PHP  array . If the collection's values are  Eloquent  models, the models will also be converted to arrays:  $collection = collect([ name  =   Desk ,  price  =  200]);\n\n$collection- toArray();\n\n/*\n    [\n        [ name  =   Desk ,  price  =  200],\n    ]\n*/   {note}  toArray  also converts all of the collection's nested objects to an array. If you want to get the raw underlying array, use the  all  method instead.", 
            "title": "toArray() {#collection-method}"
        }, 
        {
            "location": "/collections/#tojson-collection-method", 
            "text": "The  toJson  method converts the collection into JSON:  $collection = collect([ name  =   Desk ,  price  =  200]);\n\n$collection- toJson();\n\n//  { name : Desk ,  price :200}", 
            "title": "toJson() {#collection-method}"
        }, 
        {
            "location": "/collections/#transform-collection-method", 
            "text": "The  transform  method iterates over the collection and calls the given callback with each item in the collection. The items in the collection will be replaced by the values returned by the callback:  $collection = collect([1, 2, 3, 4, 5]);\n\n$collection- transform(function ($item, $key) {\n    return $item * 2;\n});\n\n$collection- all();\n\n// [2, 4, 6, 8, 10]   {note} Unlike most other collection methods,  transform  modifies the collection itself. If you wish to create a new collection instead, use the  map  method.", 
            "title": "transform() {#collection-method}"
        }, 
        {
            "location": "/collections/#union-collection-method", 
            "text": "The  union  method adds the given array to the collection. If the given array contains keys that are already in the original collection, the original collection's values will be preferred:  $collection = collect([1 =  [ a ], 2 =  [ b ]]);\n\n$union = $collection- union([3 =  [ c ], 1 =  [ b ]]);\n\n$union- all();\n\n// [1 =  [ a ], 2 =  [ b ], 3 =  [ c ]]", 
            "title": "union() {#collection-method}"
        }, 
        {
            "location": "/collections/#unique-collection-method", 
            "text": "The  unique  method returns all of the unique items in the collection. The returned collection keeps the original array keys, so in this example we'll use the  values  method to reset the keys to consecutively numbered indexes:  $collection = collect([1, 1, 2, 2, 3, 4, 2]);\n\n$unique = $collection- unique();\n\n$unique- values()- all();\n\n// [1, 2, 3, 4]  When dealing with nested arrays or objects, you may specify the key used to determine uniqueness:  $collection = collect([\n    [ name  =   iPhone 6 ,  brand  =   Apple ,  type  =   phone ],\n    [ name  =   iPhone 5 ,  brand  =   Apple ,  type  =   phone ],\n    [ name  =   Apple Watch ,  brand  =   Apple ,  type  =   watch ],\n    [ name  =   Galaxy S6 ,  brand  =   Samsung ,  type  =   phone ],\n    [ name  =   Galaxy Gear ,  brand  =   Samsung ,  type  =   watch ],\n]);\n\n$unique = $collection- unique( brand );\n\n$unique- values()- all();\n\n/*\n    [\n        [ name  =   iPhone 6 ,  brand  =   Apple ,  type  =   phone ],\n        [ name  =   Galaxy S6 ,  brand  =   Samsung ,  type  =   phone ],\n    ]\n*/  You may also pass your own callback to determine item uniqueness:  $unique = $collection- unique(function ($item) {\n    return $item[ brand ].$item[ type ];\n});\n\n$unique- values()- all();\n\n/*\n    [\n        [ name  =   iPhone 6 ,  brand  =   Apple ,  type  =   phone ],\n        [ name  =   Apple Watch ,  brand  =   Apple ,  type  =   watch ],\n        [ name  =   Galaxy S6 ,  brand  =   Samsung ,  type  =   phone ],\n        [ name  =   Galaxy Gear ,  brand  =   Samsung ,  type  =   watch ],\n    ]\n*/", 
            "title": "unique() {#collection-method}"
        }, 
        {
            "location": "/collections/#values-collection-method", 
            "text": "The  values  method returns a new collection with the keys reset to consecutive integers:  $collection = collect([\n    10 =  [ product  =   Desk ,  price  =  200],\n    11 =  [ product  =   Desk ,  price  =  200]\n]);\n\n$values = $collection- values();\n\n$values- all();\n\n/*\n    [\n        0 =  [ product  =   Desk ,  price  =  200],\n        1 =  [ product  =   Desk ,  price  =  200],\n    ]\n*/", 
            "title": "values() {#collection-method}"
        }, 
        {
            "location": "/collections/#when-collection-method", 
            "text": "The  when  method will execute the given callback when the first argument given to the method evaluates to  true :  $collection = collect([1, 2, 3]);\n\n$collection- when(true, function ($collection) {\n    return $collection- push(4);\n});\n\n$collection- all();\n\n// [1, 2, 3, 4]", 
            "title": "when() {#collection-method}"
        }, 
        {
            "location": "/collections/#where-collection-method", 
            "text": "The  where  method filters the collection by a given key / value pair:  $collection = collect([\n    [ product  =   Desk ,  price  =  200],\n    [ product  =   Chair ,  price  =  100],\n    [ product  =   Bookcase ,  price  =  150],\n    [ product  =   Door ,  price  =  100],\n]);\n\n$filtered = $collection- where( price , 100);\n\n$filtered- all();\n\n/*\n[\n    [ product  =   Chair ,  price  =  100],\n    [ product  =   Door ,  price  =  100],\n]\n*/  The  where  method uses loose comparisons when checking item values. Use the  whereStrict  method to filter using \"strict\" comparisons.", 
            "title": "where() {#collection-method}"
        }, 
        {
            "location": "/collections/#wherestrict-collection-method", 
            "text": "This method has the same signature as the  where  method; however, all values are compared using \"strict\" comparisons.", 
            "title": "whereStrict() {#collection-method}"
        }, 
        {
            "location": "/collections/#wherein-collection-method", 
            "text": "The  whereIn  method filters the collection by a given key / value contained within the given array.  $collection = collect([\n    [ product  =   Desk ,  price  =  200],\n    [ product  =   Chair ,  price  =  100],\n    [ product  =   Bookcase ,  price  =  150],\n    [ product  =   Door ,  price  =  100],\n]);\n\n$filtered = $collection- whereIn( price , [150, 200]);\n\n$filtered- all();\n\n/*\n[\n    [ product  =   Bookcase ,  price  =  150],\n    [ product  =   Desk ,  price  =  200],\n]\n*/  The  whereIn  method uses \"loose\" comparisons when checking item values. Use the  whereInStrict  method to filter using strict comparisons.", 
            "title": "whereIn() {#collection-method}"
        }, 
        {
            "location": "/collections/#whereinstrict-collection-method", 
            "text": "This method has the same signature as the  whereIn  method; however, all values are compared using strict comparisons.", 
            "title": "whereInStrict() {#collection-method}"
        }, 
        {
            "location": "/collections/#zip-collection-method", 
            "text": "The  zip  method merges together the values of the given array with the values of the original collection at the corresponding index:  $collection = collect([ Chair ,  Desk ]);\n\n$zipped = $collection- zip([100, 200]);\n\n$zipped- all();\n\n// [[ Chair , 100], [ Desk , 200]]", 
            "title": "zip() {#collection-method}"
        }, 
        {
            "location": "/collections/#higher-order-messages", 
            "text": "Collections also provide support for \"higher order messages\", which are short-cuts for performing common actions on collections. The collection methods that provide higher order messages are:  contains ,  each ,  every ,  filter ,  first ,  map ,  partition ,  reject ,  sortBy ,  sortByDesc , and  sum .  Each higher order message can be accessed as a dynamic property on a collection instance. For instance, let's use the  each  higher order message to call a method on each object within a collection:  $ users   =   User :: where ( votes ,   ,   500 ) - get ();  $ users- each- markAsVip ();   Likewise, we can use the  sum  higher order message to gather the total number of \"votes\" for a collection of users:  $ users   =   User :: where ( group ,   Development ) - get ();  return   $ users- sum- votes ;", 
            "title": "Higher Order Messages"
        }, 
        {
            "location": "/configuration/", 
            "text": "Configuration\n\n\n\n\nIntroduction\n\n\nEnvironment Configuration\n\n\nDetermining The Current Environment\n\n\n\n\n\n\nAccessing Configuration Values\n\n\nConfiguration Caching\n\n\nMaintenance Mode\n\n\n\n\n\n\nIntroduction\n\n\nAll of the configuration files for the Laravel framework are stored in the \nconfig\n directory. Each option is documented, so feel free to look through the files and get familiar with the options available to you.\n\n\n\n\nEnvironment Configuration\n\n\nIt is often helpful to have different configuration values based on the environment the application is running in. For example, you may wish to use a different cache driver locally than you do on your production server.\n\n\nTo make this a cinch, Laravel utilizes the \nDotEnv\n PHP library by Vance Lucas. In a fresh Laravel installation, the root directory of your application will contain a \n.env.example\n file. If you install Laravel via Composer, this file will automatically be renamed to \n.env\n. Otherwise, you should rename the file manually.\n\n\n\n\n{tip} You may also create a \n.env.testing\n file. This file will override values from the \n.env\n file when running PHPUnit tests or executing Artisan commands with the \n--env=testing\n option.\n\n\n\n\nRetrieving Environment Configuration\n\n\nAll of the variables listed in this file will be loaded into the \n$_ENV\n PHP super-global when your application receives a request. However, you may use the \nenv\n helper to retrieve values from these variables in your configuration files. In fact, if you review the Laravel configuration files, you will notice several of the options already using this helper:\n\n\ndebug\n =\n env(\nAPP_DEBUG\n, false),\n\n\n\n\n\nThe second value passed to the \nenv\n function is the \"default value\". This value will be used if no environment variable exists for the given key.\n\n\nYour \n.env\n file should not be committed to your application's source control, since each developer / server using your application could require a different environment configuration.\n\n\nIf you are developing with a team, you may wish to continue including a \n.env.example\n file with your application. By putting place-holder values in the example configuration file, other developers on your team can clearly see which environment variables are needed to run your application.\n\n\n\n\nDetermining The Current Environment\n\n\nThe current application environment is determined via the \nAPP_ENV\n variable from your \n.env\n file. You may access this value via the \nenvironment\n method on the \nApp\n \nfacade\n:\n\n\n$\nenvironment\n \n=\n \nApp\n::\nenvironment\n();\n\n\n\n\n\n\nYou may also pass arguments to the \nenvironment\n method to check if the environment matches a given value. The method will return \ntrue\n if the environment matches any of the given values:\n\n\nif (App::environment(\nlocal\n)) {\n    // The environment is local\n}\n\nif (App::environment(\nlocal\n, \nstaging\n)) {\n    // The environment is either local OR staging...\n}\n\n\n\n\n\n\n\nAccessing Configuration Values\n\n\nYou may easily access your configuration values using the global \nconfig\n helper function from anywhere in your application. The configuration values may be accessed using \"dot\" syntax, which includes the name of the file and option you wish to access. A default value may also be specified and will be returned if the configuration option does not exist:\n\n\n$value = config(\napp.timezone\n);\n\n\n\n\n\nTo set configuration values at runtime, pass an array to the \nconfig\n helper:\n\n\nconfig([\napp.timezone\n =\n \nAmerica/Chicago\n]);\n\n\n\n\n\n\n\nConfiguration Caching\n\n\nTo give your application a speed boost, you should cache all of your configuration files into a single file using the \nconfig:cache\n Artisan command. This will combine all of the configuration options for your application into a single file which will be loaded quickly by the framework.\n\n\nYou should typically run the \nphp artisan config:cache\n command as part of your production deployment routine. The command should not be run during local development as configuration options will frequently need to be changed during the course of your application's development.\n\n\n\n\n{note} If you execute the \nconfig:cache\n command during your deployment process, you should be sure that you are only calling the \nenv\n function from within your configuration files.\n\n\n\n\n\n\nMaintenance Mode\n\n\nWhen your application is in maintenance mode, a custom view will be displayed for all requests into your application. This makes it easy to \"disable\" your application while it is updating or when you are performing maintenance. A maintenance mode check is included in the default middleware stack for your application. If the application is in maintenance mode, a \nMaintenanceModeException\n will be thrown with a status code of 503.\n\n\nTo enable maintenance mode, simply execute the \ndown\n Artisan command:\n\n\nphp artisan down\n\n\n\n\n\nYou may also provide \nmessage\n and \nretry\n options to the \ndown\n command. The \nmessage\n value may be used to display or log a custom message, while the \nretry\n value will be set as the \nRetry-After\n HTTP header's value:\n\n\nphp artisan down --message=\nUpgrading Database\n --retry=60\n\n\n\n\n\nTo disable maintenance mode, use the \nup\n command:\n\n\nphp artisan up\n\n\n\n\n\nMaintenance Mode Response Template\n\n\nThe default template for maintenance mode responses is located in \nresources/views/errors/503.blade.php\n. You are free to modify this view as needed for your application.\n\n\nMaintenance Mode \n Queues\n\n\nWhile your application is in maintenance mode, no \nqueued jobs\n will be handled. The jobs will continue to be handled as normal once the application is out of maintenance mode.\n\n\nAlternatives To Maintenance Mode\n\n\nSince maintenance mode requires your application to have several seconds of downtime, consider alternatives like \nEnvoyer\n to accomplish zero-downtime deployment with Laravel.", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#configuration", 
            "text": "Introduction  Environment Configuration  Determining The Current Environment    Accessing Configuration Values  Configuration Caching  Maintenance Mode", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#introduction", 
            "text": "All of the configuration files for the Laravel framework are stored in the  config  directory. Each option is documented, so feel free to look through the files and get familiar with the options available to you.", 
            "title": "Introduction"
        }, 
        {
            "location": "/configuration/#environment-configuration", 
            "text": "It is often helpful to have different configuration values based on the environment the application is running in. For example, you may wish to use a different cache driver locally than you do on your production server.  To make this a cinch, Laravel utilizes the  DotEnv  PHP library by Vance Lucas. In a fresh Laravel installation, the root directory of your application will contain a  .env.example  file. If you install Laravel via Composer, this file will automatically be renamed to  .env . Otherwise, you should rename the file manually.   {tip} You may also create a  .env.testing  file. This file will override values from the  .env  file when running PHPUnit tests or executing Artisan commands with the  --env=testing  option.", 
            "title": "Environment Configuration"
        }, 
        {
            "location": "/configuration/#retrieving-environment-configuration", 
            "text": "All of the variables listed in this file will be loaded into the  $_ENV  PHP super-global when your application receives a request. However, you may use the  env  helper to retrieve values from these variables in your configuration files. In fact, if you review the Laravel configuration files, you will notice several of the options already using this helper:  debug  =  env( APP_DEBUG , false),  The second value passed to the  env  function is the \"default value\". This value will be used if no environment variable exists for the given key.  Your  .env  file should not be committed to your application's source control, since each developer / server using your application could require a different environment configuration.  If you are developing with a team, you may wish to continue including a  .env.example  file with your application. By putting place-holder values in the example configuration file, other developers on your team can clearly see which environment variables are needed to run your application.", 
            "title": "Retrieving Environment Configuration"
        }, 
        {
            "location": "/configuration/#determining-the-current-environment", 
            "text": "The current application environment is determined via the  APP_ENV  variable from your  .env  file. You may access this value via the  environment  method on the  App   facade :  $ environment   =   App :: environment ();   You may also pass arguments to the  environment  method to check if the environment matches a given value. The method will return  true  if the environment matches any of the given values:  if (App::environment( local )) {\n    // The environment is local\n}\n\nif (App::environment( local ,  staging )) {\n    // The environment is either local OR staging...\n}", 
            "title": "Determining The Current Environment"
        }, 
        {
            "location": "/configuration/#accessing-configuration-values", 
            "text": "You may easily access your configuration values using the global  config  helper function from anywhere in your application. The configuration values may be accessed using \"dot\" syntax, which includes the name of the file and option you wish to access. A default value may also be specified and will be returned if the configuration option does not exist:  $value = config( app.timezone );  To set configuration values at runtime, pass an array to the  config  helper:  config([ app.timezone  =   America/Chicago ]);", 
            "title": "Accessing Configuration Values"
        }, 
        {
            "location": "/configuration/#configuration-caching", 
            "text": "To give your application a speed boost, you should cache all of your configuration files into a single file using the  config:cache  Artisan command. This will combine all of the configuration options for your application into a single file which will be loaded quickly by the framework.  You should typically run the  php artisan config:cache  command as part of your production deployment routine. The command should not be run during local development as configuration options will frequently need to be changed during the course of your application's development.   {note} If you execute the  config:cache  command during your deployment process, you should be sure that you are only calling the  env  function from within your configuration files.", 
            "title": "Configuration Caching"
        }, 
        {
            "location": "/configuration/#maintenance-mode", 
            "text": "When your application is in maintenance mode, a custom view will be displayed for all requests into your application. This makes it easy to \"disable\" your application while it is updating or when you are performing maintenance. A maintenance mode check is included in the default middleware stack for your application. If the application is in maintenance mode, a  MaintenanceModeException  will be thrown with a status code of 503.  To enable maintenance mode, simply execute the  down  Artisan command:  php artisan down  You may also provide  message  and  retry  options to the  down  command. The  message  value may be used to display or log a custom message, while the  retry  value will be set as the  Retry-After  HTTP header's value:  php artisan down --message= Upgrading Database  --retry=60  To disable maintenance mode, use the  up  command:  php artisan up", 
            "title": "Maintenance Mode"
        }, 
        {
            "location": "/configuration/#maintenance-mode-response-template", 
            "text": "The default template for maintenance mode responses is located in  resources/views/errors/503.blade.php . You are free to modify this view as needed for your application.", 
            "title": "Maintenance Mode Response Template"
        }, 
        {
            "location": "/configuration/#maintenance-mode-queues", 
            "text": "While your application is in maintenance mode, no  queued jobs  will be handled. The jobs will continue to be handled as normal once the application is out of maintenance mode.", 
            "title": "Maintenance Mode &amp; Queues"
        }, 
        {
            "location": "/configuration/#alternatives-to-maintenance-mode", 
            "text": "Since maintenance mode requires your application to have several seconds of downtime, consider alternatives like  Envoyer  to accomplish zero-downtime deployment with Laravel.", 
            "title": "Alternatives To Maintenance Mode"
        }, 
        {
            "location": "/container/", 
            "text": "Service Container\n\n\n\n\nIntroduction\n\n\nBinding\n\n\nBinding Basics\n\n\nBinding Interfaces To Implementations\n\n\nContextual Binding\n\n\nTagging\n\n\n\n\n\n\nResolving\n\n\nThe Make Method\n\n\nAutomatic Injection\n\n\n\n\n\n\nContainer Events\n\n\n\n\n\n\nIntroduction\n\n\nThe Laravel service container is a powerful tool for managing class dependencies and performing dependency injection. Dependency injection is a fancy phrase that essentially means this: class dependencies are \"injected\" into the class via the constructor or, in some cases, \"setter\" methods.\n\n\nLet's look at a simple example:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\nuse\n \nApp\n\\\nRepositories\n\\\nUserRepository\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * The user repository implementation.\n\n\n     *\n\n\n     * @var UserRepository\n\n\n     */\n\n    \nprotected\n \n$users\n;\n\n\n    \n/**\n\n\n     * Create a new controller instance.\n\n\n     *\n\n\n     * @param  UserRepository  $users\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nUserRepository\n \n$users\n)\n\n    \n{\n\n        \n$this\n-\nusers\n \n=\n \n$users\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Show the profile for the given user.\n\n\n     *\n\n\n     * @param  int  $id\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nshow\n(\n$id\n)\n\n    \n{\n\n        \n$user\n \n=\n \n$this\n-\nusers\n-\nfind\n(\n$id\n);\n\n\n        \nreturn\n \nview\n(\nuser.profile\n,\n \n[\nuser\n \n=\n \n$user\n]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIn this example, the \nUserController\n needs to retrieve users from a data source. So, we will \ninject\n a service that is able to retrieve users. In this context, our \nUserRepository\n most likely uses \nEloquent\n to retrieve user information from the database. However, since the repository is injected, we are able to easily swap it out with another implementation. We are also able to easily \"mock\", or create a dummy implementation of the \nUserRepository\n when testing our application.\n\n\nA deep understanding of the Laravel service container is essential to building a powerful, large application, as well as for contributing to the Laravel core itself.\n\n\n\n\nBinding\n\n\n\n\nBinding Basics\n\n\nAlmost all of your service container bindings will be registered within \nservice providers\n, so most of these examples will demonstrate using the container in that context.\n\n\n\n\n{tip} There is no need to bind classes into the container if they do not depend on any interfaces. The container does not need to be instructed on how to build these objects, since it can automatically resolve these objects using reflection.\n\n\n\n\nSimple Bindings\n\n\nWithin a service provider, you always have access to the container via the \n$this-\napp\n property. We can register a binding using the \nbind\n method, passing the class or interface name that we wish to register along with a \nClosure\n that returns an instance of the class:\n\n\n$this-\napp-\nbind(\nHelpSpot\\API\n, function ($app) {\n    return new HelpSpot\\API($app-\nmake(\nHttpClient\n));\n});\n\n\n\n\n\nNote that we receive the container itself as an argument to the resolver. We can then use the container to resolve sub-dependencies of the object we are building.\n\n\nBinding A Singleton\n\n\nThe \nsingleton\n method binds a class or interface into the container that should only be resolved one time. Once a singleton binding is resolved, the same object instance will be returned on subsequent calls into the container:\n\n\n$this-\napp-\nsingleton(\nHelpSpot\\API\n, function ($app) {\n    return new HelpSpot\\API($app-\nmake(\nHttpClient\n));\n});\n\n\n\n\n\nBinding Instances\n\n\nYou may also bind an existing object instance into the container using the \ninstance\n method. The given instance will always be returned on subsequent calls into the container:\n\n\n$api = new HelpSpot\\API(new HttpClient);\n\n$this-\napp-\ninstance(\nHelpSpot\\Api\n, $api);\n\n\n\n\n\nBinding Primitives\n\n\nSometimes you may have a class that receives some injected classes, but also needs an injected primitive value such as an integer. You may easily use contextual binding to inject any value your class may need:\n\n\n$this-\napp-\nwhen(\nApp\\Http\\Controllers\\UserController\n)\n          -\nneeds(\n$variableName\n)\n          -\ngive($value);\n\n\n\n\n\n\n\nBinding Interfaces To Implementations\n\n\nA very powerful feature of the service container is its ability to bind an interface to a given implementation. For example, let's assume we have an \nEventPusher\n interface and a \nRedisEventPusher\n implementation. Once we have coded our \nRedisEventPusher\n implementation of this interface, we can register it with the service container like so:\n\n\n$this-\napp-\nbind(\n    \nApp\\Contracts\\EventPusher\n,\n    \nApp\\Services\\RedisEventPusher\n\n);\n\n\n\n\n\nThis statement tells the container that it should inject the \nRedisEventPusher\n when a class needs an implementation of \nEventPusher\n. Now we can type-hint the \nEventPusher\n interface in a constructor, or any other location where dependencies are injected by the service container:\n\n\nuse App\\Contracts\\EventPusher;\n\n/**\n * Create a new class instance.\n *\n * @param  EventPusher  $pusher\n * @return void\n */\npublic function __construct(EventPusher $pusher)\n{\n    $this-\npusher = $pusher;\n}\n\n\n\n\n\n\n\nContextual Binding\n\n\nSometimes you may have two classes that utilize the same interface, but you wish to inject different implementations into each class. For example, two controllers may depend on different implementations of the \nIlluminate\\Contracts\\Filesystem\\Filesystem\n \ncontract\n. Laravel provides a simple, fluent interface for defining this behavior:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nStorage\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nPhotoController\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nVideoController\n;\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nFilesystem\n\\\nFilesystem\n;\n\n\n\n$\nthis-\napp-\nwhen\n(\nPhotoController\n::\nclass\n)\n\n          \n-\nneeds\n(\nFilesystem\n::\nclass\n)\n\n          \n-\ngive\n(\nfunction\n \n()\n \n{\n\n              \nreturn\n \nStorage\n:\n:\ndisk\n(\nlocal\n);\n\n          \n}\n);\n\n\n\n$\nthis-\napp-\nwhen\n(\nVideoController\n::\nclass\n)\n\n          \n-\nneeds\n(\nFilesystem\n::\nclass\n)\n\n          \n-\ngive\n(\nfunction\n \n()\n \n{\n\n              \nreturn\n \nStorage\n:\n:\ndisk\n(\ns3\n);\n\n          \n}\n);\n\n\n\n\n\n\n\n\nTagging\n\n\nOccasionally, you may need to resolve all of a certain \"category\" of binding. For example, perhaps you are building a report aggregator that receives an array of many different \nReport\n interface implementations. After registering the \nReport\n implementations, you can assign them a tag using the \ntag\n method:\n\n\n$this-\napp-\nbind(\nSpeedReport\n, function () {\n    //\n});\n\n$this-\napp-\nbind(\nMemoryReport\n, function () {\n    //\n});\n\n$this-\napp-\ntag([\nSpeedReport\n, \nMemoryReport\n], \nreports\n);\n\n\n\n\n\nOnce the services have been tagged, you may easily resolve them all via the \ntagged\n method:\n\n\n$this-\napp-\nbind(\nReportAggregator\n, function ($app) {\n    return new ReportAggregator($app-\ntagged(\nreports\n));\n});\n\n\n\n\n\n\n\nResolving\n\n\n\n\nThe \nmake\n Method\n\n\nYou may use the \nmake\n method to resolve a class instance out of the container. The \nmake\n method accepts the name of the class or interface you wish to resolve:\n\n\n$api = $this-\napp-\nmake(\nHelpSpot\\API\n);\n\n\n\n\n\nIf you are in a location of your code that does not have access to the \n$app\n variable, you may use the global \nresolve\n helper:\n\n\n$api = resolve(\nHelpSpot\\API\n);\n\n\n\n\n\n\n\nAutomatic Injection\n\n\nAlternatively, and importantly, you may simply \"type-hint\" the dependency in the constructor of a class that is resolved by the container, including \ncontrollers\n, \nevent listeners\n, \nqueue jobs\n, \nmiddleware\n, and more. In practice, this is how most of your objects should be resolved by the container.\n\n\nFor example, you may type-hint a repository defined by your application in a controller's constructor. The repository will automatically be resolved and injected into the class:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nUsers\n\\\nRepository\n \nas\n \nUserRepository\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * The user repository instance.\n\n\n     */\n\n    \nprotected\n \n$users\n;\n\n\n    \n/**\n\n\n     * Create a new controller instance.\n\n\n     *\n\n\n     * @param  UserRepository  $users\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nUserRepository\n \n$users\n)\n\n    \n{\n\n        \n$this\n-\nusers\n \n=\n \n$users\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Show the user with the given ID.\n\n\n     *\n\n\n     * @param  int  $id\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nshow\n(\n$id\n)\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nContainer Events\n\n\nThe service container fires an event each time it resolves an object. You may listen to this event using the \nresolving\n method:\n\n\n$this-\napp-\nresolving(function ($object, $app) {\n    // Called when container resolves object of any type...\n});\n\n$this-\napp-\nresolving(HelpSpot\\API::class, function ($api, $app) {\n    // Called when container resolves objects of type \nHelpSpot\\API\n...\n});\n\n\n\n\n\nAs you can see, the object being resolved will be passed to the callback, allowing you to set any additional properties on the object before it is given to its consumer.", 
            "title": "Container"
        }, 
        {
            "location": "/container/#service-container", 
            "text": "Introduction  Binding  Binding Basics  Binding Interfaces To Implementations  Contextual Binding  Tagging    Resolving  The Make Method  Automatic Injection    Container Events", 
            "title": "Service Container"
        }, 
        {
            "location": "/container/#introduction", 
            "text": "The Laravel service container is a powerful tool for managing class dependencies and performing dependency injection. Dependency injection is a fancy phrase that essentially means this: class dependencies are \"injected\" into the class via the constructor or, in some cases, \"setter\" methods.  Let's look at a simple example:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ User ;  use   App \\ Repositories \\ UserRepository ;  use   App \\ Http \\ Controllers \\ Controller ;  class   UserController   extends   Controller  { \n     /**       * The user repository implementation.       *       * @var UserRepository       */ \n     protected   $users ; \n\n     /**       * Create a new controller instance.       *       * @param  UserRepository  $users       * @return void       */ \n     public   function   __construct ( UserRepository   $users ) \n     { \n         $this - users   =   $users ; \n     } \n\n     /**       * Show the profile for the given user.       *       * @param  int  $id       * @return Response       */ \n     public   function   show ( $id ) \n     { \n         $user   =   $this - users - find ( $id ); \n\n         return   view ( user.profile ,   [ user   =   $user ]); \n     }  }   In this example, the  UserController  needs to retrieve users from a data source. So, we will  inject  a service that is able to retrieve users. In this context, our  UserRepository  most likely uses  Eloquent  to retrieve user information from the database. However, since the repository is injected, we are able to easily swap it out with another implementation. We are also able to easily \"mock\", or create a dummy implementation of the  UserRepository  when testing our application.  A deep understanding of the Laravel service container is essential to building a powerful, large application, as well as for contributing to the Laravel core itself.", 
            "title": "Introduction"
        }, 
        {
            "location": "/container/#binding", 
            "text": "", 
            "title": "Binding"
        }, 
        {
            "location": "/container/#binding-basics", 
            "text": "Almost all of your service container bindings will be registered within  service providers , so most of these examples will demonstrate using the container in that context.   {tip} There is no need to bind classes into the container if they do not depend on any interfaces. The container does not need to be instructed on how to build these objects, since it can automatically resolve these objects using reflection.", 
            "title": "Binding Basics"
        }, 
        {
            "location": "/container/#simple-bindings", 
            "text": "Within a service provider, you always have access to the container via the  $this- app  property. We can register a binding using the  bind  method, passing the class or interface name that we wish to register along with a  Closure  that returns an instance of the class:  $this- app- bind( HelpSpot\\API , function ($app) {\n    return new HelpSpot\\API($app- make( HttpClient ));\n});  Note that we receive the container itself as an argument to the resolver. We can then use the container to resolve sub-dependencies of the object we are building.", 
            "title": "Simple Bindings"
        }, 
        {
            "location": "/container/#binding-a-singleton", 
            "text": "The  singleton  method binds a class or interface into the container that should only be resolved one time. Once a singleton binding is resolved, the same object instance will be returned on subsequent calls into the container:  $this- app- singleton( HelpSpot\\API , function ($app) {\n    return new HelpSpot\\API($app- make( HttpClient ));\n});", 
            "title": "Binding A Singleton"
        }, 
        {
            "location": "/container/#binding-instances", 
            "text": "You may also bind an existing object instance into the container using the  instance  method. The given instance will always be returned on subsequent calls into the container:  $api = new HelpSpot\\API(new HttpClient);\n\n$this- app- instance( HelpSpot\\Api , $api);", 
            "title": "Binding Instances"
        }, 
        {
            "location": "/container/#binding-primitives", 
            "text": "Sometimes you may have a class that receives some injected classes, but also needs an injected primitive value such as an integer. You may easily use contextual binding to inject any value your class may need:  $this- app- when( App\\Http\\Controllers\\UserController )\n          - needs( $variableName )\n          - give($value);", 
            "title": "Binding Primitives"
        }, 
        {
            "location": "/container/#binding-interfaces-to-implementations", 
            "text": "A very powerful feature of the service container is its ability to bind an interface to a given implementation. For example, let's assume we have an  EventPusher  interface and a  RedisEventPusher  implementation. Once we have coded our  RedisEventPusher  implementation of this interface, we can register it with the service container like so:  $this- app- bind(\n     App\\Contracts\\EventPusher ,\n     App\\Services\\RedisEventPusher \n);  This statement tells the container that it should inject the  RedisEventPusher  when a class needs an implementation of  EventPusher . Now we can type-hint the  EventPusher  interface in a constructor, or any other location where dependencies are injected by the service container:  use App\\Contracts\\EventPusher;\n\n/**\n * Create a new class instance.\n *\n * @param  EventPusher  $pusher\n * @return void\n */\npublic function __construct(EventPusher $pusher)\n{\n    $this- pusher = $pusher;\n}", 
            "title": "Binding Interfaces To Implementations"
        }, 
        {
            "location": "/container/#contextual-binding", 
            "text": "Sometimes you may have two classes that utilize the same interface, but you wish to inject different implementations into each class. For example, two controllers may depend on different implementations of the  Illuminate\\Contracts\\Filesystem\\Filesystem   contract . Laravel provides a simple, fluent interface for defining this behavior:  use   Illuminate \\ Support \\ Facades \\ Storage ;  use   App \\ Http \\ Controllers \\ PhotoController ;  use   App \\ Http \\ Controllers \\ VideoController ;  use   Illuminate \\ Contracts \\ Filesystem \\ Filesystem ;  $ this- app- when ( PhotoController :: class ) \n           - needs ( Filesystem :: class ) \n           - give ( function   ()   { \n               return   Storage : : disk ( local ); \n           } );  $ this- app- when ( VideoController :: class ) \n           - needs ( Filesystem :: class ) \n           - give ( function   ()   { \n               return   Storage : : disk ( s3 ); \n           } );", 
            "title": "Contextual Binding"
        }, 
        {
            "location": "/container/#tagging", 
            "text": "Occasionally, you may need to resolve all of a certain \"category\" of binding. For example, perhaps you are building a report aggregator that receives an array of many different  Report  interface implementations. After registering the  Report  implementations, you can assign them a tag using the  tag  method:  $this- app- bind( SpeedReport , function () {\n    //\n});\n\n$this- app- bind( MemoryReport , function () {\n    //\n});\n\n$this- app- tag([ SpeedReport ,  MemoryReport ],  reports );  Once the services have been tagged, you may easily resolve them all via the  tagged  method:  $this- app- bind( ReportAggregator , function ($app) {\n    return new ReportAggregator($app- tagged( reports ));\n});", 
            "title": "Tagging"
        }, 
        {
            "location": "/container/#resolving", 
            "text": "", 
            "title": "Resolving"
        }, 
        {
            "location": "/container/#the-make-method", 
            "text": "You may use the  make  method to resolve a class instance out of the container. The  make  method accepts the name of the class or interface you wish to resolve:  $api = $this- app- make( HelpSpot\\API );  If you are in a location of your code that does not have access to the  $app  variable, you may use the global  resolve  helper:  $api = resolve( HelpSpot\\API );", 
            "title": "The make Method"
        }, 
        {
            "location": "/container/#automatic-injection", 
            "text": "Alternatively, and importantly, you may simply \"type-hint\" the dependency in the constructor of a class that is resolved by the container, including  controllers ,  event listeners ,  queue jobs ,  middleware , and more. In practice, this is how most of your objects should be resolved by the container.  For example, you may type-hint a repository defined by your application in a controller's constructor. The repository will automatically be resolved and injected into the class:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ Users \\ Repository   as   UserRepository ;  class   UserController   extends   Controller  { \n     /**       * The user repository instance.       */ \n     protected   $users ; \n\n     /**       * Create a new controller instance.       *       * @param  UserRepository  $users       * @return void       */ \n     public   function   __construct ( UserRepository   $users ) \n     { \n         $this - users   =   $users ; \n     } \n\n     /**       * Show the user with the given ID.       *       * @param  int  $id       * @return Response       */ \n     public   function   show ( $id ) \n     { \n         // \n     }  }", 
            "title": "Automatic Injection"
        }, 
        {
            "location": "/container/#container-events", 
            "text": "The service container fires an event each time it resolves an object. You may listen to this event using the  resolving  method:  $this- app- resolving(function ($object, $app) {\n    // Called when container resolves object of any type...\n});\n\n$this- app- resolving(HelpSpot\\API::class, function ($api, $app) {\n    // Called when container resolves objects of type  HelpSpot\\API ...\n});  As you can see, the object being resolved will be passed to the callback, allowing you to set any additional properties on the object before it is given to its consumer.", 
            "title": "Container Events"
        }, 
        {
            "location": "/contracts/", 
            "text": "Contracts\n\n\n\n\nIntroduction\n\n\nContracts Vs. Facades\n\n\n\n\n\n\nWhen To Use Contracts\n\n\nLoose Coupling\n\n\nSimplicity\n\n\n\n\n\n\nHow To Use Contracts\n\n\nContract Reference\n\n\n\n\n\n\nIntroduction\n\n\nLaravel's Contracts are a set of interfaces that define the core services provided by the framework. For example, a \nIlluminate\\Contracts\\Queue\\Queue\n contract defines the methods needed for queueing jobs, while the \nIlluminate\\Contracts\\Mail\\Mailer\n contract defines the methods needed for sending e-mail.\n\n\nEach contract has a corresponding implementation provided by the framework. For example, Laravel provides a queue implementation with a variety of drivers, and a mailer implementation that is powered by \nSwiftMailer\n.\n\n\nAll of the Laravel contracts live in \ntheir own GitHub repository\n. This provides a quick reference point for all available contracts, as well as a single, decoupled package that may be utilized by package developers.\n\n\n\n\nContracts Vs. Facades\n\n\nLaravel's \nfacades\n and helper functions provide a simple way of utilizing Laravel's services without needing to type-hint and resolve contracts out of the service container. In most cases, each facade has an equivalent contract.\n\n\nUnlike facades, which do not require you to require them in your class' constructor, contracts allow you to define explicit dependencies for your classes. Some developers prefer to explicitly define their dependencies in this way and therefore prefer to use contracts, while other developers enjoy the convenience of facades.\n\n\n\n\n{tip} Most applications will be fine regardless of whether you prefer facades or contracts. However, if you are building a package, you should strongly consider using contracts since they will be easier to test in a package context.\n\n\n\n\n\n\nWhen To Use Contracts\n\n\nAs discussed elsewhere, much of the decision to use contracts or facades will come down to personal taste and the tastes of your development team. Both contracts and facades can be used to create robust, well-tested Laravel applications. As long as you are keeping your class' responsibilities focused, you will notice very few practical differences between using contracts and facades.\n\n\nHowever, you may still have several questions regarding contracts. For example, why use interfaces at all? Isn't using interfaces more complicated? Let's distill the reasons for using interfaces to the following headings: loose coupling and simplicity.\n\n\n\n\nLoose Coupling\n\n\nFirst, let's review some code that is tightly coupled to a cache implementation. Consider the following:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nOrders\n;\n\n\n\nclass\n \nRepository\n\n\n{\n\n    \n/**\n\n\n     * The cache instance.\n\n\n     */\n\n    \nprotected\n \n$cache\n;\n\n\n    \n/**\n\n\n     * Create a new repository instance.\n\n\n     *\n\n\n     * @param  \\SomePackage\\Cache\\Memcached  $cache\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\n\\\nSomePackage\n\\\nCache\n\\\nMemcached\n \n$cache\n)\n\n    \n{\n\n        \n$this\n-\ncache\n \n=\n \n$cache\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Retrieve an Order by ID.\n\n\n     *\n\n\n     * @param  int  $id\n\n\n     * @return Order\n\n\n     */\n\n    \npublic\n \nfunction\n \nfind\n(\n$id\n)\n\n    \n{\n\n        \nif\n \n(\n$this\n-\ncache\n-\nhas\n(\n$id\n))\n    \n{\n\n            \n//\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIn this class, the code is tightly coupled to a given cache implementation. It is tightly coupled because we are depending on a concrete Cache class from a package vendor. If the API of that package changes our code must change as well.\n\n\nLikewise, if we want to replace our underlying cache technology (Memcached) with another technology (Redis), we again will have to modify our repository. Our repository should not have so much knowledge regarding who is providing them data or how they are providing it.\n\n\nInstead of this approach, we can improve our code by depending on a simple, vendor agnostic interface:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nOrders\n;\n\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nCache\n\\\nRepository\n \nas\n \nCache\n;\n\n\n\nclass\n \nRepository\n\n\n{\n\n    \n/**\n\n\n     * The cache instance.\n\n\n     */\n\n    \nprotected\n \n$cache\n;\n\n\n    \n/**\n\n\n     * Create a new repository instance.\n\n\n     *\n\n\n     * @param  Cache  $cache\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nCache\n \n$cache\n)\n\n    \n{\n\n        \n$this\n-\ncache\n \n=\n \n$cache\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow the code is not coupled to any specific vendor, or even Laravel. Since the contracts package contains no implementation and no dependencies, you may easily write an alternative implementation of any given contract, allowing you to replace your cache implementation without modifying any of your cache consuming code.\n\n\n\n\nSimplicity\n\n\nWhen all of Laravel's services are neatly defined within simple interfaces, it is very easy to determine the functionality offered by a given service. \nThe contracts serve as succinct documentation to the framework's features.\n\n\nIn addition, when you depend on simple interfaces, your code is easier to understand and maintain. Rather than tracking down which methods are available to you within a large, complicated class, you can refer to a simple, clean interface.\n\n\n\n\nHow To Use Contracts\n\n\nSo, how do you get an implementation of a contract? It's actually quite simple.\n\n\nMany types of classes in Laravel are resolved through the \nservice container\n, including controllers, event listeners, middleware, queued jobs, and even route Closures. So, to get an implementation of a contract, you can just \"type-hint\" the interface in the constructor of the class being resolved.\n\n\nFor example, take a look at this event listener:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nListeners\n;\n\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\nuse\n \nApp\n\\\nEvents\n\\\nOrderWasPlaced\n;\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nRedis\n\\\nDatabase\n;\n\n\n\nclass\n \nCacheOrderInformation\n\n\n{\n\n    \n/**\n\n\n     * The Redis database implementation.\n\n\n     */\n\n    \nprotected\n \n$redis\n;\n\n\n    \n/**\n\n\n     * Create a new event handler instance.\n\n\n     *\n\n\n     * @param  Database  $redis\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nDatabase\n \n$redis\n)\n\n    \n{\n\n        \n$this\n-\nredis\n \n=\n \n$redis\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Handle the event.\n\n\n     *\n\n\n     * @param  OrderWasPlaced  $event\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandle\n(\nOrderWasPlaced\n \n$event\n)\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nWhen the event listener is resolved, the service container will read the type-hints on the constructor of the class, and inject the appropriate value. To learn more about registering things in the service container, check out \nits documentation\n.\n\n\n\n\nContract Reference\n\n\nThis table provides a quick reference to all of the Laravel contracts and their equivalent facades:\n\n\n\n\n\n\n\n\nContract\n\n\nReferences Facade\n\n\n\n\n\n\n\n\n\n\nIlluminate\\Contracts\\Auth\\Factory\n\n\nAuth\n\n\n\n\n\n\nIlluminate\\Contracts\\Auth\\PasswordBroker\n\n\nPassword\n\n\n\n\n\n\nIlluminate\\Contracts\\Bus\\Dispatcher\n\n\nBus\n\n\n\n\n\n\nIlluminate\\Contracts\\Broadcasting\\Broadcaster\n\n\n\n\n\n\n\n\nIlluminate\\Contracts\\Cache\\Repository\n\n\nCache\n\n\n\n\n\n\nIlluminate\\Contracts\\Cache\\Factory\n\n\nCache::driver()\n\n\n\n\n\n\nIlluminate\\Contracts\\Config\\Repository\n\n\nConfig\n\n\n\n\n\n\nIlluminate\\Contracts\\Container\\Container\n\n\nApp\n\n\n\n\n\n\nIlluminate\\Contracts\\Cookie\\Factory\n\n\nCookie\n\n\n\n\n\n\nIlluminate\\Contracts\\Cookie\\QueueingFactory\n\n\nCookie::queue()\n\n\n\n\n\n\nIlluminate\\Contracts\\Encryption\\Encrypter\n\n\nCrypt\n\n\n\n\n\n\nIlluminate\\Contracts\\Events\\Dispatcher\n\n\nEvent\n\n\n\n\n\n\nIlluminate\\Contracts\\Filesystem\\Cloud\n\n\n\n\n\n\n\n\nIlluminate\\Contracts\\Filesystem\\Factory\n\n\nFile\n\n\n\n\n\n\nIlluminate\\Contracts\\Filesystem\\Filesystem\n\n\nFile\n\n\n\n\n\n\nIlluminate\\Contracts\\Foundation\\Application\n\n\nApp\n\n\n\n\n\n\nIlluminate\\Contracts\\Hashing\\Hasher\n\n\nHash\n\n\n\n\n\n\nIlluminate\\Contracts\\Logging\\Log\n\n\nLog\n\n\n\n\n\n\nIlluminate\\Contracts\\Mail\\MailQueue\n\n\nMail::queue()\n\n\n\n\n\n\nIlluminate\\Contracts\\Mail\\Mailer\n\n\nMail\n\n\n\n\n\n\nIlluminate\\Contracts\\Queue\\Factory\n\n\nQueue::driver()\n\n\n\n\n\n\nIlluminate\\Contracts\\Queue\\Queue\n\n\nQueue\n\n\n\n\n\n\nIlluminate\\Contracts\\Redis\\Database\n\n\nRedis\n\n\n\n\n\n\nIlluminate\\Contracts\\Routing\\Registrar\n\n\nRoute\n\n\n\n\n\n\nIlluminate\\Contracts\\Routing\\ResponseFactory\n\n\nResponse\n\n\n\n\n\n\nIlluminate\\Contracts\\Routing\\UrlGenerator\n\n\nURL\n\n\n\n\n\n\nIlluminate\\Contracts\\Support\\Arrayable\n\n\n\n\n\n\n\n\nIlluminate\\Contracts\\Support\\Jsonable\n\n\n\n\n\n\n\n\nIlluminate\\Contracts\\Support\\Renderable\n\n\n\n\n\n\n\n\nIlluminate\\Contracts\\Validation\\Factory\n\n\nValidator::make()\n\n\n\n\n\n\nIlluminate\\Contracts\\Validation\\Validator\n\n\n\n\n\n\n\n\nIlluminate\\Contracts\\View\\Factory\n\n\nView::make()\n\n\n\n\n\n\nIlluminate\\Contracts\\View\\View", 
            "title": "Contracts"
        }, 
        {
            "location": "/contracts/#contracts", 
            "text": "Introduction  Contracts Vs. Facades    When To Use Contracts  Loose Coupling  Simplicity    How To Use Contracts  Contract Reference", 
            "title": "Contracts"
        }, 
        {
            "location": "/contracts/#introduction", 
            "text": "Laravel's Contracts are a set of interfaces that define the core services provided by the framework. For example, a  Illuminate\\Contracts\\Queue\\Queue  contract defines the methods needed for queueing jobs, while the  Illuminate\\Contracts\\Mail\\Mailer  contract defines the methods needed for sending e-mail.  Each contract has a corresponding implementation provided by the framework. For example, Laravel provides a queue implementation with a variety of drivers, and a mailer implementation that is powered by  SwiftMailer .  All of the Laravel contracts live in  their own GitHub repository . This provides a quick reference point for all available contracts, as well as a single, decoupled package that may be utilized by package developers.", 
            "title": "Introduction"
        }, 
        {
            "location": "/contracts/#contracts-vs-facades", 
            "text": "Laravel's  facades  and helper functions provide a simple way of utilizing Laravel's services without needing to type-hint and resolve contracts out of the service container. In most cases, each facade has an equivalent contract.  Unlike facades, which do not require you to require them in your class' constructor, contracts allow you to define explicit dependencies for your classes. Some developers prefer to explicitly define their dependencies in this way and therefore prefer to use contracts, while other developers enjoy the convenience of facades.   {tip} Most applications will be fine regardless of whether you prefer facades or contracts. However, if you are building a package, you should strongly consider using contracts since they will be easier to test in a package context.", 
            "title": "Contracts Vs. Facades"
        }, 
        {
            "location": "/contracts/#when-to-use-contracts", 
            "text": "As discussed elsewhere, much of the decision to use contracts or facades will come down to personal taste and the tastes of your development team. Both contracts and facades can be used to create robust, well-tested Laravel applications. As long as you are keeping your class' responsibilities focused, you will notice very few practical differences between using contracts and facades.  However, you may still have several questions regarding contracts. For example, why use interfaces at all? Isn't using interfaces more complicated? Let's distill the reasons for using interfaces to the following headings: loose coupling and simplicity.", 
            "title": "When To Use Contracts"
        }, 
        {
            "location": "/contracts/#loose-coupling", 
            "text": "First, let's review some code that is tightly coupled to a cache implementation. Consider the following:  ? php  namespace   App \\ Orders ;  class   Repository  { \n     /**       * The cache instance.       */ \n     protected   $cache ; \n\n     /**       * Create a new repository instance.       *       * @param  \\SomePackage\\Cache\\Memcached  $cache       * @return void       */ \n     public   function   __construct ( \\ SomePackage \\ Cache \\ Memcached   $cache ) \n     { \n         $this - cache   =   $cache ; \n     } \n\n     /**       * Retrieve an Order by ID.       *       * @param  int  $id       * @return Order       */ \n     public   function   find ( $id ) \n     { \n         if   ( $this - cache - has ( $id ))      { \n             // \n         } \n     }  }   In this class, the code is tightly coupled to a given cache implementation. It is tightly coupled because we are depending on a concrete Cache class from a package vendor. If the API of that package changes our code must change as well.  Likewise, if we want to replace our underlying cache technology (Memcached) with another technology (Redis), we again will have to modify our repository. Our repository should not have so much knowledge regarding who is providing them data or how they are providing it.  Instead of this approach, we can improve our code by depending on a simple, vendor agnostic interface:  ? php  namespace   App \\ Orders ;  use   Illuminate \\ Contracts \\ Cache \\ Repository   as   Cache ;  class   Repository  { \n     /**       * The cache instance.       */ \n     protected   $cache ; \n\n     /**       * Create a new repository instance.       *       * @param  Cache  $cache       * @return void       */ \n     public   function   __construct ( Cache   $cache ) \n     { \n         $this - cache   =   $cache ; \n     }  }   Now the code is not coupled to any specific vendor, or even Laravel. Since the contracts package contains no implementation and no dependencies, you may easily write an alternative implementation of any given contract, allowing you to replace your cache implementation without modifying any of your cache consuming code.", 
            "title": "Loose Coupling"
        }, 
        {
            "location": "/contracts/#simplicity", 
            "text": "When all of Laravel's services are neatly defined within simple interfaces, it is very easy to determine the functionality offered by a given service.  The contracts serve as succinct documentation to the framework's features.  In addition, when you depend on simple interfaces, your code is easier to understand and maintain. Rather than tracking down which methods are available to you within a large, complicated class, you can refer to a simple, clean interface.", 
            "title": "Simplicity"
        }, 
        {
            "location": "/contracts/#how-to-use-contracts", 
            "text": "So, how do you get an implementation of a contract? It's actually quite simple.  Many types of classes in Laravel are resolved through the  service container , including controllers, event listeners, middleware, queued jobs, and even route Closures. So, to get an implementation of a contract, you can just \"type-hint\" the interface in the constructor of the class being resolved.  For example, take a look at this event listener:  ? php  namespace   App \\ Listeners ;  use   App \\ User ;  use   App \\ Events \\ OrderWasPlaced ;  use   Illuminate \\ Contracts \\ Redis \\ Database ;  class   CacheOrderInformation  { \n     /**       * The Redis database implementation.       */ \n     protected   $redis ; \n\n     /**       * Create a new event handler instance.       *       * @param  Database  $redis       * @return void       */ \n     public   function   __construct ( Database   $redis ) \n     { \n         $this - redis   =   $redis ; \n     } \n\n     /**       * Handle the event.       *       * @param  OrderWasPlaced  $event       * @return void       */ \n     public   function   handle ( OrderWasPlaced   $event ) \n     { \n         // \n     }  }   When the event listener is resolved, the service container will read the type-hints on the constructor of the class, and inject the appropriate value. To learn more about registering things in the service container, check out  its documentation .", 
            "title": "How To Use Contracts"
        }, 
        {
            "location": "/contracts/#contract-reference", 
            "text": "This table provides a quick reference to all of the Laravel contracts and their equivalent facades:     Contract  References Facade      Illuminate\\Contracts\\Auth\\Factory  Auth    Illuminate\\Contracts\\Auth\\PasswordBroker  Password    Illuminate\\Contracts\\Bus\\Dispatcher  Bus    Illuminate\\Contracts\\Broadcasting\\Broadcaster     Illuminate\\Contracts\\Cache\\Repository  Cache    Illuminate\\Contracts\\Cache\\Factory  Cache::driver()    Illuminate\\Contracts\\Config\\Repository  Config    Illuminate\\Contracts\\Container\\Container  App    Illuminate\\Contracts\\Cookie\\Factory  Cookie    Illuminate\\Contracts\\Cookie\\QueueingFactory  Cookie::queue()    Illuminate\\Contracts\\Encryption\\Encrypter  Crypt    Illuminate\\Contracts\\Events\\Dispatcher  Event    Illuminate\\Contracts\\Filesystem\\Cloud     Illuminate\\Contracts\\Filesystem\\Factory  File    Illuminate\\Contracts\\Filesystem\\Filesystem  File    Illuminate\\Contracts\\Foundation\\Application  App    Illuminate\\Contracts\\Hashing\\Hasher  Hash    Illuminate\\Contracts\\Logging\\Log  Log    Illuminate\\Contracts\\Mail\\MailQueue  Mail::queue()    Illuminate\\Contracts\\Mail\\Mailer  Mail    Illuminate\\Contracts\\Queue\\Factory  Queue::driver()    Illuminate\\Contracts\\Queue\\Queue  Queue    Illuminate\\Contracts\\Redis\\Database  Redis    Illuminate\\Contracts\\Routing\\Registrar  Route    Illuminate\\Contracts\\Routing\\ResponseFactory  Response    Illuminate\\Contracts\\Routing\\UrlGenerator  URL    Illuminate\\Contracts\\Support\\Arrayable     Illuminate\\Contracts\\Support\\Jsonable     Illuminate\\Contracts\\Support\\Renderable     Illuminate\\Contracts\\Validation\\Factory  Validator::make()    Illuminate\\Contracts\\Validation\\Validator     Illuminate\\Contracts\\View\\Factory  View::make()    Illuminate\\Contracts\\View\\View", 
            "title": "Contract Reference"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contribution Guidelines\n\n\nIf you are submitting documentation for the \ncurrent stable release\n, submit it to the corresponding branch. For example, documentation for Laravel 5.1 would be submitted to the \n5.1\n branch. Documentation intended for the next release of Laravel should be submitted to the \nmaster\n branch.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#contribution-guidelines", 
            "text": "If you are submitting documentation for the  current stable release , submit it to the corresponding branch. For example, documentation for Laravel 5.1 would be submitted to the  5.1  branch. Documentation intended for the next release of Laravel should be submitted to the  master  branch.", 
            "title": "Contribution Guidelines"
        }, 
        {
            "location": "/contributions/", 
            "text": "Contribution Guide\n\n\n\n\nBug Reports\n\n\nCore Development Discussion\n\n\nWhich Branch?\n\n\nSecurity Vulnerabilities\n\n\nCoding Style\n\n\nPHPDoc\n\n\nStyleCI\n\n\n\n\n\n\n\n\n\n\nBug Reports\n\n\nTo encourage active collaboration, Laravel strongly encourages pull requests, not just bug reports. \"Bug reports\" may also be sent in the form of a pull request containing a failing test.\n\n\nHowever, if you file a bug report, your issue should contain a title and a clear description of the issue. You should also include as much relevant information as possible and a code sample that demonstrates the issue. The goal of a bug report is to make it easy for yourself - and others - to replicate the bug and develop a fix.\n\n\nRemember, bug reports are created in the hope that others with the same problem will be able to collaborate with you on solving it. Do not expect that the bug report will automatically see any activity or that others will jump to fix it. Creating a bug report serves to help yourself and others start on the path of fixing the problem.\n\n\nThe Laravel source code is managed on Github, and there are repositories for each of the Laravel projects:\n\n\n\n\nLaravel Framework\n\n\nLaravel Application\n\n\nLaravel Documentation\n\n\nLaravel Cashier\n\n\nLaravel Cashier for Braintree\n\n\nLaravel Envoy\n\n\nLaravel Homestead\n\n\nLaravel Homestead Build Scripts\n\n\nLaravel Passport\n\n\nLaravel Scout\n\n\nLaravel Socialite\n\n\nLaravel Website\n\n\nLaravel Art\n\n\n\n\n\n\nCore Development Discussion\n\n\nYou may propose new features or improvements of existing Laravel behavior in the Laravel Internals \nissue board\n. If you propose a new feature, please be willing to implement at least some of the code that would be needed to complete the feature.\n\n\nInformal discussion regarding bugs, new features, and implementation of existing features takes place in the \n#internals\n channel of the \nLaraChat\n Slack team. Taylor Otwell, the maintainer of Laravel, is typically present in the channel on weekdays from 8am-5pm (UTC-06:00 or America/Chicago), and sporadically present in the channel at other times.\n\n\n\n\nWhich Branch?\n\n\nAll\n bug fixes should be sent to the latest stable branch or to the current LTS branch (5.1). Bug fixes should \nnever\n be sent to the \nmaster\n branch unless they fix features that exist only in the upcoming release.\n\n\nMinor\n features that are \nfully backwards compatible\n with the current Laravel release may be sent to the latest stable branch.\n\n\nMajor\n new features should always be sent to the \nmaster\n branch, which contains the upcoming Laravel release.\n\n\nIf you are unsure if your feature qualifies as a major or minor, please ask Taylor Otwell in the \n#internals\n channel of the \nLaraChat\n Slack team.\n\n\n\n\nSecurity Vulnerabilities\n\n\nIf you discover a security vulnerability within Laravel, please send an email to Taylor Otwell at \ntaylor@laravel.com\n. All security vulnerabilities will be promptly addressed.\n\n\n\n\nCoding Style\n\n\nLaravel follows the \nPSR-2\n coding standard and the \nPSR-4\n autoloading standard.\n\n\n\n\nPHPDoc\n\n\nBelow is an example of a valid Laravel documentation block. Note that the \n@param\n attribute is followed by two spaces, the argument type, two more spaces, and finally the variable name:\n\n\n/**\n\n\n * Register a binding with the container.\n\n\n *\n\n\n * @param  string|array  $abstract\n\n\n * @param  \\Closure|string|null  $concrete\n\n\n * @param  bool  $shared\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nbind\n(\n$\nabstract\n,\n \n$\nconcrete\n \n=\n \nnull\n,\n \n$\nshared\n \n=\n \nfalse\n)\n\n\n{\n\n\n    \n//\n\n\n}\n\n\n\n\n\n\n\n\nStyleCI\n\n\nDon't worry if your code styling isn't perfect! \nStyleCI\n will automatically merge any style fixes into the Laravel repository after pull requests are merged. This allows us to focus on the content of the contribution and not the code style.", 
            "title": "Contributions"
        }, 
        {
            "location": "/contributions/#contribution-guide", 
            "text": "Bug Reports  Core Development Discussion  Which Branch?  Security Vulnerabilities  Coding Style  PHPDoc  StyleCI", 
            "title": "Contribution Guide"
        }, 
        {
            "location": "/contributions/#bug-reports", 
            "text": "To encourage active collaboration, Laravel strongly encourages pull requests, not just bug reports. \"Bug reports\" may also be sent in the form of a pull request containing a failing test.  However, if you file a bug report, your issue should contain a title and a clear description of the issue. You should also include as much relevant information as possible and a code sample that demonstrates the issue. The goal of a bug report is to make it easy for yourself - and others - to replicate the bug and develop a fix.  Remember, bug reports are created in the hope that others with the same problem will be able to collaborate with you on solving it. Do not expect that the bug report will automatically see any activity or that others will jump to fix it. Creating a bug report serves to help yourself and others start on the path of fixing the problem.  The Laravel source code is managed on Github, and there are repositories for each of the Laravel projects:   Laravel Framework  Laravel Application  Laravel Documentation  Laravel Cashier  Laravel Cashier for Braintree  Laravel Envoy  Laravel Homestead  Laravel Homestead Build Scripts  Laravel Passport  Laravel Scout  Laravel Socialite  Laravel Website  Laravel Art", 
            "title": "Bug Reports"
        }, 
        {
            "location": "/contributions/#core-development-discussion", 
            "text": "You may propose new features or improvements of existing Laravel behavior in the Laravel Internals  issue board . If you propose a new feature, please be willing to implement at least some of the code that would be needed to complete the feature.  Informal discussion regarding bugs, new features, and implementation of existing features takes place in the  #internals  channel of the  LaraChat  Slack team. Taylor Otwell, the maintainer of Laravel, is typically present in the channel on weekdays from 8am-5pm (UTC-06:00 or America/Chicago), and sporadically present in the channel at other times.", 
            "title": "Core Development Discussion"
        }, 
        {
            "location": "/contributions/#which-branch", 
            "text": "All  bug fixes should be sent to the latest stable branch or to the current LTS branch (5.1). Bug fixes should  never  be sent to the  master  branch unless they fix features that exist only in the upcoming release.  Minor  features that are  fully backwards compatible  with the current Laravel release may be sent to the latest stable branch.  Major  new features should always be sent to the  master  branch, which contains the upcoming Laravel release.  If you are unsure if your feature qualifies as a major or minor, please ask Taylor Otwell in the  #internals  channel of the  LaraChat  Slack team.", 
            "title": "Which Branch?"
        }, 
        {
            "location": "/contributions/#security-vulnerabilities", 
            "text": "If you discover a security vulnerability within Laravel, please send an email to Taylor Otwell at  taylor@laravel.com . All security vulnerabilities will be promptly addressed.", 
            "title": "Security Vulnerabilities"
        }, 
        {
            "location": "/contributions/#coding-style", 
            "text": "Laravel follows the  PSR-2  coding standard and the  PSR-4  autoloading standard.", 
            "title": "Coding Style"
        }, 
        {
            "location": "/contributions/#phpdoc", 
            "text": "Below is an example of a valid Laravel documentation block. Note that the  @param  attribute is followed by two spaces, the argument type, two more spaces, and finally the variable name:  /**   * Register a binding with the container.   *   * @param  string|array  $abstract   * @param  \\Closure|string|null  $concrete   * @param  bool  $shared   * @return void   */ \npublic   function   bind ( $ abstract ,   $ concrete   =   null ,   $ shared   =   false )  {       //  }", 
            "title": "PHPDoc"
        }, 
        {
            "location": "/contributions/#styleci", 
            "text": "Don't worry if your code styling isn't perfect!  StyleCI  will automatically merge any style fixes into the Laravel repository after pull requests are merged. This allows us to focus on the content of the contribution and not the code style.", 
            "title": "StyleCI"
        }, 
        {
            "location": "/controllers/", 
            "text": "Controllers\n\n\n\n\nIntroduction\n\n\nBasic Controllers\n\n\nDefining Controllers\n\n\nControllers \n Namespaces\n\n\nSingle Action Controllers\n\n\n\n\n\n\nController Middleware\n\n\nResource Controllers\n\n\nPartial Resource Routes\n\n\nNaming Resource Routes\n\n\nNaming Resource Route Parameters\n\n\nLocalizing Resource URIs\n\n\nSupplementing Resource Controllers\n\n\n\n\n\n\nDependency Injection \n Controllers\n\n\nRoute Caching\n\n\n\n\n\n\nIntroduction\n\n\nInstead of defining all of your request handling logic as Closures in route files, you may wish to organize this behavior using Controller classes. Controllers can group related request handling logic into a single class. Controllers are stored in the \napp/Http/Controllers\n directory.\n\n\n\n\nBasic Controllers\n\n\n\n\nDefining Controllers\n\n\nBelow is an example of a basic controller class. Note that the controller extends the base controller class included with Laravel. The base class provides a few convenience methods such as the \nmiddleware\n method, which may be used to attach middleware to controller actions:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Show the profile for the given user.\n\n\n     *\n\n\n     * @param  int  $id\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nshow\n(\n$id\n)\n\n    \n{\n\n        \nreturn\n \nview\n(\nuser.profile\n,\n \n[\nuser\n \n=\n \nUser\n::\nfindOrFail\n(\n$id\n)]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou can define a route to this controller action like so:\n\n\nRoute\n::\nget\n(\nuser/{id}\n,\n \nUserController@show\n);\n\n\n\n\n\n\nNow, when a request matches the specified route URI, the \nshow\n method on the \nUserController\n class will be executed. Of course, the route parameters will also be passed to the method.\n\n\n\n\n{tip} Controllers are not \nrequired\n to extend a base class. However, you will not have access to convenience features such as the \nmiddleware\n, \nvalidate\n, and \ndispatch\n methods.\n\n\n\n\n\n\nControllers \n Namespaces\n\n\nIt is very important to note that we did not need to specify the full controller namespace when defining the controller route. Since the \nRouteServiceProvider\n loads your route files within a route group that contains the namespace, we only specified the portion of the class name that comes after the \nApp\\Http\\Controllers\n portion of the namespace.\n\n\nIf you choose to nest your controllers deeper into the \nApp\\Http\\Controllers\n directory, simply use the specific class name relative to the \nApp\\Http\\Controllers\n root namespace. So, if your full controller class is \nApp\\Http\\Controllers\\Photos\\AdminController\n, you should register routes to the controller like so:\n\n\nRoute\n::\nget\n(\nfoo\n,\n \nPhotos\\AdminController@method\n);\n\n\n\n\n\n\n\n\nSingle Action Controllers\n\n\nIf you would like to define a controller that only handles a single action, you may place a single \n__invoke\n method on the controller:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nShowProfile\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Show the profile for the given user.\n\n\n     *\n\n\n     * @param  int  $id\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \n__invoke\n(\n$id\n)\n\n    \n{\n\n        \nreturn\n \nview\n(\nuser.profile\n,\n \n[\nuser\n \n=\n \nUser\n::\nfindOrFail\n(\n$id\n)]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nWhen registering routes for single action controllers, you do not need to specify a method:\n\n\nRoute\n::\nget\n(\nuser/{id}\n,\n \nShowProfile\n);\n\n\n\n\n\n\n\n\nController Middleware\n\n\nMiddleware\n may be assigned to the controller's routes in your route files:\n\n\nRoute\n::\nget\n(\nprofile\n,\n \nUserController@show\n)\n-\nmiddleware\n(\nauth\n);\n\n\n\n\n\n\nHowever, it is more convenient to specify middleware within your controller's constructor. Using the \nmiddleware\n method from your controller's constructor, you may easily assign middleware to the controller's action. You may even restrict the middleware to only certain methods on the controller class:\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Instantiate a new controller instance.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n        \n$this\n-\nmiddleware\n(\nauth\n);\n\n\n        \n$this\n-\nmiddleware\n(\nlog\n)\n-\nonly\n(\nindex\n);\n\n\n        \n$this\n-\nmiddleware\n(\nsubscribed\n)\n-\nexcept\n(\nstore\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nControllers also allow you to register middleware using a Closure. This provides a convenient way to define a middleware for a single controller without defining an entire middleware class:\n\n\n$this-\nmiddleware(function ($request, $next) {\n    // ...\n\n    return $next($request);\n});\n\n\n\n\n\n\n\n{tip} You may assign middleware to a subset of controller actions; however, it may indicate your controller is growing too large. Instead, consider breaking your controller into multiple, smaller controllers.\n\n\n\n\n\n\nResource Controllers\n\n\nLaravel resource routing assigns the typical \"CRUD\" routes to a controller with a single line of code. For example, you may wish to create a controller that handles all HTTP requests for \"photos\" stored by your application. Using the \nmake:controller\n Artisan command, we can quickly create such a controller:\n\n\nphp artisan make:controller PhotoController --resource\n\n\n\n\n\nThis command will generate a controller at \napp/Http/Controllers/PhotoController.php\n. The controller will contain a method for each of the available resource operations.\n\n\nNext, you may register a resourceful route to the controller:\n\n\nRoute\n::\nresource\n(\nphotos\n,\n \nPhotoController\n);\n\n\n\n\n\n\nThis single route declaration creates multiple routes to handle a variety of actions on the resource. The generated controller will already have methods stubbed for each of these actions, including notes informing you of the HTTP verbs and URIs they handle.\n\n\nActions Handled By Resource Controller\n\n\n\n\n\n\n\n\nVerb\n\n\nURI\n\n\nAction\n\n\nRoute Name\n\n\n\n\n\n\n\n\n\n\nGET\n\n\n/photos\n\n\nindex\n\n\nphotos.index\n\n\n\n\n\n\nGET\n\n\n/photos/create\n\n\ncreate\n\n\nphotos.create\n\n\n\n\n\n\nPOST\n\n\n/photos\n\n\nstore\n\n\nphotos.store\n\n\n\n\n\n\nGET\n\n\n/photos/{photo}\n\n\nshow\n\n\nphotos.show\n\n\n\n\n\n\nGET\n\n\n/photos/{photo}/edit\n\n\nedit\n\n\nphotos.edit\n\n\n\n\n\n\nPUT/PATCH\n\n\n/photos/{photo}\n\n\nupdate\n\n\nphotos.update\n\n\n\n\n\n\nDELETE\n\n\n/photos/{photo}\n\n\ndestroy\n\n\nphotos.destroy\n\n\n\n\n\n\n\n\nSpecifying The Resource Model\n\n\nIf you are using route model binding and would like the resource controller's methods to type-hint a model instance, you may use the \n--model\n option when generating the controller:\n\n\nphp artisan make:controller PhotoController --resource --model=Photo\n\n\n\n\n\nSpoofing Form Methods\n\n\nSince HTML forms can't make \nPUT\n, \nPATCH\n, or \nDELETE\n requests, you will need to add a hidden \n_method\n field to spoof these HTTP verbs. The \nmethod_field\n helper can create this field for you:\n\n\n{{\n \nmethod_field\n(\nPUT\n)\n \n}}\n\n\n\n\n\n\n\n\nPartial Resource Routes\n\n\nWhen declaring a resource route, you may specify a subset of actions the controller should handle instead of the full set of default actions:\n\n\nRoute::resource(\nphoto\n, \nPhotoController\n, [\nonly\n =\n [\n    \nindex\n, \nshow\n\n]]);\n\nRoute::resource(\nphoto\n, \nPhotoController\n, [\nexcept\n =\n [\n    \ncreate\n, \nstore\n, \nupdate\n, \ndestroy\n\n]]);\n\n\n\n\n\n\n\nNaming Resource Routes\n\n\nBy default, all resource controller actions have a route name; however, you can override these names by passing a \nnames\n array with your options:\n\n\nRoute::resource(\nphoto\n, \nPhotoController\n, [\nnames\n =\n [\n    \ncreate\n =\n \nphoto.build\n\n]]);\n\n\n\n\n\n\n\nNaming Resource Route Parameters\n\n\nBy default, \nRoute::resource\n will create the route parameters for your resource routes based on the \"singularized\" version of the resource name. You can easily override this on a per resource basis by passing \nparameters\n in the options array. The \nparameters\n array should be an associative array of resource names and parameter names:\n\n\nRoute::resource(\nuser\n, \nAdminUserController\n, [\nparameters\n =\n [\n    \nuser\n =\n \nadmin_user\n\n]]);\n\n\n\n\n\nThe example above generates the following URIs for the resource's \nshow\n route:\n\n\n/user/{admin_user}\n\n\n\n\n\n\n\nLocalizing Resource URIs\n\n\nBy default, \nRoute::resource\n will create resource URIs using English verbs. If you need to localize the \ncreate\n and \nedit\n action verbs, you may use the \nRoute::resourceVerbs\n method. This may be done in the \nboot\n method of your \nAppServiceProvider\n:\n\n\nuse Illuminate\\Support\\Facades\\Route;\n\n/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    Route::resourceVerbs([\n        \ncreate\n =\n \ncrear\n,\n        \nedit\n =\n \neditar\n,\n    ]);\n}\n\n\n\n\n\nOnce the verbs have been customized, a resource route registration such as \nRoute::resource('fotos', 'PhotoController')\n will produce the following URIs:\n\n\n/fotos/crear\n\n/fotos/{foto}/editar\n\n\n\n\n\n\n\nSupplementing Resource Controllers\n\n\nIf you need to add additional routes to a resource controller beyond the default set of resource routes, you should define those routes before your call to \nRoute::resource\n; otherwise, the routes defined by the \nresource\n method may unintentionally take precedence over your supplemental routes:\n\n\nRoute\n::\nget\n(\nphotos/popular\n,\n \nPhotoController@method\n);\n\n\n\nRoute\n::\nresource\n(\nphotos\n,\n \nPhotoController\n);\n\n\n\n\n\n\n\n\n{tip} Remember to keep your controllers focused. If you find yourself routinely needing methods outside of the typical set of resource actions, consider splitting your controller into two, smaller controllers.\n\n\n\n\n\n\nDependency Injection \n Controllers\n\n\nConstructor Injection\n\n\nThe Laravel \nservice container\n is used to resolve all Laravel controllers. As a result, you are able to type-hint any dependencies your controller may need in its constructor. The declared dependencies will automatically be resolved and injected into the controller instance:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nRepositories\n\\\nUserRepository\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * The user repository instance.\n\n\n     */\n\n    \nprotected\n \n$users\n;\n\n\n    \n/**\n\n\n     * Create a new controller instance.\n\n\n     *\n\n\n     * @param  UserRepository  $users\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nUserRepository\n \n$users\n)\n\n    \n{\n\n        \n$this\n-\nusers\n \n=\n \n$users\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOf course, you may also type-hint any \nLaravel contract\n. If the container can resolve it, you can type-hint it. Depending on your application, injecting your dependencies into your controller may provide better testability.\n\n\nMethod Injection\n\n\nIn addition to constructor injection, you may also type-hint dependencies on your controller's methods. A common use-case for method injection is injecting the \nIlluminate\\Http\\Request\n instance into your controller methods:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Store a new user.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nstore\n(\nRequest\n \n$request\n)\n\n    \n{\n\n        \n$name\n \n=\n \n$request\n-\nname\n;\n\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIf your controller method is also expecting input from a route parameter, simply list your route arguments after your other dependencies. For example, if your route is defined like so:\n\n\nRoute\n::\nput\n(\nuser/{id}\n,\n \nUserController@update\n);\n\n\n\n\n\n\nYou may still type-hint the \nIlluminate\\Http\\Request\n and access your \nid\n parameter by defining your controller method as follows:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Update the given user.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @param  string  $id\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nupdate\n(\nRequest\n \n$request\n,\n \n$id\n)\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nRoute Caching\n\n\n\n\n{note} Closure based routes cannot be cached. To use route caching, you must convert any Closure routes to controller classes.\n\n\n\n\nIf your application is exclusively using controller based routes, you should take advantage of Laravel's route cache. Using the route cache will drastically decrease the amount of time it takes to register all of your application's routes. In some cases, your route registration may even be up to 100x faster. To generate a route cache, just execute the \nroute:cache\n Artisan command:\n\n\nphp artisan route:cache\n\n\n\n\n\nAfter running this command, your cached routes file will be loaded on every request. Remember, if you add any new routes you will need to generate a fresh route cache. Because of this, you should only run the \nroute:cache\n command during your project's deployment.\n\n\nYou may use the \nroute:clear\n command to clear the route cache:\n\n\nphp artisan route:clear", 
            "title": "Controllers"
        }, 
        {
            "location": "/controllers/#controllers", 
            "text": "Introduction  Basic Controllers  Defining Controllers  Controllers   Namespaces  Single Action Controllers    Controller Middleware  Resource Controllers  Partial Resource Routes  Naming Resource Routes  Naming Resource Route Parameters  Localizing Resource URIs  Supplementing Resource Controllers    Dependency Injection   Controllers  Route Caching", 
            "title": "Controllers"
        }, 
        {
            "location": "/controllers/#introduction", 
            "text": "Instead of defining all of your request handling logic as Closures in route files, you may wish to organize this behavior using Controller classes. Controllers can group related request handling logic into a single class. Controllers are stored in the  app/Http/Controllers  directory.", 
            "title": "Introduction"
        }, 
        {
            "location": "/controllers/#basic-controllers", 
            "text": "", 
            "title": "Basic Controllers"
        }, 
        {
            "location": "/controllers/#defining-controllers", 
            "text": "Below is an example of a basic controller class. Note that the controller extends the base controller class included with Laravel. The base class provides a few convenience methods such as the  middleware  method, which may be used to attach middleware to controller actions:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ User ;  use   App \\ Http \\ Controllers \\ Controller ;  class   UserController   extends   Controller  { \n     /**       * Show the profile for the given user.       *       * @param  int  $id       * @return Response       */ \n     public   function   show ( $id ) \n     { \n         return   view ( user.profile ,   [ user   =   User :: findOrFail ( $id )]); \n     }  }   You can define a route to this controller action like so:  Route :: get ( user/{id} ,   UserController@show );   Now, when a request matches the specified route URI, the  show  method on the  UserController  class will be executed. Of course, the route parameters will also be passed to the method.   {tip} Controllers are not  required  to extend a base class. However, you will not have access to convenience features such as the  middleware ,  validate , and  dispatch  methods.", 
            "title": "Defining Controllers"
        }, 
        {
            "location": "/controllers/#controllers-namespaces", 
            "text": "It is very important to note that we did not need to specify the full controller namespace when defining the controller route. Since the  RouteServiceProvider  loads your route files within a route group that contains the namespace, we only specified the portion of the class name that comes after the  App\\Http\\Controllers  portion of the namespace.  If you choose to nest your controllers deeper into the  App\\Http\\Controllers  directory, simply use the specific class name relative to the  App\\Http\\Controllers  root namespace. So, if your full controller class is  App\\Http\\Controllers\\Photos\\AdminController , you should register routes to the controller like so:  Route :: get ( foo ,   Photos\\AdminController@method );", 
            "title": "Controllers &amp; Namespaces"
        }, 
        {
            "location": "/controllers/#single-action-controllers", 
            "text": "If you would like to define a controller that only handles a single action, you may place a single  __invoke  method on the controller:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ User ;  use   App \\ Http \\ Controllers \\ Controller ;  class   ShowProfile   extends   Controller  { \n     /**       * Show the profile for the given user.       *       * @param  int  $id       * @return Response       */ \n     public   function   __invoke ( $id ) \n     { \n         return   view ( user.profile ,   [ user   =   User :: findOrFail ( $id )]); \n     }  }   When registering routes for single action controllers, you do not need to specify a method:  Route :: get ( user/{id} ,   ShowProfile );", 
            "title": "Single Action Controllers"
        }, 
        {
            "location": "/controllers/#controller-middleware", 
            "text": "Middleware  may be assigned to the controller's routes in your route files:  Route :: get ( profile ,   UserController@show ) - middleware ( auth );   However, it is more convenient to specify middleware within your controller's constructor. Using the  middleware  method from your controller's constructor, you may easily assign middleware to the controller's action. You may even restrict the middleware to only certain methods on the controller class:  class   UserController   extends   Controller  { \n     /**       * Instantiate a new controller instance.       *       * @return void       */ \n     public   function   __construct () \n     { \n         $this - middleware ( auth ); \n\n         $this - middleware ( log ) - only ( index ); \n\n         $this - middleware ( subscribed ) - except ( store ); \n     }  }   Controllers also allow you to register middleware using a Closure. This provides a convenient way to define a middleware for a single controller without defining an entire middleware class:  $this- middleware(function ($request, $next) {\n    // ...\n\n    return $next($request);\n});   {tip} You may assign middleware to a subset of controller actions; however, it may indicate your controller is growing too large. Instead, consider breaking your controller into multiple, smaller controllers.", 
            "title": "Controller Middleware"
        }, 
        {
            "location": "/controllers/#resource-controllers", 
            "text": "Laravel resource routing assigns the typical \"CRUD\" routes to a controller with a single line of code. For example, you may wish to create a controller that handles all HTTP requests for \"photos\" stored by your application. Using the  make:controller  Artisan command, we can quickly create such a controller:  php artisan make:controller PhotoController --resource  This command will generate a controller at  app/Http/Controllers/PhotoController.php . The controller will contain a method for each of the available resource operations.  Next, you may register a resourceful route to the controller:  Route :: resource ( photos ,   PhotoController );   This single route declaration creates multiple routes to handle a variety of actions on the resource. The generated controller will already have methods stubbed for each of these actions, including notes informing you of the HTTP verbs and URIs they handle.", 
            "title": "Resource Controllers"
        }, 
        {
            "location": "/controllers/#actions-handled-by-resource-controller", 
            "text": "Verb  URI  Action  Route Name      GET  /photos  index  photos.index    GET  /photos/create  create  photos.create    POST  /photos  store  photos.store    GET  /photos/{photo}  show  photos.show    GET  /photos/{photo}/edit  edit  photos.edit    PUT/PATCH  /photos/{photo}  update  photos.update    DELETE  /photos/{photo}  destroy  photos.destroy", 
            "title": "Actions Handled By Resource Controller"
        }, 
        {
            "location": "/controllers/#specifying-the-resource-model", 
            "text": "If you are using route model binding and would like the resource controller's methods to type-hint a model instance, you may use the  --model  option when generating the controller:  php artisan make:controller PhotoController --resource --model=Photo", 
            "title": "Specifying The Resource Model"
        }, 
        {
            "location": "/controllers/#spoofing-form-methods", 
            "text": "Since HTML forms can't make  PUT ,  PATCH , or  DELETE  requests, you will need to add a hidden  _method  field to spoof these HTTP verbs. The  method_field  helper can create this field for you:  {{   method_field ( PUT )   }}", 
            "title": "Spoofing Form Methods"
        }, 
        {
            "location": "/controllers/#partial-resource-routes", 
            "text": "When declaring a resource route, you may specify a subset of actions the controller should handle instead of the full set of default actions:  Route::resource( photo ,  PhotoController , [ only  =  [\n     index ,  show \n]]);\n\nRoute::resource( photo ,  PhotoController , [ except  =  [\n     create ,  store ,  update ,  destroy \n]]);", 
            "title": "Partial Resource Routes"
        }, 
        {
            "location": "/controllers/#naming-resource-routes", 
            "text": "By default, all resource controller actions have a route name; however, you can override these names by passing a  names  array with your options:  Route::resource( photo ,  PhotoController , [ names  =  [\n     create  =   photo.build \n]]);", 
            "title": "Naming Resource Routes"
        }, 
        {
            "location": "/controllers/#naming-resource-route-parameters", 
            "text": "By default,  Route::resource  will create the route parameters for your resource routes based on the \"singularized\" version of the resource name. You can easily override this on a per resource basis by passing  parameters  in the options array. The  parameters  array should be an associative array of resource names and parameter names:  Route::resource( user ,  AdminUserController , [ parameters  =  [\n     user  =   admin_user \n]]);  The example above generates the following URIs for the resource's  show  route:  /user/{admin_user}", 
            "title": "Naming Resource Route Parameters"
        }, 
        {
            "location": "/controllers/#localizing-resource-uris", 
            "text": "By default,  Route::resource  will create resource URIs using English verbs. If you need to localize the  create  and  edit  action verbs, you may use the  Route::resourceVerbs  method. This may be done in the  boot  method of your  AppServiceProvider :  use Illuminate\\Support\\Facades\\Route;\n\n/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    Route::resourceVerbs([\n         create  =   crear ,\n         edit  =   editar ,\n    ]);\n}  Once the verbs have been customized, a resource route registration such as  Route::resource('fotos', 'PhotoController')  will produce the following URIs:  /fotos/crear\n\n/fotos/{foto}/editar", 
            "title": "Localizing Resource URIs"
        }, 
        {
            "location": "/controllers/#supplementing-resource-controllers", 
            "text": "If you need to add additional routes to a resource controller beyond the default set of resource routes, you should define those routes before your call to  Route::resource ; otherwise, the routes defined by the  resource  method may unintentionally take precedence over your supplemental routes:  Route :: get ( photos/popular ,   PhotoController@method );  Route :: resource ( photos ,   PhotoController );    {tip} Remember to keep your controllers focused. If you find yourself routinely needing methods outside of the typical set of resource actions, consider splitting your controller into two, smaller controllers.", 
            "title": "Supplementing Resource Controllers"
        }, 
        {
            "location": "/controllers/#dependency-injection-controllers", 
            "text": "", 
            "title": "Dependency Injection &amp; Controllers"
        }, 
        {
            "location": "/controllers/#constructor-injection", 
            "text": "The Laravel  service container  is used to resolve all Laravel controllers. As a result, you are able to type-hint any dependencies your controller may need in its constructor. The declared dependencies will automatically be resolved and injected into the controller instance:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ Repositories \\ UserRepository ;  class   UserController   extends   Controller  { \n     /**       * The user repository instance.       */ \n     protected   $users ; \n\n     /**       * Create a new controller instance.       *       * @param  UserRepository  $users       * @return void       */ \n     public   function   __construct ( UserRepository   $users ) \n     { \n         $this - users   =   $users ; \n     }  }   Of course, you may also type-hint any  Laravel contract . If the container can resolve it, you can type-hint it. Depending on your application, injecting your dependencies into your controller may provide better testability.", 
            "title": "Constructor Injection"
        }, 
        {
            "location": "/controllers/#method-injection", 
            "text": "In addition to constructor injection, you may also type-hint dependencies on your controller's methods. A common use-case for method injection is injecting the  Illuminate\\Http\\Request  instance into your controller methods:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Http \\ Request ;  class   UserController   extends   Controller  { \n     /**       * Store a new user.       *       * @param  Request  $request       * @return Response       */ \n     public   function   store ( Request   $request ) \n     { \n         $name   =   $request - name ; \n\n         // \n     }  }   If your controller method is also expecting input from a route parameter, simply list your route arguments after your other dependencies. For example, if your route is defined like so:  Route :: put ( user/{id} ,   UserController@update );   You may still type-hint the  Illuminate\\Http\\Request  and access your  id  parameter by defining your controller method as follows:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Http \\ Request ;  class   UserController   extends   Controller  { \n     /**       * Update the given user.       *       * @param  Request  $request       * @param  string  $id       * @return Response       */ \n     public   function   update ( Request   $request ,   $id ) \n     { \n         // \n     }  }", 
            "title": "Method Injection"
        }, 
        {
            "location": "/controllers/#route-caching", 
            "text": "{note} Closure based routes cannot be cached. To use route caching, you must convert any Closure routes to controller classes.   If your application is exclusively using controller based routes, you should take advantage of Laravel's route cache. Using the route cache will drastically decrease the amount of time it takes to register all of your application's routes. In some cases, your route registration may even be up to 100x faster. To generate a route cache, just execute the  route:cache  Artisan command:  php artisan route:cache  After running this command, your cached routes file will be loaded on every request. Remember, if you add any new routes you will need to generate a fresh route cache. Because of this, you should only run the  route:cache  command during your project's deployment.  You may use the  route:clear  command to clear the route cache:  php artisan route:clear", 
            "title": "Route Caching"
        }, 
        {
            "location": "/csrf/", 
            "text": "CSRF Protection\n\n\n\n\nIntroduction\n\n\nExcluding URIs\n\n\nX-CSRF-Token\n\n\nX-XSRF-Token\n\n\n\n\n\n\nIntroduction\n\n\nLaravel makes it easy to protect your application from \ncross-site request forgery\n (CSRF) attacks. Cross-site request forgeries are a type of malicious exploit whereby unauthorized commands are performed on behalf of an authenticated user.\n\n\nLaravel automatically generates a CSRF \"token\" for each active user session managed by the application. This token is used to verify that the authenticated user is the one actually making the requests to the application.\n\n\nAnytime you define a HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the \ncsrf_field\n helper to generate the token field:\n\n\nform\n \nmethod=\nPOST\n \naction=\n/profile\n\n    \n{{\n \ncsrf_field\n()\n \n}}\n\n    ...\n\n/form\n\n\n\n\n\n\nThe \nVerifyCsrfToken\n \nmiddleware\n, which is included in the \nweb\n middleware group, will automatically verify that the token in the request input matches the token stored in the session.\n\n\n\n\nExcluding URIs From CSRF Protection\n\n\nSometimes you may wish to exclude a set of URIs from CSRF protection. For example, if you are using \nStripe\n to process payments and are utilizing their webhook system, you will need to exclude your Stripe webhook handler route from CSRF protection since Stripe will not know what CSRF token to send to your routes.\n\n\nTypically, you should place these kinds of routes outside of the \nweb\n middleware group that the \nRouteServiceProvider\n applies to all routes in the \nroutes/web.php\n file. However, you may also exclude the routes by adding their URIs to the \n$except\n property of the \nVerifyCsrfToken\n middleware:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nMiddleware\n;\n\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nHttp\n\\\nMiddleware\n\\\nVerifyCsrfToken\n \nas\n \nBaseVerifier\n;\n\n\n\nclass\n \nVerifyCsrfToken\n \nextends\n \nBaseVerifier\n\n\n{\n\n    \n/**\n\n\n     * The URIs that should be excluded from CSRF verification.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$except\n \n=\n \n[\n\n        \nstripe/*\n,\n\n    \n];\n\n\n}\n\n\n\n\n\n\n\n\nX-CSRF-TOKEN\n\n\nIn addition to checking for the CSRF token as a POST parameter, the \nVerifyCsrfToken\n middleware will also check for the \nX-CSRF-TOKEN\n request header. You could, for example, store the token in a HTML \nmeta\n tag:\n\n\nmeta name=\ncsrf-token\n content=\n{{\n \ncsrf_token\n()\n \n}}\n\n\n\n\n\n\nThen, once you have created the \nmeta\n tag, you can instruct a library like jQuery to automatically add the token to all request headers. This provides simple, convenient CSRF protection for your AJAX based applications:\n\n\n$.ajaxSetup({\n    headers: {\n        \nX-CSRF-TOKEN\n: $(\nmeta[name=\ncsrf-token\n]\n).attr(\ncontent\n)\n    }\n});\n\n\n\n\n\n\n\nX-XSRF-TOKEN\n\n\nLaravel stores the current CSRF token in a \nXSRF-TOKEN\n cookie that is included with each response generated by the framework. You can use the cookie value to set the \nX-XSRF-TOKEN\n request header.\n\n\nThis cookie is primarily sent as a convenience since some JavaScript frameworks, like Angular, automatically place its value in the \nX-XSRF-TOKEN\n header.", 
            "title": "Csrf"
        }, 
        {
            "location": "/csrf/#csrf-protection", 
            "text": "Introduction  Excluding URIs  X-CSRF-Token  X-XSRF-Token", 
            "title": "CSRF Protection"
        }, 
        {
            "location": "/csrf/#introduction", 
            "text": "Laravel makes it easy to protect your application from  cross-site request forgery  (CSRF) attacks. Cross-site request forgeries are a type of malicious exploit whereby unauthorized commands are performed on behalf of an authenticated user.  Laravel automatically generates a CSRF \"token\" for each active user session managed by the application. This token is used to verify that the authenticated user is the one actually making the requests to the application.  Anytime you define a HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the  csrf_field  helper to generate the token field:  form   method= POST   action= /profile \n     {{   csrf_field ()   }} \n    ... /form   The  VerifyCsrfToken   middleware , which is included in the  web  middleware group, will automatically verify that the token in the request input matches the token stored in the session.", 
            "title": "Introduction"
        }, 
        {
            "location": "/csrf/#excluding-uris-from-csrf-protection", 
            "text": "Sometimes you may wish to exclude a set of URIs from CSRF protection. For example, if you are using  Stripe  to process payments and are utilizing their webhook system, you will need to exclude your Stripe webhook handler route from CSRF protection since Stripe will not know what CSRF token to send to your routes.  Typically, you should place these kinds of routes outside of the  web  middleware group that the  RouteServiceProvider  applies to all routes in the  routes/web.php  file. However, you may also exclude the routes by adding their URIs to the  $except  property of the  VerifyCsrfToken  middleware:  ? php  namespace   App \\ Http \\ Middleware ;  use   Illuminate \\ Foundation \\ Http \\ Middleware \\ VerifyCsrfToken   as   BaseVerifier ;  class   VerifyCsrfToken   extends   BaseVerifier  { \n     /**       * The URIs that should be excluded from CSRF verification.       *       * @var array       */ \n     protected   $except   =   [ \n         stripe/* , \n     ];  }", 
            "title": "Excluding URIs From CSRF Protection"
        }, 
        {
            "location": "/csrf/#x-csrf-token", 
            "text": "In addition to checking for the CSRF token as a POST parameter, the  VerifyCsrfToken  middleware will also check for the  X-CSRF-TOKEN  request header. You could, for example, store the token in a HTML  meta  tag:  meta name= csrf-token  content= {{   csrf_token ()   }}   Then, once you have created the  meta  tag, you can instruct a library like jQuery to automatically add the token to all request headers. This provides simple, convenient CSRF protection for your AJAX based applications:  $.ajaxSetup({\n    headers: {\n         X-CSRF-TOKEN : $( meta[name= csrf-token ] ).attr( content )\n    }\n});", 
            "title": "X-CSRF-TOKEN"
        }, 
        {
            "location": "/csrf/#x-xsrf-token", 
            "text": "Laravel stores the current CSRF token in a  XSRF-TOKEN  cookie that is included with each response generated by the framework. You can use the cookie value to set the  X-XSRF-TOKEN  request header.  This cookie is primarily sent as a convenience since some JavaScript frameworks, like Angular, automatically place its value in the  X-XSRF-TOKEN  header.", 
            "title": "X-XSRF-TOKEN"
        }, 
        {
            "location": "/database-testing/", 
            "text": "Database Testing\n\n\n\n\nIntroduction\n\n\nResetting The Database After Each Test\n\n\nUsing Migrations\n\n\nUsing Transactions\n\n\n\n\n\n\nWriting Factories\n\n\nFactory States\n\n\n\n\n\n\nUsing Factories\n\n\nCreating Models\n\n\nPersisting Models\n\n\nRelationships\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nLaravel provides a variety of helpful tools to make it easier to test your database driven applications. First, you may use the \nassertDatabaseHas\n helper to assert that data exists in the database matching a given set of criteria. For example, if you would like to verify that there is a record in the \nusers\n table with the \nemail\n value of \nsally@example.com\n, you can do the following:\n\n\npublic function testDatabase()\n{\n    // Make call to application...\n\n    $this-\nassertDatabaseHas(\nusers\n, [\n        \nemail\n =\n \nsally@example.com\n\n    ]);\n}\n\n\n\n\n\nOf course, the \nassertDatabaseHas\n method and other helpers like it are for convenience. You are free to use any of PHPUnit's built-in assertion methods to supplement your tests.\n\n\n\n\nResetting The Database After Each Test\n\n\nIt is often useful to reset your database after each test so that data from a previous test does not interfere with subsequent tests.\n\n\n\n\nUsing Migrations\n\n\nOne approach to resetting the database state is to rollback the database after each test and migrate it before the next test. Laravel provides a simple \nDatabaseMigrations\n trait that will automatically handle this for you. Simply use the trait on your test class and everything will be handled for you:\n\n\n?\nphp\n\n\n\nnamespace\n \nTests\n\\\nFeature\n;\n\n\n\nuse\n \nTests\n\\\nTestCase\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nWithoutMiddleware\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseMigrations\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseTransactions\n;\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \nuse\n \nDatabaseMigrations\n;\n\n\n    \n/**\n\n\n     * A basic functional test example.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \ntestBasicExample\n()\n\n    \n{\n\n        \n$response\n \n=\n \n$this\n-\nget\n(\n/\n);\n\n\n        \n// ...\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nUsing Transactions\n\n\nAnother approach to resetting the database state is to wrap each test case in a database transaction. Again, Laravel provides a convenient \nDatabaseTransactions\n trait that will automatically handle this for you:\n\n\n?\nphp\n\n\n\nnamespace\n \nTests\n\\\nFeature\n;\n\n\n\nuse\n \nTests\n\\\nTestCase\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nWithoutMiddleware\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseMigrations\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseTransactions\n;\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \nuse\n \nDatabaseTransactions\n;\n\n\n    \n/**\n\n\n     * A basic functional test example.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \ntestBasicExample\n()\n\n    \n{\n\n        \n$response\n \n=\n \n$this\n-\nget\n(\n/\n);\n\n\n        \n// ...\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n{note} By default, this trait will only wrap the default database connection in a transaction. If your application is using multiple database connections, you should define a \n$connectionsToTransact\n property on your test class. This property should be an array of connection names to execute the transactions on.\n\n\n\n\n\n\nWriting Factories\n\n\nWhen testing, you may need to insert a few records into your database before executing your test. Instead of manually specifying the value of each column when you create this test data, Laravel allows you to define a default set of attributes for each of your \nEloquent models\n using model factories. To get started, take a look at the \ndatabase/factories/ModelFactory.php\n file in your application. Out of the box, this file contains one factory definition:\n\n\n$factory-\ndefine(App\\User::class, function (Faker\\Generator $faker) {\n    static $password;\n\n    return [\n        \nname\n =\n $faker-\nname,\n        \nemail\n =\n $faker-\nunique()-\nsafeEmail,\n        \npassword\n =\n $password ?: $password = bcrypt(\nsecret\n),\n        \nremember_token\n =\n str_random(10),\n    ];\n});\n\n\n\n\n\nWithin the Closure, which serves as the factory definition, you may return the default test values of all attributes on the model. The Closure will receive an instance of the \nFaker\n PHP library, which allows you to conveniently generate various kinds of random data for testing.\n\n\nOf course, you are free to add your own additional factories to the \nModelFactory.php\n file. You may also create additional factory files for each model for better organization. For example, you could create \nUserFactory.php\n and \nCommentFactory.php\n files within your \ndatabase/factories\n directory. All of the files within the \nfactories\n directory will automatically be loaded by Laravel.\n\n\n\n\nFactory States\n\n\nStates allow you to define discrete modifications that can be applied to your model factories in any combination. For example, your \nUser\n model might have a \ndelinquent\n state that modifies one of its default attribute values. You may define your state transformations using the \nstate\n method:\n\n\n$factory-\nstate(App\\User::class, \ndelinquent\n, function ($faker) {\n    return [\n        \naccount_status\n =\n \ndelinquent\n,\n    ];\n});\n\n\n\n\n\n\n\nUsing Factories\n\n\n\n\nCreating Models\n\n\nOnce you have defined your factories, you may use the global \nfactory\n function in your tests or seed files to generate model instances. So, let's take a look at a few examples of creating models. First, we'll use the \nmake\n method to create models but not save them to the database:\n\n\npublic\n \nfunction\n \ntestDatabase\n()\n\n\n{\n\n    \n$user\n \n=\n \nfactory(App\\\nUser\n:\n:\nclass\n)\n-\nmake\n();\n\n\n    \n//\n \nUse\n \nmodel\n \nin\n \ntests...\n\n\n}\n\n\n\n\n\n\nYou may also create a Collection of many models or create models of a given type:\n\n\n//\n \nCreate\n \nthree\n \nApp\n\\\nUser\n \ninstances\n...\n\n\n$\nusers\n \n=\n \nfactory\n(\nApp\n\\\nUser\n::\nclass\n,\n \n3\n)\n-\nmake\n();\n\n\n\n\n\n\nApplying States\n\n\nYou may also apply any of your \nstates\n to the models. If you would like to apply multiple state transformations to the models, you should specify the name of each state you would like to apply:\n\n\n$\nusers\n \n=\n \nfactory\n(\nApp\n\\\nUser\n::\nclass\n,\n \n5\n)\n-\nstates\n(\ndelinquent\n)\n-\nmake\n();\n\n\n\n$\nusers\n \n=\n \nfactory\n(\nApp\n\\\nUser\n::\nclass\n,\n \n5\n)\n-\nstates\n(\npremium\n,\n \ndelinquent\n)\n-\nmake\n();\n\n\n\n\n\n\nOverriding Attributes\n\n\nIf you would like to override some of the default values of your models, you may pass an array of values to the \nmake\n method. Only the specified values will be replaced while the rest of the values remain set to their default values as specified by the factory:\n\n\n$user = factory(App\\User::class)-\nmake([\n    \nname\n =\n \nAbigail\n,\n]);\n\n\n\n\n\n\n\nPersisting Models\n\n\nThe \ncreate\n method not only creates the model instances but also saves them to the database using Eloquent's \nsave\n method:\n\n\npublic\n \nfunction\n \ntestDatabase\n()\n\n\n{\n\n    \n//\n \nCreate\n \na\n \nsingle\n \nApp\\User\n \ninstance...\n\n    \n$user\n \n=\n \nfactory(App\\\nUser\n:\n:\nclass\n)\n-\ncreate\n();\n\n\n    \n//\n \nCreate\n \nthree\n \nApp\\User\n \ninstances...\n\n    \n$users\n \n=\n \nfactory(App\\\nUser\n:\n:\nclass\n,\n \n3\n)\n-\ncreate\n();\n\n\n    \n//\n \nUse\n \nmodel\n \nin\n \ntests...\n\n\n}\n\n\n\n\n\n\nYou may override attributes on the model by passing an array to the \ncreate\n method:\n\n\n$user = factory(App\\User::class)-\ncreate([\n    \nname\n =\n \nAbigail\n,\n]);\n\n\n\n\n\n\n\nRelationships\n\n\nIn this example, we'll attach a relation to some created models. When using the \ncreate\n method to create multiple models, an Eloquent \ncollection instance\n is returned, allowing you to use any of the convenient functions provided by the collection, such as \neach\n:\n\n\n$\nusers\n \n=\n \nfactory\n(\nApp\n\\\nUser\n::\nclass\n,\n \n3\n)\n\n           \n-\ncreate\n()\n\n           \n-\neach\n(\nfunction\n \n($\nu\n)\n \n{\n\n                \n$u-\nposts()-\nsave(factory(App\\\nPost\n:\n:\nclass\n)\n-\nmake\n());\n\n            \n}\n);\n\n\n\n\n\n\nRelations \n Attribute Closures\n\n\nYou may also attach relationships to models using Closure attributes in your factory definitions. For example, if you would like to create a new \nUser\n instance when creating a \nPost\n, you may do the following:\n\n\n$\nfactory-\ndefine\n(\nApp\n\\\nPost\n::\nclass\n,\n \nfunction\n \n($\nfaker\n)\n \n{\n\n    \nreturn\n \n[\n\n        \ntitle\n \n=\n \n$faker\n-\ntitle\n,\n\n        \ncontent\n \n=\n \n$faker\n-\nparagraph\n,\n\n        \nuser_id\n \n=\n \nfunction\n \n()\n \n{\n\n            \nreturn\n \nfactory\n(\nApp\n\\\nUser\n::class\n)\n-\ncreate\n()\n-\nid\n;\n\n        \n}\n\n    \n]\n;\n\n\n}\n);\n\n\n\n\n\n\nThese Closures also receive the evaluated attribute array of the factory that defines them:\n\n\n$\nfactory-\ndefine\n(\nApp\n\\\nPost\n::\nclass\n,\n \nfunction\n \n($\nfaker\n)\n \n{\n\n    \nreturn\n \n[\n\n        \ntitle\n \n=\n \n$faker\n-\ntitle\n,\n\n        \ncontent\n \n=\n \n$faker\n-\nparagraph\n,\n\n        \nuser_id\n \n=\n \nfunction\n \n()\n \n{\n\n            \nreturn\n \nfactory\n(\nApp\n\\\nUser\n::class\n)\n-\ncreate\n()\n-\nid\n;\n\n        \n},\n\n        \nuser_type\n \n=\n \nfunction\n \n(\narray\n \n$post\n)\n \n{\n\n            \nreturn\n \nApp\n\\\nUser\n::find\n(\n$post\n[\nuser_id\n]\n)-\ntype\n;\n\n        \n}\n\n    \n];\n\n\n}\n);", 
            "title": "Database testing"
        }, 
        {
            "location": "/database-testing/#database-testing", 
            "text": "Introduction  Resetting The Database After Each Test  Using Migrations  Using Transactions    Writing Factories  Factory States    Using Factories  Creating Models  Persisting Models  Relationships", 
            "title": "Database Testing"
        }, 
        {
            "location": "/database-testing/#introduction", 
            "text": "Laravel provides a variety of helpful tools to make it easier to test your database driven applications. First, you may use the  assertDatabaseHas  helper to assert that data exists in the database matching a given set of criteria. For example, if you would like to verify that there is a record in the  users  table with the  email  value of  sally@example.com , you can do the following:  public function testDatabase()\n{\n    // Make call to application...\n\n    $this- assertDatabaseHas( users , [\n         email  =   sally@example.com \n    ]);\n}  Of course, the  assertDatabaseHas  method and other helpers like it are for convenience. You are free to use any of PHPUnit's built-in assertion methods to supplement your tests.", 
            "title": "Introduction"
        }, 
        {
            "location": "/database-testing/#resetting-the-database-after-each-test", 
            "text": "It is often useful to reset your database after each test so that data from a previous test does not interfere with subsequent tests.", 
            "title": "Resetting The Database After Each Test"
        }, 
        {
            "location": "/database-testing/#using-migrations", 
            "text": "One approach to resetting the database state is to rollback the database after each test and migrate it before the next test. Laravel provides a simple  DatabaseMigrations  trait that will automatically handle this for you. Simply use the trait on your test class and everything will be handled for you:  ? php  namespace   Tests \\ Feature ;  use   Tests \\ TestCase ;  use   Illuminate \\ Foundation \\ Testing \\ WithoutMiddleware ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseMigrations ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseTransactions ;  class   ExampleTest   extends   TestCase  { \n     use   DatabaseMigrations ; \n\n     /**       * A basic functional test example.       *       * @return void       */ \n     public   function   testBasicExample () \n     { \n         $response   =   $this - get ( / ); \n\n         // ... \n     }  }", 
            "title": "Using Migrations"
        }, 
        {
            "location": "/database-testing/#using-transactions", 
            "text": "Another approach to resetting the database state is to wrap each test case in a database transaction. Again, Laravel provides a convenient  DatabaseTransactions  trait that will automatically handle this for you:  ? php  namespace   Tests \\ Feature ;  use   Tests \\ TestCase ;  use   Illuminate \\ Foundation \\ Testing \\ WithoutMiddleware ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseMigrations ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseTransactions ;  class   ExampleTest   extends   TestCase  { \n     use   DatabaseTransactions ; \n\n     /**       * A basic functional test example.       *       * @return void       */ \n     public   function   testBasicExample () \n     { \n         $response   =   $this - get ( / ); \n\n         // ... \n     }  }    {note} By default, this trait will only wrap the default database connection in a transaction. If your application is using multiple database connections, you should define a  $connectionsToTransact  property on your test class. This property should be an array of connection names to execute the transactions on.", 
            "title": "Using Transactions"
        }, 
        {
            "location": "/database-testing/#writing-factories", 
            "text": "When testing, you may need to insert a few records into your database before executing your test. Instead of manually specifying the value of each column when you create this test data, Laravel allows you to define a default set of attributes for each of your  Eloquent models  using model factories. To get started, take a look at the  database/factories/ModelFactory.php  file in your application. Out of the box, this file contains one factory definition:  $factory- define(App\\User::class, function (Faker\\Generator $faker) {\n    static $password;\n\n    return [\n         name  =  $faker- name,\n         email  =  $faker- unique()- safeEmail,\n         password  =  $password ?: $password = bcrypt( secret ),\n         remember_token  =  str_random(10),\n    ];\n});  Within the Closure, which serves as the factory definition, you may return the default test values of all attributes on the model. The Closure will receive an instance of the  Faker  PHP library, which allows you to conveniently generate various kinds of random data for testing.  Of course, you are free to add your own additional factories to the  ModelFactory.php  file. You may also create additional factory files for each model for better organization. For example, you could create  UserFactory.php  and  CommentFactory.php  files within your  database/factories  directory. All of the files within the  factories  directory will automatically be loaded by Laravel.", 
            "title": "Writing Factories"
        }, 
        {
            "location": "/database-testing/#factory-states", 
            "text": "States allow you to define discrete modifications that can be applied to your model factories in any combination. For example, your  User  model might have a  delinquent  state that modifies one of its default attribute values. You may define your state transformations using the  state  method:  $factory- state(App\\User::class,  delinquent , function ($faker) {\n    return [\n         account_status  =   delinquent ,\n    ];\n});", 
            "title": "Factory States"
        }, 
        {
            "location": "/database-testing/#using-factories", 
            "text": "", 
            "title": "Using Factories"
        }, 
        {
            "location": "/database-testing/#creating-models", 
            "text": "Once you have defined your factories, you may use the global  factory  function in your tests or seed files to generate model instances. So, let's take a look at a few examples of creating models. First, we'll use the  make  method to create models but not save them to the database:  public   function   testDatabase ()  { \n     $user   =   factory(App\\ User : : class ) - make (); \n\n     //   Use   model   in   tests...  }   You may also create a Collection of many models or create models of a given type:  //   Create   three   App \\ User   instances ...  $ users   =   factory ( App \\ User :: class ,   3 ) - make ();", 
            "title": "Creating Models"
        }, 
        {
            "location": "/database-testing/#applying-states", 
            "text": "You may also apply any of your  states  to the models. If you would like to apply multiple state transformations to the models, you should specify the name of each state you would like to apply:  $ users   =   factory ( App \\ User :: class ,   5 ) - states ( delinquent ) - make ();  $ users   =   factory ( App \\ User :: class ,   5 ) - states ( premium ,   delinquent ) - make ();", 
            "title": "Applying States"
        }, 
        {
            "location": "/database-testing/#overriding-attributes", 
            "text": "If you would like to override some of the default values of your models, you may pass an array of values to the  make  method. Only the specified values will be replaced while the rest of the values remain set to their default values as specified by the factory:  $user = factory(App\\User::class)- make([\n     name  =   Abigail ,\n]);", 
            "title": "Overriding Attributes"
        }, 
        {
            "location": "/database-testing/#persisting-models", 
            "text": "The  create  method not only creates the model instances but also saves them to the database using Eloquent's  save  method:  public   function   testDatabase ()  { \n     //   Create   a   single   App\\User   instance... \n     $user   =   factory(App\\ User : : class ) - create (); \n\n     //   Create   three   App\\User   instances... \n     $users   =   factory(App\\ User : : class ,   3 ) - create (); \n\n     //   Use   model   in   tests...  }   You may override attributes on the model by passing an array to the  create  method:  $user = factory(App\\User::class)- create([\n     name  =   Abigail ,\n]);", 
            "title": "Persisting Models"
        }, 
        {
            "location": "/database-testing/#relationships", 
            "text": "In this example, we'll attach a relation to some created models. When using the  create  method to create multiple models, an Eloquent  collection instance  is returned, allowing you to use any of the convenient functions provided by the collection, such as  each :  $ users   =   factory ( App \\ User :: class ,   3 ) \n            - create () \n            - each ( function   ($ u )   { \n                 $u- posts()- save(factory(App\\ Post : : class ) - make ()); \n             } );", 
            "title": "Relationships"
        }, 
        {
            "location": "/database-testing/#relations-attribute-closures", 
            "text": "You may also attach relationships to models using Closure attributes in your factory definitions. For example, if you would like to create a new  User  instance when creating a  Post , you may do the following:  $ factory- define ( App \\ Post :: class ,   function   ($ faker )   { \n     return   [ \n         title   =   $faker - title , \n         content   =   $faker - paragraph , \n         user_id   =   function   ()   { \n             return   factory ( App \\ User ::class ) - create () - id ; \n         } \n     ] ;  } );   These Closures also receive the evaluated attribute array of the factory that defines them:  $ factory- define ( App \\ Post :: class ,   function   ($ faker )   { \n     return   [ \n         title   =   $faker - title , \n         content   =   $faker - paragraph , \n         user_id   =   function   ()   { \n             return   factory ( App \\ User ::class ) - create () - id ; \n         }, \n         user_type   =   function   ( array   $post )   { \n             return   App \\ User ::find ( $post [ user_id ] )- type ; \n         } \n     ];  } );", 
            "title": "Relations &amp; Attribute Closures"
        }, 
        {
            "location": "/database/", 
            "text": "Database: Getting Started\n\n\n\n\nIntroduction\n\n\nConfiguration\n\n\nRead \n Write Connections\n\n\nUsing Multiple Database Connections\n\n\n\n\n\n\nRunning Raw SQL Queries\n\n\nListening For Query Events\n\n\n\n\n\n\nDatabase Transactions\n\n\n\n\n\n\nIntroduction\n\n\nLaravel makes interacting with databases extremely simple across a variety of database backends using either raw SQL, the \nfluent query builder\n, and the \nEloquent ORM\n. Currently, Laravel supports four databases:\n\n\n\n- MySQL\n- Postgres\n- SQLite\n- SQL Server\n\n\n\n\n\n\nConfiguration\n\n\nThe database configuration for your application is located at \nconfig/database.php\n. In this file you may define all of your database connections, as well as specify which connection should be used by default. Examples for most of the supported database systems are provided in this file.\n\n\nBy default, Laravel's sample \nenvironment configuration\n is ready to use with \nLaravel Homestead\n, which is a convenient virtual machine for doing Laravel development on your local machine. Of course, you are free to modify this configuration as needed for your local database.\n\n\nSQLite Configuration\n\n\nAfter creating a new SQLite database using a command such as \ntouch database/database.sqlite\n, you can easily configure your environment variables to point to this newly created database by using the database's absolute path:\n\n\nDB_CONNECTION=sqlite\nDB_DATABASE=/absolute/path/to/database.sqlite\n\n\n\n\n\nSQL Server Configuration\n\n\nLaravel supports SQL Server out of the box; however, you will need to add the connection configuration for the database to your \nconfig/database.php\n configuration file:\n\n\nsqlsrv\n =\n [\n    \ndriver\n =\n \nsqlsrv\n,\n    \nhost\n =\n env(\nDB_HOST\n, \nlocalhost\n),\n    \ndatabase\n =\n env(\nDB_DATABASE\n, \nforge\n),\n    \nusername\n =\n env(\nDB_USERNAME\n, \nforge\n),\n    \npassword\n =\n env(\nDB_PASSWORD\n, \n),\n    \ncharset\n =\n \nutf8\n,\n    \nprefix\n =\n \n,\n],\n\n\n\n\n\n\n\nRead \n Write Connections\n\n\nSometimes you may wish to use one database connection for SELECT statements, and another for INSERT, UPDATE, and DELETE statements. Laravel makes this a breeze, and the proper connections will always be used whether you are using raw queries, the query builder, or the Eloquent ORM.\n\n\nTo see how read / write connections should be configured, let's look at this example:\n\n\nmysql\n =\n [\n    \nread\n =\n [\n        \nhost\n =\n \n192.168.1.1\n,\n    ],\n    \nwrite\n =\n [\n        \nhost\n =\n \n196.168.1.2\n\n    ],\n    \ndriver\n    =\n \nmysql\n,\n    \ndatabase\n  =\n \ndatabase\n,\n    \nusername\n  =\n \nroot\n,\n    \npassword\n  =\n \n,\n    \ncharset\n   =\n \nutf8\n,\n    \ncollation\n =\n \nutf8_unicode_ci\n,\n    \nprefix\n    =\n \n,\n],\n\n\n\n\n\nNote that two keys have been added to the configuration array: \nread\n and \nwrite\n. Both of these keys have array values containing a single key: \nhost\n. The rest of the database options for the \nread\n and \nwrite\n connections will be merged from the main \nmysql\n array.\n\n\nYou only need to place items in the \nread\n and \nwrite\n arrays if you wish to override the values from the main array. So, in this case, \n192.168.1.1\n will be used as the host for the \"read\" connection, while \n192.168.1.2\n will be used for the \"write\" connection. The database credentials, prefix, character set, and all other options in the main \nmysql\n array will be shared across both connections.\n\n\n\n\nUsing Multiple Database Connections\n\n\nWhen using multiple connections, you may access each connection via the \nconnection\n method on the \nDB\n facade. The \nname\n passed to the \nconnection\n method should correspond to one of the connections listed in your \nconfig/database.php\n configuration file:\n\n\n$\nusers\n \n=\n \nDB\n::\nconnection\n(\nfoo\n)\n-\nselect\n(...);\n\n\n\n\n\n\nYou may also access the raw, underlying PDO instance using the \ngetPdo\n method on a connection instance:\n\n\n$\npdo\n \n=\n \nDB\n::\nconnection\n()\n-\ngetPdo\n();\n\n\n\n\n\n\n\n\nRunning Raw SQL Queries\n\n\nOnce you have configured your database connection, you may run queries using the \nDB\n facade. The \nDB\n facade provides methods for each type of query: \nselect\n, \nupdate\n, \ninsert\n, \ndelete\n, and \nstatement\n.\n\n\nRunning A Select Query\n\n\nTo run a basic query, you may use the \nselect\n method on the \nDB\n facade:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nDB\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Show a list of all of the application\ns users.\n\n\n     *\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nindex\n()\n\n    \n{\n\n        \n$users\n \n=\n \nDB\n::\nselect\n(\nselect * from users where active = ?\n,\n \n[\n1\n]);\n\n\n        \nreturn\n \nview\n(\nuser.index\n,\n \n[\nusers\n \n=\n \n$users\n]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe first argument passed to the \nselect\n method is the raw SQL query, while the second argument is any parameter bindings that need to be bound to the query. Typically, these are the values of the \nwhere\n clause constraints. Parameter binding provides protection against SQL injection.\n\n\nThe \nselect\n method will always return an \narray\n of results. Each result within the array will be a PHP \nStdClass\n object, allowing you to access the values of the results:\n\n\nforeach ($users as $user) {\n    echo $user-\nname;\n}\n\n\n\n\n\nUsing Named Bindings\n\n\nInstead of using \n?\n to represent your parameter bindings, you may execute a query using named bindings:\n\n\n$\nresults\n \n=\n \nDB\n::\nselect\n(\nselect * from users where id = :id\n,\n \n[\nid\n \n=\n \n1\n]\n);\n\n\n\n\n\n\nRunning An Insert Statement\n\n\nTo execute an \ninsert\n statement, you may use the \ninsert\n method on the \nDB\n facade. Like \nselect\n, this method takes the raw SQL query as its first argument and bindings as its second argument:\n\n\nDB\n::\ninsert\n(\ninsert into users (id, name) values (?, ?)\n,\n \n[\n1\n,\n \nDayle\n]\n);\n\n\n\n\n\n\nRunning An Update Statement\n\n\nThe \nupdate\n method should be used to update existing records in the database. The number of rows affected by the statement will be returned:\n\n\n$\naffected\n \n=\n \nDB\n::\nupdate\n(\nupdate users set votes = 100 where name = ?\n,\n \n[\nJohn\n]\n);\n\n\n\n\n\n\nRunning A Delete Statement\n\n\nThe \ndelete\n method should be used to delete records from the database. Like \nupdate\n, the number of rows affected will be returned:\n\n\n$\ndeleted\n \n=\n \nDB\n::\ndelete\n(\ndelete from users\n);\n\n\n\n\n\n\nRunning A General Statement\n\n\nSome database statements do not return any value. For these types of operations, you may use the \nstatement\n method on the \nDB\n facade:\n\n\nDB\n::\nstatement\n(\ndrop table users\n);\n\n\n\n\n\n\n\n\nListening For Query Events\n\n\nIf you would like to receive each SQL query executed by your application, you may use the \nlisten\n method. This method is useful for logging queries or debugging. You may register your query listener in a \nservice provider\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nDB\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\n\nclass\n \nAppServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Bootstrap any application services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nDB\n::\nlisten\n(\nfunction\n \n(\n$query\n)\n \n{\n\n            \n// $query-\nsql\n\n            \n// $query-\nbindings\n\n            \n// $query-\ntime\n\n        \n});\n\n    \n}\n\n\n    \n/**\n\n\n     * Register the service provider.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nDatabase Transactions\n\n\nYou may use the \ntransaction\n method on the \nDB\n facade to run a set of operations within a database transaction. If an exception is thrown within the transaction \nClosure\n, the transaction will automatically be rolled back. If the \nClosure\n executes successfully, the transaction will automatically be committed. You don't need to worry about manually rolling back or committing while using the \ntransaction\n method:\n\n\nDB\n::\ntransaction\n(\nfunction\n \n()\n \n{\n\n    \nDB\n:\n:\ntable\n(\nusers\n)\n-\nupdate\n(\n[\nvotes\n \n=\n \n1\n]\n);\n\n\n    \nDB\n:\n:\ntable\n(\nposts\n)\n-\ndelete\n();\n\n\n}\n);\n\n\n\n\n\n\nHandling Deadlocks\n\n\nThe \ntransaction\n method accepts an optional second argument which defines the number of times a transaction should be reattempted when a deadlock occurs. Once these attempts have been exhausted, an exception will be thrown:\n\n\nDB\n::\ntransaction\n(\nfunction\n \n()\n \n{\n\n    \nDB\n:\n:\ntable\n(\nusers\n)\n-\nupdate\n(\n[\nvotes\n \n=\n \n1\n]\n);\n\n\n    \nDB\n:\n:\ntable\n(\nposts\n)\n-\ndelete\n();\n\n\n}\n,\n \n5\n);\n\n\n\n\n\n\nManually Using Transactions\n\n\nIf you would like to begin a transaction manually and have complete control over rollbacks and commits, you may use the \nbeginTransaction\n method on the \nDB\n facade:\n\n\nDB\n::\nbeginTransaction\n();\n\n\n\n\n\n\nYou can rollback the transaction via the \nrollBack\n method:\n\n\nDB\n::\nrollBack\n();\n\n\n\n\n\n\nLastly, you can commit a transaction via the \ncommit\n method:\n\n\nDB\n::\ncommit\n();\n\n\n\n\n\n\n\n\n{tip} Using the \nDB\n facade's transaction methods also controls transactions for the \nquery builder\n and \nEloquent ORM\n.", 
            "title": "Database"
        }, 
        {
            "location": "/database/#database-getting-started", 
            "text": "Introduction  Configuration  Read   Write Connections  Using Multiple Database Connections    Running Raw SQL Queries  Listening For Query Events    Database Transactions", 
            "title": "Database: Getting Started"
        }, 
        {
            "location": "/database/#introduction", 
            "text": "Laravel makes interacting with databases extremely simple across a variety of database backends using either raw SQL, the  fluent query builder , and the  Eloquent ORM . Currently, Laravel supports four databases:  \n- MySQL\n- Postgres\n- SQLite\n- SQL Server", 
            "title": "Introduction"
        }, 
        {
            "location": "/database/#configuration", 
            "text": "The database configuration for your application is located at  config/database.php . In this file you may define all of your database connections, as well as specify which connection should be used by default. Examples for most of the supported database systems are provided in this file.  By default, Laravel's sample  environment configuration  is ready to use with  Laravel Homestead , which is a convenient virtual machine for doing Laravel development on your local machine. Of course, you are free to modify this configuration as needed for your local database.", 
            "title": "Configuration"
        }, 
        {
            "location": "/database/#sqlite-configuration", 
            "text": "After creating a new SQLite database using a command such as  touch database/database.sqlite , you can easily configure your environment variables to point to this newly created database by using the database's absolute path:  DB_CONNECTION=sqlite\nDB_DATABASE=/absolute/path/to/database.sqlite", 
            "title": "SQLite Configuration"
        }, 
        {
            "location": "/database/#sql-server-configuration", 
            "text": "Laravel supports SQL Server out of the box; however, you will need to add the connection configuration for the database to your  config/database.php  configuration file:  sqlsrv  =  [\n     driver  =   sqlsrv ,\n     host  =  env( DB_HOST ,  localhost ),\n     database  =  env( DB_DATABASE ,  forge ),\n     username  =  env( DB_USERNAME ,  forge ),\n     password  =  env( DB_PASSWORD ,  ),\n     charset  =   utf8 ,\n     prefix  =   ,\n],", 
            "title": "SQL Server Configuration"
        }, 
        {
            "location": "/database/#read-write-connections", 
            "text": "Sometimes you may wish to use one database connection for SELECT statements, and another for INSERT, UPDATE, and DELETE statements. Laravel makes this a breeze, and the proper connections will always be used whether you are using raw queries, the query builder, or the Eloquent ORM.  To see how read / write connections should be configured, let's look at this example:  mysql  =  [\n     read  =  [\n         host  =   192.168.1.1 ,\n    ],\n     write  =  [\n         host  =   196.168.1.2 \n    ],\n     driver     =   mysql ,\n     database   =   database ,\n     username   =   root ,\n     password   =   ,\n     charset    =   utf8 ,\n     collation  =   utf8_unicode_ci ,\n     prefix     =   ,\n],  Note that two keys have been added to the configuration array:  read  and  write . Both of these keys have array values containing a single key:  host . The rest of the database options for the  read  and  write  connections will be merged from the main  mysql  array.  You only need to place items in the  read  and  write  arrays if you wish to override the values from the main array. So, in this case,  192.168.1.1  will be used as the host for the \"read\" connection, while  192.168.1.2  will be used for the \"write\" connection. The database credentials, prefix, character set, and all other options in the main  mysql  array will be shared across both connections.", 
            "title": "Read &amp; Write Connections"
        }, 
        {
            "location": "/database/#using-multiple-database-connections", 
            "text": "When using multiple connections, you may access each connection via the  connection  method on the  DB  facade. The  name  passed to the  connection  method should correspond to one of the connections listed in your  config/database.php  configuration file:  $ users   =   DB :: connection ( foo ) - select (...);   You may also access the raw, underlying PDO instance using the  getPdo  method on a connection instance:  $ pdo   =   DB :: connection () - getPdo ();", 
            "title": "Using Multiple Database Connections"
        }, 
        {
            "location": "/database/#running-raw-sql-queries", 
            "text": "Once you have configured your database connection, you may run queries using the  DB  facade. The  DB  facade provides methods for each type of query:  select ,  update ,  insert ,  delete , and  statement .", 
            "title": "Running Raw SQL Queries"
        }, 
        {
            "location": "/database/#running-a-select-query", 
            "text": "To run a basic query, you may use the  select  method on the  DB  facade:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Support \\ Facades \\ DB ;  use   App \\ Http \\ Controllers \\ Controller ;  class   UserController   extends   Controller  { \n     /**       * Show a list of all of the application s users.       *       * @return Response       */ \n     public   function   index () \n     { \n         $users   =   DB :: select ( select * from users where active = ? ,   [ 1 ]); \n\n         return   view ( user.index ,   [ users   =   $users ]); \n     }  }   The first argument passed to the  select  method is the raw SQL query, while the second argument is any parameter bindings that need to be bound to the query. Typically, these are the values of the  where  clause constraints. Parameter binding provides protection against SQL injection.  The  select  method will always return an  array  of results. Each result within the array will be a PHP  StdClass  object, allowing you to access the values of the results:  foreach ($users as $user) {\n    echo $user- name;\n}", 
            "title": "Running A Select Query"
        }, 
        {
            "location": "/database/#using-named-bindings", 
            "text": "Instead of using  ?  to represent your parameter bindings, you may execute a query using named bindings:  $ results   =   DB :: select ( select * from users where id = :id ,   [ id   =   1 ] );", 
            "title": "Using Named Bindings"
        }, 
        {
            "location": "/database/#running-an-insert-statement", 
            "text": "To execute an  insert  statement, you may use the  insert  method on the  DB  facade. Like  select , this method takes the raw SQL query as its first argument and bindings as its second argument:  DB :: insert ( insert into users (id, name) values (?, ?) ,   [ 1 ,   Dayle ] );", 
            "title": "Running An Insert Statement"
        }, 
        {
            "location": "/database/#running-an-update-statement", 
            "text": "The  update  method should be used to update existing records in the database. The number of rows affected by the statement will be returned:  $ affected   =   DB :: update ( update users set votes = 100 where name = ? ,   [ John ] );", 
            "title": "Running An Update Statement"
        }, 
        {
            "location": "/database/#running-a-delete-statement", 
            "text": "The  delete  method should be used to delete records from the database. Like  update , the number of rows affected will be returned:  $ deleted   =   DB :: delete ( delete from users );", 
            "title": "Running A Delete Statement"
        }, 
        {
            "location": "/database/#running-a-general-statement", 
            "text": "Some database statements do not return any value. For these types of operations, you may use the  statement  method on the  DB  facade:  DB :: statement ( drop table users );", 
            "title": "Running A General Statement"
        }, 
        {
            "location": "/database/#listening-for-query-events", 
            "text": "If you would like to receive each SQL query executed by your application, you may use the  listen  method. This method is useful for logging queries or debugging. You may register your query listener in a  service provider :  ? php  namespace   App \\ Providers ;  use   Illuminate \\ Support \\ Facades \\ DB ;  use   Illuminate \\ Support \\ ServiceProvider ;  class   AppServiceProvider   extends   ServiceProvider  { \n     /**       * Bootstrap any application services.       *       * @return void       */ \n     public   function   boot () \n     { \n         DB :: listen ( function   ( $query )   { \n             // $query- sql \n             // $query- bindings \n             // $query- time \n         }); \n     } \n\n     /**       * Register the service provider.       *       * @return void       */ \n     public   function   register () \n     { \n         // \n     }  }", 
            "title": "Listening For Query Events"
        }, 
        {
            "location": "/database/#database-transactions", 
            "text": "You may use the  transaction  method on the  DB  facade to run a set of operations within a database transaction. If an exception is thrown within the transaction  Closure , the transaction will automatically be rolled back. If the  Closure  executes successfully, the transaction will automatically be committed. You don't need to worry about manually rolling back or committing while using the  transaction  method:  DB :: transaction ( function   ()   { \n     DB : : table ( users ) - update ( [ votes   =   1 ] ); \n\n     DB : : table ( posts ) - delete ();  } );", 
            "title": "Database Transactions"
        }, 
        {
            "location": "/database/#handling-deadlocks", 
            "text": "The  transaction  method accepts an optional second argument which defines the number of times a transaction should be reattempted when a deadlock occurs. Once these attempts have been exhausted, an exception will be thrown:  DB :: transaction ( function   ()   { \n     DB : : table ( users ) - update ( [ votes   =   1 ] ); \n\n     DB : : table ( posts ) - delete ();  } ,   5 );", 
            "title": "Handling Deadlocks"
        }, 
        {
            "location": "/database/#manually-using-transactions", 
            "text": "If you would like to begin a transaction manually and have complete control over rollbacks and commits, you may use the  beginTransaction  method on the  DB  facade:  DB :: beginTransaction ();   You can rollback the transaction via the  rollBack  method:  DB :: rollBack ();   Lastly, you can commit a transaction via the  commit  method:  DB :: commit ();    {tip} Using the  DB  facade's transaction methods also controls transactions for the  query builder  and  Eloquent ORM .", 
            "title": "Manually Using Transactions"
        }, 
        {
            "location": "/documentation/", 
            "text": "Prologue\n\n\nRelease Notes\n\n\nUpgrade Guide\n\n\nContribution Guide\n\n\nAPI Documentation\n\n\n\n\n\n\nGetting Started\n\n\nInstallation\n\n\nConfiguration\n\n\nDirectory Structure\n\n\nRequest Lifecycle\n\n\n\n\n\n\nDev Environments\n\n\nHomestead\n\n\nValet\n\n\n\n\n\n\nCore Concepts\n\n\nService Container\n\n\nService Providers\n\n\nFacades\n\n\nContracts\n\n\n\n\n\n\nThe HTTP Layer\n\n\nRouting\n\n\nMiddleware\n\n\nCSRF Protection\n\n\nControllers\n\n\nRequests\n\n\nResponses\n\n\nViews\n\n\nSession\n\n\nValidation\n\n\n\n\n\n\nFrontend\n\n\nBlade Templates\n\n\nLocalization\n\n\nFrontend Scaffolding\n\n\nCompiling Assets\n\n\n\n\n\n\nSecurity\n\n\nAuthentication\n\n\nAPI Authentication\n\n\nAuthorization\n\n\nEncryption\n\n\nHashing\n\n\nPassword Reset\n\n\n\n\n\n\nGeneral Topics\n\n\nArtisan Console\n\n\nBroadcasting\n\n\nCache\n\n\nCollections\n\n\nErrors \n Logging\n\n\nEvents\n\n\nFile Storage\n\n\nHelpers\n\n\nMail\n\n\nNotifications\n\n\nPackages\n\n\nQueues\n\n\nScheduled Tasks\n\n\n\n\n\n\nDatabase\n\n\nGetting Started\n\n\nQuery Builder\n\n\nPagination\n\n\nMigrations\n\n\nSeeding\n\n\nRedis\n\n\n\n\n\n\nEloquent ORM\n\n\nGetting Started\n\n\nRelationships\n\n\nCollections\n\n\nMutators\n\n\nSerialization\n\n\n\n\n\n\nTesting\n\n\nGetting Started\n\n\nHTTP Tests\n\n\nBrowser Tests\n\n\nDatabase\n\n\nMocking\n\n\n\n\n\n\nOfficial Packages\n\n\nCashier\n\n\nEnvoy\n\n\nPassport\n\n\nScout\n\n\nSocialite", 
            "title": "Documentation"
        }, 
        {
            "location": "/dusk/", 
            "text": "Browser Tests (Laravel Dusk)\n\n\n\n\nIntroduction\n\n\nInstallation\n\n\nUsing Other Browsers\n\n\n\n\n\n\nGetting Started\n\n\nGenerating Tests\n\n\nRunning Tests\n\n\nEnvironment Handling\n\n\nCreating Browsers\n\n\nAuthentication\n\n\n\n\n\n\nInteracting With Elements\n\n\nClicking Links\n\n\nText, Values, \n Attributes\n\n\nUsing Forms\n\n\nAttaching Files\n\n\nUsing The Keyboard\n\n\nUsing The Mouse\n\n\nScoping Selectors\n\n\nWaiting For Elements\n\n\n\n\n\n\nAvailable Assertions\n\n\nPages\n\n\nGenerating Pages\n\n\nConfiguring Pages\n\n\nNavigating To Pages\n\n\nShorthand Selectors\n\n\nPage Methods\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nLaravel Dusk provides an expressive, easy-to-use browser automation and testing API. By default, Dusk does not require you to install JDK or Selenium on your machine. Instead, Dusk uses a standalone \nChromeDriver\n installation. However, you are free to utilize any other Selenium compatible driver you wish.\n\n\n\n\nInstallation\n\n\nTo get started, you should add the \nlaravel/dusk\n Composer dependency to your project:\n\n\ncomposer require laravel/dusk\n\n\n\n\n\nOnce Dusk is installed, you should register the \nLaravel\\Dusk\\DuskServiceProvider\n service provider. You should register the provider within the \nregister\n method of your \nAppServiceProvider\n in order to limit the environments in which Dusk is available, since it exposes the ability to login as other users:\n\n\nuse\n \nLaravel\n\\\nDusk\n\\\nDuskServiceProvider\n;\n\n\n\n/**\n\n\n * Register any application services.\n\n\n *\n\n\n * @return void\n\n\n */\n\n\npublic\n \nfunction\n \nregister\n()\n\n\n{\n\n    \nif\n \n($this-\napp-\nenvironment(\nlocal\n,\n \ntesting\n))\n \n{\n\n        \n$this-\napp-\nregister(\nDuskServiceProvider\n:\n:\nclass\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNext, run the \ndusk:install\n Artisan command:\n\n\nphp artisan dusk:install\n\n\n\n\n\nA \nBrowser\n directory will be created within your \ntests\n directory and will contain an example test. Next, set the \nAPP_URL\n environment variable in your \n.env\n file. This value should match the URL you use to access your application in a browser.\n\n\nTo run your tests, use the \ndusk\n Artisan command. The \ndusk\n command accepts any argument that is also accepted by the \nphpunit\n command:\n\n\nphp artisan dusk\n\n\n\n\n\n\n\nUsing Other Browsers\n\n\nBy default, Dusk uses Google Chrome and a standalone \nChromeDriver\n installation to run your browser tests. However, you may start your own Selenium server and run your tests against any browser you wish.\n\n\nTo get started, open your \ntests/DuskTestCase.php\n file, which is the base Dusk test case for your application. Within this file, you can remove the call to the \nstartChromeDriver\n method. This will stop Dusk from automatically starting the ChromeDriver:\n\n\n/**\n\n\n * Prepare for Dusk test execution.\n\n\n *\n\n\n * @beforeClass\n\n\n * @return void\n\n\n */\n\n\npublic\n \nstatic\n \nfunction\n \nprepare\n()\n\n\n{\n\n    \n//\n \nstatic\n:\n:\nstartChromeDriver\n();\n\n\n}\n\n\n\n\n\n\nNext, you may simply modify the \ndriver\n method to connect to the URL and port of your choice. In addition, you may modify the \"desired capabilities\" that should be passed to the WebDriver:\n\n\n/**\n\n\n * Create the RemoteWebDriver instance.\n\n\n *\n\n\n * @return \\Facebook\\WebDriver\\Remote\\RemoteWebDriver\n\n\n */\n\nprotected\n \nfunction\n \ndriver\n()\n\n\n{\n\n\n    \nreturn\n \nRemoteWebDriver\n:\n:\ncreate\n(\n\n\n        \nhttp://localhost:4444\n,\n \nDesiredCapabilities\n:\n:\nphantomjs\n()\n\n\n    \n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nGetting Started\n\n\n\n\nGenerating Tests\n\n\nTo generate a Dusk test, use the \ndusk:make\n Artisan command. The generated test will be placed in the \ntests/Browser\n directory:\n\n\nphp artisan dusk:make LoginTest\n\n\n\n\n\n\n\nRunning Tests\n\n\nTo run your browser tests, use the \ndusk\n Artisan command:\n\n\nphp artisan dusk\n\n\n\n\n\nThe \ndusk\n command accepts any argument that is normally accepted by the PHPUnit test runner, allowing you to only run the tests for a given \ngroup\n, etc:\n\n\nphp artisan dusk --group=foo\n\n\n\n\n\nManually Starting ChromeDriver\n\n\nBy default, Dusk will automatically attempt to start ChromeDriver. If this does not work for your particular system, you may manually start ChromeDriver before running the \ndusk\n command. If you choose to start ChromeDriver manually, you should comment out the following line of your \ntests/DuskTestCase.php\n file:\n\n\n/**\n\n\n * Prepare for Dusk test execution.\n\n\n *\n\n\n * @beforeClass\n\n\n * @return void\n\n\n */\n\n\npublic\n \nstatic\n \nfunction\n \nprepare\n()\n\n\n{\n\n    \n//\n \nstatic\n:\n:\nstartChromeDriver\n();\n\n\n}\n\n\n\n\n\n\nIn addition, if you start ChromeDriver on a port other than 9515, you should modify the \ndriver\n method of the same class:\n\n\n/**\n\n\n * Create the RemoteWebDriver instance.\n\n\n *\n\n\n * @return \\Facebook\\WebDriver\\Remote\\RemoteWebDriver\n\n\n */\n\nprotected\n \nfunction\n \ndriver\n()\n\n\n{\n\n\n    \nreturn\n \nRemoteWebDriver\n:\n:\ncreate\n(\n\n\n        \nhttp://localhost:9515\n,\n \nDesiredCapabilities\n:\n:\nchrome\n()\n\n\n    \n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nEnvironment Handling\n\n\nTo force Dusk to use its own environment file when running tests, create a \n.env.dusk.{environment}\n file in the root of your project. For example, if you will be initiating the \ndusk\n command from your \nlocal\n environment, you should create a \n.env.dusk.local\n file.\n\n\nWhen running tests, Dusk will back-up your \n.env\n file and rename your Dusk environment to \n.env\n. Once the tests have completed, your \n.env\n file will be restored.\n\n\n\n\nCreating Browsers\n\n\nTo get started, let's write a test that verifies we can log into our application. After generating a test, we can modify it to navigate to the login page, enter some credentials, and click the \"Login\" button. To create a browser instance, call the \nbrowse\n method:\n\n\n?\nphp\n\n\n\nnamespace\n \nTests\n\\\nBrowser\n;\n\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\nuse\n \nTests\n\\\nDuskTestCase\n;\n\n\nuse\n \nLaravel\n\\\nDusk\n\\\nChrome\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseMigrations\n;\n\n\n\nclass\n \nExampleTest\n \nextends\n \nDuskTestCase\n\n\n{\n\n    \nuse\n \nDatabaseMigrations\n;\n\n\n    \n/**\n\n\n     * A basic browser test example.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \ntestBasicExample\n()\n\n    \n{\n\n        \n$user\n \n=\n \nfactory\n(\nUser\n::\nclass\n)\n-\ncreate\n([\n\n            \nemail\n \n=\n \ntaylor@laravel.com\n,\n\n        \n]);\n\n\n        \n$this\n-\nbrowse\n(\nfunction\n \n(\n$browser\n)\n \nuse\n \n(\n$user\n)\n \n{\n\n            \n$browser\n-\nvisit\n(\n/login\n)\n\n                    \n-\ntype\n(\nemail\n,\n \n$user\n-\nemail\n)\n\n                    \n-\ntype\n(\npassword\n,\n \nsecret\n)\n\n                    \n-\npress\n(\nLogin\n)\n\n                    \n-\nassertPathIs\n(\n/home\n);\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAs you can see in the example above, the \nbrowse\n method accepts a callback. A browser instance will automatically be passed to this callback by Dusk and is the main object used to interact with and make assertions against your application.\n\n\n\n\n{tip} This test can be used to test the login screen generated by the \nmake:auth\n Artisan command.\n\n\n\n\nCreating Multiple Browsers\n\n\nSometimes you may need multiple browsers in order to properly carry out a test. For example, multiple browsers may be needed to test a chat screen that interacts with websockets. To create multiple browsers, simply \"ask\" for more than one browser in the signature of the callback given to the \nbrowse\n method:\n\n\n$this-\nbrowse(function ($first, $second) {\n    $first-\nloginAs(User::find(1))\n          -\nvisit(\n/home\n)\n          -\nwaitForText(\nMessage\n);\n\n    $second-\nloginAs(User::find(2))\n           -\nvisit(\n/home\n)\n           -\nwaitForText(\nMessage\n)\n           -\ntype(\nmessage\n, \nHey Taylor\n)\n           -\npress(\nSend\n);\n\n    $first-\nwaitForText(\nHey Taylor\n)\n          -\nassertSee(\nJeffrey Way\n);\n});\n\n\n\n\n\n\n\nAuthentication\n\n\nOften, you will be testing pages that require authentication. You can use Dusk's \nloginAs\n method in order to avoid interacting with the login screen during every test. The \nloginAs\n method accepts a user ID or user model instance:\n\n\n$this-\nbrowse(function ($first, $second) {\n    $first-\nloginAs(User::find(1))\n          -\nvisit(\n/home\n);\n});\n\n\n\n\n\n\n\nInteracting With Elements\n\n\n\n\nClicking Links\n\n\nTo click a link, you may use the \nclickLink\n method on the browser instance. The \nclickLink\n method will click the link that has the given display text:\n\n\n$browser-\nclickLink($linkText);\n\n\n\n\n\n\n\n{note} This method interacts with jQuery. If jQuery is not available on the page, Dusk will automatically inject it into the page so it is available for the test's duration.\n\n\n\n\n\n\nText, Values, \n Attributes\n\n\nRetrieving \n Setting Values\n\n\nDusk provides several methods for interacting with the current display text, value, and attributes of elements on the page. For example, to get the \"value\" of an element that matches a given selector, use the \nvalue\n method:\n\n\n// Retrieve the value...\n$value = $browser-\nvalue(\nselector\n);\n\n// Set the value...\n$browser-\nvalue(\nselector\n, \nvalue\n);\n\n\n\n\n\nRetrieving Text\n\n\nThe \ntext\n method may be used to retrieve the display text of an element that matches the given selector:\n\n\n$text = $browser-\ntext(\nselector\n);\n\n\n\n\n\nRetrieving Attributes\n\n\nFinally, the \nattribute\n method may be used to retrieve an attribute of an element matching the given selector:\n\n\n$attribute = $browser-\nattribute(\nselector\n, \nvalue\n);\n\n\n\n\n\n\n\nUsing Forms\n\n\nTyping Values\n\n\nDusk provides a variety of methods for interacting with forms and input elements. First, let's take a look at an example of typing text into an input field:\n\n\n$browser-\ntype(\nemail\n, \ntaylor@laravel.com\n);\n\n\n\n\n\nNote that, although the method accepts one if necessary, we are not required to pass a CSS selector into the \ntype\n method. If a CSS selector is not provided, Dusk will search for an input field with the given \nname\n attribute. Finally, Dusk will attempt to find a \ntextarea\n with the given \nname\n attribute.\n\n\nYou may \"clear\" the value of an input using the \nclear\n method:\n\n\n$browser-\nclear(\nemail\n);\n\n\n\n\n\nDropdowns\n\n\nTo select a value in a dropdown selection box, you may use the \nselect\n method. Like the \ntype\n method, the \nselect\n method does not require a full CSS selector. When passing a value to the \nselect\n method, you should pass the underlying option value instead of the display text:\n\n\n$browser-\nselect(\nsize\n, \nLarge\n);\n\n\n\n\n\nCheckboxes\n\n\nTo \"check\" a checkbox field, you may use the \ncheck\n method. Like many other input related methods, a full CSS selector is not required. If an exact selector match can't be found, Dusk will search for a checkbox with a matching \nname\n attribute:\n\n\n$browser-\ncheck(\nterms\n);\n\n$browser-\nuncheck(\nterms\n);\n\n\n\n\n\nRadio Buttons\n\n\nTo \"select\" a radio button option, you may use the \nradio\n method. Like many other input related methods, a full CSS selector is not required. If an exact selector match can't be found, Dusk will search for a radio with matching \nname\n and \nvalue\n attributes:\n\n\n$browser-\nradio(\nversion\n, \nphp7\n);\n\n\n\n\n\n\n\nAttaching Files\n\n\nThe \nattach\n method may be used to attach a file to a \nfile\n input element. Like many other input related methods, a full CSS selector is not required. If an exact selector match can't be found, Dusk will search for a file input with matching \nname\n attribute:\n\n\n$browser-\nattach(\nphoto\n, __DIR__.\n/photos/me.png\n);\n\n\n\n\n\n\n\nUsing The Keyboard\n\n\nThe \nkeys\n method allows you to provide more complex input sequences to a given element than normally allowed by the \ntype\n method. For example, you may hold modifier keys entering values. In this example, the \nshift\n key will be held while \ntaylor\n is entered into the element matching the given selector. After \ntaylor\n is typed, \notwell\n will be typed without any modifier keys:\n\n\n$browser-\nkeys(\nselector\n, [\n{shift}\n, \ntaylor\n], \notwell\n);\n\n\n\n\n\nYou may even send a \"hot key\" to the primary CSS selector that contains your application:\n\n\n$browser-\nkeys(\n.app\n, [\n{command}\n, \nj\n]);\n\n\n\n\n\n\n\n{tip} All modifier keys are wrapped in \n{}\n characters, and match the constants defined in the \nFacebook\\WebDriver\\WebDriverKeys\n class, which can be \nfound on GitHub\n.\n\n\n\n\n\n\nUsing The Mouse\n\n\nClicking On Elements\n\n\nThe \nclick\n method may be used to \"click\" on an element matching the given selector:\n\n\n$browser-\nclick(\n.selector\n);\n\n\n\n\n\nMouseover\n\n\nThe \nmouseover\n method may be used when you need to move the mouse over an element matching the given selector:\n\n\n$browser-\nmouseover(\n.selector\n);\n\n\n\n\n\nDrag \n Drop\n\n\nThe \ndrag\n method may be used to drag an element matching the given selector to another element:\n\n\n$browser-\ndrag(\n.from-selector\n, \n.to-selector\n);\n\n\n\n\n\n\n\nScoping Selectors\n\n\nSometimes you may wish to perform several operations while scoping all of the operations within a given selector. For example, you may wish to assert that some text exists only within a table and then click a button within that table. You may use the \nwith\n method to accomplish this. All operations performed within the callback given to the \nwith\n method will be scoped to the original selector:\n\n\n$browser-\nwith(\n.table\n, function ($table) {\n    $table-\nassertSee(\nHello World\n)\n          -\nclickLink(\nDelete\n);\n});\n\n\n\n\n\n\n\nWaiting For Elements\n\n\nWhen testing applications that use JavaScript extensively, it often becomes necessary to \"wait\" for certain elements or data to be available before proceeding with a test. Dusk makes this a cinch. Using a variety of methods, you may wait for elements to be visible on the page or even wait until a given JavaScript expression evaluates to \ntrue\n.\n\n\nWaiting\n\n\nIf you need to pause the test for a given number of milliseconds, use the \npause\n method:\n\n\n$browser-\npause(1000);\n\n\n\n\n\nWaiting For Selectors\n\n\nThe \nwaitFor\n method may be used to pause the execution of the test until the element matching the given CSS selector is displayed on the page. By default, this will pause the test for a maximum of five seconds before throwing an exception. If necessary, you may pass a custom timeout threshold as the second argument to the method:\n\n\n// Wait a maximum of five seconds for the selector...\n$browser-\nwaitFor(\n.selector\n);\n\n// Wait a maximum of one second for the selector...\n$browser-\nwaitFor(\n.selector\n, 1);\n\n\n\n\n\nYou may also wait until the given selector is missing from the page:\n\n\n$browser-\nwaitUntilMissing(\n.selector\n);\n\n$browser-\nwaitUntilMissing(\n.selector\n, 1);\n\n\n\n\n\nScoping Selectors When Available\n\n\nOccasionally, you may wish to wait for a given selector and then interact with the element matching the selector. For example, you may wish to wait until a modal window is available and then press the \"OK\" button within the modal. The \nwhenAvailable\n method may be used in this case. All element operations performed within the given callback will be scoped to the original selector:\n\n\n$browser-\nwhenAvailable(\n.modal\n, function ($modal) {\n    $modal-\nassertSee(\nHello World\n)\n          -\npress(\nOK\n);\n});\n\n\n\n\n\nWaiting For Text\n\n\nThe \nwaitForText\n method may be used to wait until the given text is displayed on the page:\n\n\n// Wait a maximum of five seconds for the text...\n$browser-\nwaitForText(\nHello World\n);\n\n// Wait a maximum of one second for the text...\n$browser-\nwaitForText(\nHello World\n, 1);\n\n\n\n\n\nWaiting For Links\n\n\nThe \nwaitForLink\n method may be used to wait until the given link text is displayed on the page:\n\n\n// Wait a maximum of five seconds for the link...\n$browser-\nwaitForLink(\nCreate\n);\n\n// Wait a maximum of one second for the link...\n$browser-\nwaitForLink(\nCreate\n, 1);\n\n\n\n\n\nWaiting On JavaScript Expressions\n\n\nSometimes you may wish to pause the execution of a test until a given JavaScript expression evaluates to \ntrue\n. You may easily accomplish this using the \nwaitUntil\n method. When passing an expression to this method, you do not need to include the \nreturn\n keyword or an ending semi-colon:\n\n\n// Wait a maximum of five seconds for the expression to be true...\n$browser-\nwaitUntil(\nApp.dataLoaded\n);\n\n$browser-\nwaitUntil(\nApp.data.servers.length \n 0\n);\n\n// Wait a maximum of one second for the expression to be true...\n$browser-\nwaitUntil(\nApp.data.servers.length \n 0\n, 1);\n\n\n\n\n\n\n\nAvailable Assertions\n\n\nDusk provides a variety of assertions that you may make against your application. All of the available assertions are documented in the table below:\n\n\n\n\n\n\n\n\nAssertion\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$browser-\nassertTitle($title)\n\n\nAssert the page title matches the given text.\n\n\n\n\n\n\n$browser-\nassertTitleContains($title)\n\n\nAssert the page title contains the given text.\n\n\n\n\n\n\n$browser-\nassertPathIs('/home')\n\n\nAssert the current path matches the given path.\n\n\n\n\n\n\n$browser-\nassertHasCookie($name)\n\n\nAssert the given cookie is present.\n\n\n\n\n\n\n$browser-\nassertCookieValue($name, $value)\n\n\nAssert a cookie has a given value.\n\n\n\n\n\n\n$browser-\nassertPlainCookieValue($name, $value)\n\n\nAssert an unencrypted cookie has a given value.\n\n\n\n\n\n\n$browser-\nassertSee($text)\n\n\nAssert the given text is present on the page.\n\n\n\n\n\n\n$browser-\nassertDontSee($text)\n\n\nAssert the given text is not present on the page.\n\n\n\n\n\n\n$browser-\nassertSeeIn($selector, $text)\n\n\nAssert the given text is present within the selector.\n\n\n\n\n\n\n$browser-\nassertDontSeeIn($selector, $text)\n\n\nAssert the given text is not present within the selector.\n\n\n\n\n\n\n$browser-\nassertSeeLink($linkText)\n\n\nAssert the given link is present on the page.\n\n\n\n\n\n\n$browser-\nassertDontSeeLink($linkText)\n\n\nAssert the given link is not present on the page.\n\n\n\n\n\n\n$browser-\nassertInputValue($field, $value)\n\n\nAssert the given input field has the given value.\n\n\n\n\n\n\n$browser-\nassertInputValueIsNot($field, $value)\n\n\nAssert the given input field does not have the given value.\n\n\n\n\n\n\n$browser-\nassertChecked($field)\n\n\nAssert the given checkbox is checked.\n\n\n\n\n\n\n$browser-\nassertNotChecked($field)\n\n\nAssert the given checkbox is not checked.\n\n\n\n\n\n\n$browser-\nassertSelected($field, $value)\n\n\nAssert the given dropdown has the given value selected.\n\n\n\n\n\n\n$browser-\nassertNotSelected($field, $value)\n\n\nAssert the given dropdown does not have the given value selected.\n\n\n\n\n\n\n$browser-\nassertValue($selector, $value)\n\n\nAssert the element matching the given selector has the given value.\n\n\n\n\n\n\n$browser-\nassertVisible($selector)\n\n\nAssert the element matching the given selector is visible.\n\n\n\n\n\n\n$browser-\nassertMissing($selector)\n\n\nAssert the element matching the given selector is not visible.\n\n\n\n\n\n\n\n\n\n\nPages\n\n\nSometimes, tests require several complicated actions to be performed in sequence. This can make your tests harder to read and understand. Pages allow you to define expressive actions that may then be performed on a given page using a single method. Pages also allow you to define short-cuts to common selectors for your application or a single page.\n\n\n\n\nGenerating Pages\n\n\nTo generate a page object, use the \ndusk:page\n Artisan command. All page objects will be placed in the \ntests/Browser/Pages\n directory:\n\n\nphp artisan dusk:page Login\n\n\n\n\n\n\n\nConfiguring Pages\n\n\nBy default, pages have three methods: \nurl\n, \nassert\n, and \nelements\n. We will discuss the \nurl\n and \nassert\n methods now. The \nelements\n method will be \ndiscussed in more detail below\n.\n\n\nThe \nurl\n Method\n\n\nThe \nurl\n method should return the path of the URL that represents the page. Dusk will use this URL when navigating to the page in the browser:\n\n\n/**\n\n\n * Get the URL for the page.\n\n\n *\n\n\n * @return string\n\n\n */\n\npublic\n \nfunction\n \nurl\n()\n\n\n{\n\n\n    \nreturn\n \n/login\n;\n\n\n}\n\n\n\n\n\n\nThe \nassert\n Method\n\n\nThe \nassert\n method may make any assertions necessary to verify that the browser is actually on the given page. Completing this method is not necessary; however, you are free to make these assertions if you wish. These assertions will be run automatically when navigating to the page:\n\n\n/**\n\n\n * Assert that the browser is on the page.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nassert\n(\nBrowser\n \n$\nbrowser\n)\n\n\n{\n\n\n    \n$\nbrowser\n-\nassertPathIs\n(\n$\nthis\n-\nurl\n())\n;\n\n\n}\n\n\n\n\n\n\n\n\nNavigating To Pages\n\n\nOnce a page has been configured, you may navigate to it using the \nvisit\n method:\n\n\nuse Tests\\Browser\\Pages\\Login;\n\n$browser-\nvisit(new Login);\n\n\n\n\n\nSometimes you may already be on a given page and need to \"load\" the page's selectors and methods into the current test context. This is common when pressing a button and being redirected to a given page without explicitly navigating to it. In this situation, you may use the \non\n method to load the page:\n\n\nuse Tests\\Browser\\Pages\\CreatePlaylist;\n\n$browser-\nvisit(\n/dashboard\n)\n        -\nclickLink(\nCreate Playlist\n)\n        -\non(new CreatePlaylist)\n        -\nassertSee(\n@create\n);\n\n\n\n\n\n\n\nShorthand Selectors\n\n\nThe \nelements\n method of pages allows you to define quick, easy-to-remember shortcuts for any CSS selector on your page. For example, let's define a shortcut for the \"email\" input field of the application's login page:\n\n\n/**\n\n\n * Get the element shortcuts for the page.\n\n\n *\n\n\n * @return array\n\n\n */\n\npublic\n \nfunction\n \nelements\n()\n\n\n{\n\n\n    \nreturn\n \n[\n\n\n        \n@email\n \n=\n \ninput[name=email]\n,\n\n\n    \n];\n\n\n}\n\n\n\n\n\n\nNow, you may use this shorthand selector anywhere you would use a full CSS selector:\n\n\n$browser-\ntype(\n@email\n, \ntaylor@laravel.com\n);\n\n\n\n\n\nGlobal Shorthand Selectors\n\n\nAfter installing Dusk, a base \nPage\n class will be placed in your \ntests/Browser/Pages\n directory. This class contains a \nsiteElements\n method which may be used to define global shorthand selectors that should be available on every page throughout your application:\n\n\n/**\n\n\n * Get the global element shortcuts for the site.\n\n\n *\n\n\n * @return array\n\n\n */\n\npublic\n \nstatic\n \nfunction\n \nsiteElements\n()\n\n\n{\n\n\n    \nreturn\n \n[\n\n\n        \n@element\n \n=\n \n#selector\n,\n\n\n    \n];\n\n\n}\n\n\n\n\n\n\n\n\nPage Methods\n\n\nIn addition to the default methods defined on pages, you may define additional methods which may be used throughout your tests. For example, let's imagine we are building a music management application. A common action for one page of the application might be to create a playlist. Instead of re-writing the logic to create a playlist in each test, you may define a \ncreatePlaylist\n method on a page class:\n\n\n?\nphp\n\n\n\nnamespace\n \nTests\n\\\nBrowser\n\\\nPages\n;\n\n\n\nuse\n \nLaravel\n\\\nDusk\n\\\nBrowser\n;\n\n\n\nclass\n \nDashboard\n \nextends\n \nPage\n\n\n{\n\n    \n// Other page methods...\n\n\n    \n/**\n\n\n     * Create a new playlist.\n\n\n     *\n\n\n     * @param  \\Laravel\\Dusk\\Browser  $browser\n\n\n     * @param  string  $name\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \ncreatePlaylist\n(\nBrowser\n \n$browser\n,\n \n$name\n)\n\n    \n{\n\n        \n$browser\n-\ntype\n(\nname\n,\n \n$name\n)\n\n                \n-\ncheck\n(\nshare\n)\n\n                \n-\npress\n(\nCreate Playlist\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOnce the method has been defined, you may use it within any test that utilizes the page. The browser instance will automatically be passed to the page method:\n\n\nuse Tests\\Browser\\Pages\\Dashboard;\n\n$browser-\nvisit(new Dashboard)\n        -\ncreatePlaylist(\nMy Playlist\n)\n        -\nassertSee(\nMy Playlist\n);", 
            "title": "Dusk"
        }, 
        {
            "location": "/dusk/#browser-tests-laravel-dusk", 
            "text": "Introduction  Installation  Using Other Browsers    Getting Started  Generating Tests  Running Tests  Environment Handling  Creating Browsers  Authentication    Interacting With Elements  Clicking Links  Text, Values,   Attributes  Using Forms  Attaching Files  Using The Keyboard  Using The Mouse  Scoping Selectors  Waiting For Elements    Available Assertions  Pages  Generating Pages  Configuring Pages  Navigating To Pages  Shorthand Selectors  Page Methods", 
            "title": "Browser Tests (Laravel Dusk)"
        }, 
        {
            "location": "/dusk/#introduction", 
            "text": "Laravel Dusk provides an expressive, easy-to-use browser automation and testing API. By default, Dusk does not require you to install JDK or Selenium on your machine. Instead, Dusk uses a standalone  ChromeDriver  installation. However, you are free to utilize any other Selenium compatible driver you wish.", 
            "title": "Introduction"
        }, 
        {
            "location": "/dusk/#installation", 
            "text": "To get started, you should add the  laravel/dusk  Composer dependency to your project:  composer require laravel/dusk  Once Dusk is installed, you should register the  Laravel\\Dusk\\DuskServiceProvider  service provider. You should register the provider within the  register  method of your  AppServiceProvider  in order to limit the environments in which Dusk is available, since it exposes the ability to login as other users:  use   Laravel \\ Dusk \\ DuskServiceProvider ;  /**   * Register any application services.   *   * @return void   */  public   function   register ()  { \n     if   ($this- app- environment( local ,   testing ))   { \n         $this- app- register( DuskServiceProvider : : class ); \n     }  }   Next, run the  dusk:install  Artisan command:  php artisan dusk:install  A  Browser  directory will be created within your  tests  directory and will contain an example test. Next, set the  APP_URL  environment variable in your  .env  file. This value should match the URL you use to access your application in a browser.  To run your tests, use the  dusk  Artisan command. The  dusk  command accepts any argument that is also accepted by the  phpunit  command:  php artisan dusk", 
            "title": "Installation"
        }, 
        {
            "location": "/dusk/#using-other-browsers", 
            "text": "By default, Dusk uses Google Chrome and a standalone  ChromeDriver  installation to run your browser tests. However, you may start your own Selenium server and run your tests against any browser you wish.  To get started, open your  tests/DuskTestCase.php  file, which is the base Dusk test case for your application. Within this file, you can remove the call to the  startChromeDriver  method. This will stop Dusk from automatically starting the ChromeDriver:  /**   * Prepare for Dusk test execution.   *   * @beforeClass   * @return void   */  public   static   function   prepare ()  { \n     //   static : : startChromeDriver ();  }   Next, you may simply modify the  driver  method to connect to the URL and port of your choice. In addition, you may modify the \"desired capabilities\" that should be passed to the WebDriver:  /**   * Create the RemoteWebDriver instance.   *   * @return \\Facebook\\WebDriver\\Remote\\RemoteWebDriver   */ \nprotected   function   driver ()  {       return   RemoteWebDriver : : create (           http://localhost:4444 ,   DesiredCapabilities : : phantomjs ()       ) ;  }", 
            "title": "Using Other Browsers"
        }, 
        {
            "location": "/dusk/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/dusk/#generating-tests", 
            "text": "To generate a Dusk test, use the  dusk:make  Artisan command. The generated test will be placed in the  tests/Browser  directory:  php artisan dusk:make LoginTest", 
            "title": "Generating Tests"
        }, 
        {
            "location": "/dusk/#running-tests", 
            "text": "To run your browser tests, use the  dusk  Artisan command:  php artisan dusk  The  dusk  command accepts any argument that is normally accepted by the PHPUnit test runner, allowing you to only run the tests for a given  group , etc:  php artisan dusk --group=foo", 
            "title": "Running Tests"
        }, 
        {
            "location": "/dusk/#manually-starting-chromedriver", 
            "text": "By default, Dusk will automatically attempt to start ChromeDriver. If this does not work for your particular system, you may manually start ChromeDriver before running the  dusk  command. If you choose to start ChromeDriver manually, you should comment out the following line of your  tests/DuskTestCase.php  file:  /**   * Prepare for Dusk test execution.   *   * @beforeClass   * @return void   */  public   static   function   prepare ()  { \n     //   static : : startChromeDriver ();  }   In addition, if you start ChromeDriver on a port other than 9515, you should modify the  driver  method of the same class:  /**   * Create the RemoteWebDriver instance.   *   * @return \\Facebook\\WebDriver\\Remote\\RemoteWebDriver   */ \nprotected   function   driver ()  {       return   RemoteWebDriver : : create (           http://localhost:9515 ,   DesiredCapabilities : : chrome ()       ) ;  }", 
            "title": "Manually Starting ChromeDriver"
        }, 
        {
            "location": "/dusk/#environment-handling", 
            "text": "To force Dusk to use its own environment file when running tests, create a  .env.dusk.{environment}  file in the root of your project. For example, if you will be initiating the  dusk  command from your  local  environment, you should create a  .env.dusk.local  file.  When running tests, Dusk will back-up your  .env  file and rename your Dusk environment to  .env . Once the tests have completed, your  .env  file will be restored.", 
            "title": "Environment Handling"
        }, 
        {
            "location": "/dusk/#creating-browsers", 
            "text": "To get started, let's write a test that verifies we can log into our application. After generating a test, we can modify it to navigate to the login page, enter some credentials, and click the \"Login\" button. To create a browser instance, call the  browse  method:  ? php  namespace   Tests \\ Browser ;  use   App \\ User ;  use   Tests \\ DuskTestCase ;  use   Laravel \\ Dusk \\ Chrome ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseMigrations ;  class   ExampleTest   extends   DuskTestCase  { \n     use   DatabaseMigrations ; \n\n     /**       * A basic browser test example.       *       * @return void       */ \n     public   function   testBasicExample () \n     { \n         $user   =   factory ( User :: class ) - create ([ \n             email   =   taylor@laravel.com , \n         ]); \n\n         $this - browse ( function   ( $browser )   use   ( $user )   { \n             $browser - visit ( /login ) \n                     - type ( email ,   $user - email ) \n                     - type ( password ,   secret ) \n                     - press ( Login ) \n                     - assertPathIs ( /home ); \n         }); \n     }  }   As you can see in the example above, the  browse  method accepts a callback. A browser instance will automatically be passed to this callback by Dusk and is the main object used to interact with and make assertions against your application.   {tip} This test can be used to test the login screen generated by the  make:auth  Artisan command.", 
            "title": "Creating Browsers"
        }, 
        {
            "location": "/dusk/#creating-multiple-browsers", 
            "text": "Sometimes you may need multiple browsers in order to properly carry out a test. For example, multiple browsers may be needed to test a chat screen that interacts with websockets. To create multiple browsers, simply \"ask\" for more than one browser in the signature of the callback given to the  browse  method:  $this- browse(function ($first, $second) {\n    $first- loginAs(User::find(1))\n          - visit( /home )\n          - waitForText( Message );\n\n    $second- loginAs(User::find(2))\n           - visit( /home )\n           - waitForText( Message )\n           - type( message ,  Hey Taylor )\n           - press( Send );\n\n    $first- waitForText( Hey Taylor )\n          - assertSee( Jeffrey Way );\n});", 
            "title": "Creating Multiple Browsers"
        }, 
        {
            "location": "/dusk/#authentication", 
            "text": "Often, you will be testing pages that require authentication. You can use Dusk's  loginAs  method in order to avoid interacting with the login screen during every test. The  loginAs  method accepts a user ID or user model instance:  $this- browse(function ($first, $second) {\n    $first- loginAs(User::find(1))\n          - visit( /home );\n});", 
            "title": "Authentication"
        }, 
        {
            "location": "/dusk/#interacting-with-elements", 
            "text": "", 
            "title": "Interacting With Elements"
        }, 
        {
            "location": "/dusk/#clicking-links", 
            "text": "To click a link, you may use the  clickLink  method on the browser instance. The  clickLink  method will click the link that has the given display text:  $browser- clickLink($linkText);   {note} This method interacts with jQuery. If jQuery is not available on the page, Dusk will automatically inject it into the page so it is available for the test's duration.", 
            "title": "Clicking Links"
        }, 
        {
            "location": "/dusk/#text-values-attributes", 
            "text": "", 
            "title": "Text, Values, &amp; Attributes"
        }, 
        {
            "location": "/dusk/#retrieving-setting-values", 
            "text": "Dusk provides several methods for interacting with the current display text, value, and attributes of elements on the page. For example, to get the \"value\" of an element that matches a given selector, use the  value  method:  // Retrieve the value...\n$value = $browser- value( selector );\n\n// Set the value...\n$browser- value( selector ,  value );", 
            "title": "Retrieving &amp; Setting Values"
        }, 
        {
            "location": "/dusk/#retrieving-text", 
            "text": "The  text  method may be used to retrieve the display text of an element that matches the given selector:  $text = $browser- text( selector );", 
            "title": "Retrieving Text"
        }, 
        {
            "location": "/dusk/#retrieving-attributes", 
            "text": "Finally, the  attribute  method may be used to retrieve an attribute of an element matching the given selector:  $attribute = $browser- attribute( selector ,  value );", 
            "title": "Retrieving Attributes"
        }, 
        {
            "location": "/dusk/#using-forms", 
            "text": "", 
            "title": "Using Forms"
        }, 
        {
            "location": "/dusk/#typing-values", 
            "text": "Dusk provides a variety of methods for interacting with forms and input elements. First, let's take a look at an example of typing text into an input field:  $browser- type( email ,  taylor@laravel.com );  Note that, although the method accepts one if necessary, we are not required to pass a CSS selector into the  type  method. If a CSS selector is not provided, Dusk will search for an input field with the given  name  attribute. Finally, Dusk will attempt to find a  textarea  with the given  name  attribute.  You may \"clear\" the value of an input using the  clear  method:  $browser- clear( email );", 
            "title": "Typing Values"
        }, 
        {
            "location": "/dusk/#dropdowns", 
            "text": "To select a value in a dropdown selection box, you may use the  select  method. Like the  type  method, the  select  method does not require a full CSS selector. When passing a value to the  select  method, you should pass the underlying option value instead of the display text:  $browser- select( size ,  Large );", 
            "title": "Dropdowns"
        }, 
        {
            "location": "/dusk/#checkboxes", 
            "text": "To \"check\" a checkbox field, you may use the  check  method. Like many other input related methods, a full CSS selector is not required. If an exact selector match can't be found, Dusk will search for a checkbox with a matching  name  attribute:  $browser- check( terms );\n\n$browser- uncheck( terms );", 
            "title": "Checkboxes"
        }, 
        {
            "location": "/dusk/#radio-buttons", 
            "text": "To \"select\" a radio button option, you may use the  radio  method. Like many other input related methods, a full CSS selector is not required. If an exact selector match can't be found, Dusk will search for a radio with matching  name  and  value  attributes:  $browser- radio( version ,  php7 );", 
            "title": "Radio Buttons"
        }, 
        {
            "location": "/dusk/#attaching-files", 
            "text": "The  attach  method may be used to attach a file to a  file  input element. Like many other input related methods, a full CSS selector is not required. If an exact selector match can't be found, Dusk will search for a file input with matching  name  attribute:  $browser- attach( photo , __DIR__. /photos/me.png );", 
            "title": "Attaching Files"
        }, 
        {
            "location": "/dusk/#using-the-keyboard", 
            "text": "The  keys  method allows you to provide more complex input sequences to a given element than normally allowed by the  type  method. For example, you may hold modifier keys entering values. In this example, the  shift  key will be held while  taylor  is entered into the element matching the given selector. After  taylor  is typed,  otwell  will be typed without any modifier keys:  $browser- keys( selector , [ {shift} ,  taylor ],  otwell );  You may even send a \"hot key\" to the primary CSS selector that contains your application:  $browser- keys( .app , [ {command} ,  j ]);   {tip} All modifier keys are wrapped in  {}  characters, and match the constants defined in the  Facebook\\WebDriver\\WebDriverKeys  class, which can be  found on GitHub .", 
            "title": "Using The Keyboard"
        }, 
        {
            "location": "/dusk/#using-the-mouse", 
            "text": "", 
            "title": "Using The Mouse"
        }, 
        {
            "location": "/dusk/#clicking-on-elements", 
            "text": "The  click  method may be used to \"click\" on an element matching the given selector:  $browser- click( .selector );", 
            "title": "Clicking On Elements"
        }, 
        {
            "location": "/dusk/#mouseover", 
            "text": "The  mouseover  method may be used when you need to move the mouse over an element matching the given selector:  $browser- mouseover( .selector );", 
            "title": "Mouseover"
        }, 
        {
            "location": "/dusk/#drag-drop", 
            "text": "The  drag  method may be used to drag an element matching the given selector to another element:  $browser- drag( .from-selector ,  .to-selector );", 
            "title": "Drag &amp; Drop"
        }, 
        {
            "location": "/dusk/#scoping-selectors", 
            "text": "Sometimes you may wish to perform several operations while scoping all of the operations within a given selector. For example, you may wish to assert that some text exists only within a table and then click a button within that table. You may use the  with  method to accomplish this. All operations performed within the callback given to the  with  method will be scoped to the original selector:  $browser- with( .table , function ($table) {\n    $table- assertSee( Hello World )\n          - clickLink( Delete );\n});", 
            "title": "Scoping Selectors"
        }, 
        {
            "location": "/dusk/#waiting-for-elements", 
            "text": "When testing applications that use JavaScript extensively, it often becomes necessary to \"wait\" for certain elements or data to be available before proceeding with a test. Dusk makes this a cinch. Using a variety of methods, you may wait for elements to be visible on the page or even wait until a given JavaScript expression evaluates to  true .", 
            "title": "Waiting For Elements"
        }, 
        {
            "location": "/dusk/#waiting", 
            "text": "If you need to pause the test for a given number of milliseconds, use the  pause  method:  $browser- pause(1000);", 
            "title": "Waiting"
        }, 
        {
            "location": "/dusk/#waiting-for-selectors", 
            "text": "The  waitFor  method may be used to pause the execution of the test until the element matching the given CSS selector is displayed on the page. By default, this will pause the test for a maximum of five seconds before throwing an exception. If necessary, you may pass a custom timeout threshold as the second argument to the method:  // Wait a maximum of five seconds for the selector...\n$browser- waitFor( .selector );\n\n// Wait a maximum of one second for the selector...\n$browser- waitFor( .selector , 1);  You may also wait until the given selector is missing from the page:  $browser- waitUntilMissing( .selector );\n\n$browser- waitUntilMissing( .selector , 1);", 
            "title": "Waiting For Selectors"
        }, 
        {
            "location": "/dusk/#scoping-selectors-when-available", 
            "text": "Occasionally, you may wish to wait for a given selector and then interact with the element matching the selector. For example, you may wish to wait until a modal window is available and then press the \"OK\" button within the modal. The  whenAvailable  method may be used in this case. All element operations performed within the given callback will be scoped to the original selector:  $browser- whenAvailable( .modal , function ($modal) {\n    $modal- assertSee( Hello World )\n          - press( OK );\n});", 
            "title": "Scoping Selectors When Available"
        }, 
        {
            "location": "/dusk/#waiting-for-text", 
            "text": "The  waitForText  method may be used to wait until the given text is displayed on the page:  // Wait a maximum of five seconds for the text...\n$browser- waitForText( Hello World );\n\n// Wait a maximum of one second for the text...\n$browser- waitForText( Hello World , 1);", 
            "title": "Waiting For Text"
        }, 
        {
            "location": "/dusk/#waiting-for-links", 
            "text": "The  waitForLink  method may be used to wait until the given link text is displayed on the page:  // Wait a maximum of five seconds for the link...\n$browser- waitForLink( Create );\n\n// Wait a maximum of one second for the link...\n$browser- waitForLink( Create , 1);", 
            "title": "Waiting For Links"
        }, 
        {
            "location": "/dusk/#waiting-on-javascript-expressions", 
            "text": "Sometimes you may wish to pause the execution of a test until a given JavaScript expression evaluates to  true . You may easily accomplish this using the  waitUntil  method. When passing an expression to this method, you do not need to include the  return  keyword or an ending semi-colon:  // Wait a maximum of five seconds for the expression to be true...\n$browser- waitUntil( App.dataLoaded );\n\n$browser- waitUntil( App.data.servers.length   0 );\n\n// Wait a maximum of one second for the expression to be true...\n$browser- waitUntil( App.data.servers.length   0 , 1);", 
            "title": "Waiting On JavaScript Expressions"
        }, 
        {
            "location": "/dusk/#available-assertions", 
            "text": "Dusk provides a variety of assertions that you may make against your application. All of the available assertions are documented in the table below:     Assertion  Description      $browser- assertTitle($title)  Assert the page title matches the given text.    $browser- assertTitleContains($title)  Assert the page title contains the given text.    $browser- assertPathIs('/home')  Assert the current path matches the given path.    $browser- assertHasCookie($name)  Assert the given cookie is present.    $browser- assertCookieValue($name, $value)  Assert a cookie has a given value.    $browser- assertPlainCookieValue($name, $value)  Assert an unencrypted cookie has a given value.    $browser- assertSee($text)  Assert the given text is present on the page.    $browser- assertDontSee($text)  Assert the given text is not present on the page.    $browser- assertSeeIn($selector, $text)  Assert the given text is present within the selector.    $browser- assertDontSeeIn($selector, $text)  Assert the given text is not present within the selector.    $browser- assertSeeLink($linkText)  Assert the given link is present on the page.    $browser- assertDontSeeLink($linkText)  Assert the given link is not present on the page.    $browser- assertInputValue($field, $value)  Assert the given input field has the given value.    $browser- assertInputValueIsNot($field, $value)  Assert the given input field does not have the given value.    $browser- assertChecked($field)  Assert the given checkbox is checked.    $browser- assertNotChecked($field)  Assert the given checkbox is not checked.    $browser- assertSelected($field, $value)  Assert the given dropdown has the given value selected.    $browser- assertNotSelected($field, $value)  Assert the given dropdown does not have the given value selected.    $browser- assertValue($selector, $value)  Assert the element matching the given selector has the given value.    $browser- assertVisible($selector)  Assert the element matching the given selector is visible.    $browser- assertMissing($selector)  Assert the element matching the given selector is not visible.", 
            "title": "Available Assertions"
        }, 
        {
            "location": "/dusk/#pages", 
            "text": "Sometimes, tests require several complicated actions to be performed in sequence. This can make your tests harder to read and understand. Pages allow you to define expressive actions that may then be performed on a given page using a single method. Pages also allow you to define short-cuts to common selectors for your application or a single page.", 
            "title": "Pages"
        }, 
        {
            "location": "/dusk/#generating-pages", 
            "text": "To generate a page object, use the  dusk:page  Artisan command. All page objects will be placed in the  tests/Browser/Pages  directory:  php artisan dusk:page Login", 
            "title": "Generating Pages"
        }, 
        {
            "location": "/dusk/#configuring-pages", 
            "text": "By default, pages have three methods:  url ,  assert , and  elements . We will discuss the  url  and  assert  methods now. The  elements  method will be  discussed in more detail below .", 
            "title": "Configuring Pages"
        }, 
        {
            "location": "/dusk/#the-url-method", 
            "text": "The  url  method should return the path of the URL that represents the page. Dusk will use this URL when navigating to the page in the browser:  /**   * Get the URL for the page.   *   * @return string   */ \npublic   function   url ()  {       return   /login ;  }", 
            "title": "The url Method"
        }, 
        {
            "location": "/dusk/#the-assert-method", 
            "text": "The  assert  method may make any assertions necessary to verify that the browser is actually on the given page. Completing this method is not necessary; however, you are free to make these assertions if you wish. These assertions will be run automatically when navigating to the page:  /**   * Assert that the browser is on the page.   *   * @return void   */ \npublic   function   assert ( Browser   $ browser )  {       $ browser - assertPathIs ( $ this - url ()) ;  }", 
            "title": "The assert Method"
        }, 
        {
            "location": "/dusk/#navigating-to-pages", 
            "text": "Once a page has been configured, you may navigate to it using the  visit  method:  use Tests\\Browser\\Pages\\Login;\n\n$browser- visit(new Login);  Sometimes you may already be on a given page and need to \"load\" the page's selectors and methods into the current test context. This is common when pressing a button and being redirected to a given page without explicitly navigating to it. In this situation, you may use the  on  method to load the page:  use Tests\\Browser\\Pages\\CreatePlaylist;\n\n$browser- visit( /dashboard )\n        - clickLink( Create Playlist )\n        - on(new CreatePlaylist)\n        - assertSee( @create );", 
            "title": "Navigating To Pages"
        }, 
        {
            "location": "/dusk/#shorthand-selectors", 
            "text": "The  elements  method of pages allows you to define quick, easy-to-remember shortcuts for any CSS selector on your page. For example, let's define a shortcut for the \"email\" input field of the application's login page:  /**   * Get the element shortcuts for the page.   *   * @return array   */ \npublic   function   elements ()  {       return   [           @email   =   input[name=email] ,       ];  }   Now, you may use this shorthand selector anywhere you would use a full CSS selector:  $browser- type( @email ,  taylor@laravel.com );", 
            "title": "Shorthand Selectors"
        }, 
        {
            "location": "/dusk/#global-shorthand-selectors", 
            "text": "After installing Dusk, a base  Page  class will be placed in your  tests/Browser/Pages  directory. This class contains a  siteElements  method which may be used to define global shorthand selectors that should be available on every page throughout your application:  /**   * Get the global element shortcuts for the site.   *   * @return array   */ \npublic   static   function   siteElements ()  {       return   [           @element   =   #selector ,       ];  }", 
            "title": "Global Shorthand Selectors"
        }, 
        {
            "location": "/dusk/#page-methods", 
            "text": "In addition to the default methods defined on pages, you may define additional methods which may be used throughout your tests. For example, let's imagine we are building a music management application. A common action for one page of the application might be to create a playlist. Instead of re-writing the logic to create a playlist in each test, you may define a  createPlaylist  method on a page class:  ? php  namespace   Tests \\ Browser \\ Pages ;  use   Laravel \\ Dusk \\ Browser ;  class   Dashboard   extends   Page  { \n     // Other page methods... \n\n     /**       * Create a new playlist.       *       * @param  \\Laravel\\Dusk\\Browser  $browser       * @param  string  $name       * @return void       */ \n     public   function   createPlaylist ( Browser   $browser ,   $name ) \n     { \n         $browser - type ( name ,   $name ) \n                 - check ( share ) \n                 - press ( Create Playlist ); \n     }  }   Once the method has been defined, you may use it within any test that utilizes the page. The browser instance will automatically be passed to the page method:  use Tests\\Browser\\Pages\\Dashboard;\n\n$browser- visit(new Dashboard)\n        - createPlaylist( My Playlist )\n        - assertSee( My Playlist );", 
            "title": "Page Methods"
        }, 
        {
            "location": "/eloquent-collections/", 
            "text": "Eloquent: Collections\n\n\n\n\nIntroduction\n\n\nAvailable Methods\n\n\nCustom Collections\n\n\n\n\n\n\nIntroduction\n\n\nAll multi-result sets returned by Eloquent are instances of the \nIlluminate\\Database\\Eloquent\\Collection\n object, including results retrieved via the \nget\n method or accessed via a relationship. The Eloquent collection object extends the Laravel \nbase collection\n, so it naturally inherits dozens of methods used to fluently work with the underlying array of Eloquent models.\n\n\nOf course, all collections also serve as iterators, allowing you to loop over them as if they were simple PHP arrays:\n\n\n$\nusers\n \n=\n \nApp\n\\\nUser\n::\nwhere\n(\nactive\n,\n \n1\n)\n-\nget\n();\n\n\n\nforeach\n \n($\nusers\n \nas\n \n$\nuser\n)\n \n{\n\n    \necho\n \n$user-\nname\n;\n\n\n}\n\n\n\n\n\n\nHowever, collections are much more powerful than arrays and expose a variety of map / reduce operations that may be chained using an intuitive interface. For example, let's remove all inactive models and gather the first name for each remaining user:\n\n\n$\nusers\n \n=\n \nApp\n\\\nUser\n::\nwhere\n(\nactive\n,\n \n1\n)\n-\nget\n();\n\n\n\n$\nnames\n \n=\n \n$\nusers-\nreject\n(\nfunction\n \n($\nuser\n)\n \n{\n\n    \nreturn\n \n$user-\nactive\n \n===\n \nfalse\n;\n\n\n}\n)\n\n\n-\nmap\n(\nfunction\n \n($\nuser\n)\n \n{\n\n    \nreturn\n \n$user-\nname\n;\n\n\n}\n);\n\n\n\n\n\n\n\n\n{note} While most Eloquent collection methods return a new instance of an Eloquent collection, the \npluck\n, \nkeys\n, \nzip\n, \ncollapse\n, \nflatten\n and \nflip\n methods return a \nbase collection\n instance. Likewise, if a \nmap\n operation returns a collection that does not contain any Eloquent models, it will be automatically cast to a base collection.\n\n\n\n\n\n\nAvailable Methods\n\n\nThe Base Collection\n\n\nAll Eloquent collections extend the base \nLaravel collection\n object; therefore, they inherit all of the powerful methods provided by the base collection class:\n\n\n\n    #collection-method-list > p {\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    #collection-method-list a {\n        display: block;\n    }\n\n\n\n\n\n\n[all](/docs/{{version}}/collections#method-all)\n[avg](/docs/{{version}}/collections#method-avg)\n[chunk](/docs/{{version}}/collections#method-chunk)\n[collapse](/docs/{{version}}/collections#method-collapse)\n[combine](/docs/{{version}}/collections#method-combine)\n[contains](/docs/{{version}}/collections#method-contains)\n[count](/docs/{{version}}/collections#method-count)\n[diff](/docs/{{version}}/collections#method-diff)\n[diffKeys](/docs/{{version}}/collections#method-diffkeys)\n[each](/docs/{{version}}/collections#method-each)\n[every](/docs/{{version}}/collections#method-every)\n[except](/docs/{{version}}/collections#method-except)\n[filter](/docs/{{version}}/collections#method-filter)\n[first](/docs/{{version}}/collections#method-first)\n[flatMap](/docs/{{version}}/collections#method-flatmap)\n[flatten](/docs/{{version}}/collections#method-flatten)\n[flip](/docs/{{version}}/collections#method-flip)\n[forget](/docs/{{version}}/collections#method-forget)\n[forPage](/docs/{{version}}/collections#method-forpage)\n[get](/docs/{{version}}/collections#method-get)\n[groupBy](/docs/{{version}}/collections#method-groupby)\n[has](/docs/{{version}}/collections#method-has)\n[implode](/docs/{{version}}/collections#method-implode)\n[intersect](/docs/{{version}}/collections#method-intersect)\n[isEmpty](/docs/{{version}}/collections#method-isempty)\n[keyBy](/docs/{{version}}/collections#method-keyby)\n[keys](/docs/{{version}}/collections#method-keys)\n[last](/docs/{{version}}/collections#method-last)\n[map](/docs/{{version}}/collections#method-map)\n[max](/docs/{{version}}/collections#method-max)\n[merge](/docs/{{version}}/collections#method-merge)\n[min](/docs/{{version}}/collections#method-min)\n[only](/docs/{{version}}/collections#method-only)\n[pluck](/docs/{{version}}/collections#method-pluck)\n[pop](/docs/{{version}}/collections#method-pop)\n[prepend](/docs/{{version}}/collections#method-prepend)\n[pull](/docs/{{version}}/collections#method-pull)\n[push](/docs/{{version}}/collections#method-push)\n[put](/docs/{{version}}/collections#method-put)\n[random](/docs/{{version}}/collections#method-random)\n[reduce](/docs/{{version}}/collections#method-reduce)\n[reject](/docs/{{version}}/collections#method-reject)\n[reverse](/docs/{{version}}/collections#method-reverse)\n[search](/docs/{{version}}/collections#method-search)\n[shift](/docs/{{version}}/collections#method-shift)\n[shuffle](/docs/{{version}}/collections#method-shuffle)\n[slice](/docs/{{version}}/collections#method-slice)\n[sort](/docs/{{version}}/collections#method-sort)\n[sortBy](/docs/{{version}}/collections#method-sortby)\n[sortByDesc](/docs/{{version}}/collections#method-sortbydesc)\n[splice](/docs/{{version}}/collections#method-splice)\n[sum](/docs/{{version}}/collections#method-sum)\n[take](/docs/{{version}}/collections#method-take)\n[toArray](/docs/{{version}}/collections#method-toarray)\n[toJson](/docs/{{version}}/collections#method-tojson)\n[transform](/docs/{{version}}/collections#method-transform)\n[union](/docs/{{version}}/collections#method-union)\n[unique](/docs/{{version}}/collections#method-unique)\n[values](/docs/{{version}}/collections#method-values)\n[where](/docs/{{version}}/collections#method-where)\n[whereStrict](/docs/{{version}}/collections#method-wherestrict)\n[whereIn](/docs/{{version}}/collections#method-wherein)\n[whereInLoose](/docs/{{version}}/collections#method-whereinloose)\n[zip](/docs/{{version}}/collections#method-zip)\n\n\n\n\n\n\n\nCustom Collections\n\n\nIf you need to use a custom \nCollection\n object with your own extension methods, you may override the \nnewCollection\n method on your model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nApp\n\\\nCustomCollection\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Create a new Eloquent Collection instance.\n\n\n     *\n\n\n     * @param  array  $models\n\n\n     * @return \\Illuminate\\Database\\Eloquent\\Collection\n\n\n     */\n\n    \npublic\n \nfunction\n \nnewCollection\n(\narray\n \n$models\n \n=\n \n[])\n\n    \n{\n\n        \nreturn\n \nnew\n \nCustomCollection\n(\n$models\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOnce you have defined a \nnewCollection\n method, you will receive an instance of your custom collection anytime Eloquent returns a \nCollection\n instance of that model. If you would like to use a custom collection for every model in your application, you should override the \nnewCollection\n method on a base model class that is extended by all of your models.", 
            "title": "Eloquent collections"
        }, 
        {
            "location": "/eloquent-collections/#eloquent-collections", 
            "text": "Introduction  Available Methods  Custom Collections", 
            "title": "Eloquent: Collections"
        }, 
        {
            "location": "/eloquent-collections/#introduction", 
            "text": "All multi-result sets returned by Eloquent are instances of the  Illuminate\\Database\\Eloquent\\Collection  object, including results retrieved via the  get  method or accessed via a relationship. The Eloquent collection object extends the Laravel  base collection , so it naturally inherits dozens of methods used to fluently work with the underlying array of Eloquent models.  Of course, all collections also serve as iterators, allowing you to loop over them as if they were simple PHP arrays:  $ users   =   App \\ User :: where ( active ,   1 ) - get ();  foreach   ($ users   as   $ user )   { \n     echo   $user- name ;  }   However, collections are much more powerful than arrays and expose a variety of map / reduce operations that may be chained using an intuitive interface. For example, let's remove all inactive models and gather the first name for each remaining user:  $ users   =   App \\ User :: where ( active ,   1 ) - get ();  $ names   =   $ users- reject ( function   ($ user )   { \n     return   $user- active   ===   false ;  } )  - map ( function   ($ user )   { \n     return   $user- name ;  } );    {note} While most Eloquent collection methods return a new instance of an Eloquent collection, the  pluck ,  keys ,  zip ,  collapse ,  flatten  and  flip  methods return a  base collection  instance. Likewise, if a  map  operation returns a collection that does not contain any Eloquent models, it will be automatically cast to a base collection.", 
            "title": "Introduction"
        }, 
        {
            "location": "/eloquent-collections/#available-methods", 
            "text": "", 
            "title": "Available Methods"
        }, 
        {
            "location": "/eloquent-collections/#the-base-collection", 
            "text": "All Eloquent collections extend the base  Laravel collection  object; therefore, they inherit all of the powerful methods provided by the base collection class:  \n    #collection-method-list > p {\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    #collection-method-list a {\n        display: block;\n    }  \n\n[all](/docs/{{version}}/collections#method-all)\n[avg](/docs/{{version}}/collections#method-avg)\n[chunk](/docs/{{version}}/collections#method-chunk)\n[collapse](/docs/{{version}}/collections#method-collapse)\n[combine](/docs/{{version}}/collections#method-combine)\n[contains](/docs/{{version}}/collections#method-contains)\n[count](/docs/{{version}}/collections#method-count)\n[diff](/docs/{{version}}/collections#method-diff)\n[diffKeys](/docs/{{version}}/collections#method-diffkeys)\n[each](/docs/{{version}}/collections#method-each)\n[every](/docs/{{version}}/collections#method-every)\n[except](/docs/{{version}}/collections#method-except)\n[filter](/docs/{{version}}/collections#method-filter)\n[first](/docs/{{version}}/collections#method-first)\n[flatMap](/docs/{{version}}/collections#method-flatmap)\n[flatten](/docs/{{version}}/collections#method-flatten)\n[flip](/docs/{{version}}/collections#method-flip)\n[forget](/docs/{{version}}/collections#method-forget)\n[forPage](/docs/{{version}}/collections#method-forpage)\n[get](/docs/{{version}}/collections#method-get)\n[groupBy](/docs/{{version}}/collections#method-groupby)\n[has](/docs/{{version}}/collections#method-has)\n[implode](/docs/{{version}}/collections#method-implode)\n[intersect](/docs/{{version}}/collections#method-intersect)\n[isEmpty](/docs/{{version}}/collections#method-isempty)\n[keyBy](/docs/{{version}}/collections#method-keyby)\n[keys](/docs/{{version}}/collections#method-keys)\n[last](/docs/{{version}}/collections#method-last)\n[map](/docs/{{version}}/collections#method-map)\n[max](/docs/{{version}}/collections#method-max)\n[merge](/docs/{{version}}/collections#method-merge)\n[min](/docs/{{version}}/collections#method-min)\n[only](/docs/{{version}}/collections#method-only)\n[pluck](/docs/{{version}}/collections#method-pluck)\n[pop](/docs/{{version}}/collections#method-pop)\n[prepend](/docs/{{version}}/collections#method-prepend)\n[pull](/docs/{{version}}/collections#method-pull)\n[push](/docs/{{version}}/collections#method-push)\n[put](/docs/{{version}}/collections#method-put)\n[random](/docs/{{version}}/collections#method-random)\n[reduce](/docs/{{version}}/collections#method-reduce)\n[reject](/docs/{{version}}/collections#method-reject)\n[reverse](/docs/{{version}}/collections#method-reverse)\n[search](/docs/{{version}}/collections#method-search)\n[shift](/docs/{{version}}/collections#method-shift)\n[shuffle](/docs/{{version}}/collections#method-shuffle)\n[slice](/docs/{{version}}/collections#method-slice)\n[sort](/docs/{{version}}/collections#method-sort)\n[sortBy](/docs/{{version}}/collections#method-sortby)\n[sortByDesc](/docs/{{version}}/collections#method-sortbydesc)\n[splice](/docs/{{version}}/collections#method-splice)\n[sum](/docs/{{version}}/collections#method-sum)\n[take](/docs/{{version}}/collections#method-take)\n[toArray](/docs/{{version}}/collections#method-toarray)\n[toJson](/docs/{{version}}/collections#method-tojson)\n[transform](/docs/{{version}}/collections#method-transform)\n[union](/docs/{{version}}/collections#method-union)\n[unique](/docs/{{version}}/collections#method-unique)\n[values](/docs/{{version}}/collections#method-values)\n[where](/docs/{{version}}/collections#method-where)\n[whereStrict](/docs/{{version}}/collections#method-wherestrict)\n[whereIn](/docs/{{version}}/collections#method-wherein)\n[whereInLoose](/docs/{{version}}/collections#method-whereinloose)\n[zip](/docs/{{version}}/collections#method-zip)", 
            "title": "The Base Collection"
        }, 
        {
            "location": "/eloquent-collections/#custom-collections", 
            "text": "If you need to use a custom  Collection  object with your own extension methods, you may override the  newCollection  method on your model:  ? php  namespace   App ;  use   App \\ CustomCollection ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * Create a new Eloquent Collection instance.       *       * @param  array  $models       * @return \\Illuminate\\Database\\Eloquent\\Collection       */ \n     public   function   newCollection ( array   $models   =   []) \n     { \n         return   new   CustomCollection ( $models ); \n     }  }   Once you have defined a  newCollection  method, you will receive an instance of your custom collection anytime Eloquent returns a  Collection  instance of that model. If you would like to use a custom collection for every model in your application, you should override the  newCollection  method on a base model class that is extended by all of your models.", 
            "title": "Custom Collections"
        }, 
        {
            "location": "/eloquent-mutators/", 
            "text": "Eloquent: Mutators\n\n\n\n\nIntroduction\n\n\nAccessors \n Mutators\n\n\nDefining An Accessor\n\n\nDefining A Mutator\n\n\n\n\n\n\nDate Mutators\n\n\nAttribute Casting\n\n\nArray \n JSON Casting\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nAccessors and mutators allow you to format Eloquent attribute values when you retrieve or set them on model instances. For example, you may want to use the \nLaravel encrypter\n to encrypt a value while it is stored in the database, and then automatically decrypt the attribute when you access it on an Eloquent model.\n\n\nIn addition to custom accessors and mutators, Eloquent can also automatically cast date fields to \nCarbon\n instances or even \ncast text fields to JSON\n.\n\n\n\n\nAccessors \n Mutators\n\n\n\n\nDefining An Accessor\n\n\nTo define an accessor, create a \ngetFooAttribute\n method on your model where \nFoo\n is the \"studly\" cased name of the column you wish to access. In this example, we'll define an accessor for the \nfirst_name\n attribute. The accessor will automatically be called by Eloquent when attempting to retrieve the value of the \nfirst_name\n attribute:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get the user\ns first name.\n\n\n     *\n\n\n     * @param  string  $value\n\n\n     * @return string\n\n\n     */\n\n    \npublic\n \nfunction\n \ngetFirstNameAttribute\n(\n$value\n)\n\n    \n{\n\n        \nreturn\n \nucfirst\n(\n$value\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAs you can see, the original value of the column is passed to the accessor, allowing you to manipulate and return the value. To access the value of the accessor, you may simply access the \nfirst_name\n attribute on a model instance:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nfirstName\n \n=\n \n$\nuser-\nfirst_name\n;\n\n\n\n\n\n\n\n\nDefining A Mutator\n\n\nTo define a mutator, define a \nsetFooAttribute\n method on your model where \nFoo\n is the \"studly\" cased name of the column you wish to access. So, again, let's define a mutator for the \nfirst_name\n attribute. This mutator will be automatically called when we attempt to set the value of the \nfirst_name\n attribute on the model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Set the user\ns first name.\n\n\n     *\n\n\n     * @param  string  $value\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nsetFirstNameAttribute\n(\n$value\n)\n\n    \n{\n\n        \n$this\n-\nattributes\n[\nfirst_name\n]\n \n=\n \nstrtolower\n(\n$value\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe mutator will receive the value that is being set on the attribute, allowing you to manipulate the value and set the manipulated value on the Eloquent model's internal \n$attributes\n property. So, for example, if we attempt to set the \nfirst_name\n attribute to \nSally\n:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nuser-\nfirst_name\n \n=\n \nSally\n;\n\n\n\n\n\n\nIn this example, the \nsetFirstNameAttribute\n function will be called with the value \nSally\n. The mutator will then apply the \nstrtolower\n function to the name and set its resulting value in the internal \n$attributes\n array.\n\n\n\n\nDate Mutators\n\n\nBy default, Eloquent will convert the \ncreated_at\n and \nupdated_at\n columns to instances of \nCarbon\n, which extends the PHP \nDateTime\n class to provide an assortment of helpful methods. You may customize which dates are automatically mutated, and even completely disable this mutation, by overriding the \n$dates\n property of your model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The attributes that should be mutated to dates.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$dates\n \n=\n \n[\n\n        \ncreated_at\n,\n\n        \nupdated_at\n,\n\n        \ndeleted_at\n\n    \n];\n\n\n}\n\n\n\n\n\n\nWhen a column is considered a date, you may set its value to a UNIX timestamp, date string (\nY-m-d\n), date-time string, and of course a \nDateTime\n / \nCarbon\n instance, and the date's value will automatically be correctly stored in your database:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nuser-\ndeleted_at\n \n=\n \nCarbon\n::\nnow\n();\n\n\n\n$\nuser-\nsave\n();\n\n\n\n\n\n\nAs noted above, when retrieving attributes that are listed in your \n$dates\n property, they will automatically be cast to \nCarbon\n instances, allowing you to use any of Carbon's methods on your attributes:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\nreturn\n \n$\nuser-\ndeleted_at-\ngetTimestamp\n();\n\n\n\n\n\n\nDate Formats\n\n\nBy default, timestamps are formatted as \n'Y-m-d H:i:s'\n. If you need to customize the timestamp format, set the \n$dateFormat\n property on your model. This property determines how date attributes are stored in the database, as well as their format when the model is serialized to an array or JSON:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nFlight\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The storage format of the model\ns date columns.\n\n\n     *\n\n\n     * @var string\n\n\n     */\n\n    \nprotected\n \n$dateFormat\n \n=\n \nU\n;\n\n\n}\n\n\n\n\n\n\n\n\nAttribute Casting\n\n\nThe \n$casts\n property on your model provides a convenient method of converting attributes to common data types. The \n$casts\n property should be an array where the key is the name of the attribute being cast and the value is the type you wish to cast the column to. The supported cast types are: \ninteger\n, \nreal\n, \nfloat\n, \ndouble\n, \nstring\n, \nboolean\n, \nobject\n, \narray\n, \ncollection\n, \ndate\n, \ndatetime\n, and \ntimestamp\n.\n\n\nFor example, let's cast the \nis_admin\n attribute, which is stored in our database as an integer (\n0\n or \n1\n) to a boolean value:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The attributes that should be casted to native types.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$casts\n \n=\n \n[\n\n        \nis_admin\n \n=\n \nboolean\n,\n\n    \n];\n\n\n}\n\n\n\n\n\n\nNow the \nis_admin\n attribute will always be cast to a boolean when you access it, even if the underlying value is stored in the database as an integer:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\nif\n \n($\nuser-\nis_admin\n)\n \n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\n\n\nArray \n JSON Casting\n\n\nThe \narray\n cast type is particularly useful when working with columns that are stored as serialized JSON. For example, if your database has a \nJSON\n or \nTEXT\n field type that contains serialized JSON, adding the \narray\n cast to that attribute will automatically deserialize the attribute to a PHP array when you access it on your Eloquent model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The attributes that should be casted to native types.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$casts\n \n=\n \n[\n\n        \noptions\n \n=\n \narray\n,\n\n    \n];\n\n\n}\n\n\n\n\n\n\nOnce the cast is defined, you may access the \noptions\n attribute and it will automatically be deserialized from JSON into a PHP array. When you set the value of the \noptions\n attribute, the given array will automatically be serialized back into JSON for storage:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\n$\noptions\n \n=\n \n$\nuser-\noptions\n;\n\n\n\n$\noptions\n[\nkey\n]\n \n=\n \nvalue\n;\n\n\n\n$\nuser-\noptions\n \n=\n \n$\noptions\n;\n\n\n\n$\nuser-\nsave\n();", 
            "title": "Eloquent mutators"
        }, 
        {
            "location": "/eloquent-mutators/#eloquent-mutators", 
            "text": "Introduction  Accessors   Mutators  Defining An Accessor  Defining A Mutator    Date Mutators  Attribute Casting  Array   JSON Casting", 
            "title": "Eloquent: Mutators"
        }, 
        {
            "location": "/eloquent-mutators/#introduction", 
            "text": "Accessors and mutators allow you to format Eloquent attribute values when you retrieve or set them on model instances. For example, you may want to use the  Laravel encrypter  to encrypt a value while it is stored in the database, and then automatically decrypt the attribute when you access it on an Eloquent model.  In addition to custom accessors and mutators, Eloquent can also automatically cast date fields to  Carbon  instances or even  cast text fields to JSON .", 
            "title": "Introduction"
        }, 
        {
            "location": "/eloquent-mutators/#accessors-mutators", 
            "text": "", 
            "title": "Accessors &amp; Mutators"
        }, 
        {
            "location": "/eloquent-mutators/#defining-an-accessor", 
            "text": "To define an accessor, create a  getFooAttribute  method on your model where  Foo  is the \"studly\" cased name of the column you wish to access. In this example, we'll define an accessor for the  first_name  attribute. The accessor will automatically be called by Eloquent when attempting to retrieve the value of the  first_name  attribute:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * Get the user s first name.       *       * @param  string  $value       * @return string       */ \n     public   function   getFirstNameAttribute ( $value ) \n     { \n         return   ucfirst ( $value ); \n     }  }   As you can see, the original value of the column is passed to the accessor, allowing you to manipulate and return the value. To access the value of the accessor, you may simply access the  first_name  attribute on a model instance:  $ user   =   App \\ User :: find ( 1 );  $ firstName   =   $ user- first_name ;", 
            "title": "Defining An Accessor"
        }, 
        {
            "location": "/eloquent-mutators/#defining-a-mutator", 
            "text": "To define a mutator, define a  setFooAttribute  method on your model where  Foo  is the \"studly\" cased name of the column you wish to access. So, again, let's define a mutator for the  first_name  attribute. This mutator will be automatically called when we attempt to set the value of the  first_name  attribute on the model:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * Set the user s first name.       *       * @param  string  $value       * @return void       */ \n     public   function   setFirstNameAttribute ( $value ) \n     { \n         $this - attributes [ first_name ]   =   strtolower ( $value ); \n     }  }   The mutator will receive the value that is being set on the attribute, allowing you to manipulate the value and set the manipulated value on the Eloquent model's internal  $attributes  property. So, for example, if we attempt to set the  first_name  attribute to  Sally :  $ user   =   App \\ User :: find ( 1 );  $ user- first_name   =   Sally ;   In this example, the  setFirstNameAttribute  function will be called with the value  Sally . The mutator will then apply the  strtolower  function to the name and set its resulting value in the internal  $attributes  array.", 
            "title": "Defining A Mutator"
        }, 
        {
            "location": "/eloquent-mutators/#date-mutators", 
            "text": "By default, Eloquent will convert the  created_at  and  updated_at  columns to instances of  Carbon , which extends the PHP  DateTime  class to provide an assortment of helpful methods. You may customize which dates are automatically mutated, and even completely disable this mutation, by overriding the  $dates  property of your model:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * The attributes that should be mutated to dates.       *       * @var array       */ \n     protected   $dates   =   [ \n         created_at , \n         updated_at , \n         deleted_at \n     ];  }   When a column is considered a date, you may set its value to a UNIX timestamp, date string ( Y-m-d ), date-time string, and of course a  DateTime  /  Carbon  instance, and the date's value will automatically be correctly stored in your database:  $ user   =   App \\ User :: find ( 1 );  $ user- deleted_at   =   Carbon :: now ();  $ user- save ();   As noted above, when retrieving attributes that are listed in your  $dates  property, they will automatically be cast to  Carbon  instances, allowing you to use any of Carbon's methods on your attributes:  $ user   =   App \\ User :: find ( 1 );  return   $ user- deleted_at- getTimestamp ();", 
            "title": "Date Mutators"
        }, 
        {
            "location": "/eloquent-mutators/#date-formats", 
            "text": "By default, timestamps are formatted as  'Y-m-d H:i:s' . If you need to customize the timestamp format, set the  $dateFormat  property on your model. This property determines how date attributes are stored in the database, as well as their format when the model is serialized to an array or JSON:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Flight   extends   Model  { \n     /**       * The storage format of the model s date columns.       *       * @var string       */ \n     protected   $dateFormat   =   U ;  }", 
            "title": "Date Formats"
        }, 
        {
            "location": "/eloquent-mutators/#attribute-casting", 
            "text": "The  $casts  property on your model provides a convenient method of converting attributes to common data types. The  $casts  property should be an array where the key is the name of the attribute being cast and the value is the type you wish to cast the column to. The supported cast types are:  integer ,  real ,  float ,  double ,  string ,  boolean ,  object ,  array ,  collection ,  date ,  datetime , and  timestamp .  For example, let's cast the  is_admin  attribute, which is stored in our database as an integer ( 0  or  1 ) to a boolean value:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * The attributes that should be casted to native types.       *       * @var array       */ \n     protected   $casts   =   [ \n         is_admin   =   boolean , \n     ];  }   Now the  is_admin  attribute will always be cast to a boolean when you access it, even if the underlying value is stored in the database as an integer:  $ user   =   App \\ User :: find ( 1 );  if   ($ user- is_admin )   { \n     //  }", 
            "title": "Attribute Casting"
        }, 
        {
            "location": "/eloquent-mutators/#array-json-casting", 
            "text": "The  array  cast type is particularly useful when working with columns that are stored as serialized JSON. For example, if your database has a  JSON  or  TEXT  field type that contains serialized JSON, adding the  array  cast to that attribute will automatically deserialize the attribute to a PHP array when you access it on your Eloquent model:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * The attributes that should be casted to native types.       *       * @var array       */ \n     protected   $casts   =   [ \n         options   =   array , \n     ];  }   Once the cast is defined, you may access the  options  attribute and it will automatically be deserialized from JSON into a PHP array. When you set the value of the  options  attribute, the given array will automatically be serialized back into JSON for storage:  $ user   =   App \\ User :: find ( 1 );  $ options   =   $ user- options ;  $ options [ key ]   =   value ;  $ user- options   =   $ options ;  $ user- save ();", 
            "title": "Array &amp; JSON Casting"
        }, 
        {
            "location": "/eloquent-relationships/", 
            "text": "Eloquent: Relationships\n\n\n\n\nIntroduction\n\n\nDefining Relationships\n\n\nOne To One\n\n\nOne To Many\n\n\nOne To Many (Inverse)\n\n\nMany To Many\n\n\nHas Many Through\n\n\nPolymorphic Relations\n\n\nMany To Many Polymorphic Relations\n\n\n\n\n\n\nQuerying Relations\n\n\nRelationship Methods Vs. Dynamic Properties\n\n\nQuerying Relationship Existence\n\n\nQuerying Relationship Absence\n\n\nCounting Related Models\n\n\n\n\n\n\nEager Loading\n\n\nConstraining Eager Loads\n\n\nLazy Eager Loading\n\n\n\n\n\n\nInserting \n Updating Related Models\n\n\nThe \nsave\n Method\n\n\nThe \ncreate\n Method\n\n\nBelongs To Relationships\n\n\nMany To Many Relationships\n\n\n\n\n\n\nTouching Parent Timestamps\n\n\n\n\n\n\nIntroduction\n\n\nDatabase tables are often related to one another. For example, a blog post may have many comments, or an order could be related to the user who placed it. Eloquent makes managing and working with these relationships easy, and supports several different types of relationships:\n\n\n\n\nOne To One\n\n\nOne To Many\n\n\nMany To Many\n\n\nHas Many Through\n\n\nPolymorphic Relations\n\n\nMany To Many Polymorphic Relations\n\n\n\n\n\n\nDefining Relationships\n\n\nEloquent relationships are defined as methods on your Eloquent model classes. Since, like Eloquent models themselves, relationships also serve as powerful \nquery builders\n, defining relationships as methods provides powerful method chaining and querying capabilities. For example, we may chain additional constraints on this \nposts\n relationship:\n\n\n$user-\nposts()-\nwhere(\nactive\n, 1)-\nget();\n\n\n\n\n\nBut, before diving too deep into using relationships, let's learn how to define each type.\n\n\n\n\nOne To One\n\n\nA one-to-one relationship is a very basic relation. For example, a \nUser\n model might be associated with one \nPhone\n. To define this relationship, we place a \nphone\n method on the \nUser\n model. The \nphone\n method should call the \nhasOne\n method and return its result:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get the phone record associated with the user.\n\n\n     */\n\n    \npublic\n \nfunction\n \nphone\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nhasOne\n(\nApp\\Phone\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe first argument passed to the \nhasOne\n method is the name of the related model. Once the relationship is defined, we may retrieve the related record using Eloquent's dynamic properties. Dynamic properties allow you to access relationship methods as if they were properties defined on the model:\n\n\n$\nphone\n \n=\n \nUser\n::\nfind\n(\n1\n)\n-\nphone\n;\n\n\n\n\n\n\nEloquent determines the foreign key of the relationship based on the model name. In this case, the \nPhone\n model is automatically assumed to have a \nuser_id\n foreign key. If you wish to override this convention, you may pass a second argument to the \nhasOne\n method:\n\n\nreturn $this-\nhasOne(\nApp\\Phone\n, \nforeign_key\n);\n\n\n\n\n\nAdditionally, Eloquent assumes that the foreign key should have a value matching the \nid\n (or the custom \n$primaryKey\n) column of the parent. In other words, Eloquent will look for the value of the user's \nid\n column in the \nuser_id\n column of the \nPhone\n record. If you would like the relationship to use a value other than \nid\n, you may pass a third argument to the \nhasOne\n method specifying your custom key:\n\n\nreturn $this-\nhasOne(\nApp\\Phone\n, \nforeign_key\n, \nlocal_key\n);\n\n\n\n\n\nDefining The Inverse Of The Relationship\n\n\nSo, we can access the \nPhone\n model from our \nUser\n. Now, let's define a relationship on the \nPhone\n model that will let us access the \nUser\n that owns the phone. We can define the inverse of a \nhasOne\n relationship using the \nbelongsTo\n method:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nPhone\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get the user that owns the phone.\n\n\n     */\n\n    \npublic\n \nfunction\n \nuser\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nbelongsTo\n(\nApp\\User\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIn the example above, Eloquent will try to match the \nuser_id\n from the \nPhone\n model to an \nid\n on the \nUser\n model. Eloquent determines the default foreign key name by examining the name of the relationship method and suffixing the method name with \n_id\n. However, if the foreign key on the \nPhone\n model is not \nuser_id\n, you may pass a custom key name as the second argument to the \nbelongsTo\n method:\n\n\n/**\n\n\n * Get the user that owns the phone.\n\n\n */\n\npublic\n \nfunction\n \nuser\n()\n\n\n{\n\n\n    \nreturn\n \n$\nthis\n-\nbelongsTo\n(\nApp\\User\n,\n \nforeign_key\n)\n;\n\n\n}\n\n\n\n\n\n\nIf your parent model does not use \nid\n as its primary key, or you wish to join the child model to a different column, you may pass a third argument to the \nbelongsTo\n method specifying your parent table's custom key:\n\n\n/**\n\n\n * Get the user that owns the phone.\n\n\n */\n\npublic\n \nfunction\n \nuser\n()\n\n\n{\n\n\n    \nreturn\n \n$\nthis\n-\nbelongsTo\n(\nApp\\User\n,\n \nforeign_key\n,\n \nother_key\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nOne To Many\n\n\nA \"one-to-many\" relationship is used to define relationships where a single model owns any amount of other models. For example, a blog post may have an infinite number of comments. Like all other Eloquent relationships, one-to-many relationships are defined by placing a function on your Eloquent model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nPost\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get the comments for the blog post.\n\n\n     */\n\n    \npublic\n \nfunction\n \ncomments\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nhasMany\n(\nApp\\Comment\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRemember, Eloquent will automatically determine the proper foreign key column on the \nComment\n model. By convention, Eloquent will take the \"snake case\" name of the owning model and suffix it with \n_id\n. So, for this example, Eloquent will assume the foreign key on the \nComment\n model is \npost_id\n.\n\n\nOnce the relationship has been defined, we can access the collection of comments by accessing the \ncomments\n property. Remember, since Eloquent provides \"dynamic properties\", we can access relationship methods as if they were defined as properties on the model:\n\n\n$\ncomments\n \n=\n \nApp\n\\\nPost\n::\nfind\n(\n1\n)\n-\ncomments\n;\n\n\n\nforeach\n \n($\ncomments\n \nas\n \n$\ncomment\n)\n \n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\nOf course, since all relationships also serve as query builders, you can add further constraints to which comments are retrieved by calling the \ncomments\n method and continuing to chain conditions onto the query:\n\n\n$\ncomments\n \n=\n \nApp\n\\\nPost\n::\nfind\n(\n1\n)\n-\ncomments\n()\n-\nwhere\n(\ntitle\n,\n \nfoo\n)\n-\nfirst\n();\n\n\n\n\n\n\nLike the \nhasOne\n method, you may also override the foreign and local keys by passing additional arguments to the \nhasMany\n method:\n\n\nreturn $this-\nhasMany(\nApp\\Comment\n, \nforeign_key\n);\n\nreturn $this-\nhasMany(\nApp\\Comment\n, \nforeign_key\n, \nlocal_key\n);\n\n\n\n\n\n\n\nOne To Many (Inverse)\n\n\nNow that we can access all of a post's comments, let's define a relationship to allow a comment to access its parent post. To define the inverse of a \nhasMany\n relationship, define a relationship function on the child model which calls the \nbelongsTo\n method:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nComment\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get the post that owns the comment.\n\n\n     */\n\n    \npublic\n \nfunction\n \npost\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nbelongsTo\n(\nApp\\Post\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOnce the relationship has been defined, we can retrieve the \nPost\n model for a \nComment\n by accessing the \npost\n \"dynamic property\":\n\n\n$\ncomment\n \n=\n \nApp\n\\\nComment\n::\nfind\n(\n1\n);\n\n\n\necho\n \n$\ncomment-\npost-\ntitle\n;\n\n\n\n\n\n\nIn the example above, Eloquent will try to match the \npost_id\n from the \nComment\n model to an \nid\n on the \nPost\n model. Eloquent determines the default foreign key name by examining the name of the relationship method and suffixing the method name with \n_id\n. However, if the foreign key on the \nComment\n model is not \npost_id\n, you may pass a custom key name as the second argument to the \nbelongsTo\n method:\n\n\n/**\n\n\n * Get the post that owns the comment.\n\n\n */\n\npublic\n \nfunction\n \npost\n()\n\n\n{\n\n\n    \nreturn\n \n$\nthis\n-\nbelongsTo\n(\nApp\\Post\n,\n \nforeign_key\n)\n;\n\n\n}\n\n\n\n\n\n\nIf your parent model does not use \nid\n as its primary key, or you wish to join the child model to a different column, you may pass a third argument to the \nbelongsTo\n method specifying your parent table's custom key:\n\n\n/**\n\n\n * Get the post that owns the comment.\n\n\n */\n\npublic\n \nfunction\n \npost\n()\n\n\n{\n\n\n    \nreturn\n \n$\nthis\n-\nbelongsTo\n(\nApp\\Post\n,\n \nforeign_key\n,\n \nother_key\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nMany To Many\n\n\nMany-to-many relations are slightly more complicated than \nhasOne\n and \nhasMany\n relationships. An example of such a relationship is a user with many roles, where the roles are also shared by other users. For example, many users may have the role of \"Admin\". To define this relationship, three database tables are needed: \nusers\n, \nroles\n, and \nrole_user\n. The \nrole_user\n table is derived from the alphabetical order of the related model names, and contains the \nuser_id\n and \nrole_id\n columns.\n\n\nMany-to-many relationships are defined by writing a method that returns the result of the \nbelongsToMany\n method. For example, let's define the \nroles\n method on our \nUser\n model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The roles that belong to the user.\n\n\n     */\n\n    \npublic\n \nfunction\n \nroles\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nbelongsToMany\n(\nApp\\Role\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOnce the relationship is defined, you may access the user's roles using the \nroles\n dynamic property:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\nforeach\n \n($\nuser-\nroles\n \nas\n \n$\nrole\n)\n \n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\nOf course, like all other relationship types, you may call the \nroles\n method to continue chaining query constraints onto the relationship:\n\n\n$\nroles\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n)\n-\nroles\n()\n-\norderBy\n(\nname\n)\n-\nget\n();\n\n\n\n\n\n\nAs mentioned previously, to determine the table name of the relationship's joining table, Eloquent will join the two related model names in alphabetical order. However, you are free to override this convention. You may do so by passing a second argument to the \nbelongsToMany\n method:\n\n\nreturn $this-\nbelongsToMany(\nApp\\Role\n, \nrole_user\n);\n\n\n\n\n\nIn addition to customizing the name of the joining table, you may also customize the column names of the keys on the table by passing additional arguments to the \nbelongsToMany\n method. The third argument is the foreign key name of the model on which you are defining the relationship, while the fourth argument is the foreign key name of the model that you are joining to:\n\n\nreturn $this-\nbelongsToMany(\nApp\\Role\n, \nrole_user\n, \nuser_id\n, \nrole_id\n);\n\n\n\n\n\nDefining The Inverse Of The Relationship\n\n\nTo define the inverse of a many-to-many relationship, you simply place another call to \nbelongsToMany\n on your related model. To continue our user roles example, let's define the \nusers\n method on the \nRole\n model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nRole\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The users that belong to the role.\n\n\n     */\n\n    \npublic\n \nfunction\n \nusers\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nbelongsToMany\n(\nApp\\User\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAs you can see, the relationship is defined exactly the same as its \nUser\n counterpart, with the exception of simply referencing the \nApp\\User\n model. Since we're reusing the \nbelongsToMany\n method, all of the usual table and key customization options are available when defining the inverse of many-to-many relationships.\n\n\nRetrieving Intermediate Table Columns\n\n\nAs you have already learned, working with many-to-many relations requires the presence of an intermediate table. Eloquent provides some very helpful ways of interacting with this table. For example, let's assume our \nUser\n object has many \nRole\n objects that it is related to. After accessing this relationship, we may access the intermediate table using the \npivot\n attribute on the models:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\nforeach\n \n($\nuser-\nroles\n \nas\n \n$\nrole\n)\n \n{\n\n    \necho\n \n$role-\npivot-\ncreated_at\n;\n\n\n}\n\n\n\n\n\n\nNotice that each \nRole\n model we retrieve is automatically assigned a \npivot\n attribute. This attribute contains a model representing the intermediate table, and may be used like any other Eloquent model.\n\n\nBy default, only the model keys will be present on the \npivot\n object. If your pivot table contains extra attributes, you must specify them when defining the relationship:\n\n\nreturn $this-\nbelongsToMany(\nApp\\Role\n)-\nwithPivot(\ncolumn1\n, \ncolumn2\n);\n\n\n\n\n\nIf you want your pivot table to have automatically maintained \ncreated_at\n and \nupdated_at\n timestamps, use the \nwithTimestamps\n method on the relationship definition:\n\n\nreturn $this-\nbelongsToMany(\nApp\\Role\n)-\nwithTimestamps();\n\n\n\n\n\nFiltering Relationships Via Intermediate Table Columns\n\n\nYou can also filter the results returned by \nbelongsToMany\n using the \nwherePivot\n and \nwherePivotIn\n methods when defining the relationship:\n\n\nreturn $this-\nbelongsToMany(\nApp\\Role\n)-\nwherePivot(\napproved\n, 1);\n\nreturn $this-\nbelongsToMany(\nApp\\Role\n)-\nwherePivotIn(\npriority\n, [1, 2]);\n\n\n\n\n\nDefining Custom Intermediate Table Models\n\n\nIf you would like to define a custom model to represent the intermediate table of your relationship, you may call the \nusing\n method when defining the relationship. All custom models used to represent intermediate tables of relationships must extend the \nIlluminate\\Database\\Eloquent\\Relations\\Pivot\n class:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nRole\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The users that belong to the role.\n\n\n     */\n\n    \npublic\n \nfunction\n \nusers\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nbelongsToMany\n(\nApp\\User\n)\n-\nusing\n(\nApp\\UserRole\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nHas Many Through\n\n\nThe \"has-many-through\" relationship provides a convenient shortcut for accessing distant relations via an intermediate relation. For example, a \nCountry\n model might have many \nPost\n models through an intermediate \nUser\n model. In this example, you could easily gather all blog posts for a given country. Let's look at the tables required to define this relationship:\n\n\ncountries\n    id - integer\n    name - string\n\nusers\n    id - integer\n    country_id - integer\n    name - string\n\nposts\n    id - integer\n    user_id - integer\n    title - string\n\n\n\n\n\nThough \nposts\n does not contain a \ncountry_id\n column, the \nhasManyThrough\n relation provides access to a country's posts via \n$country-\nposts\n. To perform this query, Eloquent inspects the \ncountry_id\n on the intermediate \nusers\n table. After finding the matching user IDs, they are used to query the \nposts\n table.\n\n\nNow that we have examined the table structure for the relationship, let's define it on the \nCountry\n model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nCountry\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get all of the posts for the country.\n\n\n     */\n\n    \npublic\n \nfunction\n \nposts\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nhasManyThrough\n(\nApp\\Post\n,\n \nApp\\User\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe first argument passed to the \nhasManyThrough\n method is the name of the final model we wish to access, while the second argument is the name of the intermediate model.\n\n\nTypical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the \nhasManyThrough\n method. The third argument is the name of the foreign key on the intermediate model, the fourth argument is the name of the foreign key on the final model, and the fifth argument is the local key:\n\n\nclass\n \nCountry\n \nextends\n \nModel\n\n\n{\n\n    \npublic\n \nfunction\n \nposts\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nhasManyThrough\n(\n\n            \nApp\\Post\n,\n \nApp\\User\n,\n\n            \ncountry_id\n,\n \nuser_id\n,\n \nid\n\n        \n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nPolymorphic Relations\n\n\nTable Structure\n\n\nPolymorphic relations allow a model to belong to more than one other model on a single association. For example, imagine users of your application can \"comment\" both posts and videos. Using polymorphic relationships, you can use a single \ncomments\n table for both of these scenarios. First, let's examine the table structure required to build this relationship:\n\n\nposts\n    id - integer\n    title - string\n    body - text\n\nvideos\n    id - integer\n    title - string\n    url - string\n\ncomments\n    id - integer\n    body - text\n    commentable_id - integer\n    commentable_type - string\n\n\n\n\n\nTwo important columns to note are the \ncommentable_id\n and \ncommentable_type\n columns on the \ncomments\n table. The \ncommentable_id\n column will contain the ID value of the post or video, while the \ncommentable_type\n column will contain the class name of the owning model. The \ncommentable_type\n column is how the ORM determines which \"type\" of owning model to return when accessing the \ncommentable\n relation.\n\n\nModel Structure\n\n\nNext, let's examine the model definitions needed to build this relationship:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nComment\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get all of the owning commentable models.\n\n\n     */\n\n    \npublic\n \nfunction\n \ncommentable\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nmorphTo\n();\n\n    \n}\n\n\n}\n\n\n\nclass\n \nPost\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get all of the post\ns comments.\n\n\n     */\n\n    \npublic\n \nfunction\n \ncomments\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nmorphMany\n(\nApp\\Comment\n,\n \ncommentable\n);\n\n    \n}\n\n\n}\n\n\n\nclass\n \nVideo\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get all of the video\ns comments.\n\n\n     */\n\n    \npublic\n \nfunction\n \ncomments\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nmorphMany\n(\nApp\\Comment\n,\n \ncommentable\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRetrieving Polymorphic Relations\n\n\nOnce your database table and models are defined, you may access the relationships via your models. For example, to access all of the comments for a post, we can simply use the \ncomments\n dynamic property:\n\n\n$\npost\n \n=\n \nApp\n\\\nPost\n::\nfind\n(\n1\n);\n\n\n\nforeach\n \n($\npost-\ncomments\n \nas\n \n$\ncomment\n)\n \n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\nYou may also retrieve the owner of a polymorphic relation from the polymorphic model by accessing the name of the method that performs the call to \nmorphTo\n. In our case, that is the \ncommentable\n method on the \nComment\n model. So, we will access that method as a dynamic property:\n\n\n$\ncomment\n \n=\n \nApp\n\\\nComment\n::\nfind\n(\n1\n);\n\n\n\n$\ncommentable\n \n=\n \n$\ncomment-\ncommentable\n;\n\n\n\n\n\n\nThe \ncommentable\n relation on the \nComment\n model will return either a \nPost\n or \nVideo\n instance, depending on which type of model owns the comment.\n\n\nCustom Polymorphic Types\n\n\nBy default, Laravel will use the fully qualified class name to store the type of the related model. For instance, given the example above where a \nComment\n may belong to a \nPost\n or a \nVideo\n, the default \ncommentable_type\n would be either \nApp\\Post\n or \nApp\\Video\n, respectively. However, you may wish to decouple your database from your application's internal structure. In that case, you may define a relationship \"morph map\" to instruct Eloquent to use a custom name for each model instead of the class name:\n\n\nuse Illuminate\\Database\\Eloquent\\Relations\\Relation;\n\nRelation::morphMap([\n    \nposts\n =\n \nApp\\Post\n,\n    \nvideos\n =\n \nApp\\Video\n,\n]);\n\n\n\n\n\nYou may register the \nmorphMap\n in the \nboot\n function of your \nAppServiceProvider\n or create a separate service provider if you wish.\n\n\n\n\nMany To Many Polymorphic Relations\n\n\nTable Structure\n\n\nIn addition to traditional polymorphic relations, you may also define \"many-to-many\" polymorphic relations. For example, a blog \nPost\n and \nVideo\n model could share a polymorphic relation to a \nTag\n model. Using a many-to-many polymorphic relation allows you to have a single list of unique tags that are shared across blog posts and videos. First, let's examine the table structure:\n\n\nposts\n    id - integer\n    name - string\n\nvideos\n    id - integer\n    name - string\n\ntags\n    id - integer\n    name - string\n\ntaggables\n    tag_id - integer\n    taggable_id - integer\n    taggable_type - string\n\n\n\n\n\nModel Structure\n\n\nNext, we're ready to define the relationships on the model. The \nPost\n and \nVideo\n models will both have a \ntags\n method that calls the \nmorphToMany\n method on the base Eloquent class:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nPost\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get all of the tags for the post.\n\n\n     */\n\n    \npublic\n \nfunction\n \ntags\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nmorphToMany\n(\nApp\\Tag\n,\n \ntaggable\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDefining The Inverse Of The Relationship\n\n\nNext, on the \nTag\n model, you should define a method for each of its related models. So, for this example, we will define a \nposts\n method and a \nvideos\n method:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nTag\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get all of the posts that are assigned this tag.\n\n\n     */\n\n    \npublic\n \nfunction\n \nposts\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nmorphedByMany\n(\nApp\\Post\n,\n \ntaggable\n);\n\n    \n}\n\n\n    \n/**\n\n\n     * Get all of the videos that are assigned this tag.\n\n\n     */\n\n    \npublic\n \nfunction\n \nvideos\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nmorphedByMany\n(\nApp\\Video\n,\n \ntaggable\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRetrieving The Relationship\n\n\nOnce your database table and models are defined, you may access the relationships via your models. For example, to access all of the tags for a post, you can simply use the \ntags\n dynamic property:\n\n\n$\npost\n \n=\n \nApp\n\\\nPost\n::\nfind\n(\n1\n);\n\n\n\nforeach\n \n($\npost-\ntags\n \nas\n \n$\ntag\n)\n \n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\nYou may also retrieve the owner of a polymorphic relation from the polymorphic model by accessing the name of the method that performs the call to \nmorphedByMany\n. In our case, that is the \nposts\n or \nvideos\n methods on the \nTag\n model. So, you will access those methods as dynamic properties:\n\n\n$\ntag\n \n=\n \nApp\n\\\nTag\n::\nfind\n(\n1\n);\n\n\n\nforeach\n \n($\ntag-\nvideos\n \nas\n \n$\nvideo\n)\n \n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\n\n\nQuerying Relations\n\n\nSince all types of Eloquent relationships are defined via methods, you may call those methods to obtain an instance of the relationship without actually executing the relationship queries. In addition, all types of Eloquent relationships also serve as \nquery builders\n, allowing you to continue to chain constraints onto the relationship query before finally executing the SQL against your database.\n\n\nFor example, imagine a blog system in which a \nUser\n model has many associated \nPost\n models:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get all of the posts for the user.\n\n\n     */\n\n    \npublic\n \nfunction\n \nposts\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nhasMany\n(\nApp\\Post\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou may query the \nposts\n relationship and add additional constraints to the relationship like so:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nuser-\nposts\n()\n-\nwhere\n(\nactive\n,\n \n1\n)\n-\nget\n();\n\n\n\n\n\n\nYou are able to use any of the \nquery builder\n methods on the relationship, so be sure to explore the query builder documentation to learn about all of the methods that are available to you.\n\n\n\n\nRelationship Methods Vs. Dynamic Properties\n\n\nIf you do not need to add additional constraints to an Eloquent relationship query, you may simply access the relationship as if it were a property. For example, continuing to use our \nUser\n and \nPost\n example models, we may access all of a user's posts like so:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\nforeach\n \n($\nuser-\nposts\n \nas\n \n$\npost\n)\n \n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\nDynamic properties are \"lazy loading\", meaning they will only load their relationship data when you actually access them. Because of this, developers often use \neager loading\n to pre-load relationships they know will be accessed after loading the model. Eager loading provides a significant reduction in SQL queries that must be executed to load a model's relations.\n\n\n\n\nQuerying Relationship Existence\n\n\nWhen accessing the records for a model, you may wish to limit your results based on the existence of a relationship. For example, imagine you want to retrieve all blog posts that have at least one comment. To do so, you may pass the name of the relationship to the \nhas\n method:\n\n\n//\n \nRetrieve\n \nall\n \nposts\n \nthat\n \nhave\n \nat\n \nleast\n \none\n \ncomment\n...\n\n\n$\nposts\n \n=\n \nApp\n\\\nPost\n::\nhas\n(\ncomments\n)\n-\nget\n();\n\n\n\n\n\n\nYou may also specify an operator and count to further customize the query:\n\n\n//\n \nRetrieve\n \nall\n \nposts\n \nthat\n \nhave\n \nthree\n \nor\n \nmore\n \ncomments\n...\n\n\n$\nposts\n \n=\n \nPost\n::\nhas\n(\ncomments\n,\n \n=\n,\n \n3\n)\n-\nget\n();\n\n\n\n\n\n\nNested \nhas\n statements may also be constructed using \"dot\" notation. For example, you may retrieve all posts that have at least one comment and vote:\n\n\n//\n \nRetrieve\n \nall\n \nposts\n \nthat\n \nhave\n \nat\n \nleast\n \none\n \ncomment\n \nwith\n \nvotes\n...\n\n\n$\nposts\n \n=\n \nPost\n::\nhas\n(\ncomments.votes\n)\n-\nget\n();\n\n\n\n\n\n\nIf you need even more power, you may use the \nwhereHas\n and \norWhereHas\n methods to put \"where\" conditions on your \nhas\n queries. These methods allow you to add customized constraints to a relationship constraint, such as checking the content of a comment:\n\n\n// Retrieve all posts with at least one comment containing words like foo%\n$posts = Post::whereHas(\ncomments\n, function ($query) {\n    $query-\nwhere(\ncontent\n, \nlike\n, \nfoo%\n);\n})-\nget();\n\n\n\n\n\n\n\nQuerying Relationship Absence\n\n\nWhen accessing the records for a model, you may wish to limit your results based on the absence of a relationship. For example, imagine you want to retrieve all blog posts that \ndon't\n have any comments. To do so, you may pass the name of the relationship to the \ndoesntHave\n method:\n\n\n$\nposts\n \n=\n \nApp\n\\\nPost\n::\ndoesntHave\n(\ncomments\n)\n-\nget\n();\n\n\n\n\n\n\nIf you need even more power, you may use the \nwhereDoesntHave\n method to put \"where\" conditions on your \ndoesntHave\n queries. This method allows you to add customized constraints to a relationship constraint, such as checking the content of a comment:\n\n\n$posts = Post::whereDoesntHave(\ncomments\n, function ($query) {\n    $query-\nwhere(\ncontent\n, \nlike\n, \nfoo%\n);\n})-\nget();\n\n\n\n\n\n\n\nCounting Related Models\n\n\nIf you want to count the number of results from a relationship without actually loading them you may use the \nwithCount\n method, which will place a \n{relation}_count\n column on your resulting models. For example:\n\n\n$\nposts\n \n=\n \nApp\n\\\nPost\n::\nwithCount\n(\ncomments\n)\n-\nget\n();\n\n\n\nforeach\n \n($\nposts\n \nas\n \n$\npost\n)\n \n{\n\n    \necho\n \n$post-\ncomments_count\n;\n\n\n}\n\n\n\n\n\n\nYou may add the \"counts\" for multiple relations as well as add constraints to the queries:\n\n\n$posts = Post::withCount([\nvotes\n, \ncomments\n =\n function ($query) {\n    $query-\nwhere(\ncontent\n, \nlike\n, \nfoo%\n);\n}])-\nget();\n\necho $posts[0]-\nvotes_count;\necho $posts[0]-\ncomments_count;\n\n\n\n\n\n\n\nEager Loading\n\n\nWhen accessing Eloquent relationships as properties, the relationship data is \"lazy loaded\". This means the relationship data is not actually loaded until you first access the property. However, Eloquent can \"eager load\" relationships at the time you query the parent model. Eager loading alleviates the N + 1 query problem. To illustrate the N + 1 query problem, consider a \nBook\n model that is related to \nAuthor\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nBook\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get the author that wrote the book.\n\n\n     */\n\n    \npublic\n \nfunction\n \nauthor\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nbelongsTo\n(\nApp\\Author\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow, let's retrieve all books and their authors:\n\n\n$\nbooks\n \n=\n \nApp\n\\\nBook\n::\nall\n();\n\n\n\nforeach\n \n($\nbooks\n \nas\n \n$\nbook\n)\n \n{\n\n    \necho\n \n$book-\nauthor-\nname\n;\n\n\n}\n\n\n\n\n\n\nThis loop will execute 1 query to retrieve all of the books on the table, then another query for each book to retrieve the author. So, if we have 25 books, this loop would run 26 queries: 1 for the original book, and 25 additional queries to retrieve the author of each book.\n\n\nThankfully, we can use eager loading to reduce this operation to just 2 queries. When querying, you may specify which relationships should be eager loaded using the \nwith\n method:\n\n\n$\nbooks\n \n=\n \nApp\n\\\nBook\n::\nwith\n(\nauthor\n)\n-\nget\n();\n\n\n\nforeach\n \n($\nbooks\n \nas\n \n$\nbook\n)\n \n{\n\n    \necho\n \n$book-\nauthor-\nname\n;\n\n\n}\n\n\n\n\n\n\nFor this operation, only two queries will be executed:\n\n\nselect * from books\n\nselect * from authors where id in (1, 2, 3, 4, 5, ...)\n\n\n\n\n\nEager Loading Multiple Relationships\n\n\nSometimes you may need to eager load several different relationships in a single operation. To do so, just pass additional arguments to the \nwith\n method:\n\n\n$\nbooks\n \n=\n \nApp\n\\\nBook\n::\nwith\n(\nauthor\n,\n \npublisher\n)\n-\nget\n();\n\n\n\n\n\n\nNested Eager Loading\n\n\nTo eager load nested relationships, you may use \"dot\" syntax. For example, let's eager load all of the book's authors and all of the author's personal contacts in one Eloquent statement:\n\n\n$\nbooks\n \n=\n \nApp\n\\\nBook\n::\nwith\n(\nauthor.contacts\n)\n-\nget\n();\n\n\n\n\n\n\n\n\nConstraining Eager Loads\n\n\nSometimes you may wish to eager load a relationship, but also specify additional query constraints for the eager loading query. Here's an example:\n\n\n$users = App\\User::with([\nposts\n =\n function ($query) {\n    $query-\nwhere(\ntitle\n, \nlike\n, \n%first%\n);\n}])-\nget();\n\n\n\n\n\nIn this example, Eloquent will only eager load posts where the post's \ntitle\n column contains the word \nfirst\n. Of course, you may call other \nquery builder\n methods to further customize the eager loading operation:\n\n\n$users = App\\User::with([\nposts\n =\n function ($query) {\n    $query-\norderBy(\ncreated_at\n, \ndesc\n);\n}])-\nget();\n\n\n\n\n\n\n\nLazy Eager Loading\n\n\nSometimes you may need to eager load a relationship after the parent model has already been retrieved. For example, this may be useful if you need to dynamically decide whether to load related models:\n\n\n$\nbooks\n \n=\n \nApp\n\\\nBook\n::\nall\n();\n\n\n\nif\n \n($\nsomeCondition\n)\n \n{\n\n    \n$books-\nload(\nauthor\n,\n \npublisher\n)\n;\n\n\n}\n\n\n\n\n\n\nIf you need to set additional query constraints on the eager loading query, you may pass an array keyed by the relationships you wish to load. The array values should be \nClosure\n instances which receive the query instance:\n\n\n$books-\nload([\nauthor\n =\n function ($query) {\n    $query-\norderBy(\npublished_date\n, \nasc\n);\n}]);\n\n\n\n\n\n\n\nInserting \n Updating Related Models\n\n\n\n\nThe Save Method\n\n\nEloquent provides convenient methods for adding new models to relationships. For example, perhaps you need to insert a new \nComment\n for a \nPost\n model. Instead of manually setting the \npost_id\n attribute on the \nComment\n, you may insert the \nComment\n directly from the relationship's \nsave\n method:\n\n\n$\ncomment\n \n=\n \nnew\n \nApp\n\\\nComment\n(\n[\nmessage\n \n=\n \nA new comment.\n]\n);\n\n\n\n$\npost\n \n=\n \nApp\n\\\nPost\n::\nfind\n(\n1\n);\n\n\n\n$\npost-\ncomments\n()\n-\nsave\n($\ncomment\n);\n\n\n\n\n\n\nNotice that we did not access the \ncomments\n relationship as a dynamic property. Instead, we called the \ncomments\n method to obtain an instance of the relationship. The \nsave\n method will automatically add the appropriate \npost_id\n value to the new \nComment\n model.\n\n\nIf you need to save multiple related models, you may use the \nsaveMany\n method:\n\n\n$\npost\n \n=\n \nApp\n\\\nPost\n::\nfind\n(\n1\n);\n\n\n\n$\npost-\ncomments\n()\n-\nsaveMany\n(\n[\n\n    \nnew\n \nApp\n\\\nComment\n(\n[\nmessage\n \n=\n \nA new comment.\n]\n),\n\n    \nnew\n \nApp\n\\\nComment\n(\n[\nmessage\n \n=\n \nAnother comment.\n]\n),\n\n\n]);\n\n\n\n\n\n\n\n\nThe Create Method\n\n\nIn addition to the \nsave\n and \nsaveMany\n methods, you may also use the \ncreate\n method, which accepts an array of attributes, creates a model, and inserts it into the database. Again, the difference between \nsave\n and \ncreate\n is that \nsave\n accepts a full Eloquent model instance while \ncreate\n accepts a plain PHP \narray\n:\n\n\n$\npost\n \n=\n \nApp\n\\\nPost\n::\nfind\n(\n1\n);\n\n\n\n$\ncomment\n \n=\n \n$\npost-\ncomments\n()\n-\ncreate\n(\n[\n\n    \nmessage\n \n=\n \nA new comment.\n,\n\n\n]\n);\n\n\n\n\n\n\nBefore using the \ncreate\n method, be sure to review the documentation on attribute \nmass assignment\n.\n\n\n\n\nBelongs To Relationships\n\n\nWhen updating a \nbelongsTo\n relationship, you may use the \nassociate\n method. This method will set the foreign key on the child model:\n\n\n$\naccount\n \n=\n \nApp\n\\\nAccount\n::\nfind\n(\n10\n);\n\n\n\n$\nuser-\naccount\n()\n-\nassociate\n($\naccount\n);\n\n\n\n$\nuser-\nsave\n();\n\n\n\n\n\n\nWhen removing a \nbelongsTo\n relationship, you may use the \ndissociate\n method. This method will set the relationship's foreign key to \nnull\n:\n\n\n$user-\naccount()-\ndissociate();\n\n$user-\nsave();\n\n\n\n\n\n\n\nMany To Many Relationships\n\n\nAttaching / Detaching\n\n\nEloquent also provides a few additional helper methods to make working with related models more convenient. For example, let's imagine a user can have many roles and a role can have many users. To attach a role to a user by inserting a record in the intermediate table that joins the models, use the \nattach\n method:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nuser-\nroles\n()\n-\nattach\n($\nroleId\n);\n\n\n\n\n\n\nWhen attaching a relationship to a model, you may also pass an array of additional data to be inserted into the intermediate table:\n\n\n$user-\nroles()-\nattach($roleId, [\nexpires\n =\n $expires]);\n\n\n\n\n\nOf course, sometimes it may be necessary to remove a role from a user. To remove a many-to-many relationship record, use the \ndetach\n method. The \ndetach\n method will remove the appropriate record out of the intermediate table; however, both models will remain in the database:\n\n\n// Detach a single role from the user...\n$user-\nroles()-\ndetach($roleId);\n\n// Detach all roles from the user...\n$user-\nroles()-\ndetach();\n\n\n\n\n\nFor convenience, \nattach\n and \ndetach\n also accept arrays of IDs as input:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nuser-\nroles\n()\n-\ndetach\n(\n[\n1\n,\n \n2\n,\n \n3\n]\n);\n\n\n\n$\nuser-\nroles\n()\n-\nattach\n(\n[\n1\n \n=\n \n[\nexpires\n \n=\n \n$expires\n]\n,\n \n2\n,\n \n3\n]);\n\n\n\n\n\n\nSyncing Associations\n\n\nYou may also use the \nsync\n method to construct many-to-many associations. The \nsync\n method accepts an array of IDs to place on the intermediate table. Any IDs that are not in the given array will be removed from the intermediate table. So, after this operation is complete, only the IDs in the given array will exist in the intermediate table:\n\n\n$user-\nroles()-\nsync([1, 2, 3]);\n\n\n\n\n\nYou may also pass additional intermediate table values with the IDs:\n\n\n$user-\nroles()-\nsync([1 =\n [\nexpires\n =\n true], 2, 3]);\n\n\n\n\n\nIf you do not want to detach existing IDs, you may use the \nsyncWithoutDetaching\n method:\n\n\n$user-\nroles()-\nsyncWithoutDetaching([1, 2, 3]);\n\n\n\n\n\nToggling Associations\n\n\nThe many-to-many relationship also provides a \ntoggle\n method which \"toggles\" the attachment status of the given IDs. If the given ID is currently attached, it will be detached. Likewise, if it is currently detached, it will be attached:\n\n\n$user-\nroles()-\ntoggle([1, 2, 3]);\n\n\n\n\n\nSaving Additional Data On A Pivot Table\n\n\nWhen working with a many-to-many relationship, the \nsave\n method accepts an array of additional intermediate table attributes as its second argument:\n\n\nApp\n\\\nUser\n::\nfind\n(\n1\n)\n-\nroles\n()\n-\nsave\n($\nrole\n,\n \n[\nexpires\n \n=\n \n$expires\n]\n);\n\n\n\n\n\n\nUpdating A Record On A Pivot Table\n\n\nIf you need to update an existing row in your pivot table, you may use \nupdateExistingPivot\n method. This method accepts the pivot record foreign key and an array of attributes to update:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nuser-\nroles\n()\n-\nupdateExistingPivot\n($\nroleId\n,\n \n$\nattributes\n);\n\n\n\n\n\n\n\n\nTouching Parent Timestamps\n\n\nWhen a model \nbelongsTo\n or \nbelongsToMany\n another model, such as a \nComment\n which belongs to a \nPost\n, it is sometimes helpful to update the parent's timestamp when the child model is updated. For example, when a \nComment\n model is updated, you may want to automatically \"touch\" the \nupdated_at\n timestamp of the owning \nPost\n. Eloquent makes it easy. Just add a \ntouches\n property containing the names of the relationships to the child model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nComment\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * All of the relationships to be touched.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$touches\n \n=\n \n[\npost\n];\n\n\n    \n/**\n\n\n     * Get the post that the comment belongs to.\n\n\n     */\n\n    \npublic\n \nfunction\n \npost\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nbelongsTo\n(\nApp\\Post\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow, when you update a \nComment\n, the owning \nPost\n will have its \nupdated_at\n column updated as well, making it more convenient to know when to invalidate a cache of the \nPost\n model:\n\n\n$\ncomment\n \n=\n \nApp\n\\\nComment\n::\nfind\n(\n1\n);\n\n\n\n$\ncomment-\ntext\n \n=\n \nEdit to this comment!\n;\n\n\n\n$\ncomment-\nsave\n();", 
            "title": "Eloquent relationships"
        }, 
        {
            "location": "/eloquent-relationships/#eloquent-relationships", 
            "text": "Introduction  Defining Relationships  One To One  One To Many  One To Many (Inverse)  Many To Many  Has Many Through  Polymorphic Relations  Many To Many Polymorphic Relations    Querying Relations  Relationship Methods Vs. Dynamic Properties  Querying Relationship Existence  Querying Relationship Absence  Counting Related Models    Eager Loading  Constraining Eager Loads  Lazy Eager Loading    Inserting   Updating Related Models  The  save  Method  The  create  Method  Belongs To Relationships  Many To Many Relationships    Touching Parent Timestamps", 
            "title": "Eloquent: Relationships"
        }, 
        {
            "location": "/eloquent-relationships/#introduction", 
            "text": "Database tables are often related to one another. For example, a blog post may have many comments, or an order could be related to the user who placed it. Eloquent makes managing and working with these relationships easy, and supports several different types of relationships:   One To One  One To Many  Many To Many  Has Many Through  Polymorphic Relations  Many To Many Polymorphic Relations", 
            "title": "Introduction"
        }, 
        {
            "location": "/eloquent-relationships/#defining-relationships", 
            "text": "Eloquent relationships are defined as methods on your Eloquent model classes. Since, like Eloquent models themselves, relationships also serve as powerful  query builders , defining relationships as methods provides powerful method chaining and querying capabilities. For example, we may chain additional constraints on this  posts  relationship:  $user- posts()- where( active , 1)- get();  But, before diving too deep into using relationships, let's learn how to define each type.", 
            "title": "Defining Relationships"
        }, 
        {
            "location": "/eloquent-relationships/#one-to-one", 
            "text": "A one-to-one relationship is a very basic relation. For example, a  User  model might be associated with one  Phone . To define this relationship, we place a  phone  method on the  User  model. The  phone  method should call the  hasOne  method and return its result:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * Get the phone record associated with the user.       */ \n     public   function   phone () \n     { \n         return   $this - hasOne ( App\\Phone ); \n     }  }   The first argument passed to the  hasOne  method is the name of the related model. Once the relationship is defined, we may retrieve the related record using Eloquent's dynamic properties. Dynamic properties allow you to access relationship methods as if they were properties defined on the model:  $ phone   =   User :: find ( 1 ) - phone ;   Eloquent determines the foreign key of the relationship based on the model name. In this case, the  Phone  model is automatically assumed to have a  user_id  foreign key. If you wish to override this convention, you may pass a second argument to the  hasOne  method:  return $this- hasOne( App\\Phone ,  foreign_key );  Additionally, Eloquent assumes that the foreign key should have a value matching the  id  (or the custom  $primaryKey ) column of the parent. In other words, Eloquent will look for the value of the user's  id  column in the  user_id  column of the  Phone  record. If you would like the relationship to use a value other than  id , you may pass a third argument to the  hasOne  method specifying your custom key:  return $this- hasOne( App\\Phone ,  foreign_key ,  local_key );", 
            "title": "One To One"
        }, 
        {
            "location": "/eloquent-relationships/#defining-the-inverse-of-the-relationship", 
            "text": "So, we can access the  Phone  model from our  User . Now, let's define a relationship on the  Phone  model that will let us access the  User  that owns the phone. We can define the inverse of a  hasOne  relationship using the  belongsTo  method:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Phone   extends   Model  { \n     /**       * Get the user that owns the phone.       */ \n     public   function   user () \n     { \n         return   $this - belongsTo ( App\\User ); \n     }  }   In the example above, Eloquent will try to match the  user_id  from the  Phone  model to an  id  on the  User  model. Eloquent determines the default foreign key name by examining the name of the relationship method and suffixing the method name with  _id . However, if the foreign key on the  Phone  model is not  user_id , you may pass a custom key name as the second argument to the  belongsTo  method:  /**   * Get the user that owns the phone.   */ \npublic   function   user ()  {       return   $ this - belongsTo ( App\\User ,   foreign_key ) ;  }   If your parent model does not use  id  as its primary key, or you wish to join the child model to a different column, you may pass a third argument to the  belongsTo  method specifying your parent table's custom key:  /**   * Get the user that owns the phone.   */ \npublic   function   user ()  {       return   $ this - belongsTo ( App\\User ,   foreign_key ,   other_key ) ;  }", 
            "title": "Defining The Inverse Of The Relationship"
        }, 
        {
            "location": "/eloquent-relationships/#one-to-many", 
            "text": "A \"one-to-many\" relationship is used to define relationships where a single model owns any amount of other models. For example, a blog post may have an infinite number of comments. Like all other Eloquent relationships, one-to-many relationships are defined by placing a function on your Eloquent model:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Post   extends   Model  { \n     /**       * Get the comments for the blog post.       */ \n     public   function   comments () \n     { \n         return   $this - hasMany ( App\\Comment ); \n     }  }   Remember, Eloquent will automatically determine the proper foreign key column on the  Comment  model. By convention, Eloquent will take the \"snake case\" name of the owning model and suffix it with  _id . So, for this example, Eloquent will assume the foreign key on the  Comment  model is  post_id .  Once the relationship has been defined, we can access the collection of comments by accessing the  comments  property. Remember, since Eloquent provides \"dynamic properties\", we can access relationship methods as if they were defined as properties on the model:  $ comments   =   App \\ Post :: find ( 1 ) - comments ;  foreach   ($ comments   as   $ comment )   { \n     //  }   Of course, since all relationships also serve as query builders, you can add further constraints to which comments are retrieved by calling the  comments  method and continuing to chain conditions onto the query:  $ comments   =   App \\ Post :: find ( 1 ) - comments () - where ( title ,   foo ) - first ();   Like the  hasOne  method, you may also override the foreign and local keys by passing additional arguments to the  hasMany  method:  return $this- hasMany( App\\Comment ,  foreign_key );\n\nreturn $this- hasMany( App\\Comment ,  foreign_key ,  local_key );", 
            "title": "One To Many"
        }, 
        {
            "location": "/eloquent-relationships/#one-to-many-inverse", 
            "text": "Now that we can access all of a post's comments, let's define a relationship to allow a comment to access its parent post. To define the inverse of a  hasMany  relationship, define a relationship function on the child model which calls the  belongsTo  method:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Comment   extends   Model  { \n     /**       * Get the post that owns the comment.       */ \n     public   function   post () \n     { \n         return   $this - belongsTo ( App\\Post ); \n     }  }   Once the relationship has been defined, we can retrieve the  Post  model for a  Comment  by accessing the  post  \"dynamic property\":  $ comment   =   App \\ Comment :: find ( 1 );  echo   $ comment- post- title ;   In the example above, Eloquent will try to match the  post_id  from the  Comment  model to an  id  on the  Post  model. Eloquent determines the default foreign key name by examining the name of the relationship method and suffixing the method name with  _id . However, if the foreign key on the  Comment  model is not  post_id , you may pass a custom key name as the second argument to the  belongsTo  method:  /**   * Get the post that owns the comment.   */ \npublic   function   post ()  {       return   $ this - belongsTo ( App\\Post ,   foreign_key ) ;  }   If your parent model does not use  id  as its primary key, or you wish to join the child model to a different column, you may pass a third argument to the  belongsTo  method specifying your parent table's custom key:  /**   * Get the post that owns the comment.   */ \npublic   function   post ()  {       return   $ this - belongsTo ( App\\Post ,   foreign_key ,   other_key ) ;  }", 
            "title": "One To Many (Inverse)"
        }, 
        {
            "location": "/eloquent-relationships/#many-to-many", 
            "text": "Many-to-many relations are slightly more complicated than  hasOne  and  hasMany  relationships. An example of such a relationship is a user with many roles, where the roles are also shared by other users. For example, many users may have the role of \"Admin\". To define this relationship, three database tables are needed:  users ,  roles , and  role_user . The  role_user  table is derived from the alphabetical order of the related model names, and contains the  user_id  and  role_id  columns.  Many-to-many relationships are defined by writing a method that returns the result of the  belongsToMany  method. For example, let's define the  roles  method on our  User  model:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * The roles that belong to the user.       */ \n     public   function   roles () \n     { \n         return   $this - belongsToMany ( App\\Role ); \n     }  }   Once the relationship is defined, you may access the user's roles using the  roles  dynamic property:  $ user   =   App \\ User :: find ( 1 );  foreach   ($ user- roles   as   $ role )   { \n     //  }   Of course, like all other relationship types, you may call the  roles  method to continue chaining query constraints onto the relationship:  $ roles   =   App \\ User :: find ( 1 ) - roles () - orderBy ( name ) - get ();   As mentioned previously, to determine the table name of the relationship's joining table, Eloquent will join the two related model names in alphabetical order. However, you are free to override this convention. You may do so by passing a second argument to the  belongsToMany  method:  return $this- belongsToMany( App\\Role ,  role_user );  In addition to customizing the name of the joining table, you may also customize the column names of the keys on the table by passing additional arguments to the  belongsToMany  method. The third argument is the foreign key name of the model on which you are defining the relationship, while the fourth argument is the foreign key name of the model that you are joining to:  return $this- belongsToMany( App\\Role ,  role_user ,  user_id ,  role_id );", 
            "title": "Many To Many"
        }, 
        {
            "location": "/eloquent-relationships/#defining-the-inverse-of-the-relationship_1", 
            "text": "To define the inverse of a many-to-many relationship, you simply place another call to  belongsToMany  on your related model. To continue our user roles example, let's define the  users  method on the  Role  model:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Role   extends   Model  { \n     /**       * The users that belong to the role.       */ \n     public   function   users () \n     { \n         return   $this - belongsToMany ( App\\User ); \n     }  }   As you can see, the relationship is defined exactly the same as its  User  counterpart, with the exception of simply referencing the  App\\User  model. Since we're reusing the  belongsToMany  method, all of the usual table and key customization options are available when defining the inverse of many-to-many relationships.", 
            "title": "Defining The Inverse Of The Relationship"
        }, 
        {
            "location": "/eloquent-relationships/#retrieving-intermediate-table-columns", 
            "text": "As you have already learned, working with many-to-many relations requires the presence of an intermediate table. Eloquent provides some very helpful ways of interacting with this table. For example, let's assume our  User  object has many  Role  objects that it is related to. After accessing this relationship, we may access the intermediate table using the  pivot  attribute on the models:  $ user   =   App \\ User :: find ( 1 );  foreach   ($ user- roles   as   $ role )   { \n     echo   $role- pivot- created_at ;  }   Notice that each  Role  model we retrieve is automatically assigned a  pivot  attribute. This attribute contains a model representing the intermediate table, and may be used like any other Eloquent model.  By default, only the model keys will be present on the  pivot  object. If your pivot table contains extra attributes, you must specify them when defining the relationship:  return $this- belongsToMany( App\\Role )- withPivot( column1 ,  column2 );  If you want your pivot table to have automatically maintained  created_at  and  updated_at  timestamps, use the  withTimestamps  method on the relationship definition:  return $this- belongsToMany( App\\Role )- withTimestamps();", 
            "title": "Retrieving Intermediate Table Columns"
        }, 
        {
            "location": "/eloquent-relationships/#filtering-relationships-via-intermediate-table-columns", 
            "text": "You can also filter the results returned by  belongsToMany  using the  wherePivot  and  wherePivotIn  methods when defining the relationship:  return $this- belongsToMany( App\\Role )- wherePivot( approved , 1);\n\nreturn $this- belongsToMany( App\\Role )- wherePivotIn( priority , [1, 2]);", 
            "title": "Filtering Relationships Via Intermediate Table Columns"
        }, 
        {
            "location": "/eloquent-relationships/#defining-custom-intermediate-table-models", 
            "text": "If you would like to define a custom model to represent the intermediate table of your relationship, you may call the  using  method when defining the relationship. All custom models used to represent intermediate tables of relationships must extend the  Illuminate\\Database\\Eloquent\\Relations\\Pivot  class:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Role   extends   Model  { \n     /**       * The users that belong to the role.       */ \n     public   function   users () \n     { \n         return   $this - belongsToMany ( App\\User ) - using ( App\\UserRole ); \n     }  }", 
            "title": "Defining Custom Intermediate Table Models"
        }, 
        {
            "location": "/eloquent-relationships/#has-many-through", 
            "text": "The \"has-many-through\" relationship provides a convenient shortcut for accessing distant relations via an intermediate relation. For example, a  Country  model might have many  Post  models through an intermediate  User  model. In this example, you could easily gather all blog posts for a given country. Let's look at the tables required to define this relationship:  countries\n    id - integer\n    name - string\n\nusers\n    id - integer\n    country_id - integer\n    name - string\n\nposts\n    id - integer\n    user_id - integer\n    title - string  Though  posts  does not contain a  country_id  column, the  hasManyThrough  relation provides access to a country's posts via  $country- posts . To perform this query, Eloquent inspects the  country_id  on the intermediate  users  table. After finding the matching user IDs, they are used to query the  posts  table.  Now that we have examined the table structure for the relationship, let's define it on the  Country  model:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Country   extends   Model  { \n     /**       * Get all of the posts for the country.       */ \n     public   function   posts () \n     { \n         return   $this - hasManyThrough ( App\\Post ,   App\\User ); \n     }  }   The first argument passed to the  hasManyThrough  method is the name of the final model we wish to access, while the second argument is the name of the intermediate model.  Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the  hasManyThrough  method. The third argument is the name of the foreign key on the intermediate model, the fourth argument is the name of the foreign key on the final model, and the fifth argument is the local key:  class   Country   extends   Model  { \n     public   function   posts () \n     { \n         return   $this - hasManyThrough ( \n             App\\Post ,   App\\User , \n             country_id ,   user_id ,   id \n         ); \n     }  }", 
            "title": "Has Many Through"
        }, 
        {
            "location": "/eloquent-relationships/#polymorphic-relations", 
            "text": "", 
            "title": "Polymorphic Relations"
        }, 
        {
            "location": "/eloquent-relationships/#table-structure", 
            "text": "Polymorphic relations allow a model to belong to more than one other model on a single association. For example, imagine users of your application can \"comment\" both posts and videos. Using polymorphic relationships, you can use a single  comments  table for both of these scenarios. First, let's examine the table structure required to build this relationship:  posts\n    id - integer\n    title - string\n    body - text\n\nvideos\n    id - integer\n    title - string\n    url - string\n\ncomments\n    id - integer\n    body - text\n    commentable_id - integer\n    commentable_type - string  Two important columns to note are the  commentable_id  and  commentable_type  columns on the  comments  table. The  commentable_id  column will contain the ID value of the post or video, while the  commentable_type  column will contain the class name of the owning model. The  commentable_type  column is how the ORM determines which \"type\" of owning model to return when accessing the  commentable  relation.", 
            "title": "Table Structure"
        }, 
        {
            "location": "/eloquent-relationships/#model-structure", 
            "text": "Next, let's examine the model definitions needed to build this relationship:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Comment   extends   Model  { \n     /**       * Get all of the owning commentable models.       */ \n     public   function   commentable () \n     { \n         return   $this - morphTo (); \n     }  }  class   Post   extends   Model  { \n     /**       * Get all of the post s comments.       */ \n     public   function   comments () \n     { \n         return   $this - morphMany ( App\\Comment ,   commentable ); \n     }  }  class   Video   extends   Model  { \n     /**       * Get all of the video s comments.       */ \n     public   function   comments () \n     { \n         return   $this - morphMany ( App\\Comment ,   commentable ); \n     }  }", 
            "title": "Model Structure"
        }, 
        {
            "location": "/eloquent-relationships/#retrieving-polymorphic-relations", 
            "text": "Once your database table and models are defined, you may access the relationships via your models. For example, to access all of the comments for a post, we can simply use the  comments  dynamic property:  $ post   =   App \\ Post :: find ( 1 );  foreach   ($ post- comments   as   $ comment )   { \n     //  }   You may also retrieve the owner of a polymorphic relation from the polymorphic model by accessing the name of the method that performs the call to  morphTo . In our case, that is the  commentable  method on the  Comment  model. So, we will access that method as a dynamic property:  $ comment   =   App \\ Comment :: find ( 1 );  $ commentable   =   $ comment- commentable ;   The  commentable  relation on the  Comment  model will return either a  Post  or  Video  instance, depending on which type of model owns the comment.", 
            "title": "Retrieving Polymorphic Relations"
        }, 
        {
            "location": "/eloquent-relationships/#custom-polymorphic-types", 
            "text": "By default, Laravel will use the fully qualified class name to store the type of the related model. For instance, given the example above where a  Comment  may belong to a  Post  or a  Video , the default  commentable_type  would be either  App\\Post  or  App\\Video , respectively. However, you may wish to decouple your database from your application's internal structure. In that case, you may define a relationship \"morph map\" to instruct Eloquent to use a custom name for each model instead of the class name:  use Illuminate\\Database\\Eloquent\\Relations\\Relation;\n\nRelation::morphMap([\n     posts  =   App\\Post ,\n     videos  =   App\\Video ,\n]);  You may register the  morphMap  in the  boot  function of your  AppServiceProvider  or create a separate service provider if you wish.", 
            "title": "Custom Polymorphic Types"
        }, 
        {
            "location": "/eloquent-relationships/#many-to-many-polymorphic-relations", 
            "text": "", 
            "title": "Many To Many Polymorphic Relations"
        }, 
        {
            "location": "/eloquent-relationships/#table-structure_1", 
            "text": "In addition to traditional polymorphic relations, you may also define \"many-to-many\" polymorphic relations. For example, a blog  Post  and  Video  model could share a polymorphic relation to a  Tag  model. Using a many-to-many polymorphic relation allows you to have a single list of unique tags that are shared across blog posts and videos. First, let's examine the table structure:  posts\n    id - integer\n    name - string\n\nvideos\n    id - integer\n    name - string\n\ntags\n    id - integer\n    name - string\n\ntaggables\n    tag_id - integer\n    taggable_id - integer\n    taggable_type - string", 
            "title": "Table Structure"
        }, 
        {
            "location": "/eloquent-relationships/#model-structure_1", 
            "text": "Next, we're ready to define the relationships on the model. The  Post  and  Video  models will both have a  tags  method that calls the  morphToMany  method on the base Eloquent class:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Post   extends   Model  { \n     /**       * Get all of the tags for the post.       */ \n     public   function   tags () \n     { \n         return   $this - morphToMany ( App\\Tag ,   taggable ); \n     }  }", 
            "title": "Model Structure"
        }, 
        {
            "location": "/eloquent-relationships/#defining-the-inverse-of-the-relationship_2", 
            "text": "Next, on the  Tag  model, you should define a method for each of its related models. So, for this example, we will define a  posts  method and a  videos  method:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Tag   extends   Model  { \n     /**       * Get all of the posts that are assigned this tag.       */ \n     public   function   posts () \n     { \n         return   $this - morphedByMany ( App\\Post ,   taggable ); \n     } \n\n     /**       * Get all of the videos that are assigned this tag.       */ \n     public   function   videos () \n     { \n         return   $this - morphedByMany ( App\\Video ,   taggable ); \n     }  }", 
            "title": "Defining The Inverse Of The Relationship"
        }, 
        {
            "location": "/eloquent-relationships/#retrieving-the-relationship", 
            "text": "Once your database table and models are defined, you may access the relationships via your models. For example, to access all of the tags for a post, you can simply use the  tags  dynamic property:  $ post   =   App \\ Post :: find ( 1 );  foreach   ($ post- tags   as   $ tag )   { \n     //  }   You may also retrieve the owner of a polymorphic relation from the polymorphic model by accessing the name of the method that performs the call to  morphedByMany . In our case, that is the  posts  or  videos  methods on the  Tag  model. So, you will access those methods as dynamic properties:  $ tag   =   App \\ Tag :: find ( 1 );  foreach   ($ tag- videos   as   $ video )   { \n     //  }", 
            "title": "Retrieving The Relationship"
        }, 
        {
            "location": "/eloquent-relationships/#querying-relations", 
            "text": "Since all types of Eloquent relationships are defined via methods, you may call those methods to obtain an instance of the relationship without actually executing the relationship queries. In addition, all types of Eloquent relationships also serve as  query builders , allowing you to continue to chain constraints onto the relationship query before finally executing the SQL against your database.  For example, imagine a blog system in which a  User  model has many associated  Post  models:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * Get all of the posts for the user.       */ \n     public   function   posts () \n     { \n         return   $this - hasMany ( App\\Post ); \n     }  }   You may query the  posts  relationship and add additional constraints to the relationship like so:  $ user   =   App \\ User :: find ( 1 );  $ user- posts () - where ( active ,   1 ) - get ();   You are able to use any of the  query builder  methods on the relationship, so be sure to explore the query builder documentation to learn about all of the methods that are available to you.", 
            "title": "Querying Relations"
        }, 
        {
            "location": "/eloquent-relationships/#relationship-methods-vs-dynamic-properties", 
            "text": "If you do not need to add additional constraints to an Eloquent relationship query, you may simply access the relationship as if it were a property. For example, continuing to use our  User  and  Post  example models, we may access all of a user's posts like so:  $ user   =   App \\ User :: find ( 1 );  foreach   ($ user- posts   as   $ post )   { \n     //  }   Dynamic properties are \"lazy loading\", meaning they will only load their relationship data when you actually access them. Because of this, developers often use  eager loading  to pre-load relationships they know will be accessed after loading the model. Eager loading provides a significant reduction in SQL queries that must be executed to load a model's relations.", 
            "title": "Relationship Methods Vs. Dynamic Properties"
        }, 
        {
            "location": "/eloquent-relationships/#querying-relationship-existence", 
            "text": "When accessing the records for a model, you may wish to limit your results based on the existence of a relationship. For example, imagine you want to retrieve all blog posts that have at least one comment. To do so, you may pass the name of the relationship to the  has  method:  //   Retrieve   all   posts   that   have   at   least   one   comment ...  $ posts   =   App \\ Post :: has ( comments ) - get ();   You may also specify an operator and count to further customize the query:  //   Retrieve   all   posts   that   have   three   or   more   comments ...  $ posts   =   Post :: has ( comments ,   = ,   3 ) - get ();   Nested  has  statements may also be constructed using \"dot\" notation. For example, you may retrieve all posts that have at least one comment and vote:  //   Retrieve   all   posts   that   have   at   least   one   comment   with   votes ...  $ posts   =   Post :: has ( comments.votes ) - get ();   If you need even more power, you may use the  whereHas  and  orWhereHas  methods to put \"where\" conditions on your  has  queries. These methods allow you to add customized constraints to a relationship constraint, such as checking the content of a comment:  // Retrieve all posts with at least one comment containing words like foo%\n$posts = Post::whereHas( comments , function ($query) {\n    $query- where( content ,  like ,  foo% );\n})- get();", 
            "title": "Querying Relationship Existence"
        }, 
        {
            "location": "/eloquent-relationships/#querying-relationship-absence", 
            "text": "When accessing the records for a model, you may wish to limit your results based on the absence of a relationship. For example, imagine you want to retrieve all blog posts that  don't  have any comments. To do so, you may pass the name of the relationship to the  doesntHave  method:  $ posts   =   App \\ Post :: doesntHave ( comments ) - get ();   If you need even more power, you may use the  whereDoesntHave  method to put \"where\" conditions on your  doesntHave  queries. This method allows you to add customized constraints to a relationship constraint, such as checking the content of a comment:  $posts = Post::whereDoesntHave( comments , function ($query) {\n    $query- where( content ,  like ,  foo% );\n})- get();", 
            "title": "Querying Relationship Absence"
        }, 
        {
            "location": "/eloquent-relationships/#counting-related-models", 
            "text": "If you want to count the number of results from a relationship without actually loading them you may use the  withCount  method, which will place a  {relation}_count  column on your resulting models. For example:  $ posts   =   App \\ Post :: withCount ( comments ) - get ();  foreach   ($ posts   as   $ post )   { \n     echo   $post- comments_count ;  }   You may add the \"counts\" for multiple relations as well as add constraints to the queries:  $posts = Post::withCount([ votes ,  comments  =  function ($query) {\n    $query- where( content ,  like ,  foo% );\n}])- get();\n\necho $posts[0]- votes_count;\necho $posts[0]- comments_count;", 
            "title": "Counting Related Models"
        }, 
        {
            "location": "/eloquent-relationships/#eager-loading", 
            "text": "When accessing Eloquent relationships as properties, the relationship data is \"lazy loaded\". This means the relationship data is not actually loaded until you first access the property. However, Eloquent can \"eager load\" relationships at the time you query the parent model. Eager loading alleviates the N + 1 query problem. To illustrate the N + 1 query problem, consider a  Book  model that is related to  Author :  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Book   extends   Model  { \n     /**       * Get the author that wrote the book.       */ \n     public   function   author () \n     { \n         return   $this - belongsTo ( App\\Author ); \n     }  }   Now, let's retrieve all books and their authors:  $ books   =   App \\ Book :: all ();  foreach   ($ books   as   $ book )   { \n     echo   $book- author- name ;  }   This loop will execute 1 query to retrieve all of the books on the table, then another query for each book to retrieve the author. So, if we have 25 books, this loop would run 26 queries: 1 for the original book, and 25 additional queries to retrieve the author of each book.  Thankfully, we can use eager loading to reduce this operation to just 2 queries. When querying, you may specify which relationships should be eager loaded using the  with  method:  $ books   =   App \\ Book :: with ( author ) - get ();  foreach   ($ books   as   $ book )   { \n     echo   $book- author- name ;  }   For this operation, only two queries will be executed:  select * from books\n\nselect * from authors where id in (1, 2, 3, 4, 5, ...)", 
            "title": "Eager Loading"
        }, 
        {
            "location": "/eloquent-relationships/#eager-loading-multiple-relationships", 
            "text": "Sometimes you may need to eager load several different relationships in a single operation. To do so, just pass additional arguments to the  with  method:  $ books   =   App \\ Book :: with ( author ,   publisher ) - get ();", 
            "title": "Eager Loading Multiple Relationships"
        }, 
        {
            "location": "/eloquent-relationships/#nested-eager-loading", 
            "text": "To eager load nested relationships, you may use \"dot\" syntax. For example, let's eager load all of the book's authors and all of the author's personal contacts in one Eloquent statement:  $ books   =   App \\ Book :: with ( author.contacts ) - get ();", 
            "title": "Nested Eager Loading"
        }, 
        {
            "location": "/eloquent-relationships/#constraining-eager-loads", 
            "text": "Sometimes you may wish to eager load a relationship, but also specify additional query constraints for the eager loading query. Here's an example:  $users = App\\User::with([ posts  =  function ($query) {\n    $query- where( title ,  like ,  %first% );\n}])- get();  In this example, Eloquent will only eager load posts where the post's  title  column contains the word  first . Of course, you may call other  query builder  methods to further customize the eager loading operation:  $users = App\\User::with([ posts  =  function ($query) {\n    $query- orderBy( created_at ,  desc );\n}])- get();", 
            "title": "Constraining Eager Loads"
        }, 
        {
            "location": "/eloquent-relationships/#lazy-eager-loading", 
            "text": "Sometimes you may need to eager load a relationship after the parent model has already been retrieved. For example, this may be useful if you need to dynamically decide whether to load related models:  $ books   =   App \\ Book :: all ();  if   ($ someCondition )   { \n     $books- load( author ,   publisher ) ;  }   If you need to set additional query constraints on the eager loading query, you may pass an array keyed by the relationships you wish to load. The array values should be  Closure  instances which receive the query instance:  $books- load([ author  =  function ($query) {\n    $query- orderBy( published_date ,  asc );\n}]);", 
            "title": "Lazy Eager Loading"
        }, 
        {
            "location": "/eloquent-relationships/#inserting-updating-related-models", 
            "text": "", 
            "title": "Inserting &amp; Updating Related Models"
        }, 
        {
            "location": "/eloquent-relationships/#the-save-method", 
            "text": "Eloquent provides convenient methods for adding new models to relationships. For example, perhaps you need to insert a new  Comment  for a  Post  model. Instead of manually setting the  post_id  attribute on the  Comment , you may insert the  Comment  directly from the relationship's  save  method:  $ comment   =   new   App \\ Comment ( [ message   =   A new comment. ] );  $ post   =   App \\ Post :: find ( 1 );  $ post- comments () - save ($ comment );   Notice that we did not access the  comments  relationship as a dynamic property. Instead, we called the  comments  method to obtain an instance of the relationship. The  save  method will automatically add the appropriate  post_id  value to the new  Comment  model.  If you need to save multiple related models, you may use the  saveMany  method:  $ post   =   App \\ Post :: find ( 1 );  $ post- comments () - saveMany ( [ \n     new   App \\ Comment ( [ message   =   A new comment. ] ), \n     new   App \\ Comment ( [ message   =   Another comment. ] ),  ]);", 
            "title": "The Save Method"
        }, 
        {
            "location": "/eloquent-relationships/#the-create-method", 
            "text": "In addition to the  save  and  saveMany  methods, you may also use the  create  method, which accepts an array of attributes, creates a model, and inserts it into the database. Again, the difference between  save  and  create  is that  save  accepts a full Eloquent model instance while  create  accepts a plain PHP  array :  $ post   =   App \\ Post :: find ( 1 );  $ comment   =   $ post- comments () - create ( [ \n     message   =   A new comment. ,  ] );   Before using the  create  method, be sure to review the documentation on attribute  mass assignment .", 
            "title": "The Create Method"
        }, 
        {
            "location": "/eloquent-relationships/#belongs-to-relationships", 
            "text": "When updating a  belongsTo  relationship, you may use the  associate  method. This method will set the foreign key on the child model:  $ account   =   App \\ Account :: find ( 10 );  $ user- account () - associate ($ account );  $ user- save ();   When removing a  belongsTo  relationship, you may use the  dissociate  method. This method will set the relationship's foreign key to  null :  $user- account()- dissociate();\n\n$user- save();", 
            "title": "Belongs To Relationships"
        }, 
        {
            "location": "/eloquent-relationships/#many-to-many-relationships", 
            "text": "", 
            "title": "Many To Many Relationships"
        }, 
        {
            "location": "/eloquent-relationships/#attaching-detaching", 
            "text": "Eloquent also provides a few additional helper methods to make working with related models more convenient. For example, let's imagine a user can have many roles and a role can have many users. To attach a role to a user by inserting a record in the intermediate table that joins the models, use the  attach  method:  $ user   =   App \\ User :: find ( 1 );  $ user- roles () - attach ($ roleId );   When attaching a relationship to a model, you may also pass an array of additional data to be inserted into the intermediate table:  $user- roles()- attach($roleId, [ expires  =  $expires]);  Of course, sometimes it may be necessary to remove a role from a user. To remove a many-to-many relationship record, use the  detach  method. The  detach  method will remove the appropriate record out of the intermediate table; however, both models will remain in the database:  // Detach a single role from the user...\n$user- roles()- detach($roleId);\n\n// Detach all roles from the user...\n$user- roles()- detach();  For convenience,  attach  and  detach  also accept arrays of IDs as input:  $ user   =   App \\ User :: find ( 1 );  $ user- roles () - detach ( [ 1 ,   2 ,   3 ] );  $ user- roles () - attach ( [ 1   =   [ expires   =   $expires ] ,   2 ,   3 ]);", 
            "title": "Attaching / Detaching"
        }, 
        {
            "location": "/eloquent-relationships/#syncing-associations", 
            "text": "You may also use the  sync  method to construct many-to-many associations. The  sync  method accepts an array of IDs to place on the intermediate table. Any IDs that are not in the given array will be removed from the intermediate table. So, after this operation is complete, only the IDs in the given array will exist in the intermediate table:  $user- roles()- sync([1, 2, 3]);  You may also pass additional intermediate table values with the IDs:  $user- roles()- sync([1 =  [ expires  =  true], 2, 3]);  If you do not want to detach existing IDs, you may use the  syncWithoutDetaching  method:  $user- roles()- syncWithoutDetaching([1, 2, 3]);", 
            "title": "Syncing Associations"
        }, 
        {
            "location": "/eloquent-relationships/#toggling-associations", 
            "text": "The many-to-many relationship also provides a  toggle  method which \"toggles\" the attachment status of the given IDs. If the given ID is currently attached, it will be detached. Likewise, if it is currently detached, it will be attached:  $user- roles()- toggle([1, 2, 3]);", 
            "title": "Toggling Associations"
        }, 
        {
            "location": "/eloquent-relationships/#saving-additional-data-on-a-pivot-table", 
            "text": "When working with a many-to-many relationship, the  save  method accepts an array of additional intermediate table attributes as its second argument:  App \\ User :: find ( 1 ) - roles () - save ($ role ,   [ expires   =   $expires ] );", 
            "title": "Saving Additional Data On A Pivot Table"
        }, 
        {
            "location": "/eloquent-relationships/#updating-a-record-on-a-pivot-table", 
            "text": "If you need to update an existing row in your pivot table, you may use  updateExistingPivot  method. This method accepts the pivot record foreign key and an array of attributes to update:  $ user   =   App \\ User :: find ( 1 );  $ user- roles () - updateExistingPivot ($ roleId ,   $ attributes );", 
            "title": "Updating A Record On A Pivot Table"
        }, 
        {
            "location": "/eloquent-relationships/#touching-parent-timestamps", 
            "text": "When a model  belongsTo  or  belongsToMany  another model, such as a  Comment  which belongs to a  Post , it is sometimes helpful to update the parent's timestamp when the child model is updated. For example, when a  Comment  model is updated, you may want to automatically \"touch\" the  updated_at  timestamp of the owning  Post . Eloquent makes it easy. Just add a  touches  property containing the names of the relationships to the child model:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Comment   extends   Model  { \n     /**       * All of the relationships to be touched.       *       * @var array       */ \n     protected   $touches   =   [ post ]; \n\n     /**       * Get the post that the comment belongs to.       */ \n     public   function   post () \n     { \n         return   $this - belongsTo ( App\\Post ); \n     }  }   Now, when you update a  Comment , the owning  Post  will have its  updated_at  column updated as well, making it more convenient to know when to invalidate a cache of the  Post  model:  $ comment   =   App \\ Comment :: find ( 1 );  $ comment- text   =   Edit to this comment! ;  $ comment- save ();", 
            "title": "Touching Parent Timestamps"
        }, 
        {
            "location": "/eloquent-serialization/", 
            "text": "Eloquent: Serialization\n\n\n\n\nIntroduction\n\n\nSerializing Models \n Collections\n\n\nSerializing To Arrays\n\n\nSerializing To JSON\n\n\n\n\n\n\nHiding Attributes From JSON\n\n\nAppending Values To JSON\n\n\n\n\n\n\nIntroduction\n\n\nWhen building JSON APIs, you will often need to convert your models and relationships to arrays or JSON. Eloquent includes convenient methods for making these conversions, as well as controlling which attributes are included in your serializations.\n\n\n\n\nSerializing Models \n Collections\n\n\n\n\nSerializing To Arrays\n\n\nTo convert a model and its loaded \nrelationships\n to an array, you should use the \ntoArray\n method. This method is recursive, so all attributes and all relations (including the relations of relations) will be converted to arrays:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nwith\n(\nroles\n)\n-\nfirst\n();\n\n\n\nreturn\n \n$\nuser-\ntoArray\n();\n\n\n\n\n\n\nYou may also convert entire \ncollections\n of models to arrays:\n\n\n$\nusers\n \n=\n \nApp\n\\\nUser\n::\nall\n();\n\n\n\nreturn\n \n$\nusers-\ntoArray\n();\n\n\n\n\n\n\n\n\nSerializing To JSON\n\n\nTo convert a model to JSON, you should use the \ntoJson\n method. Like \ntoArray\n, the \ntoJson\n method is recursive, so all attributes and relations will be converted to JSON:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\nreturn\n \n$\nuser-\ntoJson\n();\n\n\n\n\n\n\nAlternatively, you may cast a model or collection to a string, which will automatically call the \ntoJson\n method on the model or collection:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\nreturn\n \n(\nstring\n)\n \n$\nuser\n;\n\n\n\n\n\n\nSince models and collections are converted to JSON when cast to a string, you can return Eloquent objects directly from your application's routes or controllers:\n\n\nRoute\n::\nget\n(\nusers\n,\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \nApp\\\nUser\n:\n:\nall\n();\n\n\n}\n);\n\n\n\n\n\n\n\n\nHiding Attributes From JSON\n\n\nSometimes you may wish to limit the attributes, such as passwords, that are included in your model's array or JSON representation. To do so, add a \n$hidden\n property to your model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The attributes that should be hidden for arrays.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$hidden\n \n=\n \n[\npassword\n];\n\n\n}\n\n\n\n\n\n\n\n\n{note} When hiding relationships, use the relationship's method name, not its dynamic property name.\n\n\n\n\nAlternatively, you may use the \nvisible\n property to define a white-list of attributes that should be included in your model's array and JSON representation. All other attributes will be hidden when the model is converted to an array or JSON:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The attributes that should be visible in arrays.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$visible\n \n=\n \n[\nfirst_name\n,\n \nlast_name\n];\n\n\n}\n\n\n\n\n\n\nTemporarily Modifying Attribute Visibility\n\n\nIf you would like to make some typically hidden attributes visible on a given model instance, you may use the \nmakeVisible\n method. The \nmakeVisible\n method returns the model instance for convenient method chaining:\n\n\nreturn $user-\nmakeVisible(\nattribute\n)-\ntoArray();\n\n\n\n\n\nLikewise, if you would like to make some typically visible attributes hidden on a given model instance, you may use the \nmakeHidden\n method.\n\n\nreturn $user-\nmakeHidden(\nattribute\n)-\ntoArray();\n\n\n\n\n\n\n\nAppending Values To JSON\n\n\nOccasionally, when casting models to an array or JSON, you may wish to add attributes that do not have a corresponding column in your database. To do so, first define an \naccessor\n for the value:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Get the administrator flag for the user.\n\n\n     *\n\n\n     * @return bool\n\n\n     */\n\n    \npublic\n \nfunction\n \ngetIsAdminAttribute\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nattributes\n[\nadmin\n]\n \n==\n \nyes\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAfter creating the accessor, add the attribute name to the \nappends\n property on the model. Note that attribute names are typically referenced in \"snake case\", even though the accessor is defined using \"camel case\":\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The accessors to append to the model\ns array form.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$appends\n \n=\n \n[\nis_admin\n];\n\n\n}\n\n\n\n\n\n\nOnce the attribute has been added to the \nappends\n list, it will be included in both the model's array and JSON representations. Attributes in the \nappends\n array will also respect the \nvisible\n and \nhidden\n settings configured on the model.", 
            "title": "Eloquent serialization"
        }, 
        {
            "location": "/eloquent-serialization/#eloquent-serialization", 
            "text": "Introduction  Serializing Models   Collections  Serializing To Arrays  Serializing To JSON    Hiding Attributes From JSON  Appending Values To JSON", 
            "title": "Eloquent: Serialization"
        }, 
        {
            "location": "/eloquent-serialization/#introduction", 
            "text": "When building JSON APIs, you will often need to convert your models and relationships to arrays or JSON. Eloquent includes convenient methods for making these conversions, as well as controlling which attributes are included in your serializations.", 
            "title": "Introduction"
        }, 
        {
            "location": "/eloquent-serialization/#serializing-models-collections", 
            "text": "", 
            "title": "Serializing Models &amp; Collections"
        }, 
        {
            "location": "/eloquent-serialization/#serializing-to-arrays", 
            "text": "To convert a model and its loaded  relationships  to an array, you should use the  toArray  method. This method is recursive, so all attributes and all relations (including the relations of relations) will be converted to arrays:  $ user   =   App \\ User :: with ( roles ) - first ();  return   $ user- toArray ();   You may also convert entire  collections  of models to arrays:  $ users   =   App \\ User :: all ();  return   $ users- toArray ();", 
            "title": "Serializing To Arrays"
        }, 
        {
            "location": "/eloquent-serialization/#serializing-to-json", 
            "text": "To convert a model to JSON, you should use the  toJson  method. Like  toArray , the  toJson  method is recursive, so all attributes and relations will be converted to JSON:  $ user   =   App \\ User :: find ( 1 );  return   $ user- toJson ();   Alternatively, you may cast a model or collection to a string, which will automatically call the  toJson  method on the model or collection:  $ user   =   App \\ User :: find ( 1 );  return   ( string )   $ user ;   Since models and collections are converted to JSON when cast to a string, you can return Eloquent objects directly from your application's routes or controllers:  Route :: get ( users ,   function   ()   { \n     return   App\\ User : : all ();  } );", 
            "title": "Serializing To JSON"
        }, 
        {
            "location": "/eloquent-serialization/#hiding-attributes-from-json", 
            "text": "Sometimes you may wish to limit the attributes, such as passwords, that are included in your model's array or JSON representation. To do so, add a  $hidden  property to your model:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * The attributes that should be hidden for arrays.       *       * @var array       */ \n     protected   $hidden   =   [ password ];  }    {note} When hiding relationships, use the relationship's method name, not its dynamic property name.   Alternatively, you may use the  visible  property to define a white-list of attributes that should be included in your model's array and JSON representation. All other attributes will be hidden when the model is converted to an array or JSON:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * The attributes that should be visible in arrays.       *       * @var array       */ \n     protected   $visible   =   [ first_name ,   last_name ];  }", 
            "title": "Hiding Attributes From JSON"
        }, 
        {
            "location": "/eloquent-serialization/#temporarily-modifying-attribute-visibility", 
            "text": "If you would like to make some typically hidden attributes visible on a given model instance, you may use the  makeVisible  method. The  makeVisible  method returns the model instance for convenient method chaining:  return $user- makeVisible( attribute )- toArray();  Likewise, if you would like to make some typically visible attributes hidden on a given model instance, you may use the  makeHidden  method.  return $user- makeHidden( attribute )- toArray();", 
            "title": "Temporarily Modifying Attribute Visibility"
        }, 
        {
            "location": "/eloquent-serialization/#appending-values-to-json", 
            "text": "Occasionally, when casting models to an array or JSON, you may wish to add attributes that do not have a corresponding column in your database. To do so, first define an  accessor  for the value:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * Get the administrator flag for the user.       *       * @return bool       */ \n     public   function   getIsAdminAttribute () \n     { \n         return   $this - attributes [ admin ]   ==   yes ; \n     }  }   After creating the accessor, add the attribute name to the  appends  property on the model. Note that attribute names are typically referenced in \"snake case\", even though the accessor is defined using \"camel case\":  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * The accessors to append to the model s array form.       *       * @var array       */ \n     protected   $appends   =   [ is_admin ];  }   Once the attribute has been added to the  appends  list, it will be included in both the model's array and JSON representations. Attributes in the  appends  array will also respect the  visible  and  hidden  settings configured on the model.", 
            "title": "Appending Values To JSON"
        }, 
        {
            "location": "/eloquent/", 
            "text": "Eloquent: Getting Started\n\n\n\n\nIntroduction\n\n\nDefining Models\n\n\nEloquent Model Conventions\n\n\n\n\n\n\nRetrieving Models\n\n\nCollections\n\n\nChunking Results\n\n\n\n\n\n\nRetrieving Single Models / Aggregates\n\n\nRetrieving Aggregates\n\n\n\n\n\n\nInserting \n Updating Models\n\n\nInserts\n\n\nUpdates\n\n\nMass Assignment\n\n\nOther Creation Methods\n\n\n\n\n\n\nDeleting Models\n\n\nSoft Deleting\n\n\nQuerying Soft Deleted Models\n\n\n\n\n\n\nQuery Scopes\n\n\nGlobal Scopes\n\n\nLocal Scopes\n\n\n\n\n\n\nEvents\n\n\nObservers\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nThe Eloquent ORM included with Laravel provides a beautiful, simple ActiveRecord implementation for working with your database. Each database table has a corresponding \"Model\" which is used to interact with that table. Models allow you to query for data in your tables, as well as insert new records into the table.\n\n\nBefore getting started, be sure to configure a database connection in \nconfig/database.php\n. For more information on configuring your database, check out \nthe documentation\n.\n\n\n\n\nDefining Models\n\n\nTo get started, let's create an Eloquent model. Models typically live in the \napp\n directory, but you are free to place them anywhere that can be auto-loaded according to your \ncomposer.json\n file. All Eloquent models extend \nIlluminate\\Database\\Eloquent\\Model\n class.\n\n\nThe easiest way to create a model instance is using the \nmake:model\n \nArtisan command\n:\n\n\nphp artisan make:model User\n\n\n\n\n\nIf you would like to generate a \ndatabase migration\n when you generate the model, you may use the \n--migration\n or \n-m\n option:\n\n\nphp artisan make:model User --migration\n\nphp artisan make:model User -m\n\n\n\n\n\n\n\nEloquent Model Conventions\n\n\nNow, let's look at an example \nFlight\n model, which we will use to retrieve and store information from our \nflights\n database table:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nFlight\n \nextends\n \nModel\n\n\n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\nTable Names\n\n\nNote that we did not tell Eloquent which table to use for our \nFlight\n model. By convention, the \"snake case\", plural name of the class will be used as the table name unless another name is explicitly specified. So, in this case, Eloquent will assume the \nFlight\n model stores records in the \nflights\n table. You may specify a custom table by defining a \ntable\n property on your model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nFlight\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The table associated with the model.\n\n\n     *\n\n\n     * @var string\n\n\n     */\n\n    \nprotected\n \n$table\n \n=\n \nmy_flights\n;\n\n\n}\n\n\n\n\n\n\nPrimary Keys\n\n\nEloquent will also assume that each table has a primary key column named \nid\n. You may define a \n$primaryKey\n property to override this convention.\n\n\nIn addition, Eloquent assumes that the primary key is an incrementing integer value, which means that by default the primary key will be cast to an \nint\n automatically. If you wish to use a non-incrementing or a non-numeric primary key you must set the public \n$incrementing\n property on your model to \nfalse\n.\n\n\nTimestamps\n\n\nBy default, Eloquent expects \ncreated_at\n and \nupdated_at\n columns to exist on your tables.  If you do not wish to have these columns automatically managed by Eloquent, set the \n$timestamps\n property on your model to \nfalse\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nFlight\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Indicates if the model should be timestamped.\n\n\n     *\n\n\n     * @var bool\n\n\n     */\n\n    \npublic\n \n$timestamps\n \n=\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\nIf you need to customize the format of your timestamps, set the \n$dateFormat\n property on your model. This property determines how date attributes are stored in the database, as well as their format when the model is serialized to an array or JSON:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nFlight\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The storage format of the model\ns date columns.\n\n\n     *\n\n\n     * @var string\n\n\n     */\n\n    \nprotected\n \n$dateFormat\n \n=\n \nU\n;\n\n\n}\n\n\n\n\n\n\nIf you need to customize the names of the columns used to store the timestamps, you may set the \nCREATED_AT\n and \nUPDATED_AT\n constants in your model:\n\n\n?\nphp\n\n\n\nclass\n \nFlight\n \nextends\n \nModel\n\n\n{\n\n    \nconst\n \nCREATED_AT\n \n=\n \ncreation_date\n;\n\n    \nconst\n \nUPDATED_AT\n \n=\n \nlast_update\n;\n\n\n}\n\n\n\n\n\n\nDatabase Connection\n\n\nBy default, all Eloquent models will use the default database connection configured for your application. If you would like to specify a different connection for the model, use the \n$connection\n property:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nFlight\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The connection name for the model.\n\n\n     *\n\n\n     * @var string\n\n\n     */\n\n    \nprotected\n \n$connection\n \n=\n \nconnection-name\n;\n\n\n}\n\n\n\n\n\n\n\n\nRetrieving Models\n\n\nOnce you have created a model and \nits associated database table\n, you are ready to start retrieving data from your database. Think of each Eloquent model as a powerful \nquery builder\n allowing you to fluently query the database table associated with the model. For example:\n\n\n?php\n\n\n\nuse\n \nApp\\Flight\n;\n\n\n\n$flights\n \n=\n \nApp\\Flight\n::\nall\n();\n\n\n\nforeach\n \n(\n$flights\n \nas\n \n$flight\n)\n \n{\n\n    \necho\n \n$flight\n-\nname\n;\n\n\n}\n\n\n\n\n\n\nAdding Additional Constraints\n\n\nThe Eloquent \nall\n method will return all of the results in the model's table. Since each Eloquent model serves as a \nquery builder\n, you may also add constraints to queries, and then use the \nget\n method to retrieve the results:\n\n\n$flights = App\\Flight::where(\nactive\n, 1)\n               -\norderBy(\nname\n, \ndesc\n)\n               -\ntake(10)\n               -\nget();\n\n\n\n\n\n\n\n{tip} Since Eloquent models are query builders, you should review all of the methods available on the \nquery builder\n. You may use any of these methods in your Eloquent queries.\n\n\n\n\n\n\nCollections\n\n\nFor Eloquent methods like \nall\n and \nget\n which retrieve multiple results, an instance of \nIlluminate\\Database\\Eloquent\\Collection\n will be returned. The \nCollection\n class provides \na variety of helpful methods\n for working with your Eloquent results:\n\n\n$flights = $flights-\nreject(function ($flight) {\n    return $flight-\ncancelled;\n});\n\n\n\n\n\nOf course, you may also simply loop over the collection like an array:\n\n\nforeach ($flights as $flight) {\n    echo $flight-\nname;\n}\n\n\n\n\n\n\n\nChunking Results\n\n\nIf you need to process thousands of Eloquent records, use the \nchunk\n command. The \nchunk\n method will retrieve a \"chunk\" of Eloquent models, feeding them to a given \nClosure\n for processing. Using the \nchunk\n method will conserve memory when working with large result sets:\n\n\nFlight::chunk(200, function ($flights) {\n    foreach ($flights as $flight) {\n        //\n    }\n});\n\n\n\n\n\nThe first argument passed to the method is the number of records you wish to receive per \"chunk\". The Closure passed as the second argument will be called for each chunk that is retrieved from the database. A database query will be executed to retrieve each chunk of records passed to the Closure.\n\n\nUsing Cursors\n\n\nThe \ncursor\n method allows you to iterate through your database records using a cursor, which will only execute a single query. When processing large amounts of data, the \ncursor\n method may be used to greatly reduce your memory usage:\n\n\nforeach (Flight::where(\nfoo\n, \nbar\n)-\ncursor() as $flight) {\n    //\n}\n\n\n\n\n\n\n\nRetrieving Single Models / Aggregates\n\n\nOf course, in addition to retrieving all of the records for a given table, you may also retrieve single records using \nfind\n and \nfirst\n. Instead of returning a collection of models, these methods return a single model instance:\n\n\n//\n \nRetrieve\n \na\n \nmodel\n \nby\n \nits\n \nprimary\n \nkey\n...\n\n\n$\nflight\n \n=\n \nApp\n\\\nFlight\n::\nfind\n(\n1\n);\n\n\n\n//\n \nRetrieve\n \nthe\n \nfirst\n \nmodel\n \nmatching\n \nthe\n \nquery\n \nconstraints\n...\n\n\n$\nflight\n \n=\n \nApp\n\\\nFlight\n::\nwhere\n(\nactive\n,\n \n1\n)\n-\nfirst\n();\n\n\n\n\n\n\nYou may also call the \nfind\n method with an array of primary keys, which will return a collection of the matching records:\n\n\n$\nflights\n \n=\n \nApp\n\\\nFlight\n::\nfind\n(\n[\n1\n,\n \n2\n,\n \n3\n]\n);\n\n\n\n\n\n\nNot Found Exceptions\n\n\nSometimes you may wish to throw an exception if a model is not found. This is particularly useful in routes or controllers. The \nfindOrFail\n and \nfirstOrFail\n methods will retrieve the first result of the query; however, if no result is found, a \nIlluminate\\Database\\Eloquent\\ModelNotFoundException\n will be thrown:\n\n\n$\nmodel\n \n=\n \nApp\n\\\nFlight\n::\nfindOrFail\n(\n1\n);\n\n\n\n$\nmodel\n \n=\n \nApp\n\\\nFlight\n::\nwhere\n(\nlegs\n,\n \n,\n \n100\n)\n-\nfirstOrFail\n();\n\n\n\n\n\n\nIf the exception is not caught, a \n404\n HTTP response is automatically sent back to the user. It is not necessary to write explicit checks to return \n404\n responses when using these methods:\n\n\nRoute\n::\nget\n(\n/api/flights/{id}\n,\n \nfunction\n \n($\nid\n)\n \n{\n\n    \nreturn\n \nApp\\\nFlight\n:\n:\nfindOrFail\n(\n$\nid\n);\n\n\n}\n);\n\n\n\n\n\n\n\n\nRetrieving Aggregates\n\n\nYou may also use the \ncount\n, \nsum\n, \nmax\n, and other \naggregate methods\n provided by the \nquery builder\n. These methods return the appropriate scalar value instead of a full model instance:\n\n\n$\ncount\n \n=\n \nApp\n\\\nFlight\n::\nwhere\n(\nactive\n,\n \n1\n)\n-\ncount\n();\n\n\n\n$\nmax\n \n=\n \nApp\n\\\nFlight\n::\nwhere\n(\nactive\n,\n \n1\n)\n-\nmax\n(\nprice\n);\n\n\n\n\n\n\n\n\nInserting \n Updating Models\n\n\n\n\nInserts\n\n\nTo create a new record in the database, simply create a new model instance, set attributes on the model, then call the \nsave\n method:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nFlight\n;\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nFlightController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Create a new flight instance.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nstore\n(\nRequest\n \n$request\n)\n\n    \n{\n\n        \n// Validate the request...\n\n\n        \n$flight\n \n=\n \nnew\n \nFlight\n;\n\n\n        \n$flight\n-\nname\n \n=\n \n$request\n-\nname\n;\n\n\n        \n$flight\n-\nsave\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIn this example, we simply assign the \nname\n parameter from the incoming HTTP request to the \nname\n attribute of the \nApp\\Flight\n model instance. When we call the \nsave\n method, a record will be inserted into the database. The \ncreated_at\n and \nupdated_at\n timestamps will automatically be set when the \nsave\n method is called, so there is no need to set them manually.\n\n\n\n\nUpdates\n\n\nThe \nsave\n method may also be used to update models that already exist in the database. To update a model, you should retrieve it, set any attributes you wish to update, and then call the \nsave\n method. Again, the \nupdated_at\n timestamp will automatically be updated, so there is no need to manually set its value:\n\n\n$\nflight\n \n=\n \nApp\n\\\nFlight\n::\nfind\n(\n1\n);\n\n\n\n$\nflight-\nname\n \n=\n \nNew Flight Name\n;\n\n\n\n$\nflight-\nsave\n();\n\n\n\n\n\n\nMass Updates\n\n\nUpdates can also be performed against any number of models that match a given query. In this example, all flights that are \nactive\n and have a \ndestination\n of \nSan Diego\n will be marked as delayed:\n\n\nApp\\Flight::where(\nactive\n, 1)\n          -\nwhere(\ndestination\n, \nSan Diego\n)\n          -\nupdate([\ndelayed\n =\n 1]);\n\n\n\n\n\nThe \nupdate\n method expects an array of column and value pairs representing the columns that should be updated.\n\n\n\n\n{note} When issuing a mass update via Eloquent, the \nsaved\n and \nupdated\n model events will not be fired for the updated models. This is because the models are never actually retrieved when issuing a mass update.\n\n\n\n\n\n\nMass Assignment\n\n\nYou may also use the \ncreate\n method to save a new model in a single line. The inserted model instance will be returned to you from the method. However, before doing so, you will need to specify either a \nfillable\n or \nguarded\n attribute on the model, as all Eloquent models protect against mass-assignment by default.\n\n\nA mass-assignment vulnerability occurs when a user passes an unexpected HTTP parameter through a request, and that parameter changes a column in your database you did not expect. For example, a malicious user might send an \nis_admin\n parameter through an HTTP request, which is then passed into your model's \ncreate\n method, allowing the user to escalate themselves to an administrator.\n\n\nSo, to get started, you should define which model attributes you want to make mass assignable. You may do this using the \n$fillable\n property on the model. For example, let's make the \nname\n attribute of our \nFlight\n model mass assignable:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nFlight\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The attributes that are mass assignable.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$fillable\n \n=\n \n[\nname\n];\n\n\n}\n\n\n\n\n\n\nOnce we have made the attributes mass assignable, we can use the \ncreate\n method to insert a new record in the database. The \ncreate\n method returns the saved model instance:\n\n\n$\nflight\n \n=\n \nApp\n\\\nFlight\n::\ncreate\n(\n[\nname\n \n=\n \nFlight 10\n]\n);\n\n\n\n\n\n\nIf you already have a model instance, you may use the \nfill\n method to populate it with an array of attributes:\n\n\n$flight-\nfill([\nname\n =\n \nFlight 22\n]);\n\n\n\n\n\nGuarding Attributes\n\n\nWhile \n$fillable\n serves as a \"white list\" of attributes that should be mass assignable, you may also choose to use \n$guarded\n. The \n$guarded\n property should contain an array of attributes that you do not want to be mass assignable. All other attributes not in the array will be mass assignable. So, \n$guarded\n functions like a \"black list\". Of course, you should use either \n$fillable\n or \n$guarded\n - not both. In the example below, all attributes \nexcept for \nprice\n will be mass assignable:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nFlight\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The attributes that aren\nt mass assignable.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$guarded\n \n=\n \n[\nprice\n];\n\n\n}\n\n\n\n\n\n\nIf you would like to make all attributes mass assignable, you may define the \n$guarded\n property as an empty array:\n\n\n/**\n\n\n * The attributes that aren\nt mass assignable.\n\n\n *\n\n\n * @var array\n\n\n */\n\nprotected\n \n$\nguarded\n \n=\n \n[];\n\n\n\n\n\n\n\n\nOther Creation Methods\n\n\nfirstOrCreate\n/ \nfirstOrNew\n\n\nThere are two other methods you may use to create models by mass assigning attributes: \nfirstOrCreate\n and \nfirstOrNew\n. The \nfirstOrCreate\n method will attempt to locate a database record using the given column / value pairs. If the model can not be found in the database, a record will be inserted with the given attributes.\n\n\nThe \nfirstOrNew\n method, like \nfirstOrCreate\n will attempt to locate a record in the database matching the given attributes. However, if a model is not found, a new model instance will be returned. Note that the model returned by \nfirstOrNew\n has not yet been persisted to the database. You will need to call \nsave\n manually to persist it:\n\n\n//\n \nRetrieve\n \nthe\n \nflight\n \nby\n \nthe\n \nattributes\n,\n \nor\n \ncreate\n \nit\n \nif\n \nit\n \ndoesn\nt\n \nexist\n...\n\n\n$\nflight\n \n=\n \nApp\n\\\nFlight\n::\nfirstOrCreate\n(\n[\nname\n \n=\n \nFlight 10\n]\n);\n\n\n\n//\n \nRetrieve\n \nthe\n \nflight\n \nby\n \nthe\n \nattributes\n,\n \nor\n \ninstantiate\n \na\n \nnew\n \ninstance\n...\n\n\n$\nflight\n \n=\n \nApp\n\\\nFlight\n::\nfirstOrNew\n(\n[\nname\n \n=\n \nFlight 10\n]\n);\n\n\n\n\n\n\nupdateOrCreate\n\n\nYou may also come across situations where you want to update an existing model or create a new model if none exists. Laravel provides an \nupdateOrCreate\n method to do this in one step. Like the \nfirstOrCreate\n method, \nupdateOrCreate\n persists the model, so there's no need to call \nsave()\n:\n\n\n// If there\ns a flight from Oakland to San Diego, set the price to $99.\n// If no matching model exists, create one.\n$flight = App\\Flight::updateOrCreate(\n    [\ndeparture\n =\n \nOakland\n, \ndestination\n =\n \nSan Diego\n],\n    [\nprice\n =\n 99]\n);\n\n\n\n\n\n\n\nDeleting Models\n\n\nTo delete a model, call the \ndelete\n method on a model instance:\n\n\n$\nflight\n \n=\n \nApp\n\\\nFlight\n::\nfind\n(\n1\n);\n\n\n\n$\nflight-\ndelete\n();\n\n\n\n\n\n\nDeleting An Existing Model By Key\n\n\nIn the example above, we are retrieving the model from the database before calling the \ndelete\n method. However, if you know the primary key of the model, you may delete the model without retrieving it. To do so, call the \ndestroy\n method:\n\n\nApp\n\\\nFlight\n::\ndestroy\n(\n1\n);\n\n\n\nApp\n\\\nFlight\n::\ndestroy\n(\n[\n1\n,\n \n2\n,\n \n3\n]\n);\n\n\n\nApp\n\\\nFlight\n::\ndestroy\n(\n1\n,\n \n2\n,\n \n3\n);\n\n\n\n\n\n\nDeleting Models By Query\n\n\nOf course, you may also run a delete statement on a set of models. In this example, we will delete all flights that are marked as inactive. Like mass updates, mass deletes will not fire any model events for the models that are deleted:\n\n\n$\ndeletedRows\n \n=\n \nApp\n\\\nFlight\n::\nwhere\n(\nactive\n,\n \n0\n)\n-\ndelete\n();\n\n\n\n\n\n\n\n\n{note} When executing a mass delete statement via Eloquent, the \ndeleting\n and \ndeleted\n model events will not be fired for the deleted models. This is because the models are never actually retrieved when executing the delete statement.\n\n\n\n\n\n\nSoft Deleting\n\n\nIn addition to actually removing records from your database, Eloquent can also \"soft delete\" models. When models are soft deleted, they are not actually removed from your database. Instead, a \ndeleted_at\n attribute is set on the model and inserted into the database. If a model has a non-null \ndeleted_at\n value, the model has been soft deleted. To enable soft deletes for a model, use the \nIlluminate\\Database\\Eloquent\\SoftDeletes\n trait on the model and add the \ndeleted_at\n column to your \n$dates\n property:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nSoftDeletes\n;\n\n\n\nclass\n \nFlight\n \nextends\n \nModel\n\n\n{\n\n    \nuse\n \nSoftDeletes\n;\n\n\n    \n/**\n\n\n     * The attributes that should be mutated to dates.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$dates\n \n=\n \n[\ndeleted_at\n];\n\n\n}\n\n\n\n\n\n\nOf course, you should add the \ndeleted_at\n column to your database table. The Laravel \nschema builder\n contains a helper method to create this column:\n\n\nSchema::table(\nflights\n, function ($table) {\n    $table-\nsoftDeletes();\n});\n\n\n\n\n\nNow, when you call the \ndelete\n method on the model, the \ndeleted_at\n column will be set to the current date and time. And, when querying a model that uses soft deletes, the soft deleted models will automatically be excluded from all query results.\n\n\nTo determine if a given model instance has been soft deleted, use the \ntrashed\n method:\n\n\nif ($flight-\ntrashed()) {\n    //\n}\n\n\n\n\n\n\n\nQuerying Soft Deleted Models\n\n\nIncluding Soft Deleted Models\n\n\nAs noted above, soft deleted models will automatically be excluded from query results. However, you may force soft deleted models to appear in a result set using the \nwithTrashed\n method on the query:\n\n\n$flights = App\\Flight::withTrashed()\n                -\nwhere(\naccount_id\n, 1)\n                -\nget();\n\n\n\n\n\nThe \nwithTrashed\n method may also be used on a \nrelationship\n query:\n\n\n$flight-\nhistory()-\nwithTrashed()-\nget();\n\n\n\n\n\nRetrieving Only Soft Deleted Models\n\n\nThe \nonlyTrashed\n method will retrieve \nonly\n soft deleted models:\n\n\n$flights = App\\Flight::onlyTrashed()\n                -\nwhere(\nairline_id\n, 1)\n                -\nget();\n\n\n\n\n\nRestoring Soft Deleted Models\n\n\nSometimes you may wish to \"un-delete\" a soft deleted model. To restore a soft deleted model into an active state, use the \nrestore\n method on a model instance:\n\n\n$flight-\nrestore();\n\n\n\n\n\nYou may also use the \nrestore\n method in a query to quickly restore multiple models. Again, like other \"mass\" operations, this will not fire any model events for the models that are restored:\n\n\nApp\\Flight::withTrashed()\n        -\nwhere(\nairline_id\n, 1)\n        -\nrestore();\n\n\n\n\n\nLike the \nwithTrashed\n method, the \nrestore\n method may also be used on \nrelationships\n:\n\n\n$flight-\nhistory()-\nrestore();\n\n\n\n\n\nPermanently Deleting Models\n\n\nSometimes you may need to truly remove a model from your database. To permanently remove a soft deleted model from the database, use the \nforceDelete\n method:\n\n\n// Force deleting a single model instance...\n$flight-\nforceDelete();\n\n// Force deleting all related models...\n$flight-\nhistory()-\nforceDelete();\n\n\n\n\n\n\n\nQuery Scopes\n\n\n\n\nGlobal Scopes\n\n\nGlobal scopes allow you to add constraints to all queries for a given model. Laravel's own \nsoft delete\n functionality utilizes global scopes to only pull \"non-deleted\" models from the database. Writing your own global scopes can provide a convenient, easy way to make sure every query for a given model receives certain constraints.\n\n\nWriting Global Scopes\n\n\nWriting a global scope is simple. Define a class that implements the \nIlluminate\\Database\\Eloquent\\Scope\n interface. This interface requires you to implement one method: \napply\n. The \napply\n method may add \nwhere\n constraints to the query as needed:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nScopes\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nScope\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nBuilder\n;\n\n\n\nclass\n \nAgeScope\n \nimplements\n \nScope\n\n\n{\n\n    \n/**\n\n\n     * Apply the scope to a given Eloquent query builder.\n\n\n     *\n\n\n     * @param  \\Illuminate\\Database\\Eloquent\\Builder  $builder\n\n\n     * @param  \\Illuminate\\Database\\Eloquent\\Model  $model\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \napply\n(\nBuilder\n \n$builder\n,\n \nModel\n \n$model\n)\n\n    \n{\n\n        \n$builder\n-\nwhere\n(\nage\n,\n \n,\n \n200\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n{tip} There is not a predefined folder for scopes in a default Laravel application, so feel free to make your own \nScopes\n folder within your Laravel application's \napp\n directory.\n\n\n\n\nApplying Global Scopes\n\n\nTo assign a global scope to a model, you should override a given model's \nboot\n method and use the \naddGlobalScope\n method:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nApp\n\\\nScopes\n\\\nAgeScope\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The \nbooting\n method of the model.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \nprotected\n \nstatic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nparent\n::\nboot\n();\n\n\n        \nstatic\n::\naddGlobalScope\n(\nnew\n \nAgeScope\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAfter adding the scope, a query to \nUser::all()\n will produce the following SQL:\n\n\nselect * from `users` where `age` \n 200\n\n\n\n\n\nAnonymous Global Scopes\n\n\nEloquent also allows you to define global scopes using Closures, which is particularly useful for simple scopes that do not warrant a separate class:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nBuilder\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The \nbooting\n method of the model.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \nprotected\n \nstatic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nparent\n::\nboot\n();\n\n\n        \nstatic\n::\naddGlobalScope\n(\nage\n,\n \nfunction\n \n(\nBuilder\n \n$builder\n)\n \n{\n\n            \n$builder\n-\nwhere\n(\nage\n,\n \n,\n \n200\n);\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRemoving Global Scopes\n\n\nIf you would like to remove a global scope for a given query, you may use the \nwithoutGlobalScope\n method. The method accepts the class name of the global scope as its only argument:\n\n\nUser\n::\nwithoutGlobalScope\n(\nAgeScope\n::\nclass\n)\n-\nget\n();\n\n\n\n\n\n\nIf you would like to remove several or even all of the global scopes, you may use the \nwithoutGlobalScopes\n method:\n\n\n//\n \nRemove\n \nall\n \nof\n \nthe\n \nglobal\n \nscopes\n...\n\n\nUser\n::\nwithoutGlobalScopes\n()\n-\nget\n();\n\n\n\n//\n \nRemove\n \nsome\n \nof\n \nthe\n \nglobal\n \nscopes\n...\n\n\nUser\n::\nwithoutGlobalScopes\n(\n[\n\n    \nFirstScope\n::class\n,\n \nSecondScope\n::class\n\n\n]\n)\n-\nget\n();\n\n\n\n\n\n\n\n\nLocal Scopes\n\n\nLocal scopes allow you to define common sets of constraints that you may easily re-use throughout your application. For example, you may need to frequently retrieve all users that are considered \"popular\". To define a scope, simply prefix an Eloquent model method with \nscope\n.\n\n\nScopes should always return a query builder instance:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Scope a query to only include popular users.\n\n\n     *\n\n\n     * @param \\Illuminate\\Database\\Eloquent\\Builder $query\n\n\n     * @return \\Illuminate\\Database\\Eloquent\\Builder\n\n\n     */\n\n    \npublic\n \nfunction\n \nscopePopular\n(\n$query\n)\n\n    \n{\n\n        \nreturn\n \n$query\n-\nwhere\n(\nvotes\n,\n \n,\n \n100\n);\n\n    \n}\n\n\n    \n/**\n\n\n     * Scope a query to only include active users.\n\n\n     *\n\n\n     * @param \\Illuminate\\Database\\Eloquent\\Builder $query\n\n\n     * @return \\Illuminate\\Database\\Eloquent\\Builder\n\n\n     */\n\n    \npublic\n \nfunction\n \nscopeActive\n(\n$query\n)\n\n    \n{\n\n        \nreturn\n \n$query\n-\nwhere\n(\nactive\n,\n \n1\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nUtilizing A Local Scope\n\n\nOnce the scope has been defined, you may call the scope methods when querying the model. However, you do not need to include the \nscope\n prefix when calling the method. You can even chain calls to various scopes, for example:\n\n\n$\nusers\n \n=\n \nApp\n\\\nUser\n::\npopular\n()\n-\nactive\n()\n-\norderBy\n(\ncreated_at\n)\n-\nget\n();\n\n\n\n\n\n\nDynamic Scopes\n\n\nSometimes you may wish to define a scope that accepts parameters. To get started, just add your additional parameters to your scope. Scope parameters should be defined after the \n$query\n parameter:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nUser\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * Scope a query to only include users of a given type.\n\n\n     *\n\n\n     * @param \\Illuminate\\Database\\Eloquent\\Builder $query\n\n\n     * @param mixed $type\n\n\n     * @return \\Illuminate\\Database\\Eloquent\\Builder\n\n\n     */\n\n    \npublic\n \nfunction\n \nscopeOfType\n(\n$query\n,\n \n$type\n)\n\n    \n{\n\n        \nreturn\n \n$query\n-\nwhere\n(\ntype\n,\n \n$type\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow, you may pass the parameters when calling the scope:\n\n\n$\nusers\n \n=\n \nApp\n\\\nUser\n::\nofType\n(\nadmin\n)\n-\nget\n();\n\n\n\n\n\n\n\n\nEvents\n\n\nEloquent models fire several events, allowing you to hook into the following points in a model's lifecycle: \ncreating\n, \ncreated\n, \nupdating\n, \nupdated\n, \nsaving\n, \nsaved\n, \ndeleting\n, \ndeleted\n, \nrestoring\n, \nrestored\n. Events allow you to easily execute code each time a specific model class is saved or updated in the database.\n\n\nWhenever a new model is saved for the first time, the \ncreating\n and \ncreated\n events will fire. If a model already existed in the database and the \nsave\n method is called, the \nupdating\n / \nupdated\n events will fire. However, in both cases, the \nsaving\n / \nsaved\n events will fire.\n\n\nTo get started, define an \n$events\n property on your Eloquent model that maps various points of the Eloquent model's lifecycle to your own \nevent classes\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nApp\n\\\nEvents\n\\\nUserSaved\n;\n\n\nuse\n \nApp\n\\\nEvents\n\\\nUserDeleted\n;\n\n\nuse\n \nIlluminate\n\\\nNotifications\n\\\nNotifiable\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nAuth\n\\\nUser\n \nas\n \nAuthenticatable\n;\n\n\n\nclass\n \nUser\n \nextends\n \nAuthenticatable\n\n\n{\n\n    \nuse\n \nNotifiable\n;\n\n\n    \n/**\n\n\n     * The event map for the model.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$events\n \n=\n \n[\n\n        \nsaved\n \n=\n \nUserSaved\n::\nclass\n,\n\n        \ndeleted\n \n=\n \nUserDeleted\n::\nclass\n,\n\n    \n];\n\n\n}\n\n\n\n\n\n\n\n\nObservers\n\n\nIf you are listening for many events on a given model, you may use observers to group all of your listeners into a single class. Observers classes have method names which reflect the Eloquent events you wish to listen for. Each of these methods receives the model as their only argument. Laravel does not include a default directory for observers, so you may create any directory you like to house your observer classes:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nObservers\n;\n\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\n\nclass\n \nUserObserver\n\n\n{\n\n    \n/**\n\n\n     * Listen to the User created event.\n\n\n     *\n\n\n     * @param  User  $user\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \ncreated\n(\nUser\n \n$user\n)\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n    \n/**\n\n\n     * Listen to the User deleting event.\n\n\n     *\n\n\n     * @param  User  $user\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \ndeleting\n(\nUser\n \n$user\n)\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nTo register an observer, use the \nobserve\n method on the model you wish to observe. You may register observers in the \nboot\n method of one of your service providers. In this example, we'll register the observer in the \nAppServiceProvider\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\nuse\n \nApp\n\\\nObservers\n\\\nUserObserver\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\n\nclass\n \nAppServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Bootstrap any application services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nUser\n::\nobserve\n(\nUserObserver\n::\nclass\n);\n\n    \n}\n\n\n    \n/**\n\n\n     * Register the service provider.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}", 
            "title": "Eloquent"
        }, 
        {
            "location": "/eloquent/#eloquent-getting-started", 
            "text": "Introduction  Defining Models  Eloquent Model Conventions    Retrieving Models  Collections  Chunking Results    Retrieving Single Models / Aggregates  Retrieving Aggregates    Inserting   Updating Models  Inserts  Updates  Mass Assignment  Other Creation Methods    Deleting Models  Soft Deleting  Querying Soft Deleted Models    Query Scopes  Global Scopes  Local Scopes    Events  Observers", 
            "title": "Eloquent: Getting Started"
        }, 
        {
            "location": "/eloquent/#introduction", 
            "text": "The Eloquent ORM included with Laravel provides a beautiful, simple ActiveRecord implementation for working with your database. Each database table has a corresponding \"Model\" which is used to interact with that table. Models allow you to query for data in your tables, as well as insert new records into the table.  Before getting started, be sure to configure a database connection in  config/database.php . For more information on configuring your database, check out  the documentation .", 
            "title": "Introduction"
        }, 
        {
            "location": "/eloquent/#defining-models", 
            "text": "To get started, let's create an Eloquent model. Models typically live in the  app  directory, but you are free to place them anywhere that can be auto-loaded according to your  composer.json  file. All Eloquent models extend  Illuminate\\Database\\Eloquent\\Model  class.  The easiest way to create a model instance is using the  make:model   Artisan command :  php artisan make:model User  If you would like to generate a  database migration  when you generate the model, you may use the  --migration  or  -m  option:  php artisan make:model User --migration\n\nphp artisan make:model User -m", 
            "title": "Defining Models"
        }, 
        {
            "location": "/eloquent/#eloquent-model-conventions", 
            "text": "Now, let's look at an example  Flight  model, which we will use to retrieve and store information from our  flights  database table:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Flight   extends   Model  { \n     //  }", 
            "title": "Eloquent Model Conventions"
        }, 
        {
            "location": "/eloquent/#table-names", 
            "text": "Note that we did not tell Eloquent which table to use for our  Flight  model. By convention, the \"snake case\", plural name of the class will be used as the table name unless another name is explicitly specified. So, in this case, Eloquent will assume the  Flight  model stores records in the  flights  table. You may specify a custom table by defining a  table  property on your model:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Flight   extends   Model  { \n     /**       * The table associated with the model.       *       * @var string       */ \n     protected   $table   =   my_flights ;  }", 
            "title": "Table Names"
        }, 
        {
            "location": "/eloquent/#primary-keys", 
            "text": "Eloquent will also assume that each table has a primary key column named  id . You may define a  $primaryKey  property to override this convention.  In addition, Eloquent assumes that the primary key is an incrementing integer value, which means that by default the primary key will be cast to an  int  automatically. If you wish to use a non-incrementing or a non-numeric primary key you must set the public  $incrementing  property on your model to  false .", 
            "title": "Primary Keys"
        }, 
        {
            "location": "/eloquent/#timestamps", 
            "text": "By default, Eloquent expects  created_at  and  updated_at  columns to exist on your tables.  If you do not wish to have these columns automatically managed by Eloquent, set the  $timestamps  property on your model to  false :  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Flight   extends   Model  { \n     /**       * Indicates if the model should be timestamped.       *       * @var bool       */ \n     public   $timestamps   =   false ;  }   If you need to customize the format of your timestamps, set the  $dateFormat  property on your model. This property determines how date attributes are stored in the database, as well as their format when the model is serialized to an array or JSON:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Flight   extends   Model  { \n     /**       * The storage format of the model s date columns.       *       * @var string       */ \n     protected   $dateFormat   =   U ;  }   If you need to customize the names of the columns used to store the timestamps, you may set the  CREATED_AT  and  UPDATED_AT  constants in your model:  ? php  class   Flight   extends   Model  { \n     const   CREATED_AT   =   creation_date ; \n     const   UPDATED_AT   =   last_update ;  }", 
            "title": "Timestamps"
        }, 
        {
            "location": "/eloquent/#database-connection", 
            "text": "By default, all Eloquent models will use the default database connection configured for your application. If you would like to specify a different connection for the model, use the  $connection  property:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Flight   extends   Model  { \n     /**       * The connection name for the model.       *       * @var string       */ \n     protected   $connection   =   connection-name ;  }", 
            "title": "Database Connection"
        }, 
        {
            "location": "/eloquent/#retrieving-models", 
            "text": "Once you have created a model and  its associated database table , you are ready to start retrieving data from your database. Think of each Eloquent model as a powerful  query builder  allowing you to fluently query the database table associated with the model. For example:  ?php  use   App\\Flight ;  $flights   =   App\\Flight :: all ();  foreach   ( $flights   as   $flight )   { \n     echo   $flight - name ;  }", 
            "title": "Retrieving Models"
        }, 
        {
            "location": "/eloquent/#adding-additional-constraints", 
            "text": "The Eloquent  all  method will return all of the results in the model's table. Since each Eloquent model serves as a  query builder , you may also add constraints to queries, and then use the  get  method to retrieve the results:  $flights = App\\Flight::where( active , 1)\n               - orderBy( name ,  desc )\n               - take(10)\n               - get();   {tip} Since Eloquent models are query builders, you should review all of the methods available on the  query builder . You may use any of these methods in your Eloquent queries.", 
            "title": "Adding Additional Constraints"
        }, 
        {
            "location": "/eloquent/#collections", 
            "text": "For Eloquent methods like  all  and  get  which retrieve multiple results, an instance of  Illuminate\\Database\\Eloquent\\Collection  will be returned. The  Collection  class provides  a variety of helpful methods  for working with your Eloquent results:  $flights = $flights- reject(function ($flight) {\n    return $flight- cancelled;\n});  Of course, you may also simply loop over the collection like an array:  foreach ($flights as $flight) {\n    echo $flight- name;\n}", 
            "title": "Collections"
        }, 
        {
            "location": "/eloquent/#chunking-results", 
            "text": "If you need to process thousands of Eloquent records, use the  chunk  command. The  chunk  method will retrieve a \"chunk\" of Eloquent models, feeding them to a given  Closure  for processing. Using the  chunk  method will conserve memory when working with large result sets:  Flight::chunk(200, function ($flights) {\n    foreach ($flights as $flight) {\n        //\n    }\n});  The first argument passed to the method is the number of records you wish to receive per \"chunk\". The Closure passed as the second argument will be called for each chunk that is retrieved from the database. A database query will be executed to retrieve each chunk of records passed to the Closure.", 
            "title": "Chunking Results"
        }, 
        {
            "location": "/eloquent/#using-cursors", 
            "text": "The  cursor  method allows you to iterate through your database records using a cursor, which will only execute a single query. When processing large amounts of data, the  cursor  method may be used to greatly reduce your memory usage:  foreach (Flight::where( foo ,  bar )- cursor() as $flight) {\n    //\n}", 
            "title": "Using Cursors"
        }, 
        {
            "location": "/eloquent/#retrieving-single-models-aggregates", 
            "text": "Of course, in addition to retrieving all of the records for a given table, you may also retrieve single records using  find  and  first . Instead of returning a collection of models, these methods return a single model instance:  //   Retrieve   a   model   by   its   primary   key ...  $ flight   =   App \\ Flight :: find ( 1 );  //   Retrieve   the   first   model   matching   the   query   constraints ...  $ flight   =   App \\ Flight :: where ( active ,   1 ) - first ();   You may also call the  find  method with an array of primary keys, which will return a collection of the matching records:  $ flights   =   App \\ Flight :: find ( [ 1 ,   2 ,   3 ] );", 
            "title": "Retrieving Single Models / Aggregates"
        }, 
        {
            "location": "/eloquent/#not-found-exceptions", 
            "text": "Sometimes you may wish to throw an exception if a model is not found. This is particularly useful in routes or controllers. The  findOrFail  and  firstOrFail  methods will retrieve the first result of the query; however, if no result is found, a  Illuminate\\Database\\Eloquent\\ModelNotFoundException  will be thrown:  $ model   =   App \\ Flight :: findOrFail ( 1 );  $ model   =   App \\ Flight :: where ( legs ,   ,   100 ) - firstOrFail ();   If the exception is not caught, a  404  HTTP response is automatically sent back to the user. It is not necessary to write explicit checks to return  404  responses when using these methods:  Route :: get ( /api/flights/{id} ,   function   ($ id )   { \n     return   App\\ Flight : : findOrFail ( $ id );  } );", 
            "title": "Not Found Exceptions"
        }, 
        {
            "location": "/eloquent/#retrieving-aggregates", 
            "text": "You may also use the  count ,  sum ,  max , and other  aggregate methods  provided by the  query builder . These methods return the appropriate scalar value instead of a full model instance:  $ count   =   App \\ Flight :: where ( active ,   1 ) - count ();  $ max   =   App \\ Flight :: where ( active ,   1 ) - max ( price );", 
            "title": "Retrieving Aggregates"
        }, 
        {
            "location": "/eloquent/#inserting-updating-models", 
            "text": "", 
            "title": "Inserting &amp; Updating Models"
        }, 
        {
            "location": "/eloquent/#inserts", 
            "text": "To create a new record in the database, simply create a new model instance, set attributes on the model, then call the  save  method:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ Flight ;  use   Illuminate \\ Http \\ Request ;  use   App \\ Http \\ Controllers \\ Controller ;  class   FlightController   extends   Controller  { \n     /**       * Create a new flight instance.       *       * @param  Request  $request       * @return Response       */ \n     public   function   store ( Request   $request ) \n     { \n         // Validate the request... \n\n         $flight   =   new   Flight ; \n\n         $flight - name   =   $request - name ; \n\n         $flight - save (); \n     }  }   In this example, we simply assign the  name  parameter from the incoming HTTP request to the  name  attribute of the  App\\Flight  model instance. When we call the  save  method, a record will be inserted into the database. The  created_at  and  updated_at  timestamps will automatically be set when the  save  method is called, so there is no need to set them manually.", 
            "title": "Inserts"
        }, 
        {
            "location": "/eloquent/#updates", 
            "text": "The  save  method may also be used to update models that already exist in the database. To update a model, you should retrieve it, set any attributes you wish to update, and then call the  save  method. Again, the  updated_at  timestamp will automatically be updated, so there is no need to manually set its value:  $ flight   =   App \\ Flight :: find ( 1 );  $ flight- name   =   New Flight Name ;  $ flight- save ();", 
            "title": "Updates"
        }, 
        {
            "location": "/eloquent/#mass-updates", 
            "text": "Updates can also be performed against any number of models that match a given query. In this example, all flights that are  active  and have a  destination  of  San Diego  will be marked as delayed:  App\\Flight::where( active , 1)\n          - where( destination ,  San Diego )\n          - update([ delayed  =  1]);  The  update  method expects an array of column and value pairs representing the columns that should be updated.   {note} When issuing a mass update via Eloquent, the  saved  and  updated  model events will not be fired for the updated models. This is because the models are never actually retrieved when issuing a mass update.", 
            "title": "Mass Updates"
        }, 
        {
            "location": "/eloquent/#mass-assignment", 
            "text": "You may also use the  create  method to save a new model in a single line. The inserted model instance will be returned to you from the method. However, before doing so, you will need to specify either a  fillable  or  guarded  attribute on the model, as all Eloquent models protect against mass-assignment by default.  A mass-assignment vulnerability occurs when a user passes an unexpected HTTP parameter through a request, and that parameter changes a column in your database you did not expect. For example, a malicious user might send an  is_admin  parameter through an HTTP request, which is then passed into your model's  create  method, allowing the user to escalate themselves to an administrator.  So, to get started, you should define which model attributes you want to make mass assignable. You may do this using the  $fillable  property on the model. For example, let's make the  name  attribute of our  Flight  model mass assignable:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Flight   extends   Model  { \n     /**       * The attributes that are mass assignable.       *       * @var array       */ \n     protected   $fillable   =   [ name ];  }   Once we have made the attributes mass assignable, we can use the  create  method to insert a new record in the database. The  create  method returns the saved model instance:  $ flight   =   App \\ Flight :: create ( [ name   =   Flight 10 ] );   If you already have a model instance, you may use the  fill  method to populate it with an array of attributes:  $flight- fill([ name  =   Flight 22 ]);", 
            "title": "Mass Assignment"
        }, 
        {
            "location": "/eloquent/#guarding-attributes", 
            "text": "While  $fillable  serves as a \"white list\" of attributes that should be mass assignable, you may also choose to use  $guarded . The  $guarded  property should contain an array of attributes that you do not want to be mass assignable. All other attributes not in the array will be mass assignable. So,  $guarded  functions like a \"black list\". Of course, you should use either  $fillable  or  $guarded  - not both. In the example below, all attributes  except for  price  will be mass assignable:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Flight   extends   Model  { \n     /**       * The attributes that aren t mass assignable.       *       * @var array       */ \n     protected   $guarded   =   [ price ];  }   If you would like to make all attributes mass assignable, you may define the  $guarded  property as an empty array:  /**   * The attributes that aren t mass assignable.   *   * @var array   */ \nprotected   $ guarded   =   [];", 
            "title": "Guarding Attributes"
        }, 
        {
            "location": "/eloquent/#other-creation-methods", 
            "text": "", 
            "title": "Other Creation Methods"
        }, 
        {
            "location": "/eloquent/#firstorcreate-firstornew", 
            "text": "There are two other methods you may use to create models by mass assigning attributes:  firstOrCreate  and  firstOrNew . The  firstOrCreate  method will attempt to locate a database record using the given column / value pairs. If the model can not be found in the database, a record will be inserted with the given attributes.  The  firstOrNew  method, like  firstOrCreate  will attempt to locate a record in the database matching the given attributes. However, if a model is not found, a new model instance will be returned. Note that the model returned by  firstOrNew  has not yet been persisted to the database. You will need to call  save  manually to persist it:  //   Retrieve   the   flight   by   the   attributes ,   or   create   it   if   it   doesn t   exist ...  $ flight   =   App \\ Flight :: firstOrCreate ( [ name   =   Flight 10 ] );  //   Retrieve   the   flight   by   the   attributes ,   or   instantiate   a   new   instance ...  $ flight   =   App \\ Flight :: firstOrNew ( [ name   =   Flight 10 ] );", 
            "title": "firstOrCreate/ firstOrNew"
        }, 
        {
            "location": "/eloquent/#updateorcreate", 
            "text": "You may also come across situations where you want to update an existing model or create a new model if none exists. Laravel provides an  updateOrCreate  method to do this in one step. Like the  firstOrCreate  method,  updateOrCreate  persists the model, so there's no need to call  save() :  // If there s a flight from Oakland to San Diego, set the price to $99.\n// If no matching model exists, create one.\n$flight = App\\Flight::updateOrCreate(\n    [ departure  =   Oakland ,  destination  =   San Diego ],\n    [ price  =  99]\n);", 
            "title": "updateOrCreate"
        }, 
        {
            "location": "/eloquent/#deleting-models", 
            "text": "To delete a model, call the  delete  method on a model instance:  $ flight   =   App \\ Flight :: find ( 1 );  $ flight- delete ();", 
            "title": "Deleting Models"
        }, 
        {
            "location": "/eloquent/#deleting-an-existing-model-by-key", 
            "text": "In the example above, we are retrieving the model from the database before calling the  delete  method. However, if you know the primary key of the model, you may delete the model without retrieving it. To do so, call the  destroy  method:  App \\ Flight :: destroy ( 1 );  App \\ Flight :: destroy ( [ 1 ,   2 ,   3 ] );  App \\ Flight :: destroy ( 1 ,   2 ,   3 );", 
            "title": "Deleting An Existing Model By Key"
        }, 
        {
            "location": "/eloquent/#deleting-models-by-query", 
            "text": "Of course, you may also run a delete statement on a set of models. In this example, we will delete all flights that are marked as inactive. Like mass updates, mass deletes will not fire any model events for the models that are deleted:  $ deletedRows   =   App \\ Flight :: where ( active ,   0 ) - delete ();    {note} When executing a mass delete statement via Eloquent, the  deleting  and  deleted  model events will not be fired for the deleted models. This is because the models are never actually retrieved when executing the delete statement.", 
            "title": "Deleting Models By Query"
        }, 
        {
            "location": "/eloquent/#soft-deleting", 
            "text": "In addition to actually removing records from your database, Eloquent can also \"soft delete\" models. When models are soft deleted, they are not actually removed from your database. Instead, a  deleted_at  attribute is set on the model and inserted into the database. If a model has a non-null  deleted_at  value, the model has been soft deleted. To enable soft deletes for a model, use the  Illuminate\\Database\\Eloquent\\SoftDeletes  trait on the model and add the  deleted_at  column to your  $dates  property:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  use   Illuminate \\ Database \\ Eloquent \\ SoftDeletes ;  class   Flight   extends   Model  { \n     use   SoftDeletes ; \n\n     /**       * The attributes that should be mutated to dates.       *       * @var array       */ \n     protected   $dates   =   [ deleted_at ];  }   Of course, you should add the  deleted_at  column to your database table. The Laravel  schema builder  contains a helper method to create this column:  Schema::table( flights , function ($table) {\n    $table- softDeletes();\n});  Now, when you call the  delete  method on the model, the  deleted_at  column will be set to the current date and time. And, when querying a model that uses soft deletes, the soft deleted models will automatically be excluded from all query results.  To determine if a given model instance has been soft deleted, use the  trashed  method:  if ($flight- trashed()) {\n    //\n}", 
            "title": "Soft Deleting"
        }, 
        {
            "location": "/eloquent/#querying-soft-deleted-models", 
            "text": "", 
            "title": "Querying Soft Deleted Models"
        }, 
        {
            "location": "/eloquent/#including-soft-deleted-models", 
            "text": "As noted above, soft deleted models will automatically be excluded from query results. However, you may force soft deleted models to appear in a result set using the  withTrashed  method on the query:  $flights = App\\Flight::withTrashed()\n                - where( account_id , 1)\n                - get();  The  withTrashed  method may also be used on a  relationship  query:  $flight- history()- withTrashed()- get();", 
            "title": "Including Soft Deleted Models"
        }, 
        {
            "location": "/eloquent/#retrieving-only-soft-deleted-models", 
            "text": "The  onlyTrashed  method will retrieve  only  soft deleted models:  $flights = App\\Flight::onlyTrashed()\n                - where( airline_id , 1)\n                - get();", 
            "title": "Retrieving Only Soft Deleted Models"
        }, 
        {
            "location": "/eloquent/#restoring-soft-deleted-models", 
            "text": "Sometimes you may wish to \"un-delete\" a soft deleted model. To restore a soft deleted model into an active state, use the  restore  method on a model instance:  $flight- restore();  You may also use the  restore  method in a query to quickly restore multiple models. Again, like other \"mass\" operations, this will not fire any model events for the models that are restored:  App\\Flight::withTrashed()\n        - where( airline_id , 1)\n        - restore();  Like the  withTrashed  method, the  restore  method may also be used on  relationships :  $flight- history()- restore();", 
            "title": "Restoring Soft Deleted Models"
        }, 
        {
            "location": "/eloquent/#permanently-deleting-models", 
            "text": "Sometimes you may need to truly remove a model from your database. To permanently remove a soft deleted model from the database, use the  forceDelete  method:  // Force deleting a single model instance...\n$flight- forceDelete();\n\n// Force deleting all related models...\n$flight- history()- forceDelete();", 
            "title": "Permanently Deleting Models"
        }, 
        {
            "location": "/eloquent/#query-scopes", 
            "text": "", 
            "title": "Query Scopes"
        }, 
        {
            "location": "/eloquent/#global-scopes", 
            "text": "Global scopes allow you to add constraints to all queries for a given model. Laravel's own  soft delete  functionality utilizes global scopes to only pull \"non-deleted\" models from the database. Writing your own global scopes can provide a convenient, easy way to make sure every query for a given model receives certain constraints.", 
            "title": "Global Scopes"
        }, 
        {
            "location": "/eloquent/#writing-global-scopes", 
            "text": "Writing a global scope is simple. Define a class that implements the  Illuminate\\Database\\Eloquent\\Scope  interface. This interface requires you to implement one method:  apply . The  apply  method may add  where  constraints to the query as needed:  ? php  namespace   App \\ Scopes ;  use   Illuminate \\ Database \\ Eloquent \\ Scope ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  use   Illuminate \\ Database \\ Eloquent \\ Builder ;  class   AgeScope   implements   Scope  { \n     /**       * Apply the scope to a given Eloquent query builder.       *       * @param  \\Illuminate\\Database\\Eloquent\\Builder  $builder       * @param  \\Illuminate\\Database\\Eloquent\\Model  $model       * @return void       */ \n     public   function   apply ( Builder   $builder ,   Model   $model ) \n     { \n         $builder - where ( age ,   ,   200 ); \n     }  }    {tip} There is not a predefined folder for scopes in a default Laravel application, so feel free to make your own  Scopes  folder within your Laravel application's  app  directory.", 
            "title": "Writing Global Scopes"
        }, 
        {
            "location": "/eloquent/#applying-global-scopes", 
            "text": "To assign a global scope to a model, you should override a given model's  boot  method and use the  addGlobalScope  method:  ? php  namespace   App ;  use   App \\ Scopes \\ AgeScope ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * The  booting  method of the model.       *       * @return void       */ \n     protected   static   function   boot () \n     { \n         parent :: boot (); \n\n         static :: addGlobalScope ( new   AgeScope ); \n     }  }   After adding the scope, a query to  User::all()  will produce the following SQL:  select * from `users` where `age`   200", 
            "title": "Applying Global Scopes"
        }, 
        {
            "location": "/eloquent/#anonymous-global-scopes", 
            "text": "Eloquent also allows you to define global scopes using Closures, which is particularly useful for simple scopes that do not warrant a separate class:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  use   Illuminate \\ Database \\ Eloquent \\ Builder ;  class   User   extends   Model  { \n     /**       * The  booting  method of the model.       *       * @return void       */ \n     protected   static   function   boot () \n     { \n         parent :: boot (); \n\n         static :: addGlobalScope ( age ,   function   ( Builder   $builder )   { \n             $builder - where ( age ,   ,   200 ); \n         }); \n     }  }", 
            "title": "Anonymous Global Scopes"
        }, 
        {
            "location": "/eloquent/#removing-global-scopes", 
            "text": "If you would like to remove a global scope for a given query, you may use the  withoutGlobalScope  method. The method accepts the class name of the global scope as its only argument:  User :: withoutGlobalScope ( AgeScope :: class ) - get ();   If you would like to remove several or even all of the global scopes, you may use the  withoutGlobalScopes  method:  //   Remove   all   of   the   global   scopes ...  User :: withoutGlobalScopes () - get ();  //   Remove   some   of   the   global   scopes ...  User :: withoutGlobalScopes ( [ \n     FirstScope ::class ,   SecondScope ::class  ] ) - get ();", 
            "title": "Removing Global Scopes"
        }, 
        {
            "location": "/eloquent/#local-scopes", 
            "text": "Local scopes allow you to define common sets of constraints that you may easily re-use throughout your application. For example, you may need to frequently retrieve all users that are considered \"popular\". To define a scope, simply prefix an Eloquent model method with  scope .  Scopes should always return a query builder instance:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * Scope a query to only include popular users.       *       * @param \\Illuminate\\Database\\Eloquent\\Builder $query       * @return \\Illuminate\\Database\\Eloquent\\Builder       */ \n     public   function   scopePopular ( $query ) \n     { \n         return   $query - where ( votes ,   ,   100 ); \n     } \n\n     /**       * Scope a query to only include active users.       *       * @param \\Illuminate\\Database\\Eloquent\\Builder $query       * @return \\Illuminate\\Database\\Eloquent\\Builder       */ \n     public   function   scopeActive ( $query ) \n     { \n         return   $query - where ( active ,   1 ); \n     }  }", 
            "title": "Local Scopes"
        }, 
        {
            "location": "/eloquent/#utilizing-a-local-scope", 
            "text": "Once the scope has been defined, you may call the scope methods when querying the model. However, you do not need to include the  scope  prefix when calling the method. You can even chain calls to various scopes, for example:  $ users   =   App \\ User :: popular () - active () - orderBy ( created_at ) - get ();", 
            "title": "Utilizing A Local Scope"
        }, 
        {
            "location": "/eloquent/#dynamic-scopes", 
            "text": "Sometimes you may wish to define a scope that accepts parameters. To get started, just add your additional parameters to your scope. Scope parameters should be defined after the  $query  parameter:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   User   extends   Model  { \n     /**       * Scope a query to only include users of a given type.       *       * @param \\Illuminate\\Database\\Eloquent\\Builder $query       * @param mixed $type       * @return \\Illuminate\\Database\\Eloquent\\Builder       */ \n     public   function   scopeOfType ( $query ,   $type ) \n     { \n         return   $query - where ( type ,   $type ); \n     }  }   Now, you may pass the parameters when calling the scope:  $ users   =   App \\ User :: ofType ( admin ) - get ();", 
            "title": "Dynamic Scopes"
        }, 
        {
            "location": "/eloquent/#events", 
            "text": "Eloquent models fire several events, allowing you to hook into the following points in a model's lifecycle:  creating ,  created ,  updating ,  updated ,  saving ,  saved ,  deleting ,  deleted ,  restoring ,  restored . Events allow you to easily execute code each time a specific model class is saved or updated in the database.  Whenever a new model is saved for the first time, the  creating  and  created  events will fire. If a model already existed in the database and the  save  method is called, the  updating  /  updated  events will fire. However, in both cases, the  saving  /  saved  events will fire.  To get started, define an  $events  property on your Eloquent model that maps various points of the Eloquent model's lifecycle to your own  event classes :  ? php  namespace   App ;  use   App \\ Events \\ UserSaved ;  use   App \\ Events \\ UserDeleted ;  use   Illuminate \\ Notifications \\ Notifiable ;  use   Illuminate \\ Foundation \\ Auth \\ User   as   Authenticatable ;  class   User   extends   Authenticatable  { \n     use   Notifiable ; \n\n     /**       * The event map for the model.       *       * @var array       */ \n     protected   $events   =   [ \n         saved   =   UserSaved :: class , \n         deleted   =   UserDeleted :: class , \n     ];  }", 
            "title": "Events"
        }, 
        {
            "location": "/eloquent/#observers", 
            "text": "If you are listening for many events on a given model, you may use observers to group all of your listeners into a single class. Observers classes have method names which reflect the Eloquent events you wish to listen for. Each of these methods receives the model as their only argument. Laravel does not include a default directory for observers, so you may create any directory you like to house your observer classes:  ? php  namespace   App \\ Observers ;  use   App \\ User ;  class   UserObserver  { \n     /**       * Listen to the User created event.       *       * @param  User  $user       * @return void       */ \n     public   function   created ( User   $user ) \n     { \n         // \n     } \n\n     /**       * Listen to the User deleting event.       *       * @param  User  $user       * @return void       */ \n     public   function   deleting ( User   $user ) \n     { \n         // \n     }  }   To register an observer, use the  observe  method on the model you wish to observe. You may register observers in the  boot  method of one of your service providers. In this example, we'll register the observer in the  AppServiceProvider :  ? php  namespace   App \\ Providers ;  use   App \\ User ;  use   App \\ Observers \\ UserObserver ;  use   Illuminate \\ Support \\ ServiceProvider ;  class   AppServiceProvider   extends   ServiceProvider  { \n     /**       * Bootstrap any application services.       *       * @return void       */ \n     public   function   boot () \n     { \n         User :: observe ( UserObserver :: class ); \n     } \n\n     /**       * Register the service provider.       *       * @return void       */ \n     public   function   register () \n     { \n         // \n     }  }", 
            "title": "Observers"
        }, 
        {
            "location": "/encryption/", 
            "text": "Encryption\n\n\n\n\nIntroduction\n\n\nConfiguration\n\n\nUsing The Encrypter\n\n\n\n\n\n\nIntroduction\n\n\nLaravel's encrypter uses OpenSSL to provide AES-256 and AES-128 encryption. You are strongly encouraged to use Laravel's built-in encryption facilities and not attempt to roll your own \"home grown\" encryption algorithms. All of Laravel's encrypted values are signed using a message authentication code (MAC) so that their underlying value can not be modified once encrypted.\n\n\n\n\nConfiguration\n\n\nBefore using Laravel's encrypter, you must set a \nkey\n option in your \nconfig/app.php\n configuration file. You should use the \nphp artisan key:generate\n command to generate this key since this Artisan command will use PHP's secure random bytes generator to build your key. If this value is not properly set, all values encrypted by Laravel will be insecure.\n\n\n\n\nUsing The Encrypter\n\n\nEncrypting A Value\n\n\nYou may encrypt a value using the \nencrypt\n helper. All encrypted values are encrypted using OpenSSL and the \nAES-256-CBC\n cipher. Furthermore, all encrypted values are signed with a message authentication code (MAC) to detect any modifications to the encrypted string:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Store a secret message for the user.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @param  int  $id\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nstoreSecret\n(\nRequest\n \n$request\n,\n \n$id\n)\n\n    \n{\n\n        \n$user\n \n=\n \nUser\n::\nfindOrFail\n(\n$id\n);\n\n\n        \n$user\n-\nfill\n([\n\n            \nsecret\n \n=\n \nencrypt\n(\n$request\n-\nsecret\n)\n\n        \n])\n-\nsave\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nEncrypting Without Serialization\n\n\nEncrypted values are passed through \nserialize\n during encryption, which allows for encryption of objects and arrays. Thus, non-PHP clients receiving encrypted values will need to \nunserialize\n the data. If you would like to encrypt and decrypt values without serialization, you may use the \nencryptString\n and \ndecryptString\n methods of the \nCrypt\n facade:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nCrypt\n;\n\n\n\n$\nencrypted\n \n=\n \nCrypt\n::\nencryptString\n(\nHello world.\n);\n\n\n\n$\ndecrypted\n \n=\n \nCrypt\n::\ndecryptString\n($\nencrypted\n);\n\n\n\n\n\n\nDecrypting A Value\n\n\nYou may decrypt values using the \ndecrypt\n helper. If the value can not be properly decrypted, such as when the MAC is invalid, an \nIlluminate\\Contracts\\Encryption\\DecryptException\n will be thrown:\n\n\nuse Illuminate\\Contracts\\Encryption\\DecryptException;\n\ntry {\n    $decrypted = decrypt($encryptedValue);\n} catch (DecryptException $e) {\n    //\n}", 
            "title": "Encryption"
        }, 
        {
            "location": "/encryption/#encryption", 
            "text": "Introduction  Configuration  Using The Encrypter", 
            "title": "Encryption"
        }, 
        {
            "location": "/encryption/#introduction", 
            "text": "Laravel's encrypter uses OpenSSL to provide AES-256 and AES-128 encryption. You are strongly encouraged to use Laravel's built-in encryption facilities and not attempt to roll your own \"home grown\" encryption algorithms. All of Laravel's encrypted values are signed using a message authentication code (MAC) so that their underlying value can not be modified once encrypted.", 
            "title": "Introduction"
        }, 
        {
            "location": "/encryption/#configuration", 
            "text": "Before using Laravel's encrypter, you must set a  key  option in your  config/app.php  configuration file. You should use the  php artisan key:generate  command to generate this key since this Artisan command will use PHP's secure random bytes generator to build your key. If this value is not properly set, all values encrypted by Laravel will be insecure.", 
            "title": "Configuration"
        }, 
        {
            "location": "/encryption/#using-the-encrypter", 
            "text": "", 
            "title": "Using The Encrypter"
        }, 
        {
            "location": "/encryption/#encrypting-a-value", 
            "text": "You may encrypt a value using the  encrypt  helper. All encrypted values are encrypted using OpenSSL and the  AES-256-CBC  cipher. Furthermore, all encrypted values are signed with a message authentication code (MAC) to detect any modifications to the encrypted string:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ User ;  use   Illuminate \\ Http \\ Request ;  use   App \\ Http \\ Controllers \\ Controller ;  class   UserController   extends   Controller  { \n     /**       * Store a secret message for the user.       *       * @param  Request  $request       * @param  int  $id       * @return Response       */ \n     public   function   storeSecret ( Request   $request ,   $id ) \n     { \n         $user   =   User :: findOrFail ( $id ); \n\n         $user - fill ([ \n             secret   =   encrypt ( $request - secret ) \n         ]) - save (); \n     }  }", 
            "title": "Encrypting A Value"
        }, 
        {
            "location": "/encryption/#encrypting-without-serialization", 
            "text": "Encrypted values are passed through  serialize  during encryption, which allows for encryption of objects and arrays. Thus, non-PHP clients receiving encrypted values will need to  unserialize  the data. If you would like to encrypt and decrypt values without serialization, you may use the  encryptString  and  decryptString  methods of the  Crypt  facade:  use   Illuminate \\ Support \\ Facades \\ Crypt ;  $ encrypted   =   Crypt :: encryptString ( Hello world. );  $ decrypted   =   Crypt :: decryptString ($ encrypted );", 
            "title": "Encrypting Without Serialization"
        }, 
        {
            "location": "/encryption/#decrypting-a-value", 
            "text": "You may decrypt values using the  decrypt  helper. If the value can not be properly decrypted, such as when the MAC is invalid, an  Illuminate\\Contracts\\Encryption\\DecryptException  will be thrown:  use Illuminate\\Contracts\\Encryption\\DecryptException;\n\ntry {\n    $decrypted = decrypt($encryptedValue);\n} catch (DecryptException $e) {\n    //\n}", 
            "title": "Decrypting A Value"
        }, 
        {
            "location": "/envoy/", 
            "text": "Envoy Task Runner\n\n\n\n\nIntroduction\n\n\nInstallation\n\n\n\n\n\n\nWriting Tasks\n\n\nSetup\n\n\nVariables\n\n\nStories\n\n\nMultiple Servers\n\n\n\n\n\n\nRunning Tasks\n\n\nConfirming Task Execution\n\n\n\n\n\n\nNotifications\n\n\nSlack\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nLaravel Envoy\n provides a clean, minimal syntax for defining common tasks you run on your remote servers. Using Blade style syntax, you can easily setup tasks for deployment, Artisan commands, and more. Currently, Envoy only supports the Mac and Linux operating systems.\n\n\n\n\nInstallation\n\n\nFirst, install Envoy using the Composer \nglobal require\n command:\n\n\ncomposer global require \nlaravel/envoy=~1.0\n\n\n\n\n\n\nSince global Composer libraries can sometimes cause package version conflicts, you may wish to consider using \ncgr\n, which is a drop-in replacement for the \ncomposer global require\n command. The \ncgr\n library's installation instructions can be \nfound on GitHub\n.\n\n\n\n\n{note} Make sure to place the \n~/.composer/vendor/bin\n directory in your PATH so the \nenvoy\n executable is found when running the \nenvoy\n command in your terminal.\n\n\n\n\nUpdating Envoy\n\n\nYou may also use Composer to keep your Envoy installation up to date. Issuing the \ncomposer global update\n command will update all of your globally installed Composer packages:\n\n\ncomposer global update\n\n\n\n\n\n\n\nWriting Tasks\n\n\nAll of your Envoy tasks should be defined in an \nEnvoy.blade.php\n file in the root of your project. Here's an example to get you started:\n\n\n@\nservers\n([\nweb\n \n=\n \n[\nuser\n@192.168.1.1\n]])\n\n\n\n@\ntask\n(\nfoo\n,\n \n[\non\n \n=\n \nweb\n])\n\n    \nls\n \n-\nla\n\n\n@\nendtask\n\n\n\n\n\n\nAs you can see, an array of \n@servers\n is defined at the top of the file, allowing you to reference these servers in the \non\n option of your task declarations. Within your \n@task\n declarations, you should place the Bash code that should run on your server when the task is executed.\n\n\nYou can force a script to run locally by specifying the server's IP address as \n127.0.0.1\n:\n\n\n@servers([\nlocalhost\n =\n \n127.0.0.1\n])\n\n\n\n\n\n\n\nSetup\n\n\nSometimes, you may need to execute some PHP code before executing your Envoy tasks. You may use the \n@setup\n directive to declare variables and do other general PHP work before any of your other tasks are executed:\n\n\n@\nsetup\n\n    \n$\nnow\n \n=\n \nnew\n \nDateTime\n();\n\n\n    \n$\nenvironment\n \n=\n \nisset\n(\n$\nenv\n)\n \n?\n \n$\nenv\n \n:\n \ntesting\n;\n\n\n@\nendsetup\n\n\n\n\n\n\nIf you need to require other PHP files before your task is executed, you may use the \n@include\n directive at the top of your \nEnvoy.blade.php\n file:\n\n\n@\ninclude\n(\nvendor\n/\nautoload\n.\nphp\n)\n\n\n\n@\ntask\n(\nfoo\n)\n\n    \n# ...\n\n\n@\nendtask\n\n\n\n\n\n\n\n\nVariables\n\n\nIf needed, you may pass option values into Envoy tasks using the command line:\n\n\nenvoy run deploy --branch=master\n\n\n\n\n\nYou may access the options in your tasks via Blade's \"echo\" syntax. Of course, you may also use \nif\n statements and loops within your tasks. For example, let's verify the presence of the \n$branch\n variable before executing the \ngit pull\n command:\n\n\n@\nservers\n([\nweb\n \n=\n \n192.168.1.1\n])\n\n\n\n@\ntask\n(\ndeploy\n,\n \n[\non\n \n=\n \nweb\n])\n\n    \ncd\n \nsite\n\n\n    \n@\nif\n \n(\n$\nbranch\n)\n\n        \ngit\n \npull\n \norigin\n \n{{\n \n$\nbranch\n \n}}\n\n    \n@\nendif\n\n\n    \nphp\n \nartisan\n \nmigrate\n\n\n@\nendtask\n\n\n\n\n\n\n\n\nStories\n\n\nStories group a set of tasks under a single, convenient name, allowing you to group small, focused tasks into large tasks. For instance, a \ndeploy\n story may run the \ngit\n and \ncomposer\n tasks by listing the task names within its definition:\n\n\n@\nservers\n([\nweb\n \n=\n \n192.168.1.1\n])\n\n\n\n@\nstory\n(\ndeploy\n)\n\n    \ngit\n\n    \ncomposer\n\n\n@\nendstory\n\n\n\n@\ntask\n(\ngit\n)\n\n    \ngit\n \npull\n \norigin\n \nmaster\n\n\n@\nendtask\n\n\n\n@\ntask\n(\ncomposer\n)\n\n    \ncomposer\n \ninstall\n\n\n@\nendtask\n\n\n\n\n\n\nOnce the story has been written, you may run it just like a typical task:\n\n\nenvoy run deploy\n\n\n\n\n\n\n\nMultiple Servers\n\n\nEnvoy allows you to easily run a task across multiple servers. First, add additional servers to your \n@servers\n declaration. Each server should be assigned a unique name. Once you have defined your additional servers, list each of the servers in the task's \non\n array:\n\n\n@\nservers\n([\nweb\n-\n1\n \n=\n \n192.168.1.1\n,\n \nweb\n-\n2\n \n=\n \n192.168.1.2\n])\n\n\n\n@\ntask\n(\ndeploy\n,\n \n[\non\n \n=\n \n[\nweb\n-\n1\n,\n \nweb\n-\n2\n]])\n\n    \ncd\n \nsite\n\n    \ngit\n \npull\n \norigin\n \n{{\n \n$\nbranch\n \n}}\n\n    \nphp\n \nartisan\n \nmigrate\n\n\n@\nendtask\n\n\n\n\n\n\nParallel Execution\n\n\nBy default, tasks will be executed on each server serially. In other words, a task will finish running on the first server before proceeding to execute on the second server. If you would like to run a task across multiple servers in parallel, add the \nparallel\n option to your task declaration:\n\n\n@\nservers\n([\nweb\n-\n1\n \n=\n \n192.168.1.1\n,\n \nweb\n-\n2\n \n=\n \n192.168.1.2\n])\n\n\n\n@\ntask\n(\ndeploy\n,\n \n[\non\n \n=\n \n[\nweb\n-\n1\n,\n \nweb\n-\n2\n],\n \nparallel\n \n=\n \ntrue\n])\n\n    \ncd\n \nsite\n\n    \ngit\n \npull\n \norigin\n \n{{\n \n$\nbranch\n \n}}\n\n    \nphp\n \nartisan\n \nmigrate\n\n\n@\nendtask\n\n\n\n\n\n\n\n\nRunning Tasks\n\n\nTo run a task or story that is defined in your \nEnvoy.blade.php\n file, execute Envoy's \nrun\n command, passing the name of the task or story you would like to execute. Envoy will run the task and display the output from the servers as the task is running:\n\n\nenvoy run task\n\n\n\n\n\n\n\nConfirming Task Execution\n\n\nIf you would like to be prompted for confirmation before running a given task on your servers, you should add the \nconfirm\n directive to your task declaration. This option is particularly useful for destructive operations:\n\n\n@\ntask\n(\ndeploy\n,\n \n[\non\n \n=\n \nweb\n,\n \nconfirm\n \n=\n \ntrue\n])\n\n    \ncd\n \nsite\n\n    \ngit\n \npull\n \norigin\n \n{{\n \n$\nbranch\n \n}}\n\n    \nphp\n \nartisan\n \nmigrate\n\n\n@\nendtask\n\n\n\n\n\n\n\n\n\n\nNotifications\n\n\n\n\nSlack\n\n\nEnvoy also supports sending notifications to \nSlack\n after each task is executed. The \n@slack\n directive accepts a Slack hook URL and a channel name. You may retrieve your webhook URL by creating an \"Incoming WebHooks\" integration in your Slack control panel. You should pass the entire webhook URL into the \n@slack\n directive:\n\n\n@\nfinished\n\n    \n@\nslack\n(\nwebhook\n-\nurl\n,\n \n#\nbots\n)\n\n\n@\nendfinished\n\n\n\n\n\n\nYou may provide one of the following as the channel argument:\n\n\n\n- To send the notification to a channel: `#channel`\n- To send the notification to a user: `@user`", 
            "title": "Envoy"
        }, 
        {
            "location": "/envoy/#envoy-task-runner", 
            "text": "Introduction  Installation    Writing Tasks  Setup  Variables  Stories  Multiple Servers    Running Tasks  Confirming Task Execution    Notifications  Slack", 
            "title": "Envoy Task Runner"
        }, 
        {
            "location": "/envoy/#introduction", 
            "text": "Laravel Envoy  provides a clean, minimal syntax for defining common tasks you run on your remote servers. Using Blade style syntax, you can easily setup tasks for deployment, Artisan commands, and more. Currently, Envoy only supports the Mac and Linux operating systems.", 
            "title": "Introduction"
        }, 
        {
            "location": "/envoy/#installation", 
            "text": "First, install Envoy using the Composer  global require  command:  composer global require  laravel/envoy=~1.0   Since global Composer libraries can sometimes cause package version conflicts, you may wish to consider using  cgr , which is a drop-in replacement for the  composer global require  command. The  cgr  library's installation instructions can be  found on GitHub .   {note} Make sure to place the  ~/.composer/vendor/bin  directory in your PATH so the  envoy  executable is found when running the  envoy  command in your terminal.", 
            "title": "Installation"
        }, 
        {
            "location": "/envoy/#updating-envoy", 
            "text": "You may also use Composer to keep your Envoy installation up to date. Issuing the  composer global update  command will update all of your globally installed Composer packages:  composer global update", 
            "title": "Updating Envoy"
        }, 
        {
            "location": "/envoy/#writing-tasks", 
            "text": "All of your Envoy tasks should be defined in an  Envoy.blade.php  file in the root of your project. Here's an example to get you started:  @ servers ([ web   =   [ user @192.168.1.1 ]])  @ task ( foo ,   [ on   =   web ]) \n     ls   - la  @ endtask   As you can see, an array of  @servers  is defined at the top of the file, allowing you to reference these servers in the  on  option of your task declarations. Within your  @task  declarations, you should place the Bash code that should run on your server when the task is executed.  You can force a script to run locally by specifying the server's IP address as  127.0.0.1 :  @servers([ localhost  =   127.0.0.1 ])", 
            "title": "Writing Tasks"
        }, 
        {
            "location": "/envoy/#setup", 
            "text": "Sometimes, you may need to execute some PHP code before executing your Envoy tasks. You may use the  @setup  directive to declare variables and do other general PHP work before any of your other tasks are executed:  @ setup \n     $ now   =   new   DateTime (); \n\n     $ environment   =   isset ( $ env )   ?   $ env   :   testing ;  @ endsetup   If you need to require other PHP files before your task is executed, you may use the  @include  directive at the top of your  Envoy.blade.php  file:  @ include ( vendor / autoload . php )  @ task ( foo ) \n     # ...  @ endtask", 
            "title": "Setup"
        }, 
        {
            "location": "/envoy/#variables", 
            "text": "If needed, you may pass option values into Envoy tasks using the command line:  envoy run deploy --branch=master  You may access the options in your tasks via Blade's \"echo\" syntax. Of course, you may also use  if  statements and loops within your tasks. For example, let's verify the presence of the  $branch  variable before executing the  git pull  command:  @ servers ([ web   =   192.168.1.1 ])  @ task ( deploy ,   [ on   =   web ]) \n     cd   site \n\n     @ if   ( $ branch ) \n         git   pull   origin   {{   $ branch   }} \n     @ endif \n\n     php   artisan   migrate  @ endtask", 
            "title": "Variables"
        }, 
        {
            "location": "/envoy/#stories", 
            "text": "Stories group a set of tasks under a single, convenient name, allowing you to group small, focused tasks into large tasks. For instance, a  deploy  story may run the  git  and  composer  tasks by listing the task names within its definition:  @ servers ([ web   =   192.168.1.1 ])  @ story ( deploy ) \n     git \n     composer  @ endstory  @ task ( git ) \n     git   pull   origin   master  @ endtask  @ task ( composer ) \n     composer   install  @ endtask   Once the story has been written, you may run it just like a typical task:  envoy run deploy", 
            "title": "Stories"
        }, 
        {
            "location": "/envoy/#multiple-servers", 
            "text": "Envoy allows you to easily run a task across multiple servers. First, add additional servers to your  @servers  declaration. Each server should be assigned a unique name. Once you have defined your additional servers, list each of the servers in the task's  on  array:  @ servers ([ web - 1   =   192.168.1.1 ,   web - 2   =   192.168.1.2 ])  @ task ( deploy ,   [ on   =   [ web - 1 ,   web - 2 ]]) \n     cd   site \n     git   pull   origin   {{   $ branch   }} \n     php   artisan   migrate  @ endtask", 
            "title": "Multiple Servers"
        }, 
        {
            "location": "/envoy/#parallel-execution", 
            "text": "By default, tasks will be executed on each server serially. In other words, a task will finish running on the first server before proceeding to execute on the second server. If you would like to run a task across multiple servers in parallel, add the  parallel  option to your task declaration:  @ servers ([ web - 1   =   192.168.1.1 ,   web - 2   =   192.168.1.2 ])  @ task ( deploy ,   [ on   =   [ web - 1 ,   web - 2 ],   parallel   =   true ]) \n     cd   site \n     git   pull   origin   {{   $ branch   }} \n     php   artisan   migrate  @ endtask", 
            "title": "Parallel Execution"
        }, 
        {
            "location": "/envoy/#running-tasks", 
            "text": "To run a task or story that is defined in your  Envoy.blade.php  file, execute Envoy's  run  command, passing the name of the task or story you would like to execute. Envoy will run the task and display the output from the servers as the task is running:  envoy run task", 
            "title": "Running Tasks"
        }, 
        {
            "location": "/envoy/#confirming-task-execution", 
            "text": "If you would like to be prompted for confirmation before running a given task on your servers, you should add the  confirm  directive to your task declaration. This option is particularly useful for destructive operations:  @ task ( deploy ,   [ on   =   web ,   confirm   =   true ]) \n     cd   site \n     git   pull   origin   {{   $ branch   }} \n     php   artisan   migrate  @ endtask", 
            "title": "Confirming Task Execution"
        }, 
        {
            "location": "/envoy/#notifications", 
            "text": "", 
            "title": "Notifications"
        }, 
        {
            "location": "/envoy/#slack", 
            "text": "Envoy also supports sending notifications to  Slack  after each task is executed. The  @slack  directive accepts a Slack hook URL and a channel name. You may retrieve your webhook URL by creating an \"Incoming WebHooks\" integration in your Slack control panel. You should pass the entire webhook URL into the  @slack  directive:  @ finished \n     @ slack ( webhook - url ,   # bots )  @ endfinished   You may provide one of the following as the channel argument:  \n- To send the notification to a channel: `#channel`\n- To send the notification to a user: `@user`", 
            "title": "Slack"
        }, 
        {
            "location": "/errors/", 
            "text": "Errors \n Logging\n\n\n\n\nIntroduction\n\n\nConfiguration\n\n\nError Detail\n\n\nLog Storage\n\n\nLog Severity Levels\n\n\nCustom Monolog Configuration\n\n\n\n\n\n\nThe Exception Handler\n\n\nReport Method\n\n\nRender Method\n\n\n\n\n\n\nHTTP Exceptions\n\n\nCustom HTTP Error Pages\n\n\n\n\n\n\nLogging\n\n\n\n\n\n\nIntroduction\n\n\nWhen you start a new Laravel project, error and exception handling is already configured for you. The \nApp\\Exceptions\\Handler\n class is where all exceptions triggered by your application are logged and then rendered back to the user. We'll dive deeper into this class throughout this documentation.\n\n\nFor logging, Laravel utilizes the \nMonolog\n library, which provides support for a variety of powerful log handlers. Laravel configures several of these handlers for you, allowing you to choose between a single log file, rotating log files, or writing error information to the system log.\n\n\n\n\nConfiguration\n\n\n\n\nError Detail\n\n\nThe \ndebug\n option in your \nconfig/app.php\n configuration file determines how much information about an error is actually displayed to the user. By default, this option is set to respect the value of the \nAPP_DEBUG\n environment variable, which is stored in your \n.env\n file.\n\n\nFor local development, you should set the \nAPP_DEBUG\n environment variable to \ntrue\n. In your production environment, this value should always be \nfalse\n. If the value is set to \ntrue\n in production, you risk exposing sensitive configuration values to your application's end users.\n\n\n\n\nLog Storage\n\n\nOut of the box, Laravel supports writing log information to \nsingle\n files, \ndaily\n files, the \nsyslog\n, and the \nerrorlog\n. To configure which storage mechanism Laravel uses, you should modify the \nlog\n option in your \nconfig/app.php\n configuration file. For example, if you wish to use daily log files instead of a single file, you should set the \nlog\n value in your \napp\n configuration file to \ndaily\n:\n\n\nlog\n =\n \ndaily\n\n\n\n\n\n\nMaximum Daily Log Files\n\n\nWhen using the \ndaily\n log mode, Laravel will only retain five days of log files by default. If you want to adjust the number of retained files, you may add a \nlog_max_files\n configuration value to your \napp\n configuration file:\n\n\nlog_max_files\n =\n 30\n\n\n\n\n\n\n\nLog Severity Levels\n\n\nWhen using Monolog, log messages may have different levels of severity. By default, Laravel writes all log levels to storage. However, in your production environment, you may wish to configure the minimum severity that should be logged by adding the \nlog_level\n option to your \napp.php\n configuration file.\n\n\nOnce this option has been configured, Laravel will log all levels greater than or equal to the specified severity. For example, a default \nlog_level\n of \nerror\n will log \nerror\n, \ncritical\n, \nalert\n, and \nemergency\n messages:\n\n\nlog_level\n =\n env(\nAPP_LOG_LEVEL\n, \nerror\n),\n\n\n\n\n\n\n\n{tip} Monolog recognizes the following severity levels - from least severe to most severe: \ndebug\n, \ninfo\n, \nnotice\n, \nwarning\n, \nerror\n, \ncritical\n, \nalert\n, \nemergency\n.\n\n\n\n\n\n\nCustom Monolog Configuration\n\n\nIf you would like to have complete control over how Monolog is configured for your application, you may use the application's \nconfigureMonologUsing\n method. You should place a call to this method in your \nbootstrap/app.php\n file right before the \n$app\n variable is returned by the file:\n\n\n$app-\nconfigureMonologUsing(function ($monolog) {\n    $monolog-\npushHandler(...);\n});\n\nreturn $app;\n\n\n\n\n\n\n\nThe Exception Handler\n\n\n\n\nThe Report Method\n\n\nAll exceptions are handled by the \nApp\\Exceptions\\Handler\n class. This class contains two methods: \nreport\n and \nrender\n. We'll examine each of these methods in detail. The \nreport\n method is used to log exceptions or send them to an external service like \nBugsnag\n or \nSentry\n. By default, the \nreport\n method simply passes the exception to the base class where the exception is logged. However, you are free to log exceptions however you wish.\n\n\nFor example, if you need to report different types of exceptions in different ways, you may use the PHP \ninstanceof\n comparison operator:\n\n\n/**\n\n\n * Report or log an exception.\n\n\n *\n\n\n * This is a great spot to send exceptions to Sentry, Bugsnag, etc.\n\n\n *\n\n\n * @param  \\Exception  $exception\n\n\n * @return void\n\n\n */\n\n\npublic\n \nfunction\n \nreport\n(\nException\n \n$\nexception\n)\n\n\n{\n\n    \nif\n \n($exception\n \ninstanceof\n \nCustomException)\n \n{\n\n        \n//\n\n    \n}\n\n\n    \nreturn\n \nparent\n::\nreport\n($\nexception\n);\n\n\n}\n\n\n\n\n\n\nIgnoring Exceptions By Type\n\n\nThe \n$dontReport\n property of the exception handler contains an array of exception types that will not be logged. For example, exceptions resulting from 404 errors, as well as several other types of errors, are not written to your log files. You may add other exception types to this array as needed:\n\n\n/**\n\n\n * A list of the exception types that should not be reported.\n\n\n *\n\n\n * @var array\n\n\n */\n\nprotected\n \n$\ndontReport\n \n=\n \n[\n\n\n    \n\\\nIlluminate\n\\\nAuth\n\\\nAuthenticationException\n:\n:\nclass\n,\n\n\n    \n\\\nIlluminate\n\\\nAuth\n\\\nAccess\n\\\nAuthorizationException\n:\n:\nclass\n,\n\n\n    \n\\\nSymfony\n\\\nComponent\n\\\nHttpKernel\n\\\nException\n\\\nHttpException\n:\n:\nclass\n,\n\n\n    \n\\\nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModelNotFoundException\n:\n:\nclass\n,\n\n\n    \n\\\nIlluminate\n\\\nValidation\n\\\nValidationException\n:\n:\nclass\n,\n\n\n];\n\n\n\n\n\n\n\n\nThe Render Method\n\n\nThe \nrender\n method is responsible for converting a given exception into an HTTP response that should be sent back to the browser. By default, the exception is passed to the base class which generates a response for you. However, you are free to check the exception type or return your own custom response:\n\n\n/**\n\n\n * Render an exception into an HTTP response.\n\n\n *\n\n\n * @param  \\Illuminate\\Http\\Request  $request\n\n\n * @param  \\Exception  $exception\n\n\n * @return \\Illuminate\\Http\\Response\n\n\n */\n\n\npublic\n \nfunction\n \nrender\n($\nrequest\n,\n \nException\n \n$\nexception\n)\n\n\n{\n\n    \nif\n \n($exception\n \ninstanceof\n \nCustomException)\n \n{\n\n        \nreturn\n \nresponse()-\nview(\nerrors.custom\n,\n \n[]\n,\n \n500)\n;\n\n    \n}\n\n\n    \nreturn\n \nparent\n::\nrender\n($\nrequest\n,\n \n$\nexception\n);\n\n\n}\n\n\n\n\n\n\n\n\nHTTP Exceptions\n\n\nSome exceptions describe HTTP error codes from the server. For example, this may be a \"page not found\" error (404), an \"unauthorized error\" (401) or even a developer generated 500 error. In order to generate such a response from anywhere in your application, you may use the \nabort\n helper:\n\n\nabort(404);\n\n\n\n\n\nThe \nabort\n helper will immediately raise an exception which will be rendered by the exception handler. Optionally, you may provide the response text:\n\n\nabort(403, \nUnauthorized action.\n);\n\n\n\n\n\n\n\nCustom HTTP Error Pages\n\n\nLaravel makes it easy to display custom error pages for various HTTP status codes. For example, if you wish to customize the error page for 404 HTTP status codes, create a \nresources/views/errors/404.blade.php\n. This file will be served on all 404 errors generated by your application. The views within this directory should be named to match the HTTP status code they correspond to. The \nHttpException\n instance raised by the \nabort\n function will be passed to the view as an \n$exception\n variable.\n\n\n\n\nLogging\n\n\nLaravel provides a simple abstraction layer on top of the powerful \nMonolog\n library. By default, Laravel is configured to create a log file for your application in the \nstorage/logs\n directory. You may write information to the logs using the \nLog\n \nfacade\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nLog\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Show the profile for the given user.\n\n\n     *\n\n\n     * @param  int  $id\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nshowProfile\n(\n$id\n)\n\n    \n{\n\n        \nLog\n::\ninfo\n(\nShowing user profile for user: \n.\n$id\n);\n\n\n        \nreturn\n \nview\n(\nuser.profile\n,\n \n[\nuser\n \n=\n \nUser\n::\nfindOrFail\n(\n$id\n)]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe logger provides the eight logging levels defined in \nRFC 5424\n: \nemergency\n, \nalert\n, \ncritical\n, \nerror\n, \nwarning\n, \nnotice\n, \ninfo\n and \ndebug\n.\n\n\nLog\n::\nemergency\n($\nmessage\n);\n\n\nLog\n::\nalert\n($\nmessage\n);\n\n\nLog\n::\ncritical\n($\nmessage\n);\n\n\nLog\n::\nerror\n($\nmessage\n);\n\n\nLog\n::\nwarning\n($\nmessage\n);\n\n\nLog\n::\nnotice\n($\nmessage\n);\n\n\nLog\n::\ninfo\n($\nmessage\n);\n\n\nLog\n::\ndebug\n($\nmessage\n);\n\n\n\n\n\n\nContextual Information\n\n\nAn array of contextual data may also be passed to the log methods. This contextual data will be formatted and displayed with the log message:\n\n\nLog\n::\ninfo\n(\nUser failed to login.\n,\n \n[\nid\n \n=\n \n$user\n-\nid\n]\n);\n\n\n\n\n\n\nAccessing The Underlying Monolog Instance\n\n\nMonolog has a variety of additional handlers you may use for logging. If needed, you may access the underlying Monolog instance being used by Laravel:\n\n\n$\nmonolog\n \n=\n \nLog\n::\ngetMonolog\n();", 
            "title": "Errors"
        }, 
        {
            "location": "/errors/#errors-logging", 
            "text": "Introduction  Configuration  Error Detail  Log Storage  Log Severity Levels  Custom Monolog Configuration    The Exception Handler  Report Method  Render Method    HTTP Exceptions  Custom HTTP Error Pages    Logging", 
            "title": "Errors &amp; Logging"
        }, 
        {
            "location": "/errors/#introduction", 
            "text": "When you start a new Laravel project, error and exception handling is already configured for you. The  App\\Exceptions\\Handler  class is where all exceptions triggered by your application are logged and then rendered back to the user. We'll dive deeper into this class throughout this documentation.  For logging, Laravel utilizes the  Monolog  library, which provides support for a variety of powerful log handlers. Laravel configures several of these handlers for you, allowing you to choose between a single log file, rotating log files, or writing error information to the system log.", 
            "title": "Introduction"
        }, 
        {
            "location": "/errors/#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/errors/#error-detail", 
            "text": "The  debug  option in your  config/app.php  configuration file determines how much information about an error is actually displayed to the user. By default, this option is set to respect the value of the  APP_DEBUG  environment variable, which is stored in your  .env  file.  For local development, you should set the  APP_DEBUG  environment variable to  true . In your production environment, this value should always be  false . If the value is set to  true  in production, you risk exposing sensitive configuration values to your application's end users.", 
            "title": "Error Detail"
        }, 
        {
            "location": "/errors/#log-storage", 
            "text": "Out of the box, Laravel supports writing log information to  single  files,  daily  files, the  syslog , and the  errorlog . To configure which storage mechanism Laravel uses, you should modify the  log  option in your  config/app.php  configuration file. For example, if you wish to use daily log files instead of a single file, you should set the  log  value in your  app  configuration file to  daily :  log  =   daily", 
            "title": "Log Storage"
        }, 
        {
            "location": "/errors/#maximum-daily-log-files", 
            "text": "When using the  daily  log mode, Laravel will only retain five days of log files by default. If you want to adjust the number of retained files, you may add a  log_max_files  configuration value to your  app  configuration file:  log_max_files  =  30", 
            "title": "Maximum Daily Log Files"
        }, 
        {
            "location": "/errors/#log-severity-levels", 
            "text": "When using Monolog, log messages may have different levels of severity. By default, Laravel writes all log levels to storage. However, in your production environment, you may wish to configure the minimum severity that should be logged by adding the  log_level  option to your  app.php  configuration file.  Once this option has been configured, Laravel will log all levels greater than or equal to the specified severity. For example, a default  log_level  of  error  will log  error ,  critical ,  alert , and  emergency  messages:  log_level  =  env( APP_LOG_LEVEL ,  error ),   {tip} Monolog recognizes the following severity levels - from least severe to most severe:  debug ,  info ,  notice ,  warning ,  error ,  critical ,  alert ,  emergency .", 
            "title": "Log Severity Levels"
        }, 
        {
            "location": "/errors/#custom-monolog-configuration", 
            "text": "If you would like to have complete control over how Monolog is configured for your application, you may use the application's  configureMonologUsing  method. You should place a call to this method in your  bootstrap/app.php  file right before the  $app  variable is returned by the file:  $app- configureMonologUsing(function ($monolog) {\n    $monolog- pushHandler(...);\n});\n\nreturn $app;", 
            "title": "Custom Monolog Configuration"
        }, 
        {
            "location": "/errors/#the-exception-handler", 
            "text": "", 
            "title": "The Exception Handler"
        }, 
        {
            "location": "/errors/#the-report-method", 
            "text": "All exceptions are handled by the  App\\Exceptions\\Handler  class. This class contains two methods:  report  and  render . We'll examine each of these methods in detail. The  report  method is used to log exceptions or send them to an external service like  Bugsnag  or  Sentry . By default, the  report  method simply passes the exception to the base class where the exception is logged. However, you are free to log exceptions however you wish.  For example, if you need to report different types of exceptions in different ways, you may use the PHP  instanceof  comparison operator:  /**   * Report or log an exception.   *   * This is a great spot to send exceptions to Sentry, Bugsnag, etc.   *   * @param  \\Exception  $exception   * @return void   */  public   function   report ( Exception   $ exception )  { \n     if   ($exception   instanceof   CustomException)   { \n         // \n     } \n\n     return   parent :: report ($ exception );  }", 
            "title": "The Report Method"
        }, 
        {
            "location": "/errors/#ignoring-exceptions-by-type", 
            "text": "The  $dontReport  property of the exception handler contains an array of exception types that will not be logged. For example, exceptions resulting from 404 errors, as well as several other types of errors, are not written to your log files. You may add other exception types to this array as needed:  /**   * A list of the exception types that should not be reported.   *   * @var array   */ \nprotected   $ dontReport   =   [       \\ Illuminate \\ Auth \\ AuthenticationException : : class ,       \\ Illuminate \\ Auth \\ Access \\ AuthorizationException : : class ,       \\ Symfony \\ Component \\ HttpKernel \\ Exception \\ HttpException : : class ,       \\ Illuminate \\ Database \\ Eloquent \\ ModelNotFoundException : : class ,       \\ Illuminate \\ Validation \\ ValidationException : : class ,  ];", 
            "title": "Ignoring Exceptions By Type"
        }, 
        {
            "location": "/errors/#the-render-method", 
            "text": "The  render  method is responsible for converting a given exception into an HTTP response that should be sent back to the browser. By default, the exception is passed to the base class which generates a response for you. However, you are free to check the exception type or return your own custom response:  /**   * Render an exception into an HTTP response.   *   * @param  \\Illuminate\\Http\\Request  $request   * @param  \\Exception  $exception   * @return \\Illuminate\\Http\\Response   */  public   function   render ($ request ,   Exception   $ exception )  { \n     if   ($exception   instanceof   CustomException)   { \n         return   response()- view( errors.custom ,   [] ,   500) ; \n     } \n\n     return   parent :: render ($ request ,   $ exception );  }", 
            "title": "The Render Method"
        }, 
        {
            "location": "/errors/#http-exceptions", 
            "text": "Some exceptions describe HTTP error codes from the server. For example, this may be a \"page not found\" error (404), an \"unauthorized error\" (401) or even a developer generated 500 error. In order to generate such a response from anywhere in your application, you may use the  abort  helper:  abort(404);  The  abort  helper will immediately raise an exception which will be rendered by the exception handler. Optionally, you may provide the response text:  abort(403,  Unauthorized action. );", 
            "title": "HTTP Exceptions"
        }, 
        {
            "location": "/errors/#custom-http-error-pages", 
            "text": "Laravel makes it easy to display custom error pages for various HTTP status codes. For example, if you wish to customize the error page for 404 HTTP status codes, create a  resources/views/errors/404.blade.php . This file will be served on all 404 errors generated by your application. The views within this directory should be named to match the HTTP status code they correspond to. The  HttpException  instance raised by the  abort  function will be passed to the view as an  $exception  variable.", 
            "title": "Custom HTTP Error Pages"
        }, 
        {
            "location": "/errors/#logging", 
            "text": "Laravel provides a simple abstraction layer on top of the powerful  Monolog  library. By default, Laravel is configured to create a log file for your application in the  storage/logs  directory. You may write information to the logs using the  Log   facade :  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ User ;  use   Illuminate \\ Support \\ Facades \\ Log ;  use   App \\ Http \\ Controllers \\ Controller ;  class   UserController   extends   Controller  { \n     /**       * Show the profile for the given user.       *       * @param  int  $id       * @return Response       */ \n     public   function   showProfile ( $id ) \n     { \n         Log :: info ( Showing user profile for user:  . $id ); \n\n         return   view ( user.profile ,   [ user   =   User :: findOrFail ( $id )]); \n     }  }   The logger provides the eight logging levels defined in  RFC 5424 :  emergency ,  alert ,  critical ,  error ,  warning ,  notice ,  info  and  debug .  Log :: emergency ($ message );  Log :: alert ($ message );  Log :: critical ($ message );  Log :: error ($ message );  Log :: warning ($ message );  Log :: notice ($ message );  Log :: info ($ message );  Log :: debug ($ message );", 
            "title": "Logging"
        }, 
        {
            "location": "/errors/#contextual-information", 
            "text": "An array of contextual data may also be passed to the log methods. This contextual data will be formatted and displayed with the log message:  Log :: info ( User failed to login. ,   [ id   =   $user - id ] );", 
            "title": "Contextual Information"
        }, 
        {
            "location": "/errors/#accessing-the-underlying-monolog-instance", 
            "text": "Monolog has a variety of additional handlers you may use for logging. If needed, you may access the underlying Monolog instance being used by Laravel:  $ monolog   =   Log :: getMonolog ();", 
            "title": "Accessing The Underlying Monolog Instance"
        }, 
        {
            "location": "/events/", 
            "text": "Events\n\n\n\n\nIntroduction\n\n\nRegistering Events \n Listeners\n\n\nGenerating Events \n Listeners\n\n\nManually Registering Events\n\n\n\n\n\n\nDefining Events\n\n\nDefining Listeners\n\n\nQueued Event Listeners\n\n\nManually Accessing The Queue\n\n\nHandling Failed Jobs\n\n\n\n\n\n\nDispatching Events\n\n\nEvent Subscribers\n\n\nWriting Event Subscribers\n\n\nRegistering Event Subscribers\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nLaravel's events provides a simple observer implementation, allowing you to subscribe and listen for various events that occur in your application. Event classes are typically stored in the \napp/Events\n directory, while their listeners are stored in \napp/Listeners\n. Don't worry if you don't see these directories in your application, since they will be created for you as you generate events and listeners using Artisan console commands.\n\n\nEvents serve as a great way to decouple various aspects of your application, since a single event can have multiple listeners that do not depend on each other. For example, you may wish to send a Slack notification to your user each time an order has shipped. Instead of coupling your order processing code to your Slack notification code, you can simply raise an \nOrderShipped\n event, which a listener can receive and transform into a Slack notification.\n\n\n\n\nRegistering Events \n Listeners\n\n\nThe \nEventServiceProvider\n included with your Laravel application provides a convenient place to register all of your application's event listeners. The \nlisten\n property contains an array of all events (keys) and their listeners (values). Of course, you may add as many events to this array as your application requires. For example, let's add a \nOrderShipped\n event:\n\n\n/**\n\n\n * The event listener mappings for the application.\n\n\n *\n\n\n * @var array\n\n\n */\n\nprotected\n \n$\nlisten\n \n=\n \n[\n\n\n    \nApp\\Events\\OrderShipped\n \n=\n \n[\n\n\n        \nApp\\Listeners\\SendShipmentNotification\n,\n\n\n    \n]\n,\n\n\n];\n\n\n\n\n\n\n\n\nGenerating Events \n Listeners\n\n\nOf course, manually creating the files for each event and listener is cumbersome. Instead, simply add listeners and events to your \nEventServiceProvider\n and use the \nevent:generate\n command. This command will generate any events or listeners that are listed in your \nEventServiceProvider\n. Of course, events and listeners that already exist will be left untouched:\n\n\nphp artisan event:generate\n\n\n\n\n\n\n\nManually Registering Events\n\n\nTypically, events should be registered via the \nEventServiceProvider\n \n$listen\n array; however, you may also register Closure based events manually in the \nboot\n method of your \nEventServiceProvider\n:\n\n\n/**\n\n\n * Register any other events for your application.\n\n\n *\n\n\n * @return void\n\n\n */\n\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n    \nparent\n:\n:\nboot\n();\n\n\n    \nEvent\n:\n:\nlisten\n(\nevent.name\n,\n \nfunction\n \n($\nfoo\n,\n \n$\nbar\n)\n \n{\n\n        \n//\n\n    \n}\n);\n\n\n}\n\n\n\n\n\n\nWildcard Event Listeners\n\n\nYou may even register listeners using the \n*\n as a wildcard parameter, allowing you to catch multiple events on the same listener. Wildcard listeners receive the event name as their first argument, and the entire event data array as their second argument:\n\n\nEvent::listen(\nevent.*\n, function ($eventName, array $data) {\n    //\n});\n\n\n\n\n\n\n\nDefining Events\n\n\nAn event class is simply a data container which holds the information related to the event. For example, let's assume our generated \nOrderShipped\n event receives an \nEloquent ORM\n object:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nEvents\n;\n\n\n\nuse\n \nApp\n\\\nOrder\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nSerializesModels\n;\n\n\n\nclass\n \nOrderShipped\n\n\n{\n\n    \nuse\n \nSerializesModels\n;\n\n\n    \npublic\n \n$order\n;\n\n\n    \n/**\n\n\n     * Create a new event instance.\n\n\n     *\n\n\n     * @param  Order  $order\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nOrder\n \n$order\n)\n\n    \n{\n\n        \n$this\n-\norder\n \n=\n \n$order\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAs you can see, this event class contains no logic. It is simply a container for the \nOrder\n instance that was purchased. The \nSerializesModels\n trait used by the event will gracefully serialize any Eloquent models if the event object is serialized using PHP's \nserialize\n function.\n\n\n\n\nDefining Listeners\n\n\nNext, let's take a look at the listener for our example event. Event listeners receive the event instance in their \nhandle\n method. The \nevent:generate\n command will automatically import the proper event class and type-hint the event on the \nhandle\n method. Within the \nhandle\n method, you may perform any actions necessary to respond to the event:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nListeners\n;\n\n\n\nuse\n \nApp\n\\\nEvents\n\\\nOrderShipped\n;\n\n\n\nclass\n \nSendShipmentNotification\n\n\n{\n\n    \n/**\n\n\n     * Create the event listener.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n    \n/**\n\n\n     * Handle the event.\n\n\n     *\n\n\n     * @param  OrderShipped  $event\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandle\n(\nOrderShipped\n \n$event\n)\n\n    \n{\n\n        \n// Access the order using $event-\norder...\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n{tip} Your event listeners may also type-hint any dependencies they need on their constructors. All event listeners are resolved via the Laravel \nservice container\n, so dependencies will be injected automatically.\n\n\n\n\nStopping The Propagation Of An Event\n\n\nSometimes, you may wish to stop the propagation of an event to other listeners. You may do so by returning \nfalse\n from your listener's \nhandle\n method.\n\n\n\n\nQueued Event Listeners\n\n\nQueueing listeners can be beneficial if your listener is going to perform a slow task such as sending an e-mail or making an HTTP request. Before getting started with queued listeners, make sure to \nconfigure your queue\n and start a queue listener on your server or local development environment.\n\n\nTo specify that a listener should be queued, add the \nShouldQueue\n interface to the listener class. Listeners generated by the \nevent:generate\n Artisan command already have this interface imported into the current namespace, so you can use it immediately:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nListeners\n;\n\n\n\nuse\n \nApp\n\\\nEvents\n\\\nOrderShipped\n;\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nQueue\n\\\nShouldQueue\n;\n\n\n\nclass\n \nSendShipmentNotification\n \nimplements\n \nShouldQueue\n\n\n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\nThat's it! Now, when this listener is called for an event, it will be automatically queued by the event dispatcher using Laravel's \nqueue system\n. If no exceptions are thrown when the listener is executed by the queue, the queued job will automatically be deleted after it has finished processing.\n\n\nCustomizing The Queue Connection \n Queue Name\n\n\nIf you would like to customize the queue connection and queue name used by an event listener, you may define \n$connection\n and \n$queue\n properties on your listener class:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nListeners\n;\n\n\n\nuse\n \nApp\n\\\nEvents\n\\\nOrderShipped\n;\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nQueue\n\\\nShouldQueue\n;\n\n\n\nclass\n \nSendShipmentNotification\n \nimplements\n \nShouldQueue\n\n\n{\n\n    \n/**\n\n\n     * The name of the connection the job should be sent to.\n\n\n     *\n\n\n     * @var string|null\n\n\n     */\n\n    \npublic\n \n$connection\n \n=\n \nsqs\n;\n\n\n    \n/**\n\n\n     * The name of the queue the job should be sent to.\n\n\n     *\n\n\n     * @var string|null\n\n\n     */\n\n    \npublic\n \n$queue\n \n=\n \nlisteners\n;\n\n\n}\n\n\n\n\n\n\n\n\nManually Accessing The Queue\n\n\nIf you need to manually access the listener's underlying queue job's \ndelete\n and \nrelease\n methods, you may do so using the \nIlluminate\\Queue\\InteractsWithQueue\n trait. This trait is imported by default on generated listeners and provides access to these methods:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nListeners\n;\n\n\n\nuse\n \nApp\n\\\nEvents\n\\\nOrderShipped\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nInteractsWithQueue\n;\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nQueue\n\\\nShouldQueue\n;\n\n\n\nclass\n \nSendShipmentNotification\n \nimplements\n \nShouldQueue\n\n\n{\n\n    \nuse\n \nInteractsWithQueue\n;\n\n\n    \npublic\n \nfunction\n \nhandle\n(\nOrderShipped\n \n$event\n)\n\n    \n{\n\n        \nif\n \n(\ntrue\n)\n \n{\n\n            \n$this\n-\nrelease\n(\n30\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nHandling Failed Jobs\n\n\nSometimes your queued event listeners may fail. If queued listener exceeds the maximum number of attempts as defined by your queue worker, the \nfailed\n method will be called on your listener. The \nfailed\n method receives the event instance and the exception that caused the failure:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nListeners\n;\n\n\n\nuse\n \nApp\n\\\nEvents\n\\\nOrderShipped\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nInteractsWithQueue\n;\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nQueue\n\\\nShouldQueue\n;\n\n\n\nclass\n \nSendShipmentNotification\n \nimplements\n \nShouldQueue\n\n\n{\n\n    \nuse\n \nInteractsWithQueue\n;\n\n\n    \npublic\n \nfunction\n \nhandle\n(\nOrderShipped\n \n$event\n)\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n    \npublic\n \nfunction\n \nfailed\n(\nOrderShipped\n \n$event\n,\n \n$exception\n)\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nDispatching Events\n\n\nTo dispatch an event, you may pass an instance of the event to the \nevent\n helper. The helper will dispatch the event to all of its registered listeners. Since the \nevent\n helper is globally available, you may call it from anywhere in your application:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nOrder\n;\n\n\nuse\n \nApp\n\\\nEvents\n\\\nOrderShipped\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nOrderController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Ship the given order.\n\n\n     *\n\n\n     * @param  int  $orderId\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nship\n(\n$orderId\n)\n\n    \n{\n\n        \n$order\n \n=\n \nOrder\n::\nfindOrFail\n(\n$orderId\n);\n\n\n        \n// Order shipment logic...\n\n\n        \nevent\n(\nnew\n \nOrderShipped\n(\n$order\n));\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n{tip} When testing, it can be helpful to assert that certain events were dispatched without actually triggering their listeners. Laravel's \nbuilt-in testing helpers\n makes it a cinch.\n\n\n\n\n\n\nEvent Subscribers\n\n\n\n\nWriting Event Subscribers\n\n\nEvent subscribers are classes that may subscribe to multiple events from within the class itself, allowing you to define several event handlers within a single class. Subscribers should define a \nsubscribe\n method, which will be passed an event dispatcher instance. You may call the \nlisten\n method on the given dispatcher to register event listeners:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nListeners\n;\n\n\n\nclass\n \nUserEventSubscriber\n\n\n{\n\n    \n/**\n\n\n     * Handle user login events.\n\n\n     */\n\n    \npublic\n \nfunction\n \nonUserLogin\n(\n$event\n)\n \n{}\n\n\n    \n/**\n\n\n     * Handle user logout events.\n\n\n     */\n\n    \npublic\n \nfunction\n \nonUserLogout\n(\n$event\n)\n \n{}\n\n\n    \n/**\n\n\n     * Register the listeners for the subscriber.\n\n\n     *\n\n\n     * @param  Illuminate\\Events\\Dispatcher  $events\n\n\n     */\n\n    \npublic\n \nfunction\n \nsubscribe\n(\n$events\n)\n\n    \n{\n\n        \n$events\n-\nlisten\n(\n\n            \nIlluminate\\Auth\\Events\\Login\n,\n\n            \nApp\\Listeners\\UserEventSubscriber@onUserLogin\n\n        \n);\n\n\n        \n$events\n-\nlisten\n(\n\n            \nIlluminate\\Auth\\Events\\Logout\n,\n\n            \nApp\\Listeners\\UserEventSubscriber@onUserLogout\n\n        \n);\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\n\n\nRegistering Event Subscribers\n\n\nAfter writing the subscriber, you are ready to register it with the event dispatcher. You may register subscribers using the \n$subscribe\n property on the \nEventServiceProvider\n. For example, let's add the \nUserEventSubscriber\n to the list:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nSupport\n\\\nProviders\n\\\nEventServiceProvider\n \nas\n \nServiceProvider\n;\n\n\n\nclass\n \nEventServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * The event listener mappings for the application.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$listen\n \n=\n \n[\n\n        \n//\n\n    \n];\n\n\n    \n/**\n\n\n     * The subscriber classes to register.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$subscribe\n \n=\n \n[\n\n        \nApp\\Listeners\\UserEventSubscriber\n,\n\n    \n];\n\n\n}", 
            "title": "Events"
        }, 
        {
            "location": "/events/#events", 
            "text": "Introduction  Registering Events   Listeners  Generating Events   Listeners  Manually Registering Events    Defining Events  Defining Listeners  Queued Event Listeners  Manually Accessing The Queue  Handling Failed Jobs    Dispatching Events  Event Subscribers  Writing Event Subscribers  Registering Event Subscribers", 
            "title": "Events"
        }, 
        {
            "location": "/events/#introduction", 
            "text": "Laravel's events provides a simple observer implementation, allowing you to subscribe and listen for various events that occur in your application. Event classes are typically stored in the  app/Events  directory, while their listeners are stored in  app/Listeners . Don't worry if you don't see these directories in your application, since they will be created for you as you generate events and listeners using Artisan console commands.  Events serve as a great way to decouple various aspects of your application, since a single event can have multiple listeners that do not depend on each other. For example, you may wish to send a Slack notification to your user each time an order has shipped. Instead of coupling your order processing code to your Slack notification code, you can simply raise an  OrderShipped  event, which a listener can receive and transform into a Slack notification.", 
            "title": "Introduction"
        }, 
        {
            "location": "/events/#registering-events-listeners", 
            "text": "The  EventServiceProvider  included with your Laravel application provides a convenient place to register all of your application's event listeners. The  listen  property contains an array of all events (keys) and their listeners (values). Of course, you may add as many events to this array as your application requires. For example, let's add a  OrderShipped  event:  /**   * The event listener mappings for the application.   *   * @var array   */ \nprotected   $ listen   =   [       App\\Events\\OrderShipped   =   [           App\\Listeners\\SendShipmentNotification ,       ] ,  ];", 
            "title": "Registering Events &amp; Listeners"
        }, 
        {
            "location": "/events/#generating-events-listeners", 
            "text": "Of course, manually creating the files for each event and listener is cumbersome. Instead, simply add listeners and events to your  EventServiceProvider  and use the  event:generate  command. This command will generate any events or listeners that are listed in your  EventServiceProvider . Of course, events and listeners that already exist will be left untouched:  php artisan event:generate", 
            "title": "Generating Events &amp; Listeners"
        }, 
        {
            "location": "/events/#manually-registering-events", 
            "text": "Typically, events should be registered via the  EventServiceProvider   $listen  array; however, you may also register Closure based events manually in the  boot  method of your  EventServiceProvider :  /**   * Register any other events for your application.   *   * @return void   */  public   function   boot ()  { \n     parent : : boot (); \n\n     Event : : listen ( event.name ,   function   ($ foo ,   $ bar )   { \n         // \n     } );  }", 
            "title": "Manually Registering Events"
        }, 
        {
            "location": "/events/#wildcard-event-listeners", 
            "text": "You may even register listeners using the  *  as a wildcard parameter, allowing you to catch multiple events on the same listener. Wildcard listeners receive the event name as their first argument, and the entire event data array as their second argument:  Event::listen( event.* , function ($eventName, array $data) {\n    //\n});", 
            "title": "Wildcard Event Listeners"
        }, 
        {
            "location": "/events/#defining-events", 
            "text": "An event class is simply a data container which holds the information related to the event. For example, let's assume our generated  OrderShipped  event receives an  Eloquent ORM  object:  ? php  namespace   App \\ Events ;  use   App \\ Order ;  use   Illuminate \\ Queue \\ SerializesModels ;  class   OrderShipped  { \n     use   SerializesModels ; \n\n     public   $order ; \n\n     /**       * Create a new event instance.       *       * @param  Order  $order       * @return void       */ \n     public   function   __construct ( Order   $order ) \n     { \n         $this - order   =   $order ; \n     }  }   As you can see, this event class contains no logic. It is simply a container for the  Order  instance that was purchased. The  SerializesModels  trait used by the event will gracefully serialize any Eloquent models if the event object is serialized using PHP's  serialize  function.", 
            "title": "Defining Events"
        }, 
        {
            "location": "/events/#defining-listeners", 
            "text": "Next, let's take a look at the listener for our example event. Event listeners receive the event instance in their  handle  method. The  event:generate  command will automatically import the proper event class and type-hint the event on the  handle  method. Within the  handle  method, you may perform any actions necessary to respond to the event:  ? php  namespace   App \\ Listeners ;  use   App \\ Events \\ OrderShipped ;  class   SendShipmentNotification  { \n     /**       * Create the event listener.       *       * @return void       */ \n     public   function   __construct () \n     { \n         // \n     } \n\n     /**       * Handle the event.       *       * @param  OrderShipped  $event       * @return void       */ \n     public   function   handle ( OrderShipped   $event ) \n     { \n         // Access the order using $event- order... \n     }  }    {tip} Your event listeners may also type-hint any dependencies they need on their constructors. All event listeners are resolved via the Laravel  service container , so dependencies will be injected automatically.", 
            "title": "Defining Listeners"
        }, 
        {
            "location": "/events/#stopping-the-propagation-of-an-event", 
            "text": "Sometimes, you may wish to stop the propagation of an event to other listeners. You may do so by returning  false  from your listener's  handle  method.", 
            "title": "Stopping The Propagation Of An Event"
        }, 
        {
            "location": "/events/#queued-event-listeners", 
            "text": "Queueing listeners can be beneficial if your listener is going to perform a slow task such as sending an e-mail or making an HTTP request. Before getting started with queued listeners, make sure to  configure your queue  and start a queue listener on your server or local development environment.  To specify that a listener should be queued, add the  ShouldQueue  interface to the listener class. Listeners generated by the  event:generate  Artisan command already have this interface imported into the current namespace, so you can use it immediately:  ? php  namespace   App \\ Listeners ;  use   App \\ Events \\ OrderShipped ;  use   Illuminate \\ Contracts \\ Queue \\ ShouldQueue ;  class   SendShipmentNotification   implements   ShouldQueue  { \n     //  }   That's it! Now, when this listener is called for an event, it will be automatically queued by the event dispatcher using Laravel's  queue system . If no exceptions are thrown when the listener is executed by the queue, the queued job will automatically be deleted after it has finished processing.", 
            "title": "Queued Event Listeners"
        }, 
        {
            "location": "/events/#customizing-the-queue-connection-queue-name", 
            "text": "If you would like to customize the queue connection and queue name used by an event listener, you may define  $connection  and  $queue  properties on your listener class:  ? php  namespace   App \\ Listeners ;  use   App \\ Events \\ OrderShipped ;  use   Illuminate \\ Contracts \\ Queue \\ ShouldQueue ;  class   SendShipmentNotification   implements   ShouldQueue  { \n     /**       * The name of the connection the job should be sent to.       *       * @var string|null       */ \n     public   $connection   =   sqs ; \n\n     /**       * The name of the queue the job should be sent to.       *       * @var string|null       */ \n     public   $queue   =   listeners ;  }", 
            "title": "Customizing The Queue Connection &amp; Queue Name"
        }, 
        {
            "location": "/events/#manually-accessing-the-queue", 
            "text": "If you need to manually access the listener's underlying queue job's  delete  and  release  methods, you may do so using the  Illuminate\\Queue\\InteractsWithQueue  trait. This trait is imported by default on generated listeners and provides access to these methods:  ? php  namespace   App \\ Listeners ;  use   App \\ Events \\ OrderShipped ;  use   Illuminate \\ Queue \\ InteractsWithQueue ;  use   Illuminate \\ Contracts \\ Queue \\ ShouldQueue ;  class   SendShipmentNotification   implements   ShouldQueue  { \n     use   InteractsWithQueue ; \n\n     public   function   handle ( OrderShipped   $event ) \n     { \n         if   ( true )   { \n             $this - release ( 30 ); \n         } \n     }  }", 
            "title": "Manually Accessing The Queue"
        }, 
        {
            "location": "/events/#handling-failed-jobs", 
            "text": "Sometimes your queued event listeners may fail. If queued listener exceeds the maximum number of attempts as defined by your queue worker, the  failed  method will be called on your listener. The  failed  method receives the event instance and the exception that caused the failure:  ? php  namespace   App \\ Listeners ;  use   App \\ Events \\ OrderShipped ;  use   Illuminate \\ Queue \\ InteractsWithQueue ;  use   Illuminate \\ Contracts \\ Queue \\ ShouldQueue ;  class   SendShipmentNotification   implements   ShouldQueue  { \n     use   InteractsWithQueue ; \n\n     public   function   handle ( OrderShipped   $event ) \n     { \n         // \n     } \n\n     public   function   failed ( OrderShipped   $event ,   $exception ) \n     { \n         // \n     }  }", 
            "title": "Handling Failed Jobs"
        }, 
        {
            "location": "/events/#dispatching-events", 
            "text": "To dispatch an event, you may pass an instance of the event to the  event  helper. The helper will dispatch the event to all of its registered listeners. Since the  event  helper is globally available, you may call it from anywhere in your application:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ Order ;  use   App \\ Events \\ OrderShipped ;  use   App \\ Http \\ Controllers \\ Controller ;  class   OrderController   extends   Controller  { \n     /**       * Ship the given order.       *       * @param  int  $orderId       * @return Response       */ \n     public   function   ship ( $orderId ) \n     { \n         $order   =   Order :: findOrFail ( $orderId ); \n\n         // Order shipment logic... \n\n         event ( new   OrderShipped ( $order )); \n     }  }    {tip} When testing, it can be helpful to assert that certain events were dispatched without actually triggering their listeners. Laravel's  built-in testing helpers  makes it a cinch.", 
            "title": "Dispatching Events"
        }, 
        {
            "location": "/events/#event-subscribers", 
            "text": "", 
            "title": "Event Subscribers"
        }, 
        {
            "location": "/events/#writing-event-subscribers", 
            "text": "Event subscribers are classes that may subscribe to multiple events from within the class itself, allowing you to define several event handlers within a single class. Subscribers should define a  subscribe  method, which will be passed an event dispatcher instance. You may call the  listen  method on the given dispatcher to register event listeners:  ? php  namespace   App \\ Listeners ;  class   UserEventSubscriber  { \n     /**       * Handle user login events.       */ \n     public   function   onUserLogin ( $event )   {} \n\n     /**       * Handle user logout events.       */ \n     public   function   onUserLogout ( $event )   {} \n\n     /**       * Register the listeners for the subscriber.       *       * @param  Illuminate\\Events\\Dispatcher  $events       */ \n     public   function   subscribe ( $events ) \n     { \n         $events - listen ( \n             Illuminate\\Auth\\Events\\Login , \n             App\\Listeners\\UserEventSubscriber@onUserLogin \n         ); \n\n         $events - listen ( \n             Illuminate\\Auth\\Events\\Logout , \n             App\\Listeners\\UserEventSubscriber@onUserLogout \n         ); \n     }  }", 
            "title": "Writing Event Subscribers"
        }, 
        {
            "location": "/events/#registering-event-subscribers", 
            "text": "After writing the subscriber, you are ready to register it with the event dispatcher. You may register subscribers using the  $subscribe  property on the  EventServiceProvider . For example, let's add the  UserEventSubscriber  to the list:  ? php  namespace   App \\ Providers ;  use   Illuminate \\ Foundation \\ Support \\ Providers \\ EventServiceProvider   as   ServiceProvider ;  class   EventServiceProvider   extends   ServiceProvider  { \n     /**       * The event listener mappings for the application.       *       * @var array       */ \n     protected   $listen   =   [ \n         // \n     ]; \n\n     /**       * The subscriber classes to register.       *       * @var array       */ \n     protected   $subscribe   =   [ \n         App\\Listeners\\UserEventSubscriber , \n     ];  }", 
            "title": "Registering Event Subscribers"
        }, 
        {
            "location": "/facades/", 
            "text": "Facades\n\n\n\n\nIntroduction\n\n\nWhen To Use Facades\n\n\nFacades Vs. Dependency Injection\n\n\nFacades Vs. Helper Functions\n\n\n\n\n\n\nHow Facades Work\n\n\nFacade Class Reference\n\n\n\n\n\n\nIntroduction\n\n\nFacades provide a \"static\" interface to classes that are available in the application's \nservice container\n. Laravel ships with many facades which provide access to almost all of Laravel's features. Laravel facades serve as \"static proxies\" to underlying classes in the service container, providing the benefit of a terse, expressive syntax while maintaining more testability and flexibility than traditional static methods.\n\n\nAll of Laravel's facades are defined in the \nIlluminate\\Support\\Facades\n namespace. So, we can easily access a facade like so:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nCache\n;\n\n\n\nRoute\n::\nget\n(\n/cache\n,\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \nCache\n:\n:\nget\n(\nkey\n);\n\n\n}\n);\n\n\n\n\n\n\nThroughout the Laravel documentation, many of the examples will use facades to demonstrate various features of the framework.\n\n\n\n\nWhen To Use Facades\n\n\nFacades have many benefits. They provide a terse, memorable syntax that allows you to use Laravel's features without remembering long class names that must be injected or configured manually. Furthermore, because of their unique usage of PHP's dynamic methods, they are easy to test.\n\n\nHowever, some care must be taken when using facades. The primary danger of facades is class scope creep. Since facades are so easy to use and do not require injection, it can be easy to let your classes continue to grow and use many facades in a single class. Using dependency injection, this potential is mitigated by the visual feedback a large constructor gives you that your class is growing too large. So, when using facades, pay special attention to the size of your class so that its scope of responsibility stays narrow.\n\n\n\n\n{tip} When building a third-party package that interacts with Laravel, it's better to inject \nLaravel contracts\n instead of using facades. Since packages are built outside of Laravel itself, you will not have access to Laravel's facade testing helpers.\n\n\n\n\n\n\nFacades Vs. Dependency Injection\n\n\nOne of the primary benefits of dependency injection is the ability to swap implementations of the injected class. This is useful during testing since you can inject a mock or stub and assert that various methods were called on the stub.\n\n\nTypically, it would not be possible to mock or stub a truly static class method. However, since facades use dynamic methods to proxy method calls to objects resolved from the service container, we actually can test facades just as we would test an injected class instance. For example, given the following route:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nCache\n;\n\n\n\nRoute\n::\nget\n(\n/cache\n,\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \nCache\n:\n:\nget\n(\nkey\n);\n\n\n}\n);\n\n\n\n\n\n\nWe can write the following test to verify that the \nCache::get\n method was called with the argument we expected:\n\n\nuse Illuminate\\Support\\Facades\\Cache;\n\n/**\n * A basic functional test example.\n *\n * @return void\n */\npublic function testBasicExample()\n{\n    Cache::shouldReceive(\nget\n)\n         -\nwith(\nkey\n)\n         -\nandReturn(\nvalue\n);\n\n    $this-\nvisit(\n/cache\n)\n         -\nsee(\nvalue\n);\n}\n\n\n\n\n\n\n\nFacades Vs. Helper Functions\n\n\nIn addition to facades, Laravel includes a variety of \"helper\" functions which can perform common tasks like generating views, firing events, dispatching jobs, or sending HTTP responses. Many of these helper functions perform the same function as a corresponding facade. For example, this facade call and helper call are equivalent:\n\n\nreturn\n \nView\n::\nmake\n(\nprofile\n);\n\n\n\nreturn\n \nview\n(\nprofile\n);\n\n\n\n\n\n\nThere is absolutely no practical difference between facades and helper functions. When using helper functions, you may still test them exactly as you would the corresponding facade. For example, given the following route:\n\n\nRoute::get(\n/cache\n, function () {\n    return cache(\nkey\n);\n});\n\n\n\n\n\nUnder the hood, the \ncache\n helper is going to call the \nget\n method on the class underlying the \nCache\n facade. So, even though we are using the helper function, we can write the following test to verify that the method was called with the argument we expected:\n\n\nuse Illuminate\\Support\\Facades\\Cache;\n\n/**\n * A basic functional test example.\n *\n * @return void\n */\npublic function testBasicExample()\n{\n    Cache::shouldReceive(\nget\n)\n         -\nwith(\nkey\n)\n         -\nandReturn(\nvalue\n);\n\n    $this-\nvisit(\n/cache\n)\n         -\nsee(\nvalue\n);\n}\n\n\n\n\n\n\n\nHow Facades Work\n\n\nIn a Laravel application, a facade is a class that provides access to an object from the container. The machinery that makes this work is in the \nFacade\n class. Laravel's facades, and any custom facades you create, will extend the base \nIlluminate\\Support\\Facades\\Facade\n class.\n\n\nThe \nFacade\n base class makes use of the \n__callStatic()\n magic-method to defer calls from your facade to an object resolved from the container. In the example below, a call is made to the Laravel cache system. By glancing at this code, one might assume that the static method \nget\n is being called on the \nCache\n class:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nCache\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Show the profile for the given user.\n\n\n     *\n\n\n     * @param  int  $id\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nshowProfile\n(\n$id\n)\n\n    \n{\n\n        \n$user\n \n=\n \nCache\n::\nget\n(\nuser:\n.\n$id\n);\n\n\n        \nreturn\n \nview\n(\nprofile\n,\n \n[\nuser\n \n=\n \n$user\n]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNotice that near the top of the file we are \"importing\" the \nCache\n facade. This facade serves as a proxy to accessing the underlying implementation of the \nIlluminate\\Contracts\\Cache\\Factory\n interface. Any calls we make using the facade will be passed to the underlying instance of Laravel's cache service.\n\n\nIf we look at that \nIlluminate\\Support\\Facades\\Cache\n class, you'll see that there is no static method \nget\n:\n\n\nclass\n \nCache\n \nextends\n \nFacade\n\n\n{\n\n    \n/**\n\n\n     * Get the registered name of the component.\n\n\n     *\n\n\n     * @return string\n\n\n     */\n\n    \nprotected\n \nstatic\n \nfunction\n \ngetFacadeAccessor() {\n \nreturn\n \ncache\n;\n \n}\n\n\n}\n\n\n\n\n\n\nInstead, the \nCache\n facade extends the base \nFacade\n class and defines the method \ngetFacadeAccessor()\n. This method's job is to return the name of a service container binding. When a user references any static method on the \nCache\n facade, Laravel resolves the \ncache\n binding from the \nservice container\n and runs the requested method (in this case, \nget\n) against that object.\n\n\n\n\nFacade Class Reference\n\n\nBelow you will find every facade and its underlying class. This is a useful tool for quickly digging into the API documentation for a given facade root. The \nservice container binding\n key is also included where applicable.\n\n\n\n\n\n\n\n\nFacade\n\n\nClass\n\n\nService Container Binding\n\n\n\n\n\n\n\n\n\n\nApp\n\n\nIlluminate\\Foundation\\Application\n\n\napp\n\n\n\n\n\n\nArtisan\n\n\nIlluminate\\Contracts\\Console\\Kernel\n\n\nartisan\n\n\n\n\n\n\nAuth\n\n\nIlluminate\\Auth\\AuthManager\n\n\nauth\n\n\n\n\n\n\nBlade\n\n\nIlluminate\\View\\Compilers\\BladeCompiler\n\n\nblade.compiler\n\n\n\n\n\n\nBus\n\n\nIlluminate\\Contracts\\Bus\\Dispatcher\n\n\n\n\n\n\n\n\nCache\n\n\nIlluminate\\Cache\\Repository\n\n\ncache\n\n\n\n\n\n\nConfig\n\n\nIlluminate\\Config\\Repository\n\n\nconfig\n\n\n\n\n\n\nCookie\n\n\nIlluminate\\Cookie\\CookieJar\n\n\ncookie\n\n\n\n\n\n\nCrypt\n\n\nIlluminate\\Encryption\\Encrypter\n\n\nencrypter\n\n\n\n\n\n\nDB\n\n\nIlluminate\\Database\\DatabaseManager\n\n\ndb\n\n\n\n\n\n\nDB (Instance)\n\n\nIlluminate\\Database\\Connection\n\n\n\n\n\n\n\n\nEvent\n\n\nIlluminate\\Events\\Dispatcher\n\n\nevents\n\n\n\n\n\n\nFile\n\n\nIlluminate\\Filesystem\\Filesystem\n\n\nfiles\n\n\n\n\n\n\nGate\n\n\nIlluminate\\Contracts\\Auth\\Access\\Gate\n\n\n\n\n\n\n\n\nHash\n\n\nIlluminate\\Contracts\\Hashing\\Hasher\n\n\nhash\n\n\n\n\n\n\nLang\n\n\nIlluminate\\Translation\\Translator\n\n\ntranslator\n\n\n\n\n\n\nLog\n\n\nIlluminate\\Log\\Writer\n\n\nlog\n\n\n\n\n\n\nMail\n\n\nIlluminate\\Mail\\Mailer\n\n\nmailer\n\n\n\n\n\n\nNotification\n\n\nIlluminate\\Notifications\\ChannelManager\n\n\n\n\n\n\n\n\nPassword\n\n\nIlluminate\\Auth\\Passwords\\PasswordBrokerManager\n\n\nauth.password\n\n\n\n\n\n\nQueue\n\n\nIlluminate\\Queue\\QueueManager\n\n\nqueue\n\n\n\n\n\n\nQueue (Instance)\n\n\nIlluminate\\Contracts\\Queue\\Queue\n\n\nqueue\n\n\n\n\n\n\nQueue (Base Class)\n\n\nIlluminate\\Queue\\Queue\n\n\n\n\n\n\n\n\nRedirect\n\n\nIlluminate\\Routing\\Redirector\n\n\nredirect\n\n\n\n\n\n\nRedis\n\n\nIlluminate\\Redis\\Database\n\n\nredis\n\n\n\n\n\n\nRequest\n\n\nIlluminate\\Http\\Request\n\n\nrequest\n\n\n\n\n\n\nResponse\n\n\nIlluminate\\Contracts\\Routing\\ResponseFactory\n\n\n\n\n\n\n\n\nRoute\n\n\nIlluminate\\Routing\\Router\n\n\nrouter\n\n\n\n\n\n\nSchema\n\n\nIlluminate\\Database\\Schema\\Blueprint\n\n\n\n\n\n\n\n\nSession\n\n\nIlluminate\\Session\\SessionManager\n\n\nsession\n\n\n\n\n\n\nSession (Instance)\n\n\nIlluminate\\Session\\Store\n\n\n\n\n\n\n\n\nStorage\n\n\nIlluminate\\Contracts\\Filesystem\\Factory\n\n\nfilesystem\n\n\n\n\n\n\nURL\n\n\nIlluminate\\Routing\\UrlGenerator\n\n\nurl\n\n\n\n\n\n\nValidator\n\n\nIlluminate\\Validation\\Factory\n\n\nvalidator\n\n\n\n\n\n\nValidator (Instance)\n\n\nIlluminate\\Validation\\Validator\n\n\n\n\n\n\n\n\nView\n\n\nIlluminate\\View\\Factory\n\n\nview\n\n\n\n\n\n\nView (Instance)\n\n\nIlluminate\\View\\View", 
            "title": "Facades"
        }, 
        {
            "location": "/facades/#facades", 
            "text": "Introduction  When To Use Facades  Facades Vs. Dependency Injection  Facades Vs. Helper Functions    How Facades Work  Facade Class Reference", 
            "title": "Facades"
        }, 
        {
            "location": "/facades/#introduction", 
            "text": "Facades provide a \"static\" interface to classes that are available in the application's  service container . Laravel ships with many facades which provide access to almost all of Laravel's features. Laravel facades serve as \"static proxies\" to underlying classes in the service container, providing the benefit of a terse, expressive syntax while maintaining more testability and flexibility than traditional static methods.  All of Laravel's facades are defined in the  Illuminate\\Support\\Facades  namespace. So, we can easily access a facade like so:  use   Illuminate \\ Support \\ Facades \\ Cache ;  Route :: get ( /cache ,   function   ()   { \n     return   Cache : : get ( key );  } );   Throughout the Laravel documentation, many of the examples will use facades to demonstrate various features of the framework.", 
            "title": "Introduction"
        }, 
        {
            "location": "/facades/#when-to-use-facades", 
            "text": "Facades have many benefits. They provide a terse, memorable syntax that allows you to use Laravel's features without remembering long class names that must be injected or configured manually. Furthermore, because of their unique usage of PHP's dynamic methods, they are easy to test.  However, some care must be taken when using facades. The primary danger of facades is class scope creep. Since facades are so easy to use and do not require injection, it can be easy to let your classes continue to grow and use many facades in a single class. Using dependency injection, this potential is mitigated by the visual feedback a large constructor gives you that your class is growing too large. So, when using facades, pay special attention to the size of your class so that its scope of responsibility stays narrow.   {tip} When building a third-party package that interacts with Laravel, it's better to inject  Laravel contracts  instead of using facades. Since packages are built outside of Laravel itself, you will not have access to Laravel's facade testing helpers.", 
            "title": "When To Use Facades"
        }, 
        {
            "location": "/facades/#facades-vs-dependency-injection", 
            "text": "One of the primary benefits of dependency injection is the ability to swap implementations of the injected class. This is useful during testing since you can inject a mock or stub and assert that various methods were called on the stub.  Typically, it would not be possible to mock or stub a truly static class method. However, since facades use dynamic methods to proxy method calls to objects resolved from the service container, we actually can test facades just as we would test an injected class instance. For example, given the following route:  use   Illuminate \\ Support \\ Facades \\ Cache ;  Route :: get ( /cache ,   function   ()   { \n     return   Cache : : get ( key );  } );   We can write the following test to verify that the  Cache::get  method was called with the argument we expected:  use Illuminate\\Support\\Facades\\Cache;\n\n/**\n * A basic functional test example.\n *\n * @return void\n */\npublic function testBasicExample()\n{\n    Cache::shouldReceive( get )\n         - with( key )\n         - andReturn( value );\n\n    $this- visit( /cache )\n         - see( value );\n}", 
            "title": "Facades Vs. Dependency Injection"
        }, 
        {
            "location": "/facades/#facades-vs-helper-functions", 
            "text": "In addition to facades, Laravel includes a variety of \"helper\" functions which can perform common tasks like generating views, firing events, dispatching jobs, or sending HTTP responses. Many of these helper functions perform the same function as a corresponding facade. For example, this facade call and helper call are equivalent:  return   View :: make ( profile );  return   view ( profile );   There is absolutely no practical difference between facades and helper functions. When using helper functions, you may still test them exactly as you would the corresponding facade. For example, given the following route:  Route::get( /cache , function () {\n    return cache( key );\n});  Under the hood, the  cache  helper is going to call the  get  method on the class underlying the  Cache  facade. So, even though we are using the helper function, we can write the following test to verify that the method was called with the argument we expected:  use Illuminate\\Support\\Facades\\Cache;\n\n/**\n * A basic functional test example.\n *\n * @return void\n */\npublic function testBasicExample()\n{\n    Cache::shouldReceive( get )\n         - with( key )\n         - andReturn( value );\n\n    $this- visit( /cache )\n         - see( value );\n}", 
            "title": "Facades Vs. Helper Functions"
        }, 
        {
            "location": "/facades/#how-facades-work", 
            "text": "In a Laravel application, a facade is a class that provides access to an object from the container. The machinery that makes this work is in the  Facade  class. Laravel's facades, and any custom facades you create, will extend the base  Illuminate\\Support\\Facades\\Facade  class.  The  Facade  base class makes use of the  __callStatic()  magic-method to defer calls from your facade to an object resolved from the container. In the example below, a call is made to the Laravel cache system. By glancing at this code, one might assume that the static method  get  is being called on the  Cache  class:  ? php  namespace   App \\ Http \\ Controllers ;  use   Cache ;  use   App \\ Http \\ Controllers \\ Controller ;  class   UserController   extends   Controller  { \n     /**       * Show the profile for the given user.       *       * @param  int  $id       * @return Response       */ \n     public   function   showProfile ( $id ) \n     { \n         $user   =   Cache :: get ( user: . $id ); \n\n         return   view ( profile ,   [ user   =   $user ]); \n     }  }   Notice that near the top of the file we are \"importing\" the  Cache  facade. This facade serves as a proxy to accessing the underlying implementation of the  Illuminate\\Contracts\\Cache\\Factory  interface. Any calls we make using the facade will be passed to the underlying instance of Laravel's cache service.  If we look at that  Illuminate\\Support\\Facades\\Cache  class, you'll see that there is no static method  get :  class   Cache   extends   Facade  { \n     /**       * Get the registered name of the component.       *       * @return string       */ \n     protected   static   function   getFacadeAccessor() {   return   cache ;   }  }   Instead, the  Cache  facade extends the base  Facade  class and defines the method  getFacadeAccessor() . This method's job is to return the name of a service container binding. When a user references any static method on the  Cache  facade, Laravel resolves the  cache  binding from the  service container  and runs the requested method (in this case,  get ) against that object.", 
            "title": "How Facades Work"
        }, 
        {
            "location": "/facades/#facade-class-reference", 
            "text": "Below you will find every facade and its underlying class. This is a useful tool for quickly digging into the API documentation for a given facade root. The  service container binding  key is also included where applicable.     Facade  Class  Service Container Binding      App  Illuminate\\Foundation\\Application  app    Artisan  Illuminate\\Contracts\\Console\\Kernel  artisan    Auth  Illuminate\\Auth\\AuthManager  auth    Blade  Illuminate\\View\\Compilers\\BladeCompiler  blade.compiler    Bus  Illuminate\\Contracts\\Bus\\Dispatcher     Cache  Illuminate\\Cache\\Repository  cache    Config  Illuminate\\Config\\Repository  config    Cookie  Illuminate\\Cookie\\CookieJar  cookie    Crypt  Illuminate\\Encryption\\Encrypter  encrypter    DB  Illuminate\\Database\\DatabaseManager  db    DB (Instance)  Illuminate\\Database\\Connection     Event  Illuminate\\Events\\Dispatcher  events    File  Illuminate\\Filesystem\\Filesystem  files    Gate  Illuminate\\Contracts\\Auth\\Access\\Gate     Hash  Illuminate\\Contracts\\Hashing\\Hasher  hash    Lang  Illuminate\\Translation\\Translator  translator    Log  Illuminate\\Log\\Writer  log    Mail  Illuminate\\Mail\\Mailer  mailer    Notification  Illuminate\\Notifications\\ChannelManager     Password  Illuminate\\Auth\\Passwords\\PasswordBrokerManager  auth.password    Queue  Illuminate\\Queue\\QueueManager  queue    Queue (Instance)  Illuminate\\Contracts\\Queue\\Queue  queue    Queue (Base Class)  Illuminate\\Queue\\Queue     Redirect  Illuminate\\Routing\\Redirector  redirect    Redis  Illuminate\\Redis\\Database  redis    Request  Illuminate\\Http\\Request  request    Response  Illuminate\\Contracts\\Routing\\ResponseFactory     Route  Illuminate\\Routing\\Router  router    Schema  Illuminate\\Database\\Schema\\Blueprint     Session  Illuminate\\Session\\SessionManager  session    Session (Instance)  Illuminate\\Session\\Store     Storage  Illuminate\\Contracts\\Filesystem\\Factory  filesystem    URL  Illuminate\\Routing\\UrlGenerator  url    Validator  Illuminate\\Validation\\Factory  validator    Validator (Instance)  Illuminate\\Validation\\Validator     View  Illuminate\\View\\Factory  view    View (Instance)  Illuminate\\View\\View", 
            "title": "Facade Class Reference"
        }, 
        {
            "location": "/filesystem/", 
            "text": "Filesystem / Cloud Storage\n\n\n\n\nIntroduction\n\n\nConfiguration\n\n\nThe Public Disk\n\n\nThe Local Driver\n\n\nDriver Prerequisites\n\n\n\n\n\n\nObtaining Disk Instances\n\n\nRetrieving Files\n\n\nFile URLs\n\n\nFile Metadata\n\n\n\n\n\n\nStoring Files\n\n\nFile Uploads\n\n\nFile Visibility\n\n\n\n\n\n\nDeleting Files\n\n\nDirectories\n\n\nCustom Filesystems\n\n\n\n\n\n\nIntroduction\n\n\nLaravel provides a powerful filesystem abstraction thanks to the wonderful \nFlysystem\n PHP package by Frank de Jonge. The Laravel Flysystem integration provides simple to use drivers for working with local filesystems, Amazon S3, and Rackspace Cloud Storage. Even better, it's amazingly simple to switch between these storage options as the API remains the same for each system.\n\n\n\n\nConfiguration\n\n\nThe filesystem configuration file is located at \nconfig/filesystems.php\n. Within this file you may configure all of your \"disks\". Each disk represents a particular storage driver and storage location. Example configurations for each supported driver are included in the configuration file. So, simply modify the configuration to reflect your storage preferences and credentials.\n\n\nOf course, you may configure as many disks as you like, and may even have multiple disks that use the same driver.\n\n\n\n\nThe Public Disk\n\n\nThe \npublic\n disk is intended for files that are going to be publicly accessible. By default, the \npublic\n disk uses the \nlocal\n driver and stores these files in \nstorage/app/public\n. To make them accessible from the web, you should create a symbolic link from \npublic/storage\n to \nstorage/app/public\n. This convention will keep your publicly accessible files in one directory that can be easily shared across deployments when using zero down-time deployment systems like \nEnvoyer\n.\n\n\nTo create the symbolic link, you may use the \nstorage:link\n Artisan command:\n\n\nphp artisan storage:link\n\n\n\n\n\nOf course, once a file has been stored and the symbolic link has been created, you can create a URL to the files using the \nasset\n helper:\n\n\necho asset(\nstorage/file.txt\n);\n\n\n\n\n\n\n\nThe Local Driver\n\n\nWhen using the \nlocal\n driver, all file operations are relative to the \nroot\n directory defined in your configuration file. By default, this value is set to the \nstorage/app\n directory. Therefore, the following method would store a file in \nstorage/app/file.txt\n:\n\n\nStorage\n::\ndisk\n(\nlocal\n)\n-\nput\n(\nfile.txt\n,\n \nContents\n);\n\n\n\n\n\n\n\n\nDriver Prerequisites\n\n\nComposer Packages\n\n\nBefore using the S3 or Rackspace drivers, you will need to install the appropriate package via Composer:\n\n\n\n\nAmazon S3: \nleague/flysystem-aws-s3-v3 ~1.0\n\n\nRackspace: \nleague/flysystem-rackspace ~1.0\n\n\n\n\nS3 Driver Configuration\n\n\nThe S3 driver configuration information is located in your \nconfig/filesystems.php\n configuration file. This file contains an example configuration array for an S3 driver. You are free to modify this array with your own S3 configuration and credentials.\n\n\nFTP Driver Configuration\n\n\nLaravel's Flysystem integrations works great with FTP; however, a sample configuration is not included with the framework's default \nfilesystems.php\n configuration file. If you need to configure a FTP filesystem, you may use the example configuration below:\n\n\nftp\n =\n [\n    \ndriver\n   =\n \nftp\n,\n    \nhost\n     =\n \nftp.example.com\n,\n    \nusername\n =\n \nyour-username\n,\n    \npassword\n =\n \nyour-password\n,\n\n    // Optional FTP Settings...\n    // \nport\n     =\n 21,\n    // \nroot\n     =\n \n,\n    // \npassive\n  =\n true,\n    // \nssl\n      =\n true,\n    // \ntimeout\n  =\n 30,\n],\n\n\n\n\n\nRackspace Driver Configuration\n\n\nLaravel's Flysystem integrations works great with Rackspace; however, a sample configuration is not included with the framework's default \nfilesystems.php\n configuration file. If you need to configure a Rackspace filesystem, you may use the example configuration below:\n\n\nrackspace\n =\n [\n    \ndriver\n    =\n \nrackspace\n,\n    \nusername\n  =\n \nyour-username\n,\n    \nkey\n       =\n \nyour-key\n,\n    \ncontainer\n =\n \nyour-container\n,\n    \nendpoint\n  =\n \nhttps://identity.api.rackspacecloud.com/v2.0/\n,\n    \nregion\n    =\n \nIAD\n,\n    \nurl_type\n  =\n \npublicURL\n,\n],\n\n\n\n\n\n\n\nObtaining Disk Instances\n\n\nThe \nStorage\n facade may be used to interact with any of your configured disks. For example, you may use the \nput\n method on the facade to store an avatar on the default disk. If you call methods on the \nStorage\n facade without first calling the \ndisk\n method, the method call will automatically be passed to the default disk:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nStorage\n;\n\n\n\nStorage\n::\nput\n(\navatars/1\n,\n \n$\nfileContents\n);\n\n\n\n\n\n\nIf your applications interacts with multiple disks, you may use the \ndisk\n method on the \nStorage\n facade to work with files on a particular disk:\n\n\nStorage\n::\ndisk\n(\ns3\n)\n-\nput\n(\navatars/1\n,\n \n$\nfileContents\n);\n\n\n\n\n\n\n\n\nRetrieving Files\n\n\nThe \nget\n method may be used to retrieve the contents of a file. The raw string contents of the file will be returned by the method. Remember, all file paths should be specified relative to the \"root\" location configured for the disk:\n\n\n$\ncontents\n \n=\n \nStorage\n::\nget\n(\nfile.jpg\n);\n\n\n\n\n\n\nThe \nexists\n method may be used to determine if a file exists on the disk:\n\n\n$\nexists\n \n=\n \nStorage\n::\ndisk\n(\ns3\n)\n-\nexists\n(\nfile.jpg\n);\n\n\n\n\n\n\n\n\nFile URLs\n\n\nWhen using the \nlocal\n or \ns3\n drivers, you may use the \nurl\n method to get the URL for the given file. If you are using the \nlocal\n driver, this will typically just prepend \n/storage\n to the given path and return a relative URL to the file. If you are using the \ns3\n driver, the fully qualified remote URL will be returned:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nStorage\n;\n\n\n\n$\nurl\n \n=\n \nStorage\n::\nurl\n(\nfile1.jpg\n);\n\n\n\n\n\n\n\n\n{note} Remember, if you are using the \nlocal\n driver, all files that should be publicly accessible should be placed in the \nstorage/app/public\n directory. Furthermore, you should \ncreate a symbolic link\n at \npublic/storage\n which points to the \nstorage/app/public\n directory.\n\n\n\n\nLocal URL Host Customization\n\n\nIf you would like to pre-define the host for files stored on a disk using the \nlocal\n driver, you may add a \nurl\n option to the disk's configuration array:\n\n\npublic\n =\n [\n    \ndriver\n =\n \nlocal\n,\n    \nroot\n =\n storage_path(\napp/public\n),\n    \nurl\n =\n env(\nAPP_URL\n).\n/storage\n,\n    \nvisibility\n =\n \npublic\n,\n],\n\n\n\n\n\n\n\nFile Metadata\n\n\nIn addition to reading and writing files, Laravel can also provide information about the files themselves. For example, the \nsize\n method may be used to get the size of the file in bytes:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nStorage\n;\n\n\n\n$\nsize\n \n=\n \nStorage\n::\nsize\n(\nfile1.jpg\n);\n\n\n\n\n\n\nThe \nlastModified\n method returns the UNIX timestamp of the last time the file was modified:\n\n\n$\ntime\n \n=\n \nStorage\n::\nlastModified\n(\nfile1.jpg\n);\n\n\n\n\n\n\n\n\nStoring Files\n\n\nThe \nput\n method may be used to store raw file contents on a disk. You may also pass a PHP \nresource\n to the \nput\n method, which will use Flysystem's underlying stream support. Using streams is greatly recommended when dealing with large files:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nStorage\n;\n\n\n\nStorage\n::\nput\n(\nfile.jpg\n,\n \n$\ncontents\n);\n\n\n\nStorage\n::\nput\n(\nfile.jpg\n,\n \n$\nresource\n);\n\n\n\n\n\n\nAutomatic Streaming\n\n\nIf you would like Laravel to automatically manage streaming a given file to your storage location, you may use the \nputFile\n or \nputFileAs\n method. This method accepts either a \nIlluminate\\Http\\File\n or \nIlluminate\\Http\\UploadedFile\n instance and will automatically stream the file to your desired location:\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nFile\n;\n\n\n\n//\n \nAutomatically\n \ngenerate\n \na\n \nunique\n \nID\n \nfor\n \nfile\n \nname\n...\n\n\nStorage\n::\nputFile\n(\nphotos\n,\n \nnew\n \nFile\n(\n/path/to/photo\n));\n\n\n\n//\n \nManually\n \nspecify\n \na\n \nfile\n \nname\n...\n\n\nStorage\n::\nputFileAs\n(\nphotos\n,\n \nnew\n \nFile\n(\n/path/to/photo\n),\n \nphoto.jpg\n);\n\n\n\n\n\n\nThere are a few important things to note about the \nputFile\n method. Note that we only specified a directory name, not a file name. By default, the \nputFile\n method will generate a unique ID to serve as the file name. The path to the file will be returned by the \nputFile\n method so you can store the path, including the generated file name, in your database.\n\n\nThe \nputFile\n and \nputFileAs\n methods also accept an argument to specify the \"visibility\" of the stored file. This is particularly useful if you are storing the file on a cloud disk such as S3 and would like the file to be publicly accessible:\n\n\nStorage\n::\nputFile\n(\nphotos\n,\n \nnew\n \nFile\n(\n/path/to/photo\n),\n \npublic\n);\n\n\n\n\n\n\nPrepending \n Appending To Files\n\n\nThe \nprepend\n and \nappend\n methods allow you to write to the beginning or end of a file:\n\n\nStorage\n::\nprepend\n(\nfile.log\n,\n \nPrepended Text\n);\n\n\n\nStorage\n::\nappend\n(\nfile.log\n,\n \nAppended Text\n);\n\n\n\n\n\n\nCopying \n Moving Files\n\n\nThe \ncopy\n method may be used to copy an existing file to a new location on the disk, while the \nmove\n method may be used to rename or move an existing file to a new location:\n\n\nStorage\n::\ncopy\n(\nold/file1.jpg\n,\n \nnew/file1.jpg\n);\n\n\n\nStorage\n::\nmove\n(\nold/file1.jpg\n,\n \nnew/file1.jpg\n);\n\n\n\n\n\n\n\n\nFile Uploads\n\n\nIn web applications, one of the most common use-cases for storing files is storing user uploaded files such as profile pictures, photos, and documents. Laravel makes it very easy to store uploaded files using the \nstore\n method on an uploaded file instance. Simply call the \nstore\n method with the path at which you wish to store the uploaded file:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nUserAvatarController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Update the avatar for the user.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nupdate\n(\nRequest\n \n$request\n)\n\n    \n{\n\n        \n$path\n \n=\n \n$request\n-\nfile\n(\navatar\n)\n-\nstore\n(\navatars\n);\n\n\n        \nreturn\n \n$path\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThere are a few important things to note about this example. Note that we only specified a directory name, not a file name. By default, the \nstore\n method will generate a unique ID to serve as the file name. The path to the file will be returned by the \nstore\n method so you can store the path, including the generated file name, in your database.\n\n\nYou may also call the \nputFile\n method on the \nStorage\n facade to perform the same file manipulation as the example above:\n\n\n$\npath\n \n=\n \nStorage\n::\nputFile\n(\navatars\n,\n \n$\nrequest-\nfile\n(\navatar\n));\n\n\n\n\n\n\nSpecifying A File Name\n\n\nIf you would not like a file name to be automatically assigned to your stored file, you may use the \nstoreAs\n method, which receives the path, the file name, and the (optional) disk as its arguments:\n\n\n$path = $request-\nfile(\navatar\n)-\nstoreAs(\n    \navatars\n, $request-\nuser()-\nid\n);\n\n\n\n\n\nOf course, you may also use the \nputFileAs\n method on the \nStorage\n facade, which will perform the same file manipulation as the example above:\n\n\n$path = Storage::putFileAs(\n    \navatars\n, $request-\nfile(\navatar\n), $request-\nuser()-\nid\n);\n\n\n\n\n\nSpecifying A Disk\n\n\nBy default, this method will use your default disk. If you would like to specify another disk, pass the disk name as the second argument to the \nstore\n method:\n\n\n$path = $request-\nfile(\navatar\n)-\nstore(\n    \navatars/\n.$request-\nuser()-\nid, \ns3\n\n);\n\n\n\n\n\n\n\nFile Visibility\n\n\nIn Laravel's Flysystem integration, \"visibility\" is an abstraction of file permissions across multiple platforms. Files may either be declared \npublic\n or \nprivate\n. When a file is declared \npublic\n, you are indicating that the file should generally be accessible to others. For example, when using the S3 driver, you may retrieve URLs for \npublic\n files.\n\n\nYou can set the visibility when setting the file via the \nput\n method:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nStorage\n;\n\n\n\nStorage\n::\nput\n(\nfile.jpg\n,\n \n$\ncontents\n,\n \npublic\n);\n\n\n\n\n\n\nIf the file has already been stored, its visibility can be retrieved and set via the \ngetVisibility\n and \nsetVisibility\n methods:\n\n\n$\nvisibility\n \n=\n \nStorage\n::\ngetVisibility\n(\nfile.jpg\n);\n\n\n\nStorage\n::\nsetVisibility\n(\nfile.jpg\n,\n \npublic\n)\n\n\n\n\n\n\n\n\nDeleting Files\n\n\nThe \ndelete\n method accepts a single filename or an array of files to remove from the disk:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nStorage\n;\n\n\n\nStorage\n::\ndelete\n(\nfile.jpg\n);\n\n\n\nStorage\n::\ndelete\n(\n[\nfile1.jpg\n,\n \nfile2.jpg\n]\n);\n\n\n\n\n\n\n\n\nDirectories\n\n\nGet All Files Within A Directory\n\n\nThe \nfiles\n method returns an array of all of the files in a given directory. If you would like to retrieve a list of all files within a given directory including all sub-directories, you may use the \nallFiles\n method:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nStorage\n;\n\n\n\n$\nfiles\n \n=\n \nStorage\n::\nfiles\n($\ndirectory\n);\n\n\n\n$\nfiles\n \n=\n \nStorage\n::\nallFiles\n($\ndirectory\n);\n\n\n\n\n\n\nGet All Directories Within A Directory\n\n\nThe \ndirectories\n method returns an array of all the directories within a given directory. Additionally, you may use the \nallDirectories\n method to get a list of all directories within a given directory and all of its sub-directories:\n\n\n$\ndirectories\n \n=\n \nStorage\n::\ndirectories\n($\ndirectory\n);\n\n\n\n//\n \nRecursive\n...\n\n\n$\ndirectories\n \n=\n \nStorage\n::\nallDirectories\n($\ndirectory\n);\n\n\n\n\n\n\nCreate A Directory\n\n\nThe \nmakeDirectory\n method will create the given directory, including any needed sub-directories:\n\n\nStorage\n::\nmakeDirectory\n($\ndirectory\n);\n\n\n\n\n\n\nDelete A Directory\n\n\nFinally, the \ndeleteDirectory\n may be used to remove a directory and all of its files:\n\n\nStorage\n::\ndeleteDirectory\n($\ndirectory\n);\n\n\n\n\n\n\n\n\nCustom Filesystems\n\n\nLaravel's Flysystem integration provides drivers for several \"drivers\" out of the box; however, Flysystem is not limited to these and has adapters for many other storage systems. You can create a custom driver if you want to use one of these additional adapters in your Laravel application.\n\n\nIn order to set up the custom filesystem you will need to create a \nservice provider\n such as \nDropboxServiceProvider\n. In the provider's \nboot\n method, you may use the \nStorage\n facade's \nextend\n method to define the custom driver:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nStorage\n;\n\n\nuse\n \nLeague\n\\\nFlysystem\n\\\nFilesystem\n;\n\n\nuse\n \nDropbox\n\\\nClient\n \nas\n \nDropboxClient\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\nuse\n \nLeague\n\\\nFlysystem\n\\\nDropbox\n\\\nDropboxAdapter\n;\n\n\n\nclass\n \nDropboxServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Perform post-registration booting of services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nStorage\n::\nextend\n(\ndropbox\n,\n \nfunction\n \n(\n$app\n,\n \n$config\n)\n \n{\n\n            \n$client\n \n=\n \nnew\n \nDropboxClient\n(\n\n                \n$config\n[\naccessToken\n],\n \n$config\n[\nclientIdentifier\n]\n\n            \n);\n\n\n            \nreturn\n \nnew\n \nFilesystem\n(\nnew\n \nDropboxAdapter\n(\n$client\n));\n\n        \n});\n\n    \n}\n\n\n    \n/**\n\n\n     * Register bindings in the container.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe first argument of the \nextend\n method is the name of the driver and the second is a Closure that receives the \n$app\n and \n$config\n variables. The resolver Closure must return an instance of \nLeague\\Flysystem\\Filesystem\n. The \n$config\n variable contains the values defined in \nconfig/filesystems.php\n for the specified disk.\n\n\nOnce you have created the service provider to register the extension, you may use the \ndropbox\n driver in your \nconfig/filesystems.php\n configuration file.", 
            "title": "Filesystem"
        }, 
        {
            "location": "/filesystem/#filesystem-cloud-storage", 
            "text": "Introduction  Configuration  The Public Disk  The Local Driver  Driver Prerequisites    Obtaining Disk Instances  Retrieving Files  File URLs  File Metadata    Storing Files  File Uploads  File Visibility    Deleting Files  Directories  Custom Filesystems", 
            "title": "Filesystem / Cloud Storage"
        }, 
        {
            "location": "/filesystem/#introduction", 
            "text": "Laravel provides a powerful filesystem abstraction thanks to the wonderful  Flysystem  PHP package by Frank de Jonge. The Laravel Flysystem integration provides simple to use drivers for working with local filesystems, Amazon S3, and Rackspace Cloud Storage. Even better, it's amazingly simple to switch between these storage options as the API remains the same for each system.", 
            "title": "Introduction"
        }, 
        {
            "location": "/filesystem/#configuration", 
            "text": "The filesystem configuration file is located at  config/filesystems.php . Within this file you may configure all of your \"disks\". Each disk represents a particular storage driver and storage location. Example configurations for each supported driver are included in the configuration file. So, simply modify the configuration to reflect your storage preferences and credentials.  Of course, you may configure as many disks as you like, and may even have multiple disks that use the same driver.", 
            "title": "Configuration"
        }, 
        {
            "location": "/filesystem/#the-public-disk", 
            "text": "The  public  disk is intended for files that are going to be publicly accessible. By default, the  public  disk uses the  local  driver and stores these files in  storage/app/public . To make them accessible from the web, you should create a symbolic link from  public/storage  to  storage/app/public . This convention will keep your publicly accessible files in one directory that can be easily shared across deployments when using zero down-time deployment systems like  Envoyer .  To create the symbolic link, you may use the  storage:link  Artisan command:  php artisan storage:link  Of course, once a file has been stored and the symbolic link has been created, you can create a URL to the files using the  asset  helper:  echo asset( storage/file.txt );", 
            "title": "The Public Disk"
        }, 
        {
            "location": "/filesystem/#the-local-driver", 
            "text": "When using the  local  driver, all file operations are relative to the  root  directory defined in your configuration file. By default, this value is set to the  storage/app  directory. Therefore, the following method would store a file in  storage/app/file.txt :  Storage :: disk ( local ) - put ( file.txt ,   Contents );", 
            "title": "The Local Driver"
        }, 
        {
            "location": "/filesystem/#driver-prerequisites", 
            "text": "", 
            "title": "Driver Prerequisites"
        }, 
        {
            "location": "/filesystem/#composer-packages", 
            "text": "Before using the S3 or Rackspace drivers, you will need to install the appropriate package via Composer:   Amazon S3:  league/flysystem-aws-s3-v3 ~1.0  Rackspace:  league/flysystem-rackspace ~1.0", 
            "title": "Composer Packages"
        }, 
        {
            "location": "/filesystem/#s3-driver-configuration", 
            "text": "The S3 driver configuration information is located in your  config/filesystems.php  configuration file. This file contains an example configuration array for an S3 driver. You are free to modify this array with your own S3 configuration and credentials.", 
            "title": "S3 Driver Configuration"
        }, 
        {
            "location": "/filesystem/#ftp-driver-configuration", 
            "text": "Laravel's Flysystem integrations works great with FTP; however, a sample configuration is not included with the framework's default  filesystems.php  configuration file. If you need to configure a FTP filesystem, you may use the example configuration below:  ftp  =  [\n     driver    =   ftp ,\n     host      =   ftp.example.com ,\n     username  =   your-username ,\n     password  =   your-password ,\n\n    // Optional FTP Settings...\n    //  port      =  21,\n    //  root      =   ,\n    //  passive   =  true,\n    //  ssl       =  true,\n    //  timeout   =  30,\n],", 
            "title": "FTP Driver Configuration"
        }, 
        {
            "location": "/filesystem/#rackspace-driver-configuration", 
            "text": "Laravel's Flysystem integrations works great with Rackspace; however, a sample configuration is not included with the framework's default  filesystems.php  configuration file. If you need to configure a Rackspace filesystem, you may use the example configuration below:  rackspace  =  [\n     driver     =   rackspace ,\n     username   =   your-username ,\n     key        =   your-key ,\n     container  =   your-container ,\n     endpoint   =   https://identity.api.rackspacecloud.com/v2.0/ ,\n     region     =   IAD ,\n     url_type   =   publicURL ,\n],", 
            "title": "Rackspace Driver Configuration"
        }, 
        {
            "location": "/filesystem/#obtaining-disk-instances", 
            "text": "The  Storage  facade may be used to interact with any of your configured disks. For example, you may use the  put  method on the facade to store an avatar on the default disk. If you call methods on the  Storage  facade without first calling the  disk  method, the method call will automatically be passed to the default disk:  use   Illuminate \\ Support \\ Facades \\ Storage ;  Storage :: put ( avatars/1 ,   $ fileContents );   If your applications interacts with multiple disks, you may use the  disk  method on the  Storage  facade to work with files on a particular disk:  Storage :: disk ( s3 ) - put ( avatars/1 ,   $ fileContents );", 
            "title": "Obtaining Disk Instances"
        }, 
        {
            "location": "/filesystem/#retrieving-files", 
            "text": "The  get  method may be used to retrieve the contents of a file. The raw string contents of the file will be returned by the method. Remember, all file paths should be specified relative to the \"root\" location configured for the disk:  $ contents   =   Storage :: get ( file.jpg );   The  exists  method may be used to determine if a file exists on the disk:  $ exists   =   Storage :: disk ( s3 ) - exists ( file.jpg );", 
            "title": "Retrieving Files"
        }, 
        {
            "location": "/filesystem/#file-urls", 
            "text": "When using the  local  or  s3  drivers, you may use the  url  method to get the URL for the given file. If you are using the  local  driver, this will typically just prepend  /storage  to the given path and return a relative URL to the file. If you are using the  s3  driver, the fully qualified remote URL will be returned:  use   Illuminate \\ Support \\ Facades \\ Storage ;  $ url   =   Storage :: url ( file1.jpg );    {note} Remember, if you are using the  local  driver, all files that should be publicly accessible should be placed in the  storage/app/public  directory. Furthermore, you should  create a symbolic link  at  public/storage  which points to the  storage/app/public  directory.", 
            "title": "File URLs"
        }, 
        {
            "location": "/filesystem/#local-url-host-customization", 
            "text": "If you would like to pre-define the host for files stored on a disk using the  local  driver, you may add a  url  option to the disk's configuration array:  public  =  [\n     driver  =   local ,\n     root  =  storage_path( app/public ),\n     url  =  env( APP_URL ). /storage ,\n     visibility  =   public ,\n],", 
            "title": "Local URL Host Customization"
        }, 
        {
            "location": "/filesystem/#file-metadata", 
            "text": "In addition to reading and writing files, Laravel can also provide information about the files themselves. For example, the  size  method may be used to get the size of the file in bytes:  use   Illuminate \\ Support \\ Facades \\ Storage ;  $ size   =   Storage :: size ( file1.jpg );   The  lastModified  method returns the UNIX timestamp of the last time the file was modified:  $ time   =   Storage :: lastModified ( file1.jpg );", 
            "title": "File Metadata"
        }, 
        {
            "location": "/filesystem/#storing-files", 
            "text": "The  put  method may be used to store raw file contents on a disk. You may also pass a PHP  resource  to the  put  method, which will use Flysystem's underlying stream support. Using streams is greatly recommended when dealing with large files:  use   Illuminate \\ Support \\ Facades \\ Storage ;  Storage :: put ( file.jpg ,   $ contents );  Storage :: put ( file.jpg ,   $ resource );", 
            "title": "Storing Files"
        }, 
        {
            "location": "/filesystem/#automatic-streaming", 
            "text": "If you would like Laravel to automatically manage streaming a given file to your storage location, you may use the  putFile  or  putFileAs  method. This method accepts either a  Illuminate\\Http\\File  or  Illuminate\\Http\\UploadedFile  instance and will automatically stream the file to your desired location:  use   Illuminate \\ Http \\ File ;  //   Automatically   generate   a   unique   ID   for   file   name ...  Storage :: putFile ( photos ,   new   File ( /path/to/photo ));  //   Manually   specify   a   file   name ...  Storage :: putFileAs ( photos ,   new   File ( /path/to/photo ),   photo.jpg );   There are a few important things to note about the  putFile  method. Note that we only specified a directory name, not a file name. By default, the  putFile  method will generate a unique ID to serve as the file name. The path to the file will be returned by the  putFile  method so you can store the path, including the generated file name, in your database.  The  putFile  and  putFileAs  methods also accept an argument to specify the \"visibility\" of the stored file. This is particularly useful if you are storing the file on a cloud disk such as S3 and would like the file to be publicly accessible:  Storage :: putFile ( photos ,   new   File ( /path/to/photo ),   public );", 
            "title": "Automatic Streaming"
        }, 
        {
            "location": "/filesystem/#prepending-appending-to-files", 
            "text": "The  prepend  and  append  methods allow you to write to the beginning or end of a file:  Storage :: prepend ( file.log ,   Prepended Text );  Storage :: append ( file.log ,   Appended Text );", 
            "title": "Prepending &amp; Appending To Files"
        }, 
        {
            "location": "/filesystem/#copying-moving-files", 
            "text": "The  copy  method may be used to copy an existing file to a new location on the disk, while the  move  method may be used to rename or move an existing file to a new location:  Storage :: copy ( old/file1.jpg ,   new/file1.jpg );  Storage :: move ( old/file1.jpg ,   new/file1.jpg );", 
            "title": "Copying &amp; Moving Files"
        }, 
        {
            "location": "/filesystem/#file-uploads", 
            "text": "In web applications, one of the most common use-cases for storing files is storing user uploaded files such as profile pictures, photos, and documents. Laravel makes it very easy to store uploaded files using the  store  method on an uploaded file instance. Simply call the  store  method with the path at which you wish to store the uploaded file:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Http \\ Request ;  use   App \\ Http \\ Controllers \\ Controller ;  class   UserAvatarController   extends   Controller  { \n     /**       * Update the avatar for the user.       *       * @param  Request  $request       * @return Response       */ \n     public   function   update ( Request   $request ) \n     { \n         $path   =   $request - file ( avatar ) - store ( avatars ); \n\n         return   $path ; \n     }  }   There are a few important things to note about this example. Note that we only specified a directory name, not a file name. By default, the  store  method will generate a unique ID to serve as the file name. The path to the file will be returned by the  store  method so you can store the path, including the generated file name, in your database.  You may also call the  putFile  method on the  Storage  facade to perform the same file manipulation as the example above:  $ path   =   Storage :: putFile ( avatars ,   $ request- file ( avatar ));", 
            "title": "File Uploads"
        }, 
        {
            "location": "/filesystem/#specifying-a-file-name", 
            "text": "If you would not like a file name to be automatically assigned to your stored file, you may use the  storeAs  method, which receives the path, the file name, and the (optional) disk as its arguments:  $path = $request- file( avatar )- storeAs(\n     avatars , $request- user()- id\n);  Of course, you may also use the  putFileAs  method on the  Storage  facade, which will perform the same file manipulation as the example above:  $path = Storage::putFileAs(\n     avatars , $request- file( avatar ), $request- user()- id\n);", 
            "title": "Specifying A File Name"
        }, 
        {
            "location": "/filesystem/#specifying-a-disk", 
            "text": "By default, this method will use your default disk. If you would like to specify another disk, pass the disk name as the second argument to the  store  method:  $path = $request- file( avatar )- store(\n     avatars/ .$request- user()- id,  s3 \n);", 
            "title": "Specifying A Disk"
        }, 
        {
            "location": "/filesystem/#file-visibility", 
            "text": "In Laravel's Flysystem integration, \"visibility\" is an abstraction of file permissions across multiple platforms. Files may either be declared  public  or  private . When a file is declared  public , you are indicating that the file should generally be accessible to others. For example, when using the S3 driver, you may retrieve URLs for  public  files.  You can set the visibility when setting the file via the  put  method:  use   Illuminate \\ Support \\ Facades \\ Storage ;  Storage :: put ( file.jpg ,   $ contents ,   public );   If the file has already been stored, its visibility can be retrieved and set via the  getVisibility  and  setVisibility  methods:  $ visibility   =   Storage :: getVisibility ( file.jpg );  Storage :: setVisibility ( file.jpg ,   public )", 
            "title": "File Visibility"
        }, 
        {
            "location": "/filesystem/#deleting-files", 
            "text": "The  delete  method accepts a single filename or an array of files to remove from the disk:  use   Illuminate \\ Support \\ Facades \\ Storage ;  Storage :: delete ( file.jpg );  Storage :: delete ( [ file1.jpg ,   file2.jpg ] );", 
            "title": "Deleting Files"
        }, 
        {
            "location": "/filesystem/#directories", 
            "text": "", 
            "title": "Directories"
        }, 
        {
            "location": "/filesystem/#get-all-files-within-a-directory", 
            "text": "The  files  method returns an array of all of the files in a given directory. If you would like to retrieve a list of all files within a given directory including all sub-directories, you may use the  allFiles  method:  use   Illuminate \\ Support \\ Facades \\ Storage ;  $ files   =   Storage :: files ($ directory );  $ files   =   Storage :: allFiles ($ directory );", 
            "title": "Get All Files Within A Directory"
        }, 
        {
            "location": "/filesystem/#get-all-directories-within-a-directory", 
            "text": "The  directories  method returns an array of all the directories within a given directory. Additionally, you may use the  allDirectories  method to get a list of all directories within a given directory and all of its sub-directories:  $ directories   =   Storage :: directories ($ directory );  //   Recursive ...  $ directories   =   Storage :: allDirectories ($ directory );", 
            "title": "Get All Directories Within A Directory"
        }, 
        {
            "location": "/filesystem/#create-a-directory", 
            "text": "The  makeDirectory  method will create the given directory, including any needed sub-directories:  Storage :: makeDirectory ($ directory );", 
            "title": "Create A Directory"
        }, 
        {
            "location": "/filesystem/#delete-a-directory", 
            "text": "Finally, the  deleteDirectory  may be used to remove a directory and all of its files:  Storage :: deleteDirectory ($ directory );", 
            "title": "Delete A Directory"
        }, 
        {
            "location": "/filesystem/#custom-filesystems", 
            "text": "Laravel's Flysystem integration provides drivers for several \"drivers\" out of the box; however, Flysystem is not limited to these and has adapters for many other storage systems. You can create a custom driver if you want to use one of these additional adapters in your Laravel application.  In order to set up the custom filesystem you will need to create a  service provider  such as  DropboxServiceProvider . In the provider's  boot  method, you may use the  Storage  facade's  extend  method to define the custom driver:  ? php  namespace   App \\ Providers ;  use   Storage ;  use   League \\ Flysystem \\ Filesystem ;  use   Dropbox \\ Client   as   DropboxClient ;  use   Illuminate \\ Support \\ ServiceProvider ;  use   League \\ Flysystem \\ Dropbox \\ DropboxAdapter ;  class   DropboxServiceProvider   extends   ServiceProvider  { \n     /**       * Perform post-registration booting of services.       *       * @return void       */ \n     public   function   boot () \n     { \n         Storage :: extend ( dropbox ,   function   ( $app ,   $config )   { \n             $client   =   new   DropboxClient ( \n                 $config [ accessToken ],   $config [ clientIdentifier ] \n             ); \n\n             return   new   Filesystem ( new   DropboxAdapter ( $client )); \n         }); \n     } \n\n     /**       * Register bindings in the container.       *       * @return void       */ \n     public   function   register () \n     { \n         // \n     }  }   The first argument of the  extend  method is the name of the driver and the second is a Closure that receives the  $app  and  $config  variables. The resolver Closure must return an instance of  League\\Flysystem\\Filesystem . The  $config  variable contains the values defined in  config/filesystems.php  for the specified disk.  Once you have created the service provider to register the extension, you may use the  dropbox  driver in your  config/filesystems.php  configuration file.", 
            "title": "Custom Filesystems"
        }, 
        {
            "location": "/frontend/", 
            "text": "JavaScript \n CSS Scaffolding\n\n\n\n\nIntroduction\n\n\nWriting CSS\n\n\nWriting JavaScript\n\n\nWriting Vue Components\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nWhile Laravel does not dictate which JavaScript or CSS pre-processors you use, it does provide a basic starting point using \nBootstrap\n and \nVue\n that will be helpful for many applications. By default, Laravel uses \nNPM\n to install both of these frontend packages.\n\n\nCSS\n\n\nLaravel Mix\n provides a clean, expressive API over compiling SASS or Less, which are extensions of plain CSS that add variables, mixins, and other powerful features that make working with CSS much more enjoyable.\n\n\nIn this document, we will briefly discuss CSS compilation in general; however, you should consult the full \nLaravel Mix documentation\n for more information on compiling SASS or Less.\n\n\nJavaScript\n\n\nLaravel does not require you to use a specific JavaScript framework or library to build your applications. In fact, you don't have to use JavaScript at all. However, Laravel does include some basic scaffolding to make it easier to get started writing modern JavaScript using the \nVue\n library. Vue provides an expressive API for building robust JavaScript applications using components.\n\n\n\n\nWriting CSS\n\n\nThe Laravel \npackage.json\n file includes the \nbootstrap-sass\n package to help you get started prototyping your application's frontend using Bootstrap. However, feel free to add or remove packages from the \npackage.json\n file as needed for your own application. You are not required to use the Bootstrap framework to build your Laravel application - it is simply provided as a good starting point for those who choose to use it.\n\n\nBefore compiling your CSS, install your project's frontend dependencies using NPM:\n\n\nnpm install\n\n\n\n\n\nOnce the dependencies have been installed using \nnpm install\n, you can compile your SASS files to plain CSS using \nLaravel Mix\n. The \nnpm run dev\n command will process the instructions in your \nwebpack.mix.js\n file. Typically, your compiled CSS will be placed in the \npublic/css\n directory:\n\n\nnpm run dev\n\n\n\n\n\nThe default \nwebpack.mix.js\n included with Laravel will compile the \nresources/assets/sass/app.scss\n SASS file. This \napp.scss\n file imports a file of SASS variables and loads Bootstrap, which provides a good starting point for most applications. Feel free to customize the \napp.scss\n file however you wish or even use an entirely different pre-processor by \nconfiguring Laravel Mix\n.\n\n\n\n\nWriting JavaScript\n\n\nAll of the JavaScript dependencies required by your application can be found in the \npackage.json\n file in the project's root directory. This file is similar to a \ncomposer.json\n file except it specifies JavaScript dependencies instead of PHP dependencies. You can install these dependencies using the \nNode package manager (NPM)\n:\n\n\nnpm install\n\n\n\n\n\nBy default, the Laravel \npackage.json\n file includes a few packages such as \nvue\n and \naxios\n to help you get started building your JavaScript application. Feel free to add or remove from the \npackage.json\n file as needed for your own application.\n\n\nOnce the packages are installed, you can use the \nnpm run dev\n command to \ncompile your assets\n. Webpack is a module bundler for modern JavaScript applications. When you run the \nnpm run dev\n command, Webpack will execute the instructions in your \nwebpack.mix.js\n file:\n\n\nnpm run dev\n\n\n\n\n\nBy default, the Laravel \nwebpack.mix.js\n file compiles your SASS and the \nresources/assets/js/app.js\n file. Within the \napp.js\n file you may register your Vue components or, if you prefer a different framework, configure your own JavaScript application. Your compiled JavaScript will typically be placed in the \npublic/js\n directory.\n\n\n\n\n{tip} The \napp.js\n file will load the \nresources/assets/js/bootstrap.js\n file which bootstraps and configures Vue, Axios, jQuery, and all other JavaScript dependencies. If you have additional JavaScript dependencies to configure, you may do so in this file.\n\n\n\n\n\n\nWriting Vue Components\n\n\nBy default, fresh Laravel applications contain an \nExample.vue\n Vue component located in the \nresources/assets/js/components\n directory. The \nExample.vue\n file is an example of a \nsingle file Vue component\n which defines its JavaScript and HTML template in the same file. Single file components provide a very convenient approach to building JavaScript driven applications. The example component is registered in your \napp.js\n file:\n\n\nVue.component(\nexample\n, require(\n./components/Example.vue\n));\n\n\n\n\n\nTo use the component in your application, you may simply drop it into one of your HTML templates. For example, after running the \nmake:auth\n Artisan command to scaffold your application's authentication and registration screens, you could drop the component into the \nhome.blade.php\n Blade template:\n\n\n@\nextends\n(\nlayouts\n.\napp\n)\n\n\n\n@\nsection\n(\ncontent\n)\n\n    \nexample\n/\nexample\n\n\n@\nendsection\n\n\n\n\n\n\n\n\n{tip} Remember, you should run the \nnpm run dev\n command each time you change a Vue component. Or, you may run the \nnpm run watch\n command to monitor and automatically recompile your components each time they are modified.\n\n\n\n\nOf course, if you are interested in learning more about writing Vue components, you should read the \nVue documentation\n, which provides a thorough, easy-to-read overview of the entire Vue framework.", 
            "title": "Frontend"
        }, 
        {
            "location": "/frontend/#javascript-css-scaffolding", 
            "text": "Introduction  Writing CSS  Writing JavaScript  Writing Vue Components", 
            "title": "JavaScript &amp; CSS Scaffolding"
        }, 
        {
            "location": "/frontend/#introduction", 
            "text": "While Laravel does not dictate which JavaScript or CSS pre-processors you use, it does provide a basic starting point using  Bootstrap  and  Vue  that will be helpful for many applications. By default, Laravel uses  NPM  to install both of these frontend packages.", 
            "title": "Introduction"
        }, 
        {
            "location": "/frontend/#css", 
            "text": "Laravel Mix  provides a clean, expressive API over compiling SASS or Less, which are extensions of plain CSS that add variables, mixins, and other powerful features that make working with CSS much more enjoyable.  In this document, we will briefly discuss CSS compilation in general; however, you should consult the full  Laravel Mix documentation  for more information on compiling SASS or Less.", 
            "title": "CSS"
        }, 
        {
            "location": "/frontend/#javascript", 
            "text": "Laravel does not require you to use a specific JavaScript framework or library to build your applications. In fact, you don't have to use JavaScript at all. However, Laravel does include some basic scaffolding to make it easier to get started writing modern JavaScript using the  Vue  library. Vue provides an expressive API for building robust JavaScript applications using components.", 
            "title": "JavaScript"
        }, 
        {
            "location": "/frontend/#writing-css", 
            "text": "The Laravel  package.json  file includes the  bootstrap-sass  package to help you get started prototyping your application's frontend using Bootstrap. However, feel free to add or remove packages from the  package.json  file as needed for your own application. You are not required to use the Bootstrap framework to build your Laravel application - it is simply provided as a good starting point for those who choose to use it.  Before compiling your CSS, install your project's frontend dependencies using NPM:  npm install  Once the dependencies have been installed using  npm install , you can compile your SASS files to plain CSS using  Laravel Mix . The  npm run dev  command will process the instructions in your  webpack.mix.js  file. Typically, your compiled CSS will be placed in the  public/css  directory:  npm run dev  The default  webpack.mix.js  included with Laravel will compile the  resources/assets/sass/app.scss  SASS file. This  app.scss  file imports a file of SASS variables and loads Bootstrap, which provides a good starting point for most applications. Feel free to customize the  app.scss  file however you wish or even use an entirely different pre-processor by  configuring Laravel Mix .", 
            "title": "Writing CSS"
        }, 
        {
            "location": "/frontend/#writing-javascript", 
            "text": "All of the JavaScript dependencies required by your application can be found in the  package.json  file in the project's root directory. This file is similar to a  composer.json  file except it specifies JavaScript dependencies instead of PHP dependencies. You can install these dependencies using the  Node package manager (NPM) :  npm install  By default, the Laravel  package.json  file includes a few packages such as  vue  and  axios  to help you get started building your JavaScript application. Feel free to add or remove from the  package.json  file as needed for your own application.  Once the packages are installed, you can use the  npm run dev  command to  compile your assets . Webpack is a module bundler for modern JavaScript applications. When you run the  npm run dev  command, Webpack will execute the instructions in your  webpack.mix.js  file:  npm run dev  By default, the Laravel  webpack.mix.js  file compiles your SASS and the  resources/assets/js/app.js  file. Within the  app.js  file you may register your Vue components or, if you prefer a different framework, configure your own JavaScript application. Your compiled JavaScript will typically be placed in the  public/js  directory.   {tip} The  app.js  file will load the  resources/assets/js/bootstrap.js  file which bootstraps and configures Vue, Axios, jQuery, and all other JavaScript dependencies. If you have additional JavaScript dependencies to configure, you may do so in this file.", 
            "title": "Writing JavaScript"
        }, 
        {
            "location": "/frontend/#writing-vue-components", 
            "text": "By default, fresh Laravel applications contain an  Example.vue  Vue component located in the  resources/assets/js/components  directory. The  Example.vue  file is an example of a  single file Vue component  which defines its JavaScript and HTML template in the same file. Single file components provide a very convenient approach to building JavaScript driven applications. The example component is registered in your  app.js  file:  Vue.component( example , require( ./components/Example.vue ));  To use the component in your application, you may simply drop it into one of your HTML templates. For example, after running the  make:auth  Artisan command to scaffold your application's authentication and registration screens, you could drop the component into the  home.blade.php  Blade template:  @ extends ( layouts . app )  @ section ( content ) \n     example / example  @ endsection    {tip} Remember, you should run the  npm run dev  command each time you change a Vue component. Or, you may run the  npm run watch  command to monitor and automatically recompile your components each time they are modified.   Of course, if you are interested in learning more about writing Vue components, you should read the  Vue documentation , which provides a thorough, easy-to-read overview of the entire Vue framework.", 
            "title": "Writing Vue Components"
        }, 
        {
            "location": "/hashing/", 
            "text": "Hashing\n\n\n\n\nIntroduction\n\n\nBasic Usage\n\n\n\n\n\n\nIntroduction\n\n\nThe Laravel \nHash\n \nfacade\n provides secure Bcrypt hashing for storing user passwords. If you are using the built-in \nLoginController\n and \nRegisterController\n classes that are included with your Laravel application, they will automatically use Bcrypt for registration and authentication.\n\n\n\n\n{tip} Bcrypt is a great choice for hashing passwords because its \"work factor\" is adjustable, which means that the time it takes to generate a hash can be increased as hardware power increases.\n\n\n\n\n\n\nBasic Usage\n\n\nYou may hash a password by calling the \nmake\n method on the \nHash\n facade:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nHash\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nUpdatePasswordController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Update the password for the user.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nupdate\n(\nRequest\n \n$request\n)\n\n    \n{\n\n        \n// Validate the new password length...\n\n\n        \n$request\n-\nuser\n()\n-\nfill\n([\n\n            \npassword\n \n=\n \nHash\n::\nmake\n(\n$request\n-\nnewPassword\n)\n\n        \n])\n-\nsave\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nVerifying A Password Against A Hash\n\n\nThe \ncheck\n method allows you to verify that a given plain-text string corresponds to a given hash. However, if you are using the \nLoginController\n \nincluded with Laravel\n, you will probably not need to use this directly, as this controller automatically calls this method:\n\n\nif (Hash::check(\nplain-text\n, $hashedPassword)) {\n    // The passwords match...\n}\n\n\n\n\n\nChecking If A Password Needs To Be Rehashed\n\n\nThe \nneedsRehash\n function allows you to determine if the work factor used by the hasher has changed since the password was hashed:\n\n\nif\n \n(\nHash\n::\nneedsRehash\n($\nhashed\n))\n \n{\n\n    \n$hashed\n \n=\n \nHash\n:\n:\nmake\n(\nplain-text\n);\n\n\n}", 
            "title": "Hashing"
        }, 
        {
            "location": "/hashing/#hashing", 
            "text": "Introduction  Basic Usage", 
            "title": "Hashing"
        }, 
        {
            "location": "/hashing/#introduction", 
            "text": "The Laravel  Hash   facade  provides secure Bcrypt hashing for storing user passwords. If you are using the built-in  LoginController  and  RegisterController  classes that are included with your Laravel application, they will automatically use Bcrypt for registration and authentication.   {tip} Bcrypt is a great choice for hashing passwords because its \"work factor\" is adjustable, which means that the time it takes to generate a hash can be increased as hardware power increases.", 
            "title": "Introduction"
        }, 
        {
            "location": "/hashing/#basic-usage", 
            "text": "You may hash a password by calling the  make  method on the  Hash  facade:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Http \\ Request ;  use   Illuminate \\ Support \\ Facades \\ Hash ;  use   App \\ Http \\ Controllers \\ Controller ;  class   UpdatePasswordController   extends   Controller  { \n     /**       * Update the password for the user.       *       * @param  Request  $request       * @return Response       */ \n     public   function   update ( Request   $request ) \n     { \n         // Validate the new password length... \n\n         $request - user () - fill ([ \n             password   =   Hash :: make ( $request - newPassword ) \n         ]) - save (); \n     }  }", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/hashing/#verifying-a-password-against-a-hash", 
            "text": "The  check  method allows you to verify that a given plain-text string corresponds to a given hash. However, if you are using the  LoginController   included with Laravel , you will probably not need to use this directly, as this controller automatically calls this method:  if (Hash::check( plain-text , $hashedPassword)) {\n    // The passwords match...\n}", 
            "title": "Verifying A Password Against A Hash"
        }, 
        {
            "location": "/hashing/#checking-if-a-password-needs-to-be-rehashed", 
            "text": "The  needsRehash  function allows you to determine if the work factor used by the hasher has changed since the password was hashed:  if   ( Hash :: needsRehash ($ hashed ))   { \n     $hashed   =   Hash : : make ( plain-text );  }", 
            "title": "Checking If A Password Needs To Be Rehashed"
        }, 
        {
            "location": "/helpers/", 
            "text": "Helper Functions\n\n\n\n\nIntroduction\n\n\nAvailable Methods\n\n\n\n\n\n\nIntroduction\n\n\nLaravel includes a variety of global \"helper\" PHP functions. Many of these functions are used by the framework itself; however, you are free to use them in your own applications if you find them convenient.\n\n\n\n\nAvailable Methods\n\n\n\n    .collection-method-list > p {\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    .collection-method-list a {\n        display: block;\n    }\n\n\n\n\nArrays\n\n\n\n\n[array_add](#method-array-add)\n[array_collapse](#method-array-collapse)\n[array_divide](#method-array-divide)\n[array_dot](#method-array-dot)\n[array_except](#method-array-except)\n[array_first](#method-array-first)\n[array_flatten](#method-array-flatten)\n[array_forget](#method-array-forget)\n[array_get](#method-array-get)\n[array_has](#method-array-has)\n[array_last](#method-array-last)\n[array_only](#method-array-only)\n[array_pluck](#method-array-pluck)\n[array_prepend](#method-array-prepend)\n[array_pull](#method-array-pull)\n[array_set](#method-array-set)\n[array_sort](#method-array-sort)\n[array_sort_recursive](#method-array-sort-recursive)\n[array_where](#method-array-where)\n[head](#method-head)\n[last](#method-last)\n\n\n\n\nPaths\n\n\n\n\n[app_path](#method-app-path)\n[base_path](#method-base-path)\n[config_path](#method-config-path)\n[database_path](#method-database-path)\n[mix](#method-mix)\n[public_path](#method-public-path)\n[resource_path](#method-resource-path)\n[storage_path](#method-storage-path)\n\n\n\n\n\nStrings\n\n\n\n\n[camel_case](#method-camel-case)\n[class_basename](#method-class-basename)\n[e](#method-e)\n[ends_with](#method-ends-with)\n[snake_case](#method-snake-case)\n[str_limit](#method-str-limit)\n[starts_with](#method-starts-with)\n[str_contains](#method-str-contains)\n[str_finish](#method-str-finish)\n[str_is](#method-str-is)\n[str_plural](#method-str-plural)\n[str_random](#method-str-random)\n[str_singular](#method-str-singular)\n[str_slug](#method-str-slug)\n[studly_case](#method-studly-case)\n[title_case](#method-title-case)\n[trans](#method-trans)\n[trans_choice](#method-trans-choice)\n\n\n\n\n\nURLs\n\n\n\n\n[action](#method-action)\n[asset](#method-asset)\n[secure_asset](#method-secure-asset)\n[route](#method-route)\n[secure_url](#method-secure-url)\n[url](#method-url)\n\n\n\n\n\nMiscellaneous\n\n\n\n\n[abort](#method-abort)\n[abort_if](#method-abort-if)\n[abort_unless](#method-abort-unless)\n[auth](#method-auth)\n[back](#method-back)\n[bcrypt](#method-bcrypt)\n[cache](#method-cache)\n[collect](#method-collect)\n[config](#method-config)\n[csrf_field](#method-csrf-field)\n[csrf_token](#method-csrf-token)\n[dd](#method-dd)\n[dispatch](#method-dispatch)\n[env](#method-env)\n[event](#method-event)\n[factory](#method-factory)\n[info](#method-info)\n[logger](#method-logger)\n[method_field](#method-method-field)\n[old](#method-old)\n[redirect](#method-redirect)\n[request](#method-request)\n[response](#method-response)\n[retry](#method-retry)\n[session](#method-session)\n[value](#method-value)\n[view](#method-view)\n\n\n\n\n\n\n\nMethod Listing\n\n\n\n    #collection-method code {\n        font-size: 14px;\n    }\n\n    #collection-method:not(.first-collection-method) {\n        margin-top: 50px;\n    }\n\n\n\n\n\n\nArrays\n\n\n\n\narray_add()\n {#collection-method .first-collection-method}\n\n\nThe \narray_add\n function adds a given key / value pair to the array if the given key doesn't already exist in the array:\n\n\n$array = array_add([\nname\n =\n \nDesk\n], \nprice\n, 100);\n\n// [\nname\n =\n \nDesk\n, \nprice\n =\n 100]\n\n\n\n\n\n\n\narray_collapse()\n {#collection-method}\n\n\nThe \narray_collapse\n function collapses an array of arrays into a single array:\n\n\n$array = array_collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);\n\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\n\n\n\narray_divide()\n {#collection-method}\n\n\nThe \narray_divide\n function returns two arrays, one containing the keys, and the other containing the values of the original array:\n\n\nlist($keys, $values) = array_divide([\nname\n =\n \nDesk\n]);\n\n// $keys: [\nname\n]\n\n// $values: [\nDesk\n]\n\n\n\n\n\n\n\narray_dot()\n {#collection-method}\n\n\nThe \narray_dot\n function flattens a multi-dimensional array into a single level array that uses \"dot\" notation to indicate depth:\n\n\n$array = array_dot([\nfoo\n =\n [\nbar\n =\n \nbaz\n]]);\n\n// [\nfoo.bar\n =\n \nbaz\n];\n\n\n\n\n\n\n\narray_except()\n {#collection-method}\n\n\nThe \narray_except\n function removes the given key / value pairs from the array:\n\n\n$array = [\nname\n =\n \nDesk\n, \nprice\n =\n 100];\n\n$array = array_except($array, [\nprice\n]);\n\n// [\nname\n =\n \nDesk\n]\n\n\n\n\n\n\n\narray_first()\n {#collection-method}\n\n\nThe \narray_first\n function returns the first element of an array passing a given truth test:\n\n\n$array = [100, 200, 300];\n\n$value = array_first($array, function ($value, $key) {\n    return $value \n= 150;\n});\n\n// 200\n\n\n\n\n\nA default value may also be passed as the third parameter to the method. This value will be returned if no value passes the truth test:\n\n\n$value = array_first($array, $callback, $default);\n\n\n\n\n\n\n\narray_flatten()\n {#collection-method}\n\n\nThe \narray_flatten\n function will flatten a multi-dimensional array into a single level.\n\n\n$array = [\nname\n =\n \nJoe\n, \nlanguages\n =\n [\nPHP\n, \nRuby\n]];\n\n$array = array_flatten($array);\n\n// [\nJoe\n, \nPHP\n, \nRuby\n];\n\n\n\n\n\n\n\narray_forget()\n {#collection-method}\n\n\nThe \narray_forget\n function removes a given key / value pair from a deeply nested array using \"dot\" notation:\n\n\n$array = [\nproducts\n =\n [\ndesk\n =\n [\nprice\n =\n 100]]];\n\narray_forget($array, \nproducts.desk\n);\n\n// [\nproducts\n =\n []]\n\n\n\n\n\n\n\narray_get()\n {#collection-method}\n\n\nThe \narray_get\n function retrieves a value from a deeply nested array using \"dot\" notation:\n\n\n$array = [\nproducts\n =\n [\ndesk\n =\n [\nprice\n =\n 100]]];\n\n$value = array_get($array, \nproducts.desk\n);\n\n// [\nprice\n =\n 100]\n\n\n\n\n\nThe \narray_get\n function also accepts a default value, which will be returned if the specific key is not found:\n\n\n$value = array_get($array, \nnames.john\n, \ndefault\n);\n\n\n\n\n\n\n\narray_has()\n {#collection-method}\n\n\nThe \narray_has\n function checks that a given item or items exists in an array using \"dot\" notation:\n\n\n$array = [\nproduct\n =\n [\nname\n =\n \ndesk\n, \nprice\n =\n 100]];\n\n$hasItem = array_has($array, \nproduct.name\n);\n\n// true\n\n$hasItems = array_has($array, [\nproduct.price\n, \nproduct.discount\n]);\n\n// false\n\n\n\n\n\n\n\narray_last()\n {#collection-method}\n\n\nThe \narray_last\n function returns the last element of an array passing a given truth test:\n\n\n$array = [100, 200, 300, 110];\n\n$value = array_last($array, function ($value, $key) {\n    return $value \n= 150;\n});\n\n// 300\n\n\n\n\n\n\n\narray_only()\n {#collection-method}\n\n\nThe \narray_only\n function will return only the specified key / value pairs from the given array:\n\n\n$array = [\nname\n =\n \nDesk\n, \nprice\n =\n 100, \norders\n =\n 10];\n\n$array = array_only($array, [\nname\n, \nprice\n]);\n\n// [\nname\n =\n \nDesk\n, \nprice\n =\n 100]\n\n\n\n\n\n\n\narray_pluck()\n {#collection-method}\n\n\nThe \narray_pluck\n function will pluck a list of the given key / value pairs from the array:\n\n\n$array = [\n    [\ndeveloper\n =\n [\nid\n =\n 1, \nname\n =\n \nTaylor\n]],\n    [\ndeveloper\n =\n [\nid\n =\n 2, \nname\n =\n \nAbigail\n]],\n];\n\n$array = array_pluck($array, \ndeveloper.name\n);\n\n// [\nTaylor\n, \nAbigail\n];\n\n\n\n\n\nYou may also specify how you wish the resulting list to be keyed:\n\n\n$array = array_pluck($array, \ndeveloper.name\n, \ndeveloper.id\n);\n\n// [1 =\n \nTaylor\n, 2 =\n \nAbigail\n];\n\n\n\n\n\n\n\narray_prepend()\n {#collection-method}\n\n\nThe \narray_prepend\n function will push an item onto the beginning of an array:\n\n\n$array = [\none\n, \ntwo\n, \nthree\n, \nfour\n];\n\n$array = array_prepend($array, \nzero\n);\n\n// $array: [\nzero\n, \none\n, \ntwo\n, \nthree\n, \nfour\n]\n\n\n\n\n\n\n\narray_pull()\n {#collection-method}\n\n\nThe \narray_pull\n function returns and removes a key / value pair from the array:\n\n\n$array = [\nname\n =\n \nDesk\n, \nprice\n =\n 100];\n\n$name = array_pull($array, \nname\n);\n\n// $name: Desk\n\n// $array: [\nprice\n =\n 100]\n\n\n\n\n\n\n\narray_set()\n {#collection-method}\n\n\nThe \narray_set\n function sets a value within a deeply nested array using \"dot\" notation:\n\n\n$array = [\nproducts\n =\n [\ndesk\n =\n [\nprice\n =\n 100]]];\n\narray_set($array, \nproducts.desk.price\n, 200);\n\n// [\nproducts\n =\n [\ndesk\n =\n [\nprice\n =\n 200]]]\n\n\n\n\n\n\n\narray_sort()\n {#collection-method}\n\n\nThe \narray_sort\n function sorts the array by the results of the given Closure:\n\n\n$array = [\n    [\nname\n =\n \nDesk\n],\n    [\nname\n =\n \nChair\n],\n];\n\n$array = array_values(array_sort($array, function ($value) {\n    return $value[\nname\n];\n}));\n\n/*\n    [\n        [\nname\n =\n \nChair\n],\n        [\nname\n =\n \nDesk\n],\n    ]\n*/\n\n\n\n\n\n\n\narray_sort_recursive()\n {#collection-method}\n\n\nThe \narray_sort_recursive\n function recursively sorts the array using the \nsort\n function:\n\n\n$array = [\n    [\n        \nRoman\n,\n        \nTaylor\n,\n        \nLi\n,\n    ],\n    [\n        \nPHP\n,\n        \nRuby\n,\n        \nJavaScript\n,\n    ],\n];\n\n$array = array_sort_recursive($array);\n\n/*\n    [\n        [\n            \nLi\n,\n            \nRoman\n,\n            \nTaylor\n,\n        ],\n        [\n            \nJavaScript\n,\n            \nPHP\n,\n            \nRuby\n,\n        ]\n    ];\n*/\n\n\n\n\n\n\n\narray_where()\n {#collection-method}\n\n\nThe \narray_where\n function filters the array using the given Closure:\n\n\n$array = [100, \n200\n, 300, \n400\n, 500];\n\n$array = array_where($array, function ($value, $key) {\n    return is_string($value);\n});\n\n// [1 =\n 200, 3 =\n 400]\n\n\n\n\n\n\n\nhead()\n {#collection-method}\n\n\nThe \nhead\n function simply returns the first element in the given array:\n\n\n$array = [100, 200, 300];\n\n$first = head($array);\n\n// 100\n\n\n\n\n\n\n\nlast()\n {#collection-method}\n\n\nThe \nlast\n function returns the last element in the given array:\n\n\n$array = [100, 200, 300];\n\n$last = last($array);\n\n// 300\n\n\n\n\n\n\n\nPaths\n\n\n\n\napp_path()\n {#collection-method}\n\n\nThe \napp_path\n function returns the fully qualified path to the \napp\n directory. You may also use the \napp_path\n function to generate a fully qualified path to a file relative to the application directory:\n\n\n$path = app_path();\n\n$path = app_path(\nHttp/Controllers/Controller.php\n);\n\n\n\n\n\n\n\nbase_path()\n {#collection-method}\n\n\nThe \nbase_path\n function returns the fully qualified path to the project root. You may also use the \nbase_path\n function to generate a fully qualified path to a given file relative to the project root directory:\n\n\n$path = base_path();\n\n$path = base_path(\nvendor/bin\n);\n\n\n\n\n\n\n\nconfig_path()\n {#collection-method}\n\n\nThe \nconfig_path\n function returns the fully qualified path to the application configuration directory:\n\n\n$path = config_path();\n\n\n\n\n\n\n\ndatabase_path()\n {#collection-method}\n\n\nThe \ndatabase_path\n function returns the fully qualified path to the application's database directory:\n\n\n$path = database_path();\n\n\n\n\n\n\n\nmix()\n {#collection-method}\n\n\nThe \nmix\n function gets the path to a \nversioned Mix file\n:\n\n\nmix($file);\n\n\n\n\n\n\n\npublic_path()\n {#collection-method}\n\n\nThe \npublic_path\n function returns the fully qualified path to the \npublic\n directory:\n\n\n$path = public_path();\n\n\n\n\n\n\n\nresource_path()\n {#collection-method}\n\n\nThe \nresource_path\n function returns the fully qualified path to the \nresources\n directory. You may also use the \nresource_path\n function to generate a fully qualified path to a given file relative to the resources directory:\n\n\n$path = resource_path();\n\n$path = resource_path(\nassets/sass/app.scss\n);\n\n\n\n\n\n\n\nstorage_path()\n {#collection-method}\n\n\nThe \nstorage_path\n function returns the fully qualified path to the \nstorage\n directory. You may also use the \nstorage_path\n function to generate a fully qualified path to a given file relative to the storage directory:\n\n\n$path = storage_path();\n\n$path = storage_path(\napp/file.txt\n);\n\n\n\n\n\n\n\nStrings\n\n\n\n\ncamel_case()\n {#collection-method}\n\n\nThe \ncamel_case\n function converts the given string to \ncamelCase\n:\n\n\n$camel = camel_case(\nfoo_bar\n);\n\n// fooBar\n\n\n\n\n\n\n\nclass_basename()\n {#collection-method}\n\n\nThe \nclass_basename\n returns the class name of the given class with the class' namespace removed:\n\n\n$class = class_basename(\nFoo\\Bar\\Baz\n);\n\n// Baz\n\n\n\n\n\n\n\ne()\n {#collection-method}\n\n\nThe \ne\n function runs \nhtmlspecialchars\n over the given string:\n\n\necho e(\nhtml\nfoo\n/html\n);\n\n// \nlt;\nhtml\ngt;\nfoo\nlt;\n/html\ngt;\n\n\n\n\n\n\n\n\nends_with()\n {#collection-method}\n\n\nThe \nends_with\n function determines if the given string ends with the given value:\n\n\n$value = ends_with(\nThis is my name\n, \nname\n);\n\n// true\n\n\n\n\n\n\n\nsnake_case()\n {#collection-method}\n\n\nThe \nsnake_case\n function converts the given string to \nsnake_case\n:\n\n\n$snake = snake_case(\nfooBar\n);\n\n// foo_bar\n\n\n\n\n\n\n\nstr_limit()\n {#collection-method}\n\n\nThe \nstr_limit\n function limits the number of characters in a string. The function accepts a string as its first argument and the maximum number of resulting characters as its second argument:\n\n\n$value = str_limit(\nThe PHP framework for web artisans.\n, 7);\n\n// The PHP...\n\n\n\n\n\n\n\nstarts_with()\n {#collection-method}\n\n\nThe \nstarts_with\n function determines if the given string begins with the given value:\n\n\n$value = starts_with(\nThis is my name\n, \nThis\n);\n\n// true\n\n\n\n\n\n\n\nstr_contains()\n {#collection-method}\n\n\nThe \nstr_contains\n function determines if the given string contains the given value:\n\n\n$value = str_contains(\nThis is my name\n, \nmy\n);\n\n// true\n\n\n\n\n\nYou may also pass an array of values to determine if the given string contains any of the values:\n\n\n$value = str_contains(\nThis is my name\n, [\nmy\n, \nfoo\n]);\n\n// true\n\n\n\n\n\n\n\nstr_finish()\n {#collection-method}\n\n\nThe \nstr_finish\n function adds a single instance of the given value to a string:\n\n\n$string = str_finish(\nthis/string\n, \n/\n);\n\n// this/string/\n\n\n\n\n\n\n\nstr_is()\n {#collection-method}\n\n\nThe \nstr_is\n function determines if a given string matches a given pattern. Asterisks may be used to indicate wildcards:\n\n\n$value = str_is(\nfoo*\n, \nfoobar\n);\n\n// true\n\n$value = str_is(\nbaz*\n, \nfoobar\n);\n\n// false\n\n\n\n\n\n\n\nstr_plural()\n {#collection-method}\n\n\nThe \nstr_plural\n function converts a string to its plural form. This function currently only supports the English language:\n\n\n$plural = str_plural(\ncar\n);\n\n// cars\n\n$plural = str_plural(\nchild\n);\n\n// children\n\n\n\n\n\nYou may provide an integer as a second argument to the function to retrieve the singular or plural form of the string:\n\n\n$plural = str_plural(\nchild\n, 2);\n\n// children\n\n$plural = str_plural(\nchild\n, 1);\n\n// child\n\n\n\n\n\n\n\nstr_random()\n {#collection-method}\n\n\nThe \nstr_random\n function generates a random string of the specified length. This function uses PHP's \nrandom_bytes\n function:\n\n\n$string = str_random(40);\n\n\n\n\n\n\n\nstr_singular()\n {#collection-method}\n\n\nThe \nstr_singular\n function converts a string to its singular form. This function currently only supports the English language:\n\n\n$singular = str_singular(\ncars\n);\n\n// car\n\n\n\n\n\n\n\nstr_slug()\n {#collection-method}\n\n\nThe \nstr_slug\n function generates a URL friendly \"slug\" from the given string:\n\n\n$title = str_slug(\nLaravel 5 Framework\n, \n-\n);\n\n// laravel-5-framework\n\n\n\n\n\n\n\nstudly_case()\n {#collection-method}\n\n\nThe \nstudly_case\n function converts the given string to \nStudlyCase\n:\n\n\n$value = studly_case(\nfoo_bar\n);\n\n// FooBar\n\n\n\n\n\n\n\ntitle_case()\n {#collection-method}\n\n\nThe \ntitle_case\n function converts the given string to \nTitle Case\n:\n\n\n$title = title_case(\na nice title uses the correct case\n);\n\n// A Nice Title Uses The Correct Case\n\n\n\n\n\n\n\ntrans()\n {#collection-method}\n\n\nThe \ntrans\n function translates the given language line using your \nlocalization files\n:\n\n\necho trans(\nvalidation.required\n):\n\n\n\n\n\n\n\ntrans_choice()\n {#collection-method}\n\n\nThe \ntrans_choice\n function translates the given language line with inflection:\n\n\n$value = trans_choice(\nfoo.bar\n, $count);\n\n\n\n\n\n\n\nURLs\n\n\n\n\naction()\n {#collection-method}\n\n\nThe \naction\n function generates a URL for the given controller action. You do not need to pass the full namespace to the controller. Instead, pass the controller class name relative to the \nApp\\Http\\Controllers\n namespace:\n\n\n$url = action(\nHomeController@getIndex\n);\n\n\n\n\n\nIf the method accepts route parameters, you may pass them as the second argument to the method:\n\n\n$url = action(\nUserController@profile\n, [\nid\n =\n 1]);\n\n\n\n\n\n\n\nasset()\n {#collection-method}\n\n\nGenerate a URL for an asset using the current scheme of the request (HTTP or HTTPS):\n\n\n$url = asset(\nimg/photo.jpg\n);\n\n\n\n\n\n\n\nsecure_asset()\n {#collection-method}\n\n\nGenerate a URL for an asset using HTTPS:\n\n\necho secure_asset(\nfoo/bar.zip\n, $title, $attributes = []);\n\n\n\n\n\n\n\nroute()\n {#collection-method}\n\n\nThe \nroute\n function generates a URL for the given named route:\n\n\n$url = route(\nrouteName\n);\n\n\n\n\n\nIf the route accepts parameters, you may pass them as the second argument to the method:\n\n\n$url = route(\nrouteName\n, [\nid\n =\n 1]);\n\n\n\n\n\n\n\nsecure_url()\n {#collection-method}\n\n\nThe \nsecure_url\n function generates a fully qualified HTTPS URL to the given path:\n\n\necho secure_url(\nuser/profile\n);\n\necho secure_url(\nuser/profile\n, [1]);\n\n\n\n\n\n\n\nurl()\n {#collection-method}\n\n\nThe \nurl\n function generates a fully qualified URL to the given path:\n\n\necho url(\nuser/profile\n);\n\necho url(\nuser/profile\n, [1]);\n\n\n\n\n\nIf no path is provided, a \nIlluminate\\Routing\\UrlGenerator\n instance is returned:\n\n\necho url()-\ncurrent();\necho url()-\nfull();\necho url()-\nprevious();\n\n\n\n\n\n\n\nMiscellaneous\n\n\n\n\nabort()\n {#collection-method}\n\n\nThe \nabort\n function throws a HTTP exception which will be rendered by the exception handler:\n\n\nabort(401);\n\n\n\n\n\nYou may also provide the exception's response text:\n\n\nabort(401, \nUnauthorized.\n);\n\n\n\n\n\n\n\nabort_if()\n {#collection-method}\n\n\nThe \nabort_if\n function throws an HTTP exception if a given boolean expression evaluates to \ntrue\n:\n\n\nabort_if\n(!\n \nAuth\n::\nuser\n()\n-\nisAdmin\n(),\n \n403\n);\n\n\n\n\n\n\n\n\nabort_unless()\n {#collection-method}\n\n\nThe \nabort_unless\n function throws an HTTP exception if a given boolean expression evaluates to \nfalse\n:\n\n\nabort_unless\n(\nAuth\n::\nuser\n()\n-\nisAdmin\n(),\n \n403\n);\n\n\n\n\n\n\n\n\nauth()\n {#collection-method}\n\n\nThe \nauth\n function returns an authenticator instance. You may use it instead of the \nAuth\n facade for convenience:\n\n\n$user = auth()-\nuser();\n\n\n\n\n\n\n\nback()\n {#collection-method}\n\n\nThe \nback()\n function generates a redirect response to the user's previous location:\n\n\nreturn back();\n\n\n\n\n\n\n\nbcrypt()\n {#collection-method}\n\n\nThe \nbcrypt\n function hashes the given value using Bcrypt. You may use it as an alternative to the \nHash\n facade:\n\n\n$password = bcrypt(\nmy-secret-password\n);\n\n\n\n\n\n\n\ncache()\n {#collection-method}\n\n\nThe \ncache\n function may be used to get values from the cache. If the given key does not exist in the cache, an optional default value will be returned:\n\n\n$value = cache(\nkey\n);\n\n$value = cache(\nkey\n, \ndefault\n);\n\n\n\n\n\nYou may add items to the cache by passing an array of key / value pairs to the function. You should also pass the number of minutes or duration the cached value should be considered valid:\n\n\ncache\n(\n[\nkey\n \n=\n \nvalue\n]\n,\n \n5\n);\n\n\n\ncache\n(\n[\nkey\n \n=\n \nvalue\n]\n,\n \nCarbon\n::\nnow\n()\n-\naddSeconds\n(\n10\n));\n\n\n\n\n\n\n\n\ncollect()\n {#collection-method}\n\n\nThe \ncollect\n function creates a \ncollection\n instance from the given array:\n\n\n$collection = collect([\ntaylor\n, \nabigail\n]);\n\n\n\n\n\n\n\nconfig()\n {#collection-method}\n\n\nThe \nconfig\n function gets the value of a configuration variable. The configuration values may be accessed using \"dot\" syntax, which includes the name of the file and the option you wish to access. A default value may be specified and is returned if the configuration option does not exist:\n\n\n$value = config(\napp.timezone\n);\n\n$value = config(\napp.timezone\n, $default);\n\n\n\n\n\nThe \nconfig\n helper may also be used to set configuration variables at runtime by passing an array of key / value pairs:\n\n\nconfig([\napp.debug\n =\n true]);\n\n\n\n\n\n\n\ncsrf_field()\n {#collection-method}\n\n\nThe \ncsrf_field\n function generates an HTML \nhidden\n input field containing the value of the CSRF token. For example, using \nBlade syntax\n:\n\n\n{{\n \ncsrf_field\n()\n \n}}\n\n\n\n\n\n\n\n\ncsrf_token()\n {#collection-method}\n\n\nThe \ncsrf_token\n function retrieves the value of the current CSRF token:\n\n\n$token = csrf_token();\n\n\n\n\n\n\n\ndd()\n {#collection-method}\n\n\nThe \ndd\n function dumps the given variables and ends execution of the script:\n\n\ndd($value);\n\ndd($value1, $value2, $value3, ...);\n\n\n\n\n\nIf you do not want to halt the execution of your script, use the \ndump\n function instead:\n\n\ndump($value);\n\n\n\n\n\n\n\ndispatch()\n {#collection-method}\n\n\nThe \ndispatch\n function pushes a new job onto the Laravel \njob queue\n:\n\n\ndispatch(new App\\Jobs\\SendEmails);\n\n\n\n\n\n\n\nenv()\n {#collection-method}\n\n\nThe \nenv\n function gets the value of an environment variable or returns a default value:\n\n\n$env = env(\nAPP_ENV\n);\n\n// Return a default value if the variable doesn\nt exist...\n$env = env(\nAPP_ENV\n, \nproduction\n);\n\n\n\n\n\n\n\nevent()\n {#collection-method}\n\n\nThe \nevent\n function dispatches the given \nevent\n to its listeners:\n\n\nevent(new UserRegistered($user));\n\n\n\n\n\n\n\nfactory()\n {#collection-method}\n\n\nThe \nfactory\n function creates a model factory builder for a given class, name, and amount. It can be used while \ntesting\n or \nseeding\n:\n\n\n$\nuser\n \n=\n \nfactory\n(\nApp\n\\\nUser\n::\nclass\n)\n-\nmake\n();\n\n\n\n\n\n\n\n\ninfo()\n {#collection-method}\n\n\nThe \ninfo\n function will write information to the log:\n\n\ninfo(\nSome helpful information!\n);\n\n\n\n\n\nAn array of contextual data may also be passed to the function:\n\n\ninfo(\nUser login attempt failed.\n, [\nid\n =\n $user-\nid]);\n\n\n\n\n\n\n\nlogger()\n {#collection-method}\n\n\nThe \nlogger\n function can be used to write a \ndebug\n level message to the log:\n\n\nlogger(\nDebug message\n);\n\n\n\n\n\nAn array of contextual data may also be passed to the function:\n\n\nlogger(\nUser has logged in.\n, [\nid\n =\n $user-\nid]);\n\n\n\n\n\nA \nlogger\n instance will be returned if no value is passed to the function:\n\n\nlogger()-\nerror(\nYou are not allowed here.\n);\n\n\n\n\n\n\n\nmethod_field()\n {#collection-method}\n\n\nThe \nmethod_field\n function generates an HTML \nhidden\n input field containing the spoofed value of the form's HTTP verb. For example, using \nBlade syntax\n:\n\n\nform\n \nmethod=\nPOST\n\n    \n{{\n \nmethod_field\n(\nDELETE\n)\n \n}}\n\n\n/form\n\n\n\n\n\n\n\n\nold()\n {#collection-method}\n\n\nThe \nold\n function \nretrieves\n an old input value flashed into the session:\n\n\n$value = old(\nvalue\n);\n\n$value = old(\nvalue\n, \ndefault\n);\n\n\n\n\n\n\n\nredirect()\n {#collection-method}\n\n\nThe \nredirect\n function returns a redirect HTTP response, or returns the redirector instance if called with no arguments:\n\n\nreturn redirect(\n/home\n);\n\nreturn redirect()-\nroute(\nroute.name\n);\n\n\n\n\n\n\n\nrequest()\n {#collection-method}\n\n\nThe \nrequest\n function returns the current \nrequest\n instance or obtains an input item:\n\n\n$request = request();\n\n$value = request(\nkey\n, $default = null)\n\n\n\n\n\n\n\nresponse()\n {#collection-method}\n\n\nThe \nresponse\n function creates a \nresponse\n instance or obtains an instance of the response factory:\n\n\nreturn response(\nHello World\n, 200, $headers);\n\nreturn response()-\njson([\nfoo\n =\n \nbar\n], 200, $headers);\n\n\n\n\n\n\n\nretry()\n {#collection-method}\n\n\nThe \nretry\n function attempts to execute the given callback until the given maximum attempt threshold is met. If the callback does not throw an exception, it's return value will be returned. If the callback throws an exception, it will automatically be retried. If the maximum attempt count is exceeded, the exception will be thrown:\n\n\nreturn retry(5, function () {\n    // Attempt 5 times while resting 100ms in between attempts...\n}, 100);\n\n\n\n\n\n\n\nsession()\n {#collection-method}\n\n\nThe \nsession\n function may be used to get or set session values:\n\n\n$value = session(\nkey\n);\n\n\n\n\n\nYou may set values by passing an array of key / value pairs to the function:\n\n\nsession([\nchairs\n =\n 7, \ninstruments\n =\n 3]);\n\n\n\n\n\nThe session store will be returned if no value is passed to the function:\n\n\n$value = session()-\nget(\nkey\n);\n\nsession()-\nput(\nkey\n, $value);\n\n\n\n\n\n\n\nvalue()\n {#collection-method}\n\n\nThe \nvalue\n function's behavior will simply return the value it is given. However, if you pass a \nClosure\n to the function, the \nClosure\n will be executed then its result will be returned:\n\n\n$value = value(function () {\n    return \nbar\n;\n});\n\n\n\n\n\n\n\nview()\n {#collection-method}\n\n\nThe \nview\n function retrieves a \nview\n instance:\n\n\nreturn view(\nauth.login\n);", 
            "title": "Helpers"
        }, 
        {
            "location": "/helpers/#helper-functions", 
            "text": "Introduction  Available Methods", 
            "title": "Helper Functions"
        }, 
        {
            "location": "/helpers/#introduction", 
            "text": "Laravel includes a variety of global \"helper\" PHP functions. Many of these functions are used by the framework itself; however, you are free to use them in your own applications if you find them convenient.", 
            "title": "Introduction"
        }, 
        {
            "location": "/helpers/#available-methods", 
            "text": ".collection-method-list > p {\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    .collection-method-list a {\n        display: block;\n    }", 
            "title": "Available Methods"
        }, 
        {
            "location": "/helpers/#arrays", 
            "text": "[array_add](#method-array-add)\n[array_collapse](#method-array-collapse)\n[array_divide](#method-array-divide)\n[array_dot](#method-array-dot)\n[array_except](#method-array-except)\n[array_first](#method-array-first)\n[array_flatten](#method-array-flatten)\n[array_forget](#method-array-forget)\n[array_get](#method-array-get)\n[array_has](#method-array-has)\n[array_last](#method-array-last)\n[array_only](#method-array-only)\n[array_pluck](#method-array-pluck)\n[array_prepend](#method-array-prepend)\n[array_pull](#method-array-pull)\n[array_set](#method-array-set)\n[array_sort](#method-array-sort)\n[array_sort_recursive](#method-array-sort-recursive)\n[array_where](#method-array-where)\n[head](#method-head)\n[last](#method-last)", 
            "title": "Arrays"
        }, 
        {
            "location": "/helpers/#paths", 
            "text": "[app_path](#method-app-path)\n[base_path](#method-base-path)\n[config_path](#method-config-path)\n[database_path](#method-database-path)\n[mix](#method-mix)\n[public_path](#method-public-path)\n[resource_path](#method-resource-path)\n[storage_path](#method-storage-path)", 
            "title": "Paths"
        }, 
        {
            "location": "/helpers/#strings", 
            "text": "[camel_case](#method-camel-case)\n[class_basename](#method-class-basename)\n[e](#method-e)\n[ends_with](#method-ends-with)\n[snake_case](#method-snake-case)\n[str_limit](#method-str-limit)\n[starts_with](#method-starts-with)\n[str_contains](#method-str-contains)\n[str_finish](#method-str-finish)\n[str_is](#method-str-is)\n[str_plural](#method-str-plural)\n[str_random](#method-str-random)\n[str_singular](#method-str-singular)\n[str_slug](#method-str-slug)\n[studly_case](#method-studly-case)\n[title_case](#method-title-case)\n[trans](#method-trans)\n[trans_choice](#method-trans-choice)", 
            "title": "Strings"
        }, 
        {
            "location": "/helpers/#urls", 
            "text": "[action](#method-action)\n[asset](#method-asset)\n[secure_asset](#method-secure-asset)\n[route](#method-route)\n[secure_url](#method-secure-url)\n[url](#method-url)", 
            "title": "URLs"
        }, 
        {
            "location": "/helpers/#miscellaneous", 
            "text": "[abort](#method-abort)\n[abort_if](#method-abort-if)\n[abort_unless](#method-abort-unless)\n[auth](#method-auth)\n[back](#method-back)\n[bcrypt](#method-bcrypt)\n[cache](#method-cache)\n[collect](#method-collect)\n[config](#method-config)\n[csrf_field](#method-csrf-field)\n[csrf_token](#method-csrf-token)\n[dd](#method-dd)\n[dispatch](#method-dispatch)\n[env](#method-env)\n[event](#method-event)\n[factory](#method-factory)\n[info](#method-info)\n[logger](#method-logger)\n[method_field](#method-method-field)\n[old](#method-old)\n[redirect](#method-redirect)\n[request](#method-request)\n[response](#method-response)\n[retry](#method-retry)\n[session](#method-session)\n[value](#method-value)\n[view](#method-view)", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/helpers/#method-listing", 
            "text": "#collection-method code {\n        font-size: 14px;\n    }\n\n    #collection-method:not(.first-collection-method) {\n        margin-top: 50px;\n    }", 
            "title": "Method Listing"
        }, 
        {
            "location": "/helpers/#arrays_1", 
            "text": "", 
            "title": "Arrays"
        }, 
        {
            "location": "/helpers/#array_add-collection-method-first-collection-method", 
            "text": "The  array_add  function adds a given key / value pair to the array if the given key doesn't already exist in the array:  $array = array_add([ name  =   Desk ],  price , 100);\n\n// [ name  =   Desk ,  price  =  100]", 
            "title": "array_add() {#collection-method .first-collection-method}"
        }, 
        {
            "location": "/helpers/#array_collapse-collection-method", 
            "text": "The  array_collapse  function collapses an array of arrays into a single array:  $array = array_collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);\n\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]", 
            "title": "array_collapse() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_divide-collection-method", 
            "text": "The  array_divide  function returns two arrays, one containing the keys, and the other containing the values of the original array:  list($keys, $values) = array_divide([ name  =   Desk ]);\n\n// $keys: [ name ]\n\n// $values: [ Desk ]", 
            "title": "array_divide() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_dot-collection-method", 
            "text": "The  array_dot  function flattens a multi-dimensional array into a single level array that uses \"dot\" notation to indicate depth:  $array = array_dot([ foo  =  [ bar  =   baz ]]);\n\n// [ foo.bar  =   baz ];", 
            "title": "array_dot() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_except-collection-method", 
            "text": "The  array_except  function removes the given key / value pairs from the array:  $array = [ name  =   Desk ,  price  =  100];\n\n$array = array_except($array, [ price ]);\n\n// [ name  =   Desk ]", 
            "title": "array_except() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_first-collection-method", 
            "text": "The  array_first  function returns the first element of an array passing a given truth test:  $array = [100, 200, 300];\n\n$value = array_first($array, function ($value, $key) {\n    return $value  = 150;\n});\n\n// 200  A default value may also be passed as the third parameter to the method. This value will be returned if no value passes the truth test:  $value = array_first($array, $callback, $default);", 
            "title": "array_first() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_flatten-collection-method", 
            "text": "The  array_flatten  function will flatten a multi-dimensional array into a single level.  $array = [ name  =   Joe ,  languages  =  [ PHP ,  Ruby ]];\n\n$array = array_flatten($array);\n\n// [ Joe ,  PHP ,  Ruby ];", 
            "title": "array_flatten() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_forget-collection-method", 
            "text": "The  array_forget  function removes a given key / value pair from a deeply nested array using \"dot\" notation:  $array = [ products  =  [ desk  =  [ price  =  100]]];\n\narray_forget($array,  products.desk );\n\n// [ products  =  []]", 
            "title": "array_forget() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_get-collection-method", 
            "text": "The  array_get  function retrieves a value from a deeply nested array using \"dot\" notation:  $array = [ products  =  [ desk  =  [ price  =  100]]];\n\n$value = array_get($array,  products.desk );\n\n// [ price  =  100]  The  array_get  function also accepts a default value, which will be returned if the specific key is not found:  $value = array_get($array,  names.john ,  default );", 
            "title": "array_get() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_has-collection-method", 
            "text": "The  array_has  function checks that a given item or items exists in an array using \"dot\" notation:  $array = [ product  =  [ name  =   desk ,  price  =  100]];\n\n$hasItem = array_has($array,  product.name );\n\n// true\n\n$hasItems = array_has($array, [ product.price ,  product.discount ]);\n\n// false", 
            "title": "array_has() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_last-collection-method", 
            "text": "The  array_last  function returns the last element of an array passing a given truth test:  $array = [100, 200, 300, 110];\n\n$value = array_last($array, function ($value, $key) {\n    return $value  = 150;\n});\n\n// 300", 
            "title": "array_last() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_only-collection-method", 
            "text": "The  array_only  function will return only the specified key / value pairs from the given array:  $array = [ name  =   Desk ,  price  =  100,  orders  =  10];\n\n$array = array_only($array, [ name ,  price ]);\n\n// [ name  =   Desk ,  price  =  100]", 
            "title": "array_only() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_pluck-collection-method", 
            "text": "The  array_pluck  function will pluck a list of the given key / value pairs from the array:  $array = [\n    [ developer  =  [ id  =  1,  name  =   Taylor ]],\n    [ developer  =  [ id  =  2,  name  =   Abigail ]],\n];\n\n$array = array_pluck($array,  developer.name );\n\n// [ Taylor ,  Abigail ];  You may also specify how you wish the resulting list to be keyed:  $array = array_pluck($array,  developer.name ,  developer.id );\n\n// [1 =   Taylor , 2 =   Abigail ];", 
            "title": "array_pluck() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_prepend-collection-method", 
            "text": "The  array_prepend  function will push an item onto the beginning of an array:  $array = [ one ,  two ,  three ,  four ];\n\n$array = array_prepend($array,  zero );\n\n// $array: [ zero ,  one ,  two ,  three ,  four ]", 
            "title": "array_prepend() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_pull-collection-method", 
            "text": "The  array_pull  function returns and removes a key / value pair from the array:  $array = [ name  =   Desk ,  price  =  100];\n\n$name = array_pull($array,  name );\n\n// $name: Desk\n\n// $array: [ price  =  100]", 
            "title": "array_pull() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_set-collection-method", 
            "text": "The  array_set  function sets a value within a deeply nested array using \"dot\" notation:  $array = [ products  =  [ desk  =  [ price  =  100]]];\n\narray_set($array,  products.desk.price , 200);\n\n// [ products  =  [ desk  =  [ price  =  200]]]", 
            "title": "array_set() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_sort-collection-method", 
            "text": "The  array_sort  function sorts the array by the results of the given Closure:  $array = [\n    [ name  =   Desk ],\n    [ name  =   Chair ],\n];\n\n$array = array_values(array_sort($array, function ($value) {\n    return $value[ name ];\n}));\n\n/*\n    [\n        [ name  =   Chair ],\n        [ name  =   Desk ],\n    ]\n*/", 
            "title": "array_sort() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_sort_recursive-collection-method", 
            "text": "The  array_sort_recursive  function recursively sorts the array using the  sort  function:  $array = [\n    [\n         Roman ,\n         Taylor ,\n         Li ,\n    ],\n    [\n         PHP ,\n         Ruby ,\n         JavaScript ,\n    ],\n];\n\n$array = array_sort_recursive($array);\n\n/*\n    [\n        [\n             Li ,\n             Roman ,\n             Taylor ,\n        ],\n        [\n             JavaScript ,\n             PHP ,\n             Ruby ,\n        ]\n    ];\n*/", 
            "title": "array_sort_recursive() {#collection-method}"
        }, 
        {
            "location": "/helpers/#array_where-collection-method", 
            "text": "The  array_where  function filters the array using the given Closure:  $array = [100,  200 , 300,  400 , 500];\n\n$array = array_where($array, function ($value, $key) {\n    return is_string($value);\n});\n\n// [1 =  200, 3 =  400]", 
            "title": "array_where() {#collection-method}"
        }, 
        {
            "location": "/helpers/#head-collection-method", 
            "text": "The  head  function simply returns the first element in the given array:  $array = [100, 200, 300];\n\n$first = head($array);\n\n// 100", 
            "title": "head() {#collection-method}"
        }, 
        {
            "location": "/helpers/#last-collection-method", 
            "text": "The  last  function returns the last element in the given array:  $array = [100, 200, 300];\n\n$last = last($array);\n\n// 300", 
            "title": "last() {#collection-method}"
        }, 
        {
            "location": "/helpers/#paths_1", 
            "text": "", 
            "title": "Paths"
        }, 
        {
            "location": "/helpers/#app_path-collection-method", 
            "text": "The  app_path  function returns the fully qualified path to the  app  directory. You may also use the  app_path  function to generate a fully qualified path to a file relative to the application directory:  $path = app_path();\n\n$path = app_path( Http/Controllers/Controller.php );", 
            "title": "app_path() {#collection-method}"
        }, 
        {
            "location": "/helpers/#base_path-collection-method", 
            "text": "The  base_path  function returns the fully qualified path to the project root. You may also use the  base_path  function to generate a fully qualified path to a given file relative to the project root directory:  $path = base_path();\n\n$path = base_path( vendor/bin );", 
            "title": "base_path() {#collection-method}"
        }, 
        {
            "location": "/helpers/#config_path-collection-method", 
            "text": "The  config_path  function returns the fully qualified path to the application configuration directory:  $path = config_path();", 
            "title": "config_path() {#collection-method}"
        }, 
        {
            "location": "/helpers/#database_path-collection-method", 
            "text": "The  database_path  function returns the fully qualified path to the application's database directory:  $path = database_path();", 
            "title": "database_path() {#collection-method}"
        }, 
        {
            "location": "/helpers/#mix-collection-method", 
            "text": "The  mix  function gets the path to a  versioned Mix file :  mix($file);", 
            "title": "mix() {#collection-method}"
        }, 
        {
            "location": "/helpers/#public_path-collection-method", 
            "text": "The  public_path  function returns the fully qualified path to the  public  directory:  $path = public_path();", 
            "title": "public_path() {#collection-method}"
        }, 
        {
            "location": "/helpers/#resource_path-collection-method", 
            "text": "The  resource_path  function returns the fully qualified path to the  resources  directory. You may also use the  resource_path  function to generate a fully qualified path to a given file relative to the resources directory:  $path = resource_path();\n\n$path = resource_path( assets/sass/app.scss );", 
            "title": "resource_path() {#collection-method}"
        }, 
        {
            "location": "/helpers/#storage_path-collection-method", 
            "text": "The  storage_path  function returns the fully qualified path to the  storage  directory. You may also use the  storage_path  function to generate a fully qualified path to a given file relative to the storage directory:  $path = storage_path();\n\n$path = storage_path( app/file.txt );", 
            "title": "storage_path() {#collection-method}"
        }, 
        {
            "location": "/helpers/#strings_1", 
            "text": "", 
            "title": "Strings"
        }, 
        {
            "location": "/helpers/#camel_case-collection-method", 
            "text": "The  camel_case  function converts the given string to  camelCase :  $camel = camel_case( foo_bar );\n\n// fooBar", 
            "title": "camel_case() {#collection-method}"
        }, 
        {
            "location": "/helpers/#class_basename-collection-method", 
            "text": "The  class_basename  returns the class name of the given class with the class' namespace removed:  $class = class_basename( Foo\\Bar\\Baz );\n\n// Baz", 
            "title": "class_basename() {#collection-method}"
        }, 
        {
            "location": "/helpers/#e-collection-method", 
            "text": "The  e  function runs  htmlspecialchars  over the given string:  echo e( html foo /html );\n\n//  lt; html gt; foo lt; /html gt;", 
            "title": "e() {#collection-method}"
        }, 
        {
            "location": "/helpers/#ends_with-collection-method", 
            "text": "The  ends_with  function determines if the given string ends with the given value:  $value = ends_with( This is my name ,  name );\n\n// true", 
            "title": "ends_with() {#collection-method}"
        }, 
        {
            "location": "/helpers/#snake_case-collection-method", 
            "text": "The  snake_case  function converts the given string to  snake_case :  $snake = snake_case( fooBar );\n\n// foo_bar", 
            "title": "snake_case() {#collection-method}"
        }, 
        {
            "location": "/helpers/#str_limit-collection-method", 
            "text": "The  str_limit  function limits the number of characters in a string. The function accepts a string as its first argument and the maximum number of resulting characters as its second argument:  $value = str_limit( The PHP framework for web artisans. , 7);\n\n// The PHP...", 
            "title": "str_limit() {#collection-method}"
        }, 
        {
            "location": "/helpers/#starts_with-collection-method", 
            "text": "The  starts_with  function determines if the given string begins with the given value:  $value = starts_with( This is my name ,  This );\n\n// true", 
            "title": "starts_with() {#collection-method}"
        }, 
        {
            "location": "/helpers/#str_contains-collection-method", 
            "text": "The  str_contains  function determines if the given string contains the given value:  $value = str_contains( This is my name ,  my );\n\n// true  You may also pass an array of values to determine if the given string contains any of the values:  $value = str_contains( This is my name , [ my ,  foo ]);\n\n// true", 
            "title": "str_contains() {#collection-method}"
        }, 
        {
            "location": "/helpers/#str_finish-collection-method", 
            "text": "The  str_finish  function adds a single instance of the given value to a string:  $string = str_finish( this/string ,  / );\n\n// this/string/", 
            "title": "str_finish() {#collection-method}"
        }, 
        {
            "location": "/helpers/#str_is-collection-method", 
            "text": "The  str_is  function determines if a given string matches a given pattern. Asterisks may be used to indicate wildcards:  $value = str_is( foo* ,  foobar );\n\n// true\n\n$value = str_is( baz* ,  foobar );\n\n// false", 
            "title": "str_is() {#collection-method}"
        }, 
        {
            "location": "/helpers/#str_plural-collection-method", 
            "text": "The  str_plural  function converts a string to its plural form. This function currently only supports the English language:  $plural = str_plural( car );\n\n// cars\n\n$plural = str_plural( child );\n\n// children  You may provide an integer as a second argument to the function to retrieve the singular or plural form of the string:  $plural = str_plural( child , 2);\n\n// children\n\n$plural = str_plural( child , 1);\n\n// child", 
            "title": "str_plural() {#collection-method}"
        }, 
        {
            "location": "/helpers/#str_random-collection-method", 
            "text": "The  str_random  function generates a random string of the specified length. This function uses PHP's  random_bytes  function:  $string = str_random(40);", 
            "title": "str_random() {#collection-method}"
        }, 
        {
            "location": "/helpers/#str_singular-collection-method", 
            "text": "The  str_singular  function converts a string to its singular form. This function currently only supports the English language:  $singular = str_singular( cars );\n\n// car", 
            "title": "str_singular() {#collection-method}"
        }, 
        {
            "location": "/helpers/#str_slug-collection-method", 
            "text": "The  str_slug  function generates a URL friendly \"slug\" from the given string:  $title = str_slug( Laravel 5 Framework ,  - );\n\n// laravel-5-framework", 
            "title": "str_slug() {#collection-method}"
        }, 
        {
            "location": "/helpers/#studly_case-collection-method", 
            "text": "The  studly_case  function converts the given string to  StudlyCase :  $value = studly_case( foo_bar );\n\n// FooBar", 
            "title": "studly_case() {#collection-method}"
        }, 
        {
            "location": "/helpers/#title_case-collection-method", 
            "text": "The  title_case  function converts the given string to  Title Case :  $title = title_case( a nice title uses the correct case );\n\n// A Nice Title Uses The Correct Case", 
            "title": "title_case() {#collection-method}"
        }, 
        {
            "location": "/helpers/#trans-collection-method", 
            "text": "The  trans  function translates the given language line using your  localization files :  echo trans( validation.required ):", 
            "title": "trans() {#collection-method}"
        }, 
        {
            "location": "/helpers/#trans_choice-collection-method", 
            "text": "The  trans_choice  function translates the given language line with inflection:  $value = trans_choice( foo.bar , $count);", 
            "title": "trans_choice() {#collection-method}"
        }, 
        {
            "location": "/helpers/#urls_1", 
            "text": "", 
            "title": "URLs"
        }, 
        {
            "location": "/helpers/#action-collection-method", 
            "text": "The  action  function generates a URL for the given controller action. You do not need to pass the full namespace to the controller. Instead, pass the controller class name relative to the  App\\Http\\Controllers  namespace:  $url = action( HomeController@getIndex );  If the method accepts route parameters, you may pass them as the second argument to the method:  $url = action( UserController@profile , [ id  =  1]);", 
            "title": "action() {#collection-method}"
        }, 
        {
            "location": "/helpers/#asset-collection-method", 
            "text": "Generate a URL for an asset using the current scheme of the request (HTTP or HTTPS):  $url = asset( img/photo.jpg );", 
            "title": "asset() {#collection-method}"
        }, 
        {
            "location": "/helpers/#secure_asset-collection-method", 
            "text": "Generate a URL for an asset using HTTPS:  echo secure_asset( foo/bar.zip , $title, $attributes = []);", 
            "title": "secure_asset() {#collection-method}"
        }, 
        {
            "location": "/helpers/#route-collection-method", 
            "text": "The  route  function generates a URL for the given named route:  $url = route( routeName );  If the route accepts parameters, you may pass them as the second argument to the method:  $url = route( routeName , [ id  =  1]);", 
            "title": "route() {#collection-method}"
        }, 
        {
            "location": "/helpers/#secure_url-collection-method", 
            "text": "The  secure_url  function generates a fully qualified HTTPS URL to the given path:  echo secure_url( user/profile );\n\necho secure_url( user/profile , [1]);", 
            "title": "secure_url() {#collection-method}"
        }, 
        {
            "location": "/helpers/#url-collection-method", 
            "text": "The  url  function generates a fully qualified URL to the given path:  echo url( user/profile );\n\necho url( user/profile , [1]);  If no path is provided, a  Illuminate\\Routing\\UrlGenerator  instance is returned:  echo url()- current();\necho url()- full();\necho url()- previous();", 
            "title": "url() {#collection-method}"
        }, 
        {
            "location": "/helpers/#miscellaneous_1", 
            "text": "", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/helpers/#abort-collection-method", 
            "text": "The  abort  function throws a HTTP exception which will be rendered by the exception handler:  abort(401);  You may also provide the exception's response text:  abort(401,  Unauthorized. );", 
            "title": "abort() {#collection-method}"
        }, 
        {
            "location": "/helpers/#abort_if-collection-method", 
            "text": "The  abort_if  function throws an HTTP exception if a given boolean expression evaluates to  true :  abort_if (!   Auth :: user () - isAdmin (),   403 );", 
            "title": "abort_if() {#collection-method}"
        }, 
        {
            "location": "/helpers/#abort_unless-collection-method", 
            "text": "The  abort_unless  function throws an HTTP exception if a given boolean expression evaluates to  false :  abort_unless ( Auth :: user () - isAdmin (),   403 );", 
            "title": "abort_unless() {#collection-method}"
        }, 
        {
            "location": "/helpers/#auth-collection-method", 
            "text": "The  auth  function returns an authenticator instance. You may use it instead of the  Auth  facade for convenience:  $user = auth()- user();", 
            "title": "auth() {#collection-method}"
        }, 
        {
            "location": "/helpers/#back-collection-method", 
            "text": "The  back()  function generates a redirect response to the user's previous location:  return back();", 
            "title": "back() {#collection-method}"
        }, 
        {
            "location": "/helpers/#bcrypt-collection-method", 
            "text": "The  bcrypt  function hashes the given value using Bcrypt. You may use it as an alternative to the  Hash  facade:  $password = bcrypt( my-secret-password );", 
            "title": "bcrypt() {#collection-method}"
        }, 
        {
            "location": "/helpers/#cache-collection-method", 
            "text": "The  cache  function may be used to get values from the cache. If the given key does not exist in the cache, an optional default value will be returned:  $value = cache( key );\n\n$value = cache( key ,  default );  You may add items to the cache by passing an array of key / value pairs to the function. You should also pass the number of minutes or duration the cached value should be considered valid:  cache ( [ key   =   value ] ,   5 );  cache ( [ key   =   value ] ,   Carbon :: now () - addSeconds ( 10 ));", 
            "title": "cache() {#collection-method}"
        }, 
        {
            "location": "/helpers/#collect-collection-method", 
            "text": "The  collect  function creates a  collection  instance from the given array:  $collection = collect([ taylor ,  abigail ]);", 
            "title": "collect() {#collection-method}"
        }, 
        {
            "location": "/helpers/#config-collection-method", 
            "text": "The  config  function gets the value of a configuration variable. The configuration values may be accessed using \"dot\" syntax, which includes the name of the file and the option you wish to access. A default value may be specified and is returned if the configuration option does not exist:  $value = config( app.timezone );\n\n$value = config( app.timezone , $default);  The  config  helper may also be used to set configuration variables at runtime by passing an array of key / value pairs:  config([ app.debug  =  true]);", 
            "title": "config() {#collection-method}"
        }, 
        {
            "location": "/helpers/#csrf_field-collection-method", 
            "text": "The  csrf_field  function generates an HTML  hidden  input field containing the value of the CSRF token. For example, using  Blade syntax :  {{   csrf_field ()   }}", 
            "title": "csrf_field() {#collection-method}"
        }, 
        {
            "location": "/helpers/#csrf_token-collection-method", 
            "text": "The  csrf_token  function retrieves the value of the current CSRF token:  $token = csrf_token();", 
            "title": "csrf_token() {#collection-method}"
        }, 
        {
            "location": "/helpers/#dd-collection-method", 
            "text": "The  dd  function dumps the given variables and ends execution of the script:  dd($value);\n\ndd($value1, $value2, $value3, ...);  If you do not want to halt the execution of your script, use the  dump  function instead:  dump($value);", 
            "title": "dd() {#collection-method}"
        }, 
        {
            "location": "/helpers/#dispatch-collection-method", 
            "text": "The  dispatch  function pushes a new job onto the Laravel  job queue :  dispatch(new App\\Jobs\\SendEmails);", 
            "title": "dispatch() {#collection-method}"
        }, 
        {
            "location": "/helpers/#env-collection-method", 
            "text": "The  env  function gets the value of an environment variable or returns a default value:  $env = env( APP_ENV );\n\n// Return a default value if the variable doesn t exist...\n$env = env( APP_ENV ,  production );", 
            "title": "env() {#collection-method}"
        }, 
        {
            "location": "/helpers/#event-collection-method", 
            "text": "The  event  function dispatches the given  event  to its listeners:  event(new UserRegistered($user));", 
            "title": "event() {#collection-method}"
        }, 
        {
            "location": "/helpers/#factory-collection-method", 
            "text": "The  factory  function creates a model factory builder for a given class, name, and amount. It can be used while  testing  or  seeding :  $ user   =   factory ( App \\ User :: class ) - make ();", 
            "title": "factory() {#collection-method}"
        }, 
        {
            "location": "/helpers/#info-collection-method", 
            "text": "The  info  function will write information to the log:  info( Some helpful information! );  An array of contextual data may also be passed to the function:  info( User login attempt failed. , [ id  =  $user- id]);", 
            "title": "info() {#collection-method}"
        }, 
        {
            "location": "/helpers/#logger-collection-method", 
            "text": "The  logger  function can be used to write a  debug  level message to the log:  logger( Debug message );  An array of contextual data may also be passed to the function:  logger( User has logged in. , [ id  =  $user- id]);  A  logger  instance will be returned if no value is passed to the function:  logger()- error( You are not allowed here. );", 
            "title": "logger() {#collection-method}"
        }, 
        {
            "location": "/helpers/#method_field-collection-method", 
            "text": "The  method_field  function generates an HTML  hidden  input field containing the spoofed value of the form's HTTP verb. For example, using  Blade syntax :  form   method= POST \n     {{   method_field ( DELETE )   }}  /form", 
            "title": "method_field() {#collection-method}"
        }, 
        {
            "location": "/helpers/#old-collection-method", 
            "text": "The  old  function  retrieves  an old input value flashed into the session:  $value = old( value );\n\n$value = old( value ,  default );", 
            "title": "old() {#collection-method}"
        }, 
        {
            "location": "/helpers/#redirect-collection-method", 
            "text": "The  redirect  function returns a redirect HTTP response, or returns the redirector instance if called with no arguments:  return redirect( /home );\n\nreturn redirect()- route( route.name );", 
            "title": "redirect() {#collection-method}"
        }, 
        {
            "location": "/helpers/#request-collection-method", 
            "text": "The  request  function returns the current  request  instance or obtains an input item:  $request = request();\n\n$value = request( key , $default = null)", 
            "title": "request() {#collection-method}"
        }, 
        {
            "location": "/helpers/#response-collection-method", 
            "text": "The  response  function creates a  response  instance or obtains an instance of the response factory:  return response( Hello World , 200, $headers);\n\nreturn response()- json([ foo  =   bar ], 200, $headers);", 
            "title": "response() {#collection-method}"
        }, 
        {
            "location": "/helpers/#retry-collection-method", 
            "text": "The  retry  function attempts to execute the given callback until the given maximum attempt threshold is met. If the callback does not throw an exception, it's return value will be returned. If the callback throws an exception, it will automatically be retried. If the maximum attempt count is exceeded, the exception will be thrown:  return retry(5, function () {\n    // Attempt 5 times while resting 100ms in between attempts...\n}, 100);", 
            "title": "retry() {#collection-method}"
        }, 
        {
            "location": "/helpers/#session-collection-method", 
            "text": "The  session  function may be used to get or set session values:  $value = session( key );  You may set values by passing an array of key / value pairs to the function:  session([ chairs  =  7,  instruments  =  3]);  The session store will be returned if no value is passed to the function:  $value = session()- get( key );\n\nsession()- put( key , $value);", 
            "title": "session() {#collection-method}"
        }, 
        {
            "location": "/helpers/#value-collection-method", 
            "text": "The  value  function's behavior will simply return the value it is given. However, if you pass a  Closure  to the function, the  Closure  will be executed then its result will be returned:  $value = value(function () {\n    return  bar ;\n});", 
            "title": "value() {#collection-method}"
        }, 
        {
            "location": "/helpers/#view-collection-method", 
            "text": "The  view  function retrieves a  view  instance:  return view( auth.login );", 
            "title": "view() {#collection-method}"
        }, 
        {
            "location": "/homestead/", 
            "text": "Laravel Homestead\n\n\n\n\nIntroduction\n\n\nInstallation \n Setup\n\n\nFirst Steps\n\n\nConfiguring Homestead\n\n\nLaunching The Vagrant Box\n\n\nPer Project Installation\n\n\nInstalling MariaDB\n\n\n\n\n\n\nDaily Usage\n\n\nAccessing Homestead Globally\n\n\nConnecting Via SSH\n\n\nConnecting To Databases\n\n\nAdding Additional Sites\n\n\nConfiguring Cron Schedules\n\n\nPorts\n\n\n\n\n\n\nNetwork Interfaces\n\n\nUpdating Homestead\n\n\nOld Versions\n\n\n\n\n\n\nIntroduction\n\n\nLaravel strives to make the entire PHP development experience delightful, including your local development environment. \nVagrant\n provides a simple, elegant way to manage and provision Virtual Machines.\n\n\nLaravel Homestead is an official, pre-packaged Vagrant box that provides you a wonderful development environment without requiring you to install PHP, a web server, and any other server software on your local machine. No more worrying about messing up your operating system! Vagrant boxes are completely disposable. If something goes wrong, you can destroy and re-create the box in minutes!\n\n\nHomestead runs on any Windows, Mac, or Linux system, and includes the Nginx web server, PHP 7.1, MySQL, Postgres, Redis, Memcached, Node, and all of the other goodies you need to develop amazing Laravel applications.\n\n\n\n\n{note} If you are using Windows, you may need to enable hardware virtualization (VT-x). It can usually be enabled via your BIOS. If you are using Hyper-V on a UEFI system you may additionally need to disable Hyper-V in order to access VT-x.\n\n\n\n\n\n\nIncluded Software\n\n\n\n\nUbuntu 16.04\n\n\nGit\n\n\nPHP 7.1\n\n\nNginx\n\n\nMySQL\n\n\nMariaDB\n\n\nSqlite3\n\n\nPostgres\n\n\nComposer\n\n\nNode (With Yarn, PM2, Bower, Grunt, and Gulp)\n\n\nRedis\n\n\nMemcached\n\n\nBeanstalkd\n\n\n\n\n\n\nInstallation \n Setup\n\n\n\n\nFirst Steps\n\n\nBefore launching your Homestead environment, you must install \nVirtualBox 5.1\n, \nVMWare\n, or \nParallels\n as well as \nVagrant\n. All of these software packages provide easy-to-use visual installers for all popular operating systems.\n\n\nTo use the VMware provider, you will need to purchase both VMware Fusion / Workstation and the \nVMware Vagrant plug-in\n. Though it is not free, VMware can provide faster shared folder performance out of the box.\n\n\nTo use the Parallels provider, you will need to install \nParallels Vagrant plug-in\n. It is free of charge.\n\n\nInstalling The Homestead Vagrant Box\n\n\nOnce VirtualBox / VMware and Vagrant have been installed, you should add the \nlaravel/homestead\n box to your Vagrant installation using the following command in your terminal. It will take a few minutes to download the box, depending on your Internet connection speed:\n\n\nvagrant box add laravel/homestead\n\n\n\n\n\nIf this command fails, make sure your Vagrant installation is up to date.\n\n\nInstalling Homestead\n\n\nYou may install Homestead by simply cloning the repository. Consider cloning the repository into a \nHomestead\n folder within your \"home\" directory, as the Homestead box will serve as the host to all of your Laravel projects:\n\n\ncd ~\n\ngit clone https://github.com/laravel/homestead.git Homestead\n\n\n\n\n\nOnce you have cloned the Homestead repository, run the \nbash init.sh\n command from the Homestead directory to create the \nHomestead.yaml\n configuration file. The \nHomestead.yaml\n file will be placed in the Homestead directory:\n\n\n// Mac / Linux...\nbash init.sh\n\n// Windows...\ninit.bat\n\n\n\n\n\n\n\nConfiguring Homestead\n\n\nSetting Your Provider\n\n\nThe \nprovider\n key in your \nHomestead.yaml\n file indicates which Vagrant provider should be used: \nvirtualbox\n, \nvmware_fusion\n, \nvmware_workstation\n, or \nparallels\n. You may set this to the provider you prefer:\n\n\nprovider\n:\n \nvirtualbox\n\n\n\n\n\n\nConfiguring Shared Folders\n\n\nThe \nfolders\n property of the \nHomestead.yaml\n file lists all of the folders you wish to share with your Homestead environment. As files within these folders are changed, they will be kept in sync between your local machine and the Homestead environment. You may configure as many shared folders as necessary:\n\n\nfolders:\n    - map: ~/Code\n      to: /home/vagrant/Code\n\n\n\n\n\nTo enable \nNFS\n, just add a simple flag to your synced folder configuration:\n\n\nfolders:\n    - map: ~/Code\n      to: /home/vagrant/Code\n      type: \nnfs\n\n\n\n\n\n\nYou may also pass any options supported by Vagrant's \nSynced Folders\n by listing them under the \noptions\n key:\n\n\nfolders:\n    - map: ~/Code\n      to: /home/vagrant/Code\n      type: \nrsync\n\n      options:\n          rsync__args: [\n--verbose\n, \n--archive\n, \n--delete\n, \n-zz\n]\n          rsync__exclude: [\nnode_modules\n]\n\n\n\n\n\nConfiguring Nginx Sites\n\n\nNot familiar with Nginx? No problem. The \nsites\n property allows you to easily map a \"domain\" to a folder on your Homestead environment. A sample site configuration is included in the \nHomestead.yaml\n file. Again, you may add as many sites to your Homestead environment as necessary. Homestead can serve as a convenient, virtualized environment for every Laravel project you are working on:\n\n\nsites:\n    - map: homestead.app\n      to: /home/vagrant/Code/Laravel/public\n\n\n\n\n\nIf you change the \nsites\n property after provisioning the Homestead box, you should re-run \nvagrant reload --provision\n  to update the Nginx configuration on the virtual machine.\n\n\nThe Hosts File\n\n\nYou must add the \"domains\" for your Nginx sites to the \nhosts\n file on your machine. The \nhosts\n file will redirect requests for your Homestead sites into your Homestead machine. On Mac and Linux, this file is located at \n/etc/hosts\n. On Windows, it is located at \nC:\\Windows\\System32\\drivers\\etc\\hosts\n. The lines you add to this file will look like the following:\n\n\n192.168.10.10  homestead.app\n\n\n\n\n\nMake sure the IP address listed is the one set in your \nHomestead.yaml\n file. Once you have added the domain to your \nhosts\n file and launched the Vagrant box you will be able to access the site via your web browser:\n\n\nhttp://homestead.app\n\n\n\n\n\n\n\nLaunching The Vagrant Box\n\n\nOnce you have edited the \nHomestead.yaml\n to your liking, run the \nvagrant up\n command from your Homestead directory. Vagrant will boot the virtual machine and automatically configure your shared folders and Nginx sites.\n\n\nTo destroy the machine, you may use the \nvagrant destroy --force\n command.\n\n\n\n\nPer Project Installation\n\n\nInstead of installing Homestead globally and sharing the same Homestead box across all of your projects, you may instead configure a Homestead instance for each project you manage. Installing Homestead per project may be beneficial if you wish to ship a \nVagrantfile\n with your project, allowing others working on the project to simply \nvagrant up\n.\n\n\nTo install Homestead directly into your project, require it using Composer:\n\n\ncomposer require laravel/homestead --dev\n\n\n\n\n\nOnce Homestead has been installed, use the \nmake\n command to generate the \nVagrantfile\n and \nHomestead.yaml\n file in your project root. The \nmake\n command will automatically configure the \nsites\n and \nfolders\n directives in the \nHomestead.yaml\n file.\n\n\nMac / Linux:\n\n\nphp vendor/bin/homestead make\n\n\n\n\n\nWindows:\n\n\nvendor\\\\bin\\\\homestead make\n\n\n\n\n\nNext, run the \nvagrant up\n command in your terminal and access your project at \nhttp://homestead.app\n in your browser. Remember, you will still need to add an \n/etc/hosts\n file entry for \nhomestead.app\n or the domain of your choice.\n\n\n\n\nInstalling MariaDB\n\n\nIf you prefer to use MariaDB instead of MySQL, you may add the \nmariadb\n option to your \nHomestead.yaml\n file. This option will remove MySQL and install MariaDB. MariaDB serves as a drop-in replacement for MySQL so you should still use the \nmysql\n database driver in your application's database configuration:\n\n\nbox\n:\n \nlaravel\n/\nhomestead\n\n\nip\n:\n \n192.168.20.20\n\n\nmemory\n:\n \n2048\n\n\ncpus\n:\n \n4\n\n\nprovider\n:\n \nvirtualbox\n\n\nmariadb\n:\n \ntrue\n\n\n\n\n\n\n\n\nDaily Usage\n\n\n\n\nAccessing Homestead Globally\n\n\nSometimes you may want to \nvagrant up\n your Homestead machine from anywhere on your filesystem. You can do this on Mac / Linux systems by adding a Bash function to your Bash profile. On Windows, you may accomplish this by adding a \"batch\" file to your \nPATH\n. This scripts will allow you to run any Vagrant command from anywhere on your system and will automatically point that command to your Homestead installation:\n\n\nMac / Linux\n\n\nfunction\n \nhomestead() {\n\n    \n(\n \ncd\n \n~\n/Homestead \n vagrant $* )\n\n\n}\n\n\n\n\n\n\nMake sure to tweak the \n~/Homestead\n path in the function to the location of your actual Homestead installation. Once the function is installed, you may run commands like \nhomestead up\n or \nhomestead ssh\n from anywhere on your system.\n\n\nWindows\n\n\nCreate a \nhomestead.bat\n batch file anywhere on your machine with the following contents:\n\n\n@echo off\n\nset cwd=%cd%\nset homesteadVagrant=C:\\Homestead\n\ncd /d %homesteadVagrant% \n vagrant %*\ncd /d %cwd%\n\nset cwd=\nset homesteadVagrant=\n\n\n\n\n\nMake sure to tweak the example \nC:\\Homestead\n path in the script to the actual location of your Homestead installation. After creating the file, add the file location to your \nPATH\n. You may then run commands like \nhomestead up\n or \nhomestead ssh\n from anywhere on your system.\n\n\n\n\nConnecting Via SSH\n\n\nYou can SSH into your virtual machine by issuing the \nvagrant ssh\n terminal command from your Homestead directory.\n\n\nBut, since you will probably need to SSH into your Homestead machine frequently, consider adding the \"function\" described above to your host machine to quickly SSH into the Homestead box.\n\n\n\n\nConnecting To Databases\n\n\nA \nhomestead\n database is configured for both MySQL and Postgres out of the box. For even more convenience, Laravel's \n.env\n file configures the framework to use this database out of the box.\n\n\nTo connect to your MySQL or Postgres database from your host machine's database client, you should connect to \n127.0.0.1\n and port \n33060\n (MySQL) or \n54320\n (Postgres). The username and password for both databases is \nhomestead\n / \nsecret\n.\n\n\n\n\n{note} You should only use these non-standard ports when connecting to the databases from your host machine. You will use the default 3306 and 5432 ports in your Laravel database configuration file since Laravel is running \nwithin\n the virtual machine.\n\n\n\n\n\n\nAdding Additional Sites\n\n\nOnce your Homestead environment is provisioned and running, you may want to add additional Nginx sites for your Laravel applications. You can run as many Laravel installations as you wish on a single Homestead environment. To add an additional site, simply add the site to your \nHomestead.yaml\n file:\n\n\nsites:\n    - map: homestead.app\n      to: /home/vagrant/Code/Laravel/public\n    - map: another.app\n      to: /home/vagrant/Code/another/public\n\n\n\n\n\nIf Vagrant is not automatically managing your \"hosts\" file, you may need to add the new site to that file as well:\n\n\n192.168.10.10  homestead.app\n192.168.10.10  another.app\n\n\n\n\n\nOnce the site has been added, run the \nvagrant reload --provision\n command from your Homestead directory.\n\n\n\n\nConfiguring Cron Schedules\n\n\nLaravel provides a convenient way to \nschedule Cron jobs\n by scheduling a single \nschedule:run\n Artisan command to be run every minute. The \nschedule:run\n command will examine the job schedule defined in your \nApp\\Console\\Kernel\n class to determine which jobs should be run.\n\n\nIf you would like the \nschedule:run\n command to be run for a Homestead site, you may set the \nschedule\n option to \ntrue\n when defining the site:\n\n\nsites:\n    - map: homestead.app\n      to: /home/vagrant/Code/Laravel/public\n      schedule: true\n\n\n\n\n\nThe Cron job for the site will be defined in the \n/etc/cron.d\n folder of the virtual machine.\n\n\n\n\nPorts\n\n\nBy default, the following ports are forwarded to your Homestead environment:\n\n\n\n\nSSH:\n 2222 \n Forwards To 22\n\n\nHTTP:\n 8000 \n Forwards To 80\n\n\nHTTPS:\n 44300 \n Forwards To 443\n\n\nMySQL:\n 33060 \n Forwards To 3306\n\n\nPostgres:\n 54320 \n Forwards To 5432\n\n\n\n\nForwarding Additional Ports\n\n\nIf you wish, you may forward additional ports to the Vagrant box, as well as specify their protocol:\n\n\nports:\n    - send: 93000\n      to: 9300\n    - send: 7777\n      to: 777\n      protocol: udp\n\n\n\n\n\n\n\nNetwork Interfaces\n\n\nThe \nnetworks\n property of the \nHomestead.yaml\n configures network interfaces for your Homestead environment. You may configure as many interfaces as necessary:\n\n\nnetworks:\n    - type: \nprivate_network\n\n      ip: \n192.168.10.20\n\n\n\n\n\n\nTo enable a \nbridged\n interface, configure a \nbridge\n setting and change the network type to \npublic_network\n:\n\n\nnetworks:\n    - type: \npublic_network\n\n      ip: \n192.168.10.20\n\n      bridge: \nen1: Wi-Fi (AirPort)\n\n\n\n\n\n\nTo enable \nDHCP\n, just remove the \nip\n option from your configuration:\n\n\nnetworks:\n    - type: \npublic_network\n\n      bridge: \nen1: Wi-Fi (AirPort)\n\n\n\n\n\n\n\n\nUpdating Homestead\n\n\nYou can update Homestead in two simple steps. First, you should update the Vagrant box using the \nvagrant box update\n command:\n\n\nvagrant box update\n\n\n\n\n\nNext, you need to update the Homestead source code. If you cloned the repository you can simply \ngit pull origin master\n at the location you originally cloned the repository.\n\n\nIf you have installed Homestead via your project's \ncomposer.json\n file, you should ensure your \ncomposer.json\n file contains \n\"laravel/homestead\": \"^4\"\n and update your dependencies:\n\n\ncomposer update\n\n\n\n\n\n\n\nOld Versions\n\n\nYou can easily override the version of the box that Homestead uses by adding the following line to your \nHomestead.yaml\n file:\n\n\nversion\n:\n \n0.6\n.\n0\n\n\n\n\n\n\nAn example:\n\n\nbox\n:\n \nlaravel\n/\nhomestead\n\n\nversion\n:\n \n0.6\n.\n0\n\n\nip\n:\n \n192.168.20.20\n\n\nmemory\n:\n \n2048\n\n\ncpus\n:\n \n4\n\n\nprovider\n:\n \nvirtualbox\n\n\n\n\n\n\nWhen you use an older version of the Homestead box you need to match that with a compatible version of the Homestead source code. Below is a chart which shows the supported box versions, which version of Homestead source code to use, and the version of PHP provided:\n\n\n\n\n\n\n\n\n\n\nHomestead Version\n\n\nBox Version\n\n\n\n\n\n\n\n\n\n\nPHP 7.0\n\n\n3.1.0\n\n\n0.6.0\n\n\n\n\n\n\nPHP 7.1\n\n\n4.0.0\n\n\n1.0.0", 
            "title": "Homestead"
        }, 
        {
            "location": "/homestead/#laravel-homestead", 
            "text": "Introduction  Installation   Setup  First Steps  Configuring Homestead  Launching The Vagrant Box  Per Project Installation  Installing MariaDB    Daily Usage  Accessing Homestead Globally  Connecting Via SSH  Connecting To Databases  Adding Additional Sites  Configuring Cron Schedules  Ports    Network Interfaces  Updating Homestead  Old Versions", 
            "title": "Laravel Homestead"
        }, 
        {
            "location": "/homestead/#introduction", 
            "text": "Laravel strives to make the entire PHP development experience delightful, including your local development environment.  Vagrant  provides a simple, elegant way to manage and provision Virtual Machines.  Laravel Homestead is an official, pre-packaged Vagrant box that provides you a wonderful development environment without requiring you to install PHP, a web server, and any other server software on your local machine. No more worrying about messing up your operating system! Vagrant boxes are completely disposable. If something goes wrong, you can destroy and re-create the box in minutes!  Homestead runs on any Windows, Mac, or Linux system, and includes the Nginx web server, PHP 7.1, MySQL, Postgres, Redis, Memcached, Node, and all of the other goodies you need to develop amazing Laravel applications.   {note} If you are using Windows, you may need to enable hardware virtualization (VT-x). It can usually be enabled via your BIOS. If you are using Hyper-V on a UEFI system you may additionally need to disable Hyper-V in order to access VT-x.", 
            "title": "Introduction"
        }, 
        {
            "location": "/homestead/#included-software", 
            "text": "Ubuntu 16.04  Git  PHP 7.1  Nginx  MySQL  MariaDB  Sqlite3  Postgres  Composer  Node (With Yarn, PM2, Bower, Grunt, and Gulp)  Redis  Memcached  Beanstalkd", 
            "title": "Included Software"
        }, 
        {
            "location": "/homestead/#installation-setup", 
            "text": "", 
            "title": "Installation &amp; Setup"
        }, 
        {
            "location": "/homestead/#first-steps", 
            "text": "Before launching your Homestead environment, you must install  VirtualBox 5.1 ,  VMWare , or  Parallels  as well as  Vagrant . All of these software packages provide easy-to-use visual installers for all popular operating systems.  To use the VMware provider, you will need to purchase both VMware Fusion / Workstation and the  VMware Vagrant plug-in . Though it is not free, VMware can provide faster shared folder performance out of the box.  To use the Parallels provider, you will need to install  Parallels Vagrant plug-in . It is free of charge.", 
            "title": "First Steps"
        }, 
        {
            "location": "/homestead/#installing-the-homestead-vagrant-box", 
            "text": "Once VirtualBox / VMware and Vagrant have been installed, you should add the  laravel/homestead  box to your Vagrant installation using the following command in your terminal. It will take a few minutes to download the box, depending on your Internet connection speed:  vagrant box add laravel/homestead  If this command fails, make sure your Vagrant installation is up to date.", 
            "title": "Installing The Homestead Vagrant Box"
        }, 
        {
            "location": "/homestead/#installing-homestead", 
            "text": "You may install Homestead by simply cloning the repository. Consider cloning the repository into a  Homestead  folder within your \"home\" directory, as the Homestead box will serve as the host to all of your Laravel projects:  cd ~\n\ngit clone https://github.com/laravel/homestead.git Homestead  Once you have cloned the Homestead repository, run the  bash init.sh  command from the Homestead directory to create the  Homestead.yaml  configuration file. The  Homestead.yaml  file will be placed in the Homestead directory:  // Mac / Linux...\nbash init.sh\n\n// Windows...\ninit.bat", 
            "title": "Installing Homestead"
        }, 
        {
            "location": "/homestead/#configuring-homestead", 
            "text": "", 
            "title": "Configuring Homestead"
        }, 
        {
            "location": "/homestead/#setting-your-provider", 
            "text": "The  provider  key in your  Homestead.yaml  file indicates which Vagrant provider should be used:  virtualbox ,  vmware_fusion ,  vmware_workstation , or  parallels . You may set this to the provider you prefer:  provider :   virtualbox", 
            "title": "Setting Your Provider"
        }, 
        {
            "location": "/homestead/#configuring-shared-folders", 
            "text": "The  folders  property of the  Homestead.yaml  file lists all of the folders you wish to share with your Homestead environment. As files within these folders are changed, they will be kept in sync between your local machine and the Homestead environment. You may configure as many shared folders as necessary:  folders:\n    - map: ~/Code\n      to: /home/vagrant/Code  To enable  NFS , just add a simple flag to your synced folder configuration:  folders:\n    - map: ~/Code\n      to: /home/vagrant/Code\n      type:  nfs   You may also pass any options supported by Vagrant's  Synced Folders  by listing them under the  options  key:  folders:\n    - map: ~/Code\n      to: /home/vagrant/Code\n      type:  rsync \n      options:\n          rsync__args: [ --verbose ,  --archive ,  --delete ,  -zz ]\n          rsync__exclude: [ node_modules ]", 
            "title": "Configuring Shared Folders"
        }, 
        {
            "location": "/homestead/#configuring-nginx-sites", 
            "text": "Not familiar with Nginx? No problem. The  sites  property allows you to easily map a \"domain\" to a folder on your Homestead environment. A sample site configuration is included in the  Homestead.yaml  file. Again, you may add as many sites to your Homestead environment as necessary. Homestead can serve as a convenient, virtualized environment for every Laravel project you are working on:  sites:\n    - map: homestead.app\n      to: /home/vagrant/Code/Laravel/public  If you change the  sites  property after provisioning the Homestead box, you should re-run  vagrant reload --provision   to update the Nginx configuration on the virtual machine.", 
            "title": "Configuring Nginx Sites"
        }, 
        {
            "location": "/homestead/#the-hosts-file", 
            "text": "You must add the \"domains\" for your Nginx sites to the  hosts  file on your machine. The  hosts  file will redirect requests for your Homestead sites into your Homestead machine. On Mac and Linux, this file is located at  /etc/hosts . On Windows, it is located at  C:\\Windows\\System32\\drivers\\etc\\hosts . The lines you add to this file will look like the following:  192.168.10.10  homestead.app  Make sure the IP address listed is the one set in your  Homestead.yaml  file. Once you have added the domain to your  hosts  file and launched the Vagrant box you will be able to access the site via your web browser:  http://homestead.app", 
            "title": "The Hosts File"
        }, 
        {
            "location": "/homestead/#launching-the-vagrant-box", 
            "text": "Once you have edited the  Homestead.yaml  to your liking, run the  vagrant up  command from your Homestead directory. Vagrant will boot the virtual machine and automatically configure your shared folders and Nginx sites.  To destroy the machine, you may use the  vagrant destroy --force  command.", 
            "title": "Launching The Vagrant Box"
        }, 
        {
            "location": "/homestead/#per-project-installation", 
            "text": "Instead of installing Homestead globally and sharing the same Homestead box across all of your projects, you may instead configure a Homestead instance for each project you manage. Installing Homestead per project may be beneficial if you wish to ship a  Vagrantfile  with your project, allowing others working on the project to simply  vagrant up .  To install Homestead directly into your project, require it using Composer:  composer require laravel/homestead --dev  Once Homestead has been installed, use the  make  command to generate the  Vagrantfile  and  Homestead.yaml  file in your project root. The  make  command will automatically configure the  sites  and  folders  directives in the  Homestead.yaml  file.  Mac / Linux:  php vendor/bin/homestead make  Windows:  vendor\\\\bin\\\\homestead make  Next, run the  vagrant up  command in your terminal and access your project at  http://homestead.app  in your browser. Remember, you will still need to add an  /etc/hosts  file entry for  homestead.app  or the domain of your choice.", 
            "title": "Per Project Installation"
        }, 
        {
            "location": "/homestead/#installing-mariadb", 
            "text": "If you prefer to use MariaDB instead of MySQL, you may add the  mariadb  option to your  Homestead.yaml  file. This option will remove MySQL and install MariaDB. MariaDB serves as a drop-in replacement for MySQL so you should still use the  mysql  database driver in your application's database configuration:  box :   laravel / homestead  ip :   192.168.20.20  memory :   2048  cpus :   4  provider :   virtualbox  mariadb :   true", 
            "title": "Installing MariaDB"
        }, 
        {
            "location": "/homestead/#daily-usage", 
            "text": "", 
            "title": "Daily Usage"
        }, 
        {
            "location": "/homestead/#accessing-homestead-globally", 
            "text": "Sometimes you may want to  vagrant up  your Homestead machine from anywhere on your filesystem. You can do this on Mac / Linux systems by adding a Bash function to your Bash profile. On Windows, you may accomplish this by adding a \"batch\" file to your  PATH . This scripts will allow you to run any Vagrant command from anywhere on your system and will automatically point that command to your Homestead installation:", 
            "title": "Accessing Homestead Globally"
        }, 
        {
            "location": "/homestead/#mac-linux", 
            "text": "function   homestead() { \n     (   cd   ~ /Homestead   vagrant $* )  }   Make sure to tweak the  ~/Homestead  path in the function to the location of your actual Homestead installation. Once the function is installed, you may run commands like  homestead up  or  homestead ssh  from anywhere on your system.", 
            "title": "Mac / Linux"
        }, 
        {
            "location": "/homestead/#windows", 
            "text": "Create a  homestead.bat  batch file anywhere on your machine with the following contents:  @echo off\n\nset cwd=%cd%\nset homesteadVagrant=C:\\Homestead\n\ncd /d %homesteadVagrant%   vagrant %*\ncd /d %cwd%\n\nset cwd=\nset homesteadVagrant=  Make sure to tweak the example  C:\\Homestead  path in the script to the actual location of your Homestead installation. After creating the file, add the file location to your  PATH . You may then run commands like  homestead up  or  homestead ssh  from anywhere on your system.", 
            "title": "Windows"
        }, 
        {
            "location": "/homestead/#connecting-via-ssh", 
            "text": "You can SSH into your virtual machine by issuing the  vagrant ssh  terminal command from your Homestead directory.  But, since you will probably need to SSH into your Homestead machine frequently, consider adding the \"function\" described above to your host machine to quickly SSH into the Homestead box.", 
            "title": "Connecting Via SSH"
        }, 
        {
            "location": "/homestead/#connecting-to-databases", 
            "text": "A  homestead  database is configured for both MySQL and Postgres out of the box. For even more convenience, Laravel's  .env  file configures the framework to use this database out of the box.  To connect to your MySQL or Postgres database from your host machine's database client, you should connect to  127.0.0.1  and port  33060  (MySQL) or  54320  (Postgres). The username and password for both databases is  homestead  /  secret .   {note} You should only use these non-standard ports when connecting to the databases from your host machine. You will use the default 3306 and 5432 ports in your Laravel database configuration file since Laravel is running  within  the virtual machine.", 
            "title": "Connecting To Databases"
        }, 
        {
            "location": "/homestead/#adding-additional-sites", 
            "text": "Once your Homestead environment is provisioned and running, you may want to add additional Nginx sites for your Laravel applications. You can run as many Laravel installations as you wish on a single Homestead environment. To add an additional site, simply add the site to your  Homestead.yaml  file:  sites:\n    - map: homestead.app\n      to: /home/vagrant/Code/Laravel/public\n    - map: another.app\n      to: /home/vagrant/Code/another/public  If Vagrant is not automatically managing your \"hosts\" file, you may need to add the new site to that file as well:  192.168.10.10  homestead.app\n192.168.10.10  another.app  Once the site has been added, run the  vagrant reload --provision  command from your Homestead directory.", 
            "title": "Adding Additional Sites"
        }, 
        {
            "location": "/homestead/#configuring-cron-schedules", 
            "text": "Laravel provides a convenient way to  schedule Cron jobs  by scheduling a single  schedule:run  Artisan command to be run every minute. The  schedule:run  command will examine the job schedule defined in your  App\\Console\\Kernel  class to determine which jobs should be run.  If you would like the  schedule:run  command to be run for a Homestead site, you may set the  schedule  option to  true  when defining the site:  sites:\n    - map: homestead.app\n      to: /home/vagrant/Code/Laravel/public\n      schedule: true  The Cron job for the site will be defined in the  /etc/cron.d  folder of the virtual machine.", 
            "title": "Configuring Cron Schedules"
        }, 
        {
            "location": "/homestead/#ports", 
            "text": "By default, the following ports are forwarded to your Homestead environment:   SSH:  2222   Forwards To 22  HTTP:  8000   Forwards To 80  HTTPS:  44300   Forwards To 443  MySQL:  33060   Forwards To 3306  Postgres:  54320   Forwards To 5432", 
            "title": "Ports"
        }, 
        {
            "location": "/homestead/#forwarding-additional-ports", 
            "text": "If you wish, you may forward additional ports to the Vagrant box, as well as specify their protocol:  ports:\n    - send: 93000\n      to: 9300\n    - send: 7777\n      to: 777\n      protocol: udp", 
            "title": "Forwarding Additional Ports"
        }, 
        {
            "location": "/homestead/#network-interfaces", 
            "text": "The  networks  property of the  Homestead.yaml  configures network interfaces for your Homestead environment. You may configure as many interfaces as necessary:  networks:\n    - type:  private_network \n      ip:  192.168.10.20   To enable a  bridged  interface, configure a  bridge  setting and change the network type to  public_network :  networks:\n    - type:  public_network \n      ip:  192.168.10.20 \n      bridge:  en1: Wi-Fi (AirPort)   To enable  DHCP , just remove the  ip  option from your configuration:  networks:\n    - type:  public_network \n      bridge:  en1: Wi-Fi (AirPort)", 
            "title": "Network Interfaces"
        }, 
        {
            "location": "/homestead/#updating-homestead", 
            "text": "You can update Homestead in two simple steps. First, you should update the Vagrant box using the  vagrant box update  command:  vagrant box update  Next, you need to update the Homestead source code. If you cloned the repository you can simply  git pull origin master  at the location you originally cloned the repository.  If you have installed Homestead via your project's  composer.json  file, you should ensure your  composer.json  file contains  \"laravel/homestead\": \"^4\"  and update your dependencies:  composer update", 
            "title": "Updating Homestead"
        }, 
        {
            "location": "/homestead/#old-versions", 
            "text": "You can easily override the version of the box that Homestead uses by adding the following line to your  Homestead.yaml  file:  version :   0.6 . 0   An example:  box :   laravel / homestead  version :   0.6 . 0  ip :   192.168.20.20  memory :   2048  cpus :   4  provider :   virtualbox   When you use an older version of the Homestead box you need to match that with a compatible version of the Homestead source code. Below is a chart which shows the supported box versions, which version of Homestead source code to use, and the version of PHP provided:      Homestead Version  Box Version      PHP 7.0  3.1.0  0.6.0    PHP 7.1  4.0.0  1.0.0", 
            "title": "Old Versions"
        }, 
        {
            "location": "/http-tests/", 
            "text": "HTTP Tests\n\n\n\n\nIntroduction\n\n\nSession / Authentication\n\n\nTesting JSON APIs\n\n\nAvailable Assertions\n\n\n\n\n\n\nIntroduction\n\n\nLaravel provides a very fluent API for making HTTP requests to your application and examining the output. For example, take a look at the test defined below:\n\n\n?\nphp\n\n\n\nnamespace\n \nTests\n\\\nFeature\n;\n\n\n\nuse\n \nTests\n\\\nTestCase\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nWithoutMiddleware\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseMigrations\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseTransactions\n;\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \n/**\n\n\n     * A basic test example.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \ntestBasicTest\n()\n\n    \n{\n\n        \n$response\n \n=\n \n$this\n-\nget\n(\n/\n);\n\n\n        \n$response\n-\nassertStatus\n(\n200\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe \nget\n method makes a \nGET\n request into the application, while the \nassertStatus\n method asserts that the returned response should have the given HTTP status code. In addition to this simple assertion, Laravel also contains a variety of assertions for inspecting the response headers, content, JSON structure, and more.\n\n\n\n\nSession / Authentication\n\n\nLaravel provides several helpers for working with the session during HTTP testing. First, you may set the session data to a given array using the \nwithSession\n method. This is useful for loading the session with data before issuing a request to your application:\n\n\n?\nphp\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \npublic\n \nfunction\n \ntestApplication\n()\n\n    \n{\n\n        \n$response\n \n=\n \n$this\n-\nwithSession\n([\nfoo\n \n=\n \nbar\n])\n\n                         \n-\nget\n(\n/\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOf course, one common use of the session is for maintaining state for the authenticated user. The \nactingAs\n helper method provides a simple way to authenticate a given user as the current user. For example, we may use a \nmodel factory\n to generate and authenticate a user:\n\n\n?\nphp\n\n\n\nuse\n \nApp\n\\\nUser\n;\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \npublic\n \nfunction\n \ntestApplication\n()\n\n    \n{\n\n        \n$user\n \n=\n \nfactory\n(\nUser\n::\nclass\n)\n-\ncreate\n();\n\n\n        \n$response\n \n=\n \n$this\n-\nactingAs\n(\n$user\n)\n\n                         \n-\nwithSession\n([\nfoo\n \n=\n \nbar\n])\n\n                         \n-\nget\n(\n/\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou may also specify which guard should be used to authenticate the given user by passing the guard name as the second argument to the \nactingAs\n method:\n\n\n$this-\nactingAs($user, \napi\n)\n\n\n\n\n\n\n\nTesting JSON APIs\n\n\nLaravel also provides several helpers for testing JSON APIs and their responses. For example, the \njson\n, \nget\n, \npost\n, \nput\n, \npatch\n, and \ndelete\n methods may be used to issue requests with various HTTP verbs. You may also easily pass data and headers to these methods. To get started, let's write a test to make a \nPOST\n request to \n/user\n and assert that the expected data was returned:\n\n\n?\nphp\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \n/**\n\n\n     * A basic functional test example.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \ntestBasicExample\n()\n\n    \n{\n\n        \n$response\n \n=\n \n$this\n-\njson\n(\nPOST\n,\n \n/user\n,\n \n[\nname\n \n=\n \nSally\n]);\n\n\n        \n$response\n\n            \n-\nassertStatus\n(\n200\n)\n\n            \n-\nassertJson\n([\n\n                \ncreated\n \n=\n \ntrue\n,\n\n            \n]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n{tip} The \nassertJson\n method converts the response to an array and utilizes \nPHPUnit::assertArraySubset\n to verify that the given array exists within the JSON response returned by the application. So, if there are other properties in the JSON response, this test will still pass as long as the given fragment is present.\n\n\n\n\n\n\nVerifying Exact Match\n\n\nIf you would like to verify that the given array is an \nexact\n match for the JSON returned by the application, you should use the \nassertExactJson\n method:\n\n\n?\nphp\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \n/**\n\n\n     * A basic functional test example.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \ntestBasicExample\n()\n\n    \n{\n\n        \n$response\n \n=\n \n$this\n-\njson\n(\nPOST\n,\n \n/user\n,\n \n[\nname\n \n=\n \nSally\n]);\n\n\n        \n$response\n\n            \n-\nassertStatus\n(\n200\n)\n\n            \n-\nassertExactJson\n([\n\n                \ncreated\n \n=\n \ntrue\n,\n\n            \n]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nAvailable Assertions\n\n\nLaravel provides a variety of custom assertion methods for your \nPHPUnit\n tests. These assertions may be accessed on the response that is returned from the \njson\n, \nget\n, \npost\n, \nput\n, and \ndelete\n test methods:\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$response-\nassertStatus($code);\n\n\nAssert that the response has a given code.\n\n\n\n\n\n\n$response-\nassertRedirect($uri);\n\n\nAssert that the response is a redirect to a given URI.\n\n\n\n\n\n\n$response-\nassertHeader($headerName, $value = null);\n\n\nAssert that the given header is present on the response.\n\n\n\n\n\n\n$response-\nassertCookie($cookieName, $value = null);\n\n\nAssert that the response contains the given cookie.\n\n\n\n\n\n\n$response-\nassertPlainCookie($cookieName, $value = null);\n\n\nAssert that the response contains the given cookie (unencrypted).\n\n\n\n\n\n\n$response-\nassertSessionHas($key, $value = null);\n\n\nAssert that the session contains the given piece of data.\n\n\n\n\n\n\n$response-\nassertSessionHasErrors(array $keys);\n\n\nAssert that the session contains an error for the given field.\n\n\n\n\n\n\n$response-\nassertSessionMissing($key);\n\n\nAssert that the session does not contain the given key.\n\n\n\n\n\n\n$response-\nassertJson(array $data);\n\n\nAssert that the response contains the given JSON data.\n\n\n\n\n\n\n$response-\nassertJsonFragment(array $data);\n\n\nAssert that the response contains the given JSON fragment.\n\n\n\n\n\n\n$response-\nassertExactJson(array $data);\n\n\nAssert that the response contains an exact match of the given JSON data.\n\n\n\n\n\n\n$response-\nassertJsonStructure(array $structure);\n\n\nAssert that the response has a given JSON structure.\n\n\n\n\n\n\n$response-\nassertViewHas($key, $value = null);\n\n\nAssert that the response view was given a piece of data.", 
            "title": "Http tests"
        }, 
        {
            "location": "/http-tests/#http-tests", 
            "text": "Introduction  Session / Authentication  Testing JSON APIs  Available Assertions", 
            "title": "HTTP Tests"
        }, 
        {
            "location": "/http-tests/#introduction", 
            "text": "Laravel provides a very fluent API for making HTTP requests to your application and examining the output. For example, take a look at the test defined below:  ? php  namespace   Tests \\ Feature ;  use   Tests \\ TestCase ;  use   Illuminate \\ Foundation \\ Testing \\ WithoutMiddleware ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseMigrations ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseTransactions ;  class   ExampleTest   extends   TestCase  { \n     /**       * A basic test example.       *       * @return void       */ \n     public   function   testBasicTest () \n     { \n         $response   =   $this - get ( / ); \n\n         $response - assertStatus ( 200 ); \n     }  }   The  get  method makes a  GET  request into the application, while the  assertStatus  method asserts that the returned response should have the given HTTP status code. In addition to this simple assertion, Laravel also contains a variety of assertions for inspecting the response headers, content, JSON structure, and more.", 
            "title": "Introduction"
        }, 
        {
            "location": "/http-tests/#session-authentication", 
            "text": "Laravel provides several helpers for working with the session during HTTP testing. First, you may set the session data to a given array using the  withSession  method. This is useful for loading the session with data before issuing a request to your application:  ? php  class   ExampleTest   extends   TestCase  { \n     public   function   testApplication () \n     { \n         $response   =   $this - withSession ([ foo   =   bar ]) \n                          - get ( / ); \n     }  }   Of course, one common use of the session is for maintaining state for the authenticated user. The  actingAs  helper method provides a simple way to authenticate a given user as the current user. For example, we may use a  model factory  to generate and authenticate a user:  ? php  use   App \\ User ;  class   ExampleTest   extends   TestCase  { \n     public   function   testApplication () \n     { \n         $user   =   factory ( User :: class ) - create (); \n\n         $response   =   $this - actingAs ( $user ) \n                          - withSession ([ foo   =   bar ]) \n                          - get ( / ) \n     }  }   You may also specify which guard should be used to authenticate the given user by passing the guard name as the second argument to the  actingAs  method:  $this- actingAs($user,  api )", 
            "title": "Session / Authentication"
        }, 
        {
            "location": "/http-tests/#testing-json-apis", 
            "text": "Laravel also provides several helpers for testing JSON APIs and their responses. For example, the  json ,  get ,  post ,  put ,  patch , and  delete  methods may be used to issue requests with various HTTP verbs. You may also easily pass data and headers to these methods. To get started, let's write a test to make a  POST  request to  /user  and assert that the expected data was returned:  ? php  class   ExampleTest   extends   TestCase  { \n     /**       * A basic functional test example.       *       * @return void       */ \n     public   function   testBasicExample () \n     { \n         $response   =   $this - json ( POST ,   /user ,   [ name   =   Sally ]); \n\n         $response \n             - assertStatus ( 200 ) \n             - assertJson ([ \n                 created   =   true , \n             ]); \n     }  }    {tip} The  assertJson  method converts the response to an array and utilizes  PHPUnit::assertArraySubset  to verify that the given array exists within the JSON response returned by the application. So, if there are other properties in the JSON response, this test will still pass as long as the given fragment is present.", 
            "title": "Testing JSON APIs"
        }, 
        {
            "location": "/http-tests/#verifying-exact-match", 
            "text": "If you would like to verify that the given array is an  exact  match for the JSON returned by the application, you should use the  assertExactJson  method:  ? php  class   ExampleTest   extends   TestCase  { \n     /**       * A basic functional test example.       *       * @return void       */ \n     public   function   testBasicExample () \n     { \n         $response   =   $this - json ( POST ,   /user ,   [ name   =   Sally ]); \n\n         $response \n             - assertStatus ( 200 ) \n             - assertExactJson ([ \n                 created   =   true , \n             ]); \n     }  }", 
            "title": "Verifying Exact Match"
        }, 
        {
            "location": "/http-tests/#available-assertions", 
            "text": "Laravel provides a variety of custom assertion methods for your  PHPUnit  tests. These assertions may be accessed on the response that is returned from the  json ,  get ,  post ,  put , and  delete  test methods:     Method  Description      $response- assertStatus($code);  Assert that the response has a given code.    $response- assertRedirect($uri);  Assert that the response is a redirect to a given URI.    $response- assertHeader($headerName, $value = null);  Assert that the given header is present on the response.    $response- assertCookie($cookieName, $value = null);  Assert that the response contains the given cookie.    $response- assertPlainCookie($cookieName, $value = null);  Assert that the response contains the given cookie (unencrypted).    $response- assertSessionHas($key, $value = null);  Assert that the session contains the given piece of data.    $response- assertSessionHasErrors(array $keys);  Assert that the session contains an error for the given field.    $response- assertSessionMissing($key);  Assert that the session does not contain the given key.    $response- assertJson(array $data);  Assert that the response contains the given JSON data.    $response- assertJsonFragment(array $data);  Assert that the response contains the given JSON fragment.    $response- assertExactJson(array $data);  Assert that the response contains an exact match of the given JSON data.    $response- assertJsonStructure(array $structure);  Assert that the response has a given JSON structure.    $response- assertViewHas($key, $value = null);  Assert that the response view was given a piece of data.", 
            "title": "Available Assertions"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\n\n\n\nInstallation\n\n\nServer Requirements\n\n\nInstalling Laravel\n\n\nConfiguration\n\n\n\n\n\n\nWeb Server Configuration\n\n\nPretty URLs\n\n\n\n\n\n\n\n\n\n\nInstallation\n\n\n\n\n{video} Are you a visual learner? Laracasts provides a \nfree, thorough introduction to Laravel\n for newcomers to the framework. It's a great place to start your journey.\n\n\n\n\n\n\nServer Requirements\n\n\nThe Laravel framework has a few system requirements. Of course, all of these requirements are satisfied by the \nLaravel Homestead\n virtual machine, so it's highly recommended that you use Homestead as your local Laravel development environment.\n\n\nHowever, if you are not using Homestead, you will need to make sure your server meets the following requirements:\n\n\n\n- PHP >= 5.6.4\n- OpenSSL PHP Extension\n- PDO PHP Extension\n- Mbstring PHP Extension\n- Tokenizer PHP Extension\n- XML PHP Extension\n\n\n\n\n\n\nInstalling Laravel\n\n\nLaravel utilizes \nComposer\n to manage its dependencies. So, before using Laravel, make sure you have Composer installed on your machine.\n\n\nVia Laravel Installer\n\n\nFirst, download the Laravel installer using Composer:\n\n\ncomposer global require \nlaravel/installer\n\n\n\n\n\n\nMake sure to place the \n$HOME/.composer/vendor/bin\n directory (or the equivalent directory for your OS) in your $PATH so the \nlaravel\n executable can be located by your system.\n\n\nOnce installed, the \nlaravel new\n command will create a fresh Laravel installation in the directory you specify. For instance, \nlaravel new blog\n will create a directory named \nblog\n containing a fresh Laravel installation with all of Laravel's dependencies already installed:\n\n\nlaravel new blog\n\n\n\n\n\nVia Composer Create-Project\n\n\nAlternatively, you may also install Laravel by issuing the Composer \ncreate-project\n command in your terminal:\n\n\ncomposer create-project --prefer-dist laravel/laravel blog\n\n\n\n\n\nLocal Development Server\n\n\nIf you have PHP installed locally and you would like to use PHP's built-in development server to serve your application, you may use the \nserve\n Artisan command. This command will start a development server at \nhttp://localhost:8000\n:\n\n\nphp artisan serve\n\n\n\n\n\nOf course, more robust local development options are available via \nHomestead\n and \nValet\n.\n\n\n\n\nConfiguration\n\n\nPublic Directory\n\n\nAfter installing Laravel, you should configure your web server's document / web root to be the \npublic\n directory. The \nindex.php\n in this directory serves as the front controller for all HTTP requests entering your application.\n\n\nConfiguration Files\n\n\nAll of the configuration files for the Laravel framework are stored in the \nconfig\n directory. Each option is documented, so feel free to look through the files and get familiar with the options available to you.\n\n\nDirectory Permissions\n\n\nAfter installing Laravel, you may need to configure some permissions. Directories within the \nstorage\n and the \nbootstrap/cache\n directories should be writable by your web server or Laravel will not run. If you are using the \nHomestead\n virtual machine, these permissions should already be set.\n\n\nApplication Key\n\n\nThe next thing you should do after installing Laravel is set your application key to a random string. If you installed Laravel via Composer or the Laravel installer, this key has already been set for you by the \nphp artisan key:generate\n command.\n\n\nTypically, this string should be 32 characters long. The key can be set in the \n.env\n environment file. If you have not renamed the \n.env.example\n file to \n.env\n, you should do that now. \nIf the application key is not set, your user sessions and other encrypted data will not be secure!\n\n\nAdditional Configuration\n\n\nLaravel needs almost no other configuration out of the box. You are free to get started developing! However, you may wish to review the \nconfig/app.php\n file and its documentation. It contains several options such as \ntimezone\n and \nlocale\n that you may wish to change according to your application.\n\n\nYou may also want to configure a few additional components of Laravel, such as:\n\n\n\n- [Cache](/docs/{{version}}/cache#configuration)\n- [Database](/docs/{{version}}/database#configuration)\n- [Session](/docs/{{version}}/session#configuration)\n\n\n\n\n\n\nWeb Server Configuration\n\n\n\n\nPretty URLs\n\n\nApache\n\n\nLaravel includes a \npublic/.htaccess\n file that is used to provide URLs without the \nindex.php\n front controller in the path. Before serving Laravel with Apache, be sure to enable the \nmod_rewrite\n module so the \n.htaccess\n file will be honored by the server.\n\n\nIf the \n.htaccess\n file that ships with Laravel does not work with your Apache installation, try this alternative:\n\n\nOptions +FollowSymLinks\nRewriteEngine On\n\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteRule ^ index.php [L]\n\n\n\n\n\nNginx\n\n\nIf you are using Nginx, the following directive in your site configuration will direct all requests to the \nindex.php\n front controller:\n\n\nlocation / {\n    try_files $uri $uri/ /index.php?$query_string;\n}\n\n\n\n\n\nOf course, when using \nHomestead\n or \nValet\n, pretty URLs will be automatically configured.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "Installation  Server Requirements  Installing Laravel  Configuration    Web Server Configuration  Pretty URLs", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation_1", 
            "text": "{video} Are you a visual learner? Laracasts provides a  free, thorough introduction to Laravel  for newcomers to the framework. It's a great place to start your journey.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#server-requirements", 
            "text": "The Laravel framework has a few system requirements. Of course, all of these requirements are satisfied by the  Laravel Homestead  virtual machine, so it's highly recommended that you use Homestead as your local Laravel development environment.  However, if you are not using Homestead, you will need to make sure your server meets the following requirements:  \n- PHP >= 5.6.4\n- OpenSSL PHP Extension\n- PDO PHP Extension\n- Mbstring PHP Extension\n- Tokenizer PHP Extension\n- XML PHP Extension", 
            "title": "Server Requirements"
        }, 
        {
            "location": "/installation/#installing-laravel", 
            "text": "Laravel utilizes  Composer  to manage its dependencies. So, before using Laravel, make sure you have Composer installed on your machine.", 
            "title": "Installing Laravel"
        }, 
        {
            "location": "/installation/#via-laravel-installer", 
            "text": "First, download the Laravel installer using Composer:  composer global require  laravel/installer   Make sure to place the  $HOME/.composer/vendor/bin  directory (or the equivalent directory for your OS) in your $PATH so the  laravel  executable can be located by your system.  Once installed, the  laravel new  command will create a fresh Laravel installation in the directory you specify. For instance,  laravel new blog  will create a directory named  blog  containing a fresh Laravel installation with all of Laravel's dependencies already installed:  laravel new blog", 
            "title": "Via Laravel Installer"
        }, 
        {
            "location": "/installation/#via-composer-create-project", 
            "text": "Alternatively, you may also install Laravel by issuing the Composer  create-project  command in your terminal:  composer create-project --prefer-dist laravel/laravel blog", 
            "title": "Via Composer Create-Project"
        }, 
        {
            "location": "/installation/#local-development-server", 
            "text": "If you have PHP installed locally and you would like to use PHP's built-in development server to serve your application, you may use the  serve  Artisan command. This command will start a development server at  http://localhost:8000 :  php artisan serve  Of course, more robust local development options are available via  Homestead  and  Valet .", 
            "title": "Local Development Server"
        }, 
        {
            "location": "/installation/#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/installation/#public-directory", 
            "text": "After installing Laravel, you should configure your web server's document / web root to be the  public  directory. The  index.php  in this directory serves as the front controller for all HTTP requests entering your application.", 
            "title": "Public Directory"
        }, 
        {
            "location": "/installation/#configuration-files", 
            "text": "All of the configuration files for the Laravel framework are stored in the  config  directory. Each option is documented, so feel free to look through the files and get familiar with the options available to you.", 
            "title": "Configuration Files"
        }, 
        {
            "location": "/installation/#directory-permissions", 
            "text": "After installing Laravel, you may need to configure some permissions. Directories within the  storage  and the  bootstrap/cache  directories should be writable by your web server or Laravel will not run. If you are using the  Homestead  virtual machine, these permissions should already be set.", 
            "title": "Directory Permissions"
        }, 
        {
            "location": "/installation/#application-key", 
            "text": "The next thing you should do after installing Laravel is set your application key to a random string. If you installed Laravel via Composer or the Laravel installer, this key has already been set for you by the  php artisan key:generate  command.  Typically, this string should be 32 characters long. The key can be set in the  .env  environment file. If you have not renamed the  .env.example  file to  .env , you should do that now.  If the application key is not set, your user sessions and other encrypted data will not be secure!", 
            "title": "Application Key"
        }, 
        {
            "location": "/installation/#additional-configuration", 
            "text": "Laravel needs almost no other configuration out of the box. You are free to get started developing! However, you may wish to review the  config/app.php  file and its documentation. It contains several options such as  timezone  and  locale  that you may wish to change according to your application.  You may also want to configure a few additional components of Laravel, such as:  \n- [Cache](/docs/{{version}}/cache#configuration)\n- [Database](/docs/{{version}}/database#configuration)\n- [Session](/docs/{{version}}/session#configuration)", 
            "title": "Additional Configuration"
        }, 
        {
            "location": "/installation/#web-server-configuration", 
            "text": "", 
            "title": "Web Server Configuration"
        }, 
        {
            "location": "/installation/#pretty-urls", 
            "text": "", 
            "title": "Pretty URLs"
        }, 
        {
            "location": "/installation/#apache", 
            "text": "Laravel includes a  public/.htaccess  file that is used to provide URLs without the  index.php  front controller in the path. Before serving Laravel with Apache, be sure to enable the  mod_rewrite  module so the  .htaccess  file will be honored by the server.  If the  .htaccess  file that ships with Laravel does not work with your Apache installation, try this alternative:  Options +FollowSymLinks\nRewriteEngine On\n\nRewriteCond %{REQUEST_FILENAME} !-d\nRewriteCond %{REQUEST_FILENAME} !-f\nRewriteRule ^ index.php [L]", 
            "title": "Apache"
        }, 
        {
            "location": "/installation/#nginx", 
            "text": "If you are using Nginx, the following directive in your site configuration will direct all requests to the  index.php  front controller:  location / {\n    try_files $uri $uri/ /index.php?$query_string;\n}  Of course, when using  Homestead  or  Valet , pretty URLs will be automatically configured.", 
            "title": "Nginx"
        }, 
        {
            "location": "/license/", 
            "text": "The MIT License (MIT)\nCopyright \u00a9 Taylor Otwell\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/lifecycle/", 
            "text": "Request Lifecycle\n\n\n\n\nIntroduction\n\n\nLifecycle Overview\n\n\nFocus On Service Providers\n\n\n\n\n\n\nIntroduction\n\n\nWhen using any tool in the \"real world\", you feel more confident if you understand how that tool works. Application development is no different. When you understand how your development tools function, you feel more comfortable and confident using them.\n\n\nThe goal of this document is to give you a good, high-level overview of how the Laravel framework works. By getting to know the overall framework better, everything feels less \"magical\" and you will be more confident building your applications. If you don't understand all of the terms right away, don't lose heart! Just try to get a basic grasp of what is going on, and your knowledge will grow as you explore other sections of the documentation.\n\n\n\n\nLifecycle Overview\n\n\nFirst Things\n\n\nThe entry point for all requests to a Laravel application is the \npublic/index.php\n file. All requests are directed to this file by your web server (Apache / Nginx) configuration. The \nindex.php\n file doesn't contain much code. Rather, it is simply a starting point for loading the rest of the framework.\n\n\nThe \nindex.php\n file loads the Composer generated autoloader definition, and then retrieves an instance of the Laravel application from \nbootstrap/app.php\n script. The first action taken by Laravel itself is to create an instance of the application / \nservice container\n.\n\n\nHTTP / Console Kernels\n\n\nNext, the incoming request is sent to either the HTTP kernel or the console kernel, depending on the type of request that is entering the application. These two kernels serve as the central location that all requests flow through. For now, let's just focus on the HTTP kernel, which is located in \napp/Http/Kernel.php\n.\n\n\nThe HTTP kernel extends the \nIlluminate\\Foundation\\Http\\Kernel\n class, which defines an array of \nbootstrappers\n that will be run before the request is executed. These bootstrappers configure error handling, configure logging, \ndetect the application environment\n, and perform other tasks that need to be done before the request is actually handled.\n\n\nThe HTTP kernel also defines a list of HTTP \nmiddleware\n that all requests must pass through before being handled by the application. These middleware handle reading and writing the \nHTTP session\n, determining if the application is in maintenance mode, \nverifying the CSRF token\n, and more.\n\n\nThe method signature for the HTTP kernel's \nhandle\n method is quite simple: receive a \nRequest\n and return a \nResponse\n. Think of the Kernel as being a big black box that represents your entire application. Feed it HTTP requests and it will return HTTP responses.\n\n\nService Providers\n\n\nOne of the most important Kernel bootstrapping actions is loading the \nservice providers\n for your application. All of the service providers for the application are configured in the \nconfig/app.php\n configuration file's \nproviders\n array. First, the \nregister\n method will be called on all providers, then, once all providers have been registered, the \nboot\n method will be called.\n\n\nService providers are responsible for bootstrapping all of the framework's various components, such as the database, queue, validation, and routing components. Since they bootstrap and configure every feature offered by the framework, service providers are the most important aspect of the entire Laravel bootstrap process.\n\n\nDispatch Request\n\n\nOnce the application has been bootstrapped and all service providers have been registered, the \nRequest\n will be handed off to the router for dispatching. The router will dispatch the request to a route or controller, as well as run any route specific middleware.\n\n\n\n\nFocus On Service Providers\n\n\nService providers are truly the key to bootstrapping a Laravel application. The application instance is created, the service providers are registered, and the request is handed to the bootstrapped application. It's really that simple!\n\n\nHaving a firm grasp of how a Laravel application is built and bootstrapped via service providers is very valuable. Of course, your application's default service providers are stored in the \napp/Providers\n directory.\n\n\nBy default, the \nAppServiceProvider\n is fairly empty. This provider is a great place to add your application's own bootstrapping and service container bindings. Of course, for large applications, you may wish to create several service providers, each with a more granular type of bootstrapping.", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/lifecycle/#request-lifecycle", 
            "text": "Introduction  Lifecycle Overview  Focus On Service Providers", 
            "title": "Request Lifecycle"
        }, 
        {
            "location": "/lifecycle/#introduction", 
            "text": "When using any tool in the \"real world\", you feel more confident if you understand how that tool works. Application development is no different. When you understand how your development tools function, you feel more comfortable and confident using them.  The goal of this document is to give you a good, high-level overview of how the Laravel framework works. By getting to know the overall framework better, everything feels less \"magical\" and you will be more confident building your applications. If you don't understand all of the terms right away, don't lose heart! Just try to get a basic grasp of what is going on, and your knowledge will grow as you explore other sections of the documentation.", 
            "title": "Introduction"
        }, 
        {
            "location": "/lifecycle/#lifecycle-overview", 
            "text": "", 
            "title": "Lifecycle Overview"
        }, 
        {
            "location": "/lifecycle/#first-things", 
            "text": "The entry point for all requests to a Laravel application is the  public/index.php  file. All requests are directed to this file by your web server (Apache / Nginx) configuration. The  index.php  file doesn't contain much code. Rather, it is simply a starting point for loading the rest of the framework.  The  index.php  file loads the Composer generated autoloader definition, and then retrieves an instance of the Laravel application from  bootstrap/app.php  script. The first action taken by Laravel itself is to create an instance of the application /  service container .", 
            "title": "First Things"
        }, 
        {
            "location": "/lifecycle/#http-console-kernels", 
            "text": "Next, the incoming request is sent to either the HTTP kernel or the console kernel, depending on the type of request that is entering the application. These two kernels serve as the central location that all requests flow through. For now, let's just focus on the HTTP kernel, which is located in  app/Http/Kernel.php .  The HTTP kernel extends the  Illuminate\\Foundation\\Http\\Kernel  class, which defines an array of  bootstrappers  that will be run before the request is executed. These bootstrappers configure error handling, configure logging,  detect the application environment , and perform other tasks that need to be done before the request is actually handled.  The HTTP kernel also defines a list of HTTP  middleware  that all requests must pass through before being handled by the application. These middleware handle reading and writing the  HTTP session , determining if the application is in maintenance mode,  verifying the CSRF token , and more.  The method signature for the HTTP kernel's  handle  method is quite simple: receive a  Request  and return a  Response . Think of the Kernel as being a big black box that represents your entire application. Feed it HTTP requests and it will return HTTP responses.", 
            "title": "HTTP / Console Kernels"
        }, 
        {
            "location": "/lifecycle/#service-providers", 
            "text": "One of the most important Kernel bootstrapping actions is loading the  service providers  for your application. All of the service providers for the application are configured in the  config/app.php  configuration file's  providers  array. First, the  register  method will be called on all providers, then, once all providers have been registered, the  boot  method will be called.  Service providers are responsible for bootstrapping all of the framework's various components, such as the database, queue, validation, and routing components. Since they bootstrap and configure every feature offered by the framework, service providers are the most important aspect of the entire Laravel bootstrap process.", 
            "title": "Service Providers"
        }, 
        {
            "location": "/lifecycle/#dispatch-request", 
            "text": "Once the application has been bootstrapped and all service providers have been registered, the  Request  will be handed off to the router for dispatching. The router will dispatch the request to a route or controller, as well as run any route specific middleware.", 
            "title": "Dispatch Request"
        }, 
        {
            "location": "/lifecycle/#focus-on-service-providers", 
            "text": "Service providers are truly the key to bootstrapping a Laravel application. The application instance is created, the service providers are registered, and the request is handed to the bootstrapped application. It's really that simple!  Having a firm grasp of how a Laravel application is built and bootstrapped via service providers is very valuable. Of course, your application's default service providers are stored in the  app/Providers  directory.  By default, the  AppServiceProvider  is fairly empty. This provider is a great place to add your application's own bootstrapping and service container bindings. Of course, for large applications, you may wish to create several service providers, each with a more granular type of bootstrapping.", 
            "title": "Focus On Service Providers"
        }, 
        {
            "location": "/localization/", 
            "text": "Localization\n\n\n\n\nIntroduction\n\n\nDefining Translation Strings\n\n\nUsing Short Keys\n\n\nUsing Translation Strings As Keys\n\n\n\n\n\n\nRetrieving Translation Strings\n\n\nReplacing Parameters In Translation Strings\n\n\nPluralization\n\n\n\n\n\n\nOverriding Package Language Files\n\n\n\n\n\n\nIntroduction\n\n\nLaravel's localization features provide a convenient way to retrieve strings in various languages, allowing you to easily support multiple languages within your application. Language strings are stored in files within the \nresources/lang\n directory. Within this directory there should be a subdirectory for each language supported by the application:\n\n\n/resources\n    /lang\n        /en\n            messages.php\n        /es\n            messages.php\n\n\n\n\n\nAll language files simply return an array of keyed strings. For example:\n\n\n?php\n\n\n\nreturn\n \n[\n\n    \nwelcome\n \n=\n \nWelcome to our application\n\n\n];\n\n\n\n\n\n\nConfiguring The Locale\n\n\nThe default language for your application is stored in the \nconfig/app.php\n configuration file. Of course, you may modify this value to suit the needs of your application. You may also change the active language at runtime using the \nsetLocale\n method on the \nApp\n facade:\n\n\nRoute\n::\nget\n(\nwelcome/{locale}\n,\n \nfunction\n \n($\nlocale\n)\n \n{\n\n    \nApp\n:\n:\nsetLocale\n(\n$\nlocale\n);\n\n\n    \n//\n\n\n}\n);\n\n\n\n\n\n\nYou may configure a \"fallback language\", which will be used when the active language does not contain a given translation string. Like the default language, the fallback language is also configured in the \nconfig/app.php\n configuration file:\n\n\nfallback_locale\n =\n \nen\n,\n\n\n\n\n\nDetermining The Current Locale\n\n\nYou may use the \ngetLocale\n and \nisLocale\n methods on the \nApp\n facade to determine the current locale or check if the locale is a given value:\n\n\n$\nlocale\n \n=\n \nApp\n::\ngetLocale\n();\n\n\n\nif\n \n(\nApp\n::\nisLocale\n(\nen\n))\n \n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\n\n\nDefining Translation Strings\n\n\n\n\nUsing Short Keys\n\n\nTypically, translation strings are stored in files within the \nresources/lang\n directory. Within this directory there should be a subdirectory for each language supported by the application:\n\n\n/resources\n    /lang\n        /en\n            messages.php\n        /es\n            messages.php\n\n\n\n\n\nAll language files simply return an array of keyed strings. For example:\n\n\n?php\n\n\n\n// resources/lang/en/messages.php\n\n\n\nreturn\n \n[\n\n    \nwelcome\n \n=\n \nWelcome to our application\n\n\n];\n\n\n\n\n\n\n\n\nUsing Translation Strings As Keys\n\n\nFor applications with heavy translation requirements, defining every string with a \"short key\" can become quickly confusing when referencing them in your views. For this reason, Laravel also provides support for defining translation strings using the \"default\" translation of the string as the key.\n\n\nTranslation files that use translation strings as keys are stored as JSON files in the \nresources/lang\n directory. For example, if your application has a Spanish translation, you should create a \nresources/lang/es.json\n file:\n\n\n{\n    \nI love programming.\n: \nMe encanta la programaci\u00f3n.\n\n}\n\n\n\n\n\n\n\nRetrieving Translation Strings\n\n\nYou may retrieve lines from language files using the \n__\n helper function. The \n__\n method accepts the file and key of the translation string as its first argument. For example, let's retrieve the \nwelcome\n translation string from the \nresources/lang/messages.php\n language file:\n\n\necho __(\nmessages.welcome\n);\n\necho __(\nI love programming.\n);\n\n\n\n\n\nOf course if you are using the \nBlade templating engine\n, you may use the \n{{ }}\n syntax to echo the translation string or use the \n@lang\n directive:\n\n\n{{\n \n__\n(\nmessages.welcome\n)\n \n}}\n\n\n\n@lang(\nmessages.welcome\n)\n\n\n\n\n\n\nIf the specified translation string does not exist, the \n__\n function will simply return the translation string key. So, using the example above, the \n__\n function would return \nmessages.welcome\n if the translation string does not exist.\n\n\n\n\nReplacing Parameters In Translation Strings\n\n\nIf you wish, you may define place-holders in your translation strings. All place-holders are prefixed with a \n:\n. For example, you may define a welcome message with a place-holder name:\n\n\nwelcome\n =\n \nWelcome, :name\n,\n\n\n\n\n\nTo replace the place-holders when retrieving a translation string, pass an array of replacements as the second argument to the \n__\n function:\n\n\necho __(\nmessages.welcome\n, [\nname\n =\n \ndayle\n]);\n\n\n\n\n\nIf your place-holder contains all capital letters, or only has its first letter capitalized, the translated value will be capitalized accordingly:\n\n\nwelcome\n =\n \nWelcome, :NAME\n, // Welcome, DAYLE\n\ngoodbye\n =\n \nGoodbye, :Name\n, // Goodbye, Dayle\n\n\n\n\n\n\n\nPluralization\n\n\nPluralization is a complex problem, as different languages have a variety of complex rules for pluralization. By using a \"pipe\" character, you may distinguish singular and plural forms of a string:\n\n\napples\n =\n \nThere is one apple|There are many apples\n,\n\n\n\n\n\nYou may even create more complex pluralization rules which specify translation strings for multiple number ranges:\n\n\napples\n =\n \n{0} There are none|[1,19] There are some|[20,*] There are many\n,\n\n\n\n\n\nAfter defining a translation string that has pluralization options, you may use the \ntrans_choice\n function to retrieve the line for a given \"count\". In this example, since the count is greater than one, the plural form of the translation string is returned:\n\n\necho trans_choice(\nmessages.apples\n, 10);\n\n\n\n\n\n\n\nOverriding Package Language Files\n\n\nSome packages may ship with their own language files. Instead of changing the package's core files to tweak these lines, you may override them by placing files in the \nresources/lang/vendor/{package}/{locale}\n directory.\n\n\nSo, for example, if you need to override the English translation strings in \nmessages.php\n for a package named \nskyrim/hearthfire\n, you should place a language file at: \nresources/lang/vendor/hearthfire/en/messages.php\n. Within this file, you should only define the translation strings you wish to override. Any translation strings you don't override will still be loaded from the package's original language files.", 
            "title": "Localization"
        }, 
        {
            "location": "/localization/#localization", 
            "text": "Introduction  Defining Translation Strings  Using Short Keys  Using Translation Strings As Keys    Retrieving Translation Strings  Replacing Parameters In Translation Strings  Pluralization    Overriding Package Language Files", 
            "title": "Localization"
        }, 
        {
            "location": "/localization/#introduction", 
            "text": "Laravel's localization features provide a convenient way to retrieve strings in various languages, allowing you to easily support multiple languages within your application. Language strings are stored in files within the  resources/lang  directory. Within this directory there should be a subdirectory for each language supported by the application:  /resources\n    /lang\n        /en\n            messages.php\n        /es\n            messages.php  All language files simply return an array of keyed strings. For example:  ?php  return   [ \n     welcome   =   Welcome to our application  ];", 
            "title": "Introduction"
        }, 
        {
            "location": "/localization/#configuring-the-locale", 
            "text": "The default language for your application is stored in the  config/app.php  configuration file. Of course, you may modify this value to suit the needs of your application. You may also change the active language at runtime using the  setLocale  method on the  App  facade:  Route :: get ( welcome/{locale} ,   function   ($ locale )   { \n     App : : setLocale ( $ locale ); \n\n     //  } );   You may configure a \"fallback language\", which will be used when the active language does not contain a given translation string. Like the default language, the fallback language is also configured in the  config/app.php  configuration file:  fallback_locale  =   en ,", 
            "title": "Configuring The Locale"
        }, 
        {
            "location": "/localization/#determining-the-current-locale", 
            "text": "You may use the  getLocale  and  isLocale  methods on the  App  facade to determine the current locale or check if the locale is a given value:  $ locale   =   App :: getLocale ();  if   ( App :: isLocale ( en ))   { \n     //  }", 
            "title": "Determining The Current Locale"
        }, 
        {
            "location": "/localization/#defining-translation-strings", 
            "text": "", 
            "title": "Defining Translation Strings"
        }, 
        {
            "location": "/localization/#using-short-keys", 
            "text": "Typically, translation strings are stored in files within the  resources/lang  directory. Within this directory there should be a subdirectory for each language supported by the application:  /resources\n    /lang\n        /en\n            messages.php\n        /es\n            messages.php  All language files simply return an array of keyed strings. For example:  ?php  // resources/lang/en/messages.php  return   [ \n     welcome   =   Welcome to our application  ];", 
            "title": "Using Short Keys"
        }, 
        {
            "location": "/localization/#using-translation-strings-as-keys", 
            "text": "For applications with heavy translation requirements, defining every string with a \"short key\" can become quickly confusing when referencing them in your views. For this reason, Laravel also provides support for defining translation strings using the \"default\" translation of the string as the key.  Translation files that use translation strings as keys are stored as JSON files in the  resources/lang  directory. For example, if your application has a Spanish translation, you should create a  resources/lang/es.json  file:  {\n     I love programming. :  Me encanta la programaci\u00f3n. \n}", 
            "title": "Using Translation Strings As Keys"
        }, 
        {
            "location": "/localization/#retrieving-translation-strings", 
            "text": "You may retrieve lines from language files using the  __  helper function. The  __  method accepts the file and key of the translation string as its first argument. For example, let's retrieve the  welcome  translation string from the  resources/lang/messages.php  language file:  echo __( messages.welcome );\n\necho __( I love programming. );  Of course if you are using the  Blade templating engine , you may use the  {{ }}  syntax to echo the translation string or use the  @lang  directive:  {{   __ ( messages.welcome )   }}  @lang( messages.welcome )   If the specified translation string does not exist, the  __  function will simply return the translation string key. So, using the example above, the  __  function would return  messages.welcome  if the translation string does not exist.", 
            "title": "Retrieving Translation Strings"
        }, 
        {
            "location": "/localization/#replacing-parameters-in-translation-strings", 
            "text": "If you wish, you may define place-holders in your translation strings. All place-holders are prefixed with a  : . For example, you may define a welcome message with a place-holder name:  welcome  =   Welcome, :name ,  To replace the place-holders when retrieving a translation string, pass an array of replacements as the second argument to the  __  function:  echo __( messages.welcome , [ name  =   dayle ]);  If your place-holder contains all capital letters, or only has its first letter capitalized, the translated value will be capitalized accordingly:  welcome  =   Welcome, :NAME , // Welcome, DAYLE goodbye  =   Goodbye, :Name , // Goodbye, Dayle", 
            "title": "Replacing Parameters In Translation Strings"
        }, 
        {
            "location": "/localization/#pluralization", 
            "text": "Pluralization is a complex problem, as different languages have a variety of complex rules for pluralization. By using a \"pipe\" character, you may distinguish singular and plural forms of a string:  apples  =   There is one apple|There are many apples ,  You may even create more complex pluralization rules which specify translation strings for multiple number ranges:  apples  =   {0} There are none|[1,19] There are some|[20,*] There are many ,  After defining a translation string that has pluralization options, you may use the  trans_choice  function to retrieve the line for a given \"count\". In this example, since the count is greater than one, the plural form of the translation string is returned:  echo trans_choice( messages.apples , 10);", 
            "title": "Pluralization"
        }, 
        {
            "location": "/localization/#overriding-package-language-files", 
            "text": "Some packages may ship with their own language files. Instead of changing the package's core files to tweak these lines, you may override them by placing files in the  resources/lang/vendor/{package}/{locale}  directory.  So, for example, if you need to override the English translation strings in  messages.php  for a package named  skyrim/hearthfire , you should place a language file at:  resources/lang/vendor/hearthfire/en/messages.php . Within this file, you should only define the translation strings you wish to override. Any translation strings you don't override will still be loaded from the package's original language files.", 
            "title": "Overriding Package Language Files"
        }, 
        {
            "location": "/mail/", 
            "text": "Mail\n\n\n\n\nIntroduction\n\n\nDriver Prerequisites\n\n\n\n\n\n\nGenerating Mailables\n\n\nWriting Mailables\n\n\nConfiguring The Sender\n\n\nConfiguring The View\n\n\nView Data\n\n\nAttachments\n\n\nInline Attachments\n\n\n\n\n\n\nMarkdown Mailables\n\n\nGenerating Markdown Mailables\n\n\nWriting Markdown Messages\n\n\nCustomizing The Components\n\n\n\n\n\n\nSending Mail\n\n\nQueueing Mail\n\n\n\n\n\n\nMail \n Local Development\n\n\nEvents\n\n\n\n\n\n\nIntroduction\n\n\nLaravel provides a clean, simple API over the popular \nSwiftMailer\n library with drivers for SMTP, Mailgun, SparkPost, Amazon SES, PHP's \nmail\n function, and \nsendmail\n, allowing you to quickly get started sending mail through a local or cloud based service of your choice.\n\n\n\n\nDriver Prerequisites\n\n\nThe API based drivers such as Mailgun and SparkPost are often simpler and faster than SMTP servers. If possible, you should use one of these drivers. All of the API drivers require the Guzzle HTTP library, which may be installed via the Composer package manager:\n\n\ncomposer require guzzlehttp/guzzle\n\n\n\n\n\nMailgun Driver\n\n\nTo use the Mailgun driver, first install Guzzle, then set the \ndriver\n option in your \nconfig/mail.php\n configuration file to \nmailgun\n. Next, verify that your \nconfig/services.php\n configuration file contains the following options:\n\n\nmailgun\n =\n [\n    \ndomain\n =\n \nyour-mailgun-domain\n,\n    \nsecret\n =\n \nyour-mailgun-key\n,\n],\n\n\n\n\n\nSparkPost Driver\n\n\nTo use the SparkPost driver, first install Guzzle, then set the \ndriver\n option in your \nconfig/mail.php\n configuration file to \nsparkpost\n. Next, verify that your \nconfig/services.php\n configuration file contains the following options:\n\n\nsparkpost\n =\n [\n    \nsecret\n =\n \nyour-sparkpost-key\n,\n],\n\n\n\n\n\nSES Driver\n\n\nTo use the Amazon SES driver you must first install the Amazon AWS SDK for PHP. You may install this library by adding the following line to your \ncomposer.json\n file's \nrequire\n section and running the \ncomposer update\n command:\n\n\naws/aws-sdk-php\n: \n~3.0\n\n\n\n\n\n\nNext, set the \ndriver\n option in your \nconfig/mail.php\n configuration file to \nses\n and verify that your \nconfig/services.php\n configuration file contains the following options:\n\n\nses\n =\n [\n    \nkey\n =\n \nyour-ses-key\n,\n    \nsecret\n =\n \nyour-ses-secret\n,\n    \nregion\n =\n \nses-region\n,  // e.g. us-east-1\n],\n\n\n\n\n\n\n\nGenerating Mailables\n\n\nIn Laravel, each type of email sent by your application is represented as a \"mailable\" class. These classes are stored in the \napp/Mail\n directory. Don't worry if you don't see this directory in your application, since it will be generated for you when you create your first mailable class using the \nmake:mail\n command:\n\n\nphp artisan make:mail OrderShipped\n\n\n\n\n\n\n\nWriting Mailables\n\n\nAll of a mailable class' configuration is done in the \nbuild\n method. Within this method, you may call various methods such as \nfrom\n, \nsubject\n, \nview\n, and \nattach\n to configure the email's presentation and delivery.\n\n\n\n\nConfiguring The Sender\n\n\nUsing The \nfrom\n Method\n\n\nFirst, let's explore configuring the sender of the email. Or, in other words, who the email is going to be \"from\". There are two ways to configure the sender. First, you may use the \nfrom\n method within your mailable class' \nbuild\n method:\n\n\n/**\n\n\n * Build the message.\n\n\n *\n\n\n * @return $this\n\n\n */\n\npublic\n \nfunction\n \nbuild\n()\n\n\n{\n\n\n    \nreturn\n \n$\nthis\n-\nfrom\n(\nexample@example.com\n)\n\n\n                \n-\nview\n(\nemails.orders.shipped\n)\n;\n\n\n}\n\n\n\n\n\n\nUsing A Global \nfrom\n Address\n\n\nHowever, if your application uses the same \"from\" address for all of its emails, it can become cumbersome to call the \nfrom\n method in each mailable class you generate. Instead, you may specify a global \"from\" address in your \nconfig/mail.php\n configuration file. This address will be used if no other \"from\" address is specified within the mailable class:\n\n\nfrom\n =\n [\naddress\n =\n \nexample@example.com\n, \nname\n =\n \nApp Name\n],\n\n\n\n\n\n\n\nConfiguring The View\n\n\nWithin a mailable class' \nbuild\n method, you may use the \nview\n method to specify which template should be used when rendering the email's contents. Since each email typically uses a \nBlade template\n to render its contents, you have the full power and convenience of the Blade templating engine when building your email's HTML:\n\n\n/**\n\n\n * Build the message.\n\n\n *\n\n\n * @return $this\n\n\n */\n\npublic\n \nfunction\n \nbuild\n()\n\n\n{\n\n\n    \nreturn\n \n$\nthis\n-\nview\n(\nemails.orders.shipped\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\n{tip} You may wish to create a \nresources/views/emails\n directory to house all of your email templates; however, you are free to place them wherever you wish within your \nresources/views\n directory.\n\n\n\n\nPlain Text Emails\n\n\nIf you would like to define a plain-text version of your email, you may use the \ntext\n method. Like the \nview\n method, the \ntext\n method accepts a template name which will be used to render the contents of the email. You are free to define both a HTML and plain-text version of your message:\n\n\n/**\n\n\n * Build the message.\n\n\n *\n\n\n * @return $this\n\n\n */\n\npublic\n \nfunction\n \nbuild\n()\n\n\n{\n\n\n    \nreturn\n \n$\nthis\n-\nview\n(\nemails.orders.shipped\n)\n\n\n                \n-\ntext\n(\nemails.orders.shipped_plain\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nView Data\n\n\nVia Public Properties\n\n\nTypically, you will want to pass some data to your view that you can utilize when rendering the email's HTML. There are two ways you may make data available to your view. First, any public property defined on your mailable class will automatically be made available to the view. So, for example, you may pass data into your mailable class' constructor and set that data to public properties defined on the class:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nMail\n;\n\n\n\nuse\n \nApp\n\\\nOrder\n;\n\n\nuse\n \nIlluminate\n\\\nBus\n\\\nQueueable\n;\n\n\nuse\n \nIlluminate\n\\\nMail\n\\\nMailable\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nSerializesModels\n;\n\n\n\nclass\n \nOrderShipped\n \nextends\n \nMailable\n\n\n{\n\n    \nuse\n \nQueueable\n,\n \nSerializesModels\n;\n\n\n    \n/**\n\n\n     * The order instance.\n\n\n     *\n\n\n     * @var Order\n\n\n     */\n\n    \npublic\n \n$order\n;\n\n\n    \n/**\n\n\n     * Create a new message instance.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nOrder\n \n$order\n)\n\n    \n{\n\n        \n$this\n-\norder\n \n=\n \n$order\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Build the message.\n\n\n     *\n\n\n     * @return $this\n\n\n     */\n\n    \npublic\n \nfunction\n \nbuild\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nview\n(\nemails.orders.shipped\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOnce the data has been set to a public property, it will automatically be available in your view, so you may access it like you would access any other data in your Blade templates:\n\n\ndiv\n\n    Price: \n{{\n \n$\norder-\nprice\n \n}}\n\n\n/div\n\n\n\n\n\n\nVia The \nwith\n Method:\n\n\nIf you would like to customize the format of your email's data before it is sent to the template, you may manually pass your data to the view via the \nwith\n method. Typically, you will still pass data via the mailable class' constructor; however, you should set this data to \nprotected\n or \nprivate\n properties so the data is not automatically made available to the template. Then, when calling the \nwith\n method, pass an array of data that you wish to make available to the template:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nMail\n;\n\n\n\nuse\n \nApp\n\\\nOrder\n;\n\n\nuse\n \nIlluminate\n\\\nBus\n\\\nQueueable\n;\n\n\nuse\n \nIlluminate\n\\\nMail\n\\\nMailable\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nSerializesModels\n;\n\n\n\nclass\n \nOrderShipped\n \nextends\n \nMailable\n\n\n{\n\n    \nuse\n \nQueueable\n,\n \nSerializesModels\n;\n\n\n    \n/**\n\n\n     * The order instance.\n\n\n     *\n\n\n     * @var Order\n\n\n     */\n\n    \nprotected\n \n$order\n;\n\n\n    \n/**\n\n\n     * Create a new message instance.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nOrder\n \n$order\n)\n\n    \n{\n\n        \n$this\n-\norder\n \n=\n \n$order\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Build the message.\n\n\n     *\n\n\n     * @return $this\n\n\n     */\n\n    \npublic\n \nfunction\n \nbuild\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nview\n(\nemails.orders.shipped\n)\n\n                    \n-\nwith\n([\n\n                        \norderName\n \n=\n \n$this\n-\norder\n-\nname\n,\n\n                        \norderPrice\n \n=\n \n$this\n-\norder\n-\nprice\n,\n\n                    \n]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOnce the data has been passed to the \nwith\n method, it will automatically be available in your view, so you may access it like you would access any other data in your Blade templates:\n\n\ndiv\n\n    Price: \n{{\n \n$\norderPrice\n \n}}\n\n\n/div\n\n\n\n\n\n\n\n\nAttachments\n\n\nTo add attachments to an email, use the \nattach\n method within the mailable class' \nbuild\n method. The \nattach\n method accepts the full path to the file as its first argument:\n\n\n    /**\n     * Build the message.\n     *\n     * @return $this\n     */\n    public function build()\n    {\n        return $this-\nview(\nemails.orders.shipped\n)\n                    -\nattach(\n/path/to/file\n);\n    }\n\n\n\n\n\nWhen attaching files to a message, you may also specify the display name and / or MIME type by passing an \narray\n as the second argument to the \nattach\n method:\n\n\n    /**\n     * Build the message.\n     *\n     * @return $this\n     */\n    public function build()\n    {\n        return $this-\nview(\nemails.orders.shipped\n)\n                    -\nattach(\n/path/to/file\n, [\n                        \nas\n =\n \nname.pdf\n,\n                        \nmime\n =\n \napplication/pdf\n,\n                    ]);\n    }\n\n\n\n\n\nRaw Data Attachments\n\n\nThe \nattachData\n method may be used to attach a raw string of bytes as an attachment. For example, you might use this method if you have generated a PDF in memory and want to attach it to the email without writing it to disk. The \nattachData\n method accepts the raw data bytes as its first argument, the name of the file as its second argument, and an array of options as its third argument:\n\n\n    /**\n     * Build the message.\n     *\n     * @return $this\n     */\n    public function build()\n    {\n        return $this-\nview(\nemails.orders.shipped\n)\n                    -\nattachData($this-\npdf, \nname.pdf\n, [\n                        \nmime\n =\n \napplication/pdf\n,\n                    ]);\n    }\n\n\n\n\n\n\n\nInline Attachments\n\n\nEmbedding inline images into your emails is typically cumbersome; however, Laravel provides a convenient way to attach images to your emails and retrieving the appropriate CID. To embed an inline image, use the \nembed\n method on the \n$message\n variable within your email template. Laravel automatically makes the \n$message\n variable available to all of your email templates, so you don't need to worry about passing it in manually:\n\n\nbody\n\n    Here is an image:\n\n    \nimg\n \nsrc=\n{{\n \n$\nmessage-\nembed\n(\n$\npathToFile\n)\n \n}}\n\n\n/body\n\n\n\n\n\n\nEmbedding Raw Data Attachments\n\n\nIf you already have a raw data string you wish to embed into an email template, you may use the \nembedData\n method on the \n$message\n variable:\n\n\nbody\n\n    Here is an image from raw data:\n\n    \nimg\n \nsrc=\n{{\n \n$\nmessage-\nembedData\n(\n$\ndata\n,\n \n$\nname\n)\n \n}}\n\n\n/body\n\n\n\n\n\n\n\n\nMarkdown Mailables\n\n\nMarkdown mailable messages allow you to take advantage of the pre-built templates and components of mail notifications in your mailables. Since the messages are written in Markdown, Laravel is able to render beautiful, responsive HTML templates for the messages while also automatically generating a plain-text counterpart.\n\n\n\n\nGenerating Markdown Mailables\n\n\nTo generate a mailable with a corresponding Markdown template, you may use the \n--markdown\n option of the \nmake:mail\n Artisan command:\n\n\nphp artisan make:mail OrderShipped --markdown=emails.orders.shipped\n\n\n\n\n\nThen, when configuring the mailable within its \nbuild\n method, call the \nmarkdown\n method instead of the \nview\n method. The \nmarkdown\n methods accepts the name of the Markdown template and an optional array of data to make available to the template:\n\n\n/**\n\n\n * Build the message.\n\n\n *\n\n\n * @return $this\n\n\n */\n\npublic\n \nfunction\n \nbuild\n()\n\n\n{\n\n\n    \nreturn\n \n$\nthis\n-\nfrom\n(\nexample@example.com\n)\n\n\n                \n-\nmarkdown\n(\nemails.orders.shipped\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nWriting Markdown Messages\n\n\nMarkdown mailables use a combination of Blade components and Markdown syntax which allow you to easily construct mail messages while leveraging Laravel's pre-crafted components:\n\n\n@\ncomponent\n(\nmail\n::\nmessage\n)\n\n\n# Order Shipped\n\n\n\nYour\n \norder\n \nhas\n \nbeen\n \nshipped\n!\n\n\n\n@\ncomponent\n(\nmail\n::\nbutton\n,\n \n[\nurl\n \n=\n \n$\nurl\n])\n\n\nView\n \nOrder\n\n\n@\nendcomponent\n\n\n\nThanks\n,\nbr\n\n\n{{\n \nconfig\n(\napp\n.\nname\n)\n \n}}\n\n\n@\nendcomponent\n\n\n\n\n\n\nButton Component\n\n\nThe button component renders a centered button link. The component accepts two arguments, a \nurl\n and an optional \ncolor\n. Supported colors are \nblue\n, \ngreen\n, and \nred\n. You may add as many button components to a message as you wish:\n\n\n@\ncomponent\n(\nmail\n::\nbutton\n,\n \n[\nurl\n \n=\n \n$\nurl\n,\n \ncolor\n \n=\n \ngreen\n])\n\n\nView\n \nOrder\n\n\n@\nendcomponent\n\n\n\n\n\n\nPanel Component\n\n\nThe panel component renders the given block of text in a panel that has a slightly different background color than the rest of the message. This allows you to draw attention to a given block of text:\n\n\n@\ncomponent\n(\nmail\n::\npanel\n)\n\n\nThis\n \nis\n \nthe\n \npanel\n \ncontent\n.\n\n\n@\nendcomponent\n\n\n\n\n\n\nTable Component\n\n\nThe table component allows you to transform a Markdown table into an HTML table. The component accepts the Markdown table as its content. Table column alignment is supported using the default Markdown table alignment syntax:\n\n\n@\ncomponent\n(\nmail\n::\ntable\n)\n\n\n|\n \nLaravel\n       \n|\n \nTable\n         \n|\n \nExample\n  \n|\n\n\n|\n \n-------------\n \n|:-------------:|\n \n--------:|\n\n\n|\n \nCol\n \n2\n \nis\n      \n|\n \nCentered\n      \n|\n \n$\n10\n      \n|\n\n\n|\n \nCol\n \n3\n \nis\n      \n|\n \nRight\n-\nAligned\n \n|\n \n$\n20\n      \n|\n\n\n@\nendcomponent\n\n\n\n\n\n\n\n\nCustomizing The Components\n\n\nYou may export all of the Markdown mail components to your own application for customization. To export the components, use the \nvendor:publish\n Artisan command to publish the \nlaravel-mail\n asset tag:\n\n\nphp artisan vendor:publish --tag=laravel-mail\n\n\n\n\n\nThis command will publish the Markdown mail components to the \nresources/views/vendor/mail\n directory. The \nmail\n directory will contain a \nhtml\n and a \nmarkdown\n directory, each containing their respective representations of every available component. You are free to customize these components however you like.\n\n\nCustomizing The CSS\n\n\nAfter exporting the components, the \nresources/views/vendor/mail/html/themes\n directory will contain a \ndefault.css\n file. You may customize the CSS in this file and your styles will automatically be in-lined within the HTML representations of your Markdown mail messages.\n\n\n\n\n{tip} If you would like to build an entirely new theme for the Markdown components, simply write a new CSS file within the \nhtml/themes\n directory and change the \ntheme\n option of your \nmail\n configuration file.\n\n\n\n\n\n\nSending Mail\n\n\nTo send a message, use the \nto\n method on the \nMail\n \nfacade\n. The \nto\n method accepts an email address, a user instance, or a collection of users. If you pass an object or collection of objects, the mailer will automatically use their \nemail\n and \nname\n properties when setting the email recipients, so make sure these attributes are available on your objects. Once you have specified your recipients, you may pass an instance of your mailable class to the \nsend\n method:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nOrder\n;\n\n\nuse\n \nApp\n\\\nMail\n\\\nOrderShipped\n;\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nMail\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nOrderController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Ship the given order.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @param  int  $orderId\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nship\n(\nRequest\n \n$request\n,\n \n$orderId\n)\n\n    \n{\n\n        \n$order\n \n=\n \nOrder\n::\nfindOrFail\n(\n$orderId\n);\n\n\n        \n// Ship order...\n\n\n        \nMail\n::\nto\n(\n$request\n-\nuser\n())\n-\nsend\n(\nnew\n \nOrderShipped\n(\n$order\n));\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOf course, you are not limited to just specifying the \"to\" recipients when sending a message. You are free to set \"to\", \"cc\", and \"bcc\" recipients all within a single, chained method call:\n\n\nMail::to($request-\nuser())\n    -\ncc($moreUsers)\n    -\nbcc($evenMoreUsers)\n    -\nsend(new OrderShipped($order));\n\n\n\n\n\n\n\nQueueing Mail\n\n\nQueueing A Mail Message\n\n\nSince sending email messages can drastically lengthen the response time of your application, many developers choose to queue email messages for background sending. Laravel makes this easy using its built-in \nunified queue API\n. To queue a mail message, use the \nqueue\n method on the \nMail\n facade after specifying the message's recipients:\n\n\nMail::to($request-\nuser())\n    -\ncc($moreUsers)\n    -\nbcc($evenMoreUsers)\n    -\nqueue(new OrderShipped($order));\n\n\n\n\n\nThis method will automatically take care of pushing a job onto the queue so the message is sent in the background. Of course, you will need to \nconfigure your queues\n before using this feature.\n\n\nDelayed Message Queueing\n\n\nIf you wish to delay the delivery of a queued email message, you may use the \nlater\n method. As its first argument, the \nlater\n method accepts a \nDateTime\n instance indicating when the message should be sent:\n\n\n$\nwhen\n \n=\n \nCarbon\n\\\nCarbon\n::\nnow\n()\n-\naddMinutes\n(\n10\n);\n\n\n\nMail\n::\nto\n($\nrequest-\nuser\n())\n\n    \n-\ncc\n($\nmoreUsers\n)\n\n    \n-\nbcc\n($\nevenMoreUsers\n)\n\n    \n-\nlater\n($\nwhen\n,\n \nnew\n \nOrderShipped\n($\norder\n));\n\n\n\n\n\n\nPushing To Specific Queues\n\n\nSince all mailable classes generated using the \nmake:mail\n command make use of the \nIlluminate\\Bus\\Queueable\n trait, you may call the \nonQueue\n and \nonConnection\n methods on any mailable class instance, allowing you to specify the connection and queue name for the message:\n\n\n$message = (new OrderShipped($order))\n                -\nonConnection(\nsqs\n)\n                -\nonQueue(\nemails\n);\n\nMail::to($request-\nuser())\n    -\ncc($moreUsers)\n    -\nbcc($evenMoreUsers)\n    -\nqueue($message);\n\n\n\n\n\nQueueing By Default\n\n\nIf you have mailable classes that you want to always be queued, you may implement the \nShouldQueue\n contract on the class. Now, even if you call the \nsend\n method when mailing, the mailable will still be queued since it implements the contract:\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nQueue\n\\\nShouldQueue\n;\n\n\n\nclass\n \nOrderShipped\n \nextends\n \nMailable\n \nimplements\n \nShouldQueue\n\n\n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\n\n\nMail \n Local Development\n\n\nWhen developing an application that sends email, you probably don't want to actually send emails to live email addresses. Laravel provides several ways to \"disable\" the actual sending of emails during local development.\n\n\nLog Driver\n\n\nInstead of sending your emails, the \nlog\n mail driver will write all email messages to your log files for inspection. For more information on configuring your application per environment, check out the \nconfiguration documentation\n.\n\n\nUniversal To\n\n\nAnother solution provided by Laravel is to set a universal recipient of all emails sent by the framework. This way, all the emails generated by your application will be sent to a specific address, instead of the address actually specified when sending the message. This can be done via the \nto\n option in your \nconfig/mail.php\n configuration file:\n\n\nto\n =\n [\n    \naddress\n =\n \nexample@example.com\n,\n    \nname\n =\n \nExample\n\n],\n\n\n\n\n\nMailtrap\n\n\nFinally, you may use a service like \nMailtrap\n and the \nsmtp\n driver to send your email messages to a \"dummy\" mailbox where you may view them in a true email client. This approach has the benefit of allowing you to actually inspect the final emails in Mailtrap's message viewer.\n\n\n\n\nEvents\n\n\nLaravel fires an event just before sending mail messages. Remember, this event is fired when the mail is \nsent\n, not when it is queued. You may register an event listener for this event in your \nEventServiceProvider\n:\n\n\n/**\n\n\n * The event listener mappings for the application.\n\n\n *\n\n\n * @var array\n\n\n */\n\nprotected\n \n$\nlisten\n \n=\n \n[\n\n\n    \nIlluminate\\Mail\\Events\\MessageSending\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogSentMessage\n,\n\n\n    \n]\n,\n\n\n];", 
            "title": "Mail"
        }, 
        {
            "location": "/mail/#mail", 
            "text": "Introduction  Driver Prerequisites    Generating Mailables  Writing Mailables  Configuring The Sender  Configuring The View  View Data  Attachments  Inline Attachments    Markdown Mailables  Generating Markdown Mailables  Writing Markdown Messages  Customizing The Components    Sending Mail  Queueing Mail    Mail   Local Development  Events", 
            "title": "Mail"
        }, 
        {
            "location": "/mail/#introduction", 
            "text": "Laravel provides a clean, simple API over the popular  SwiftMailer  library with drivers for SMTP, Mailgun, SparkPost, Amazon SES, PHP's  mail  function, and  sendmail , allowing you to quickly get started sending mail through a local or cloud based service of your choice.", 
            "title": "Introduction"
        }, 
        {
            "location": "/mail/#driver-prerequisites", 
            "text": "The API based drivers such as Mailgun and SparkPost are often simpler and faster than SMTP servers. If possible, you should use one of these drivers. All of the API drivers require the Guzzle HTTP library, which may be installed via the Composer package manager:  composer require guzzlehttp/guzzle", 
            "title": "Driver Prerequisites"
        }, 
        {
            "location": "/mail/#mailgun-driver", 
            "text": "To use the Mailgun driver, first install Guzzle, then set the  driver  option in your  config/mail.php  configuration file to  mailgun . Next, verify that your  config/services.php  configuration file contains the following options:  mailgun  =  [\n     domain  =   your-mailgun-domain ,\n     secret  =   your-mailgun-key ,\n],", 
            "title": "Mailgun Driver"
        }, 
        {
            "location": "/mail/#sparkpost-driver", 
            "text": "To use the SparkPost driver, first install Guzzle, then set the  driver  option in your  config/mail.php  configuration file to  sparkpost . Next, verify that your  config/services.php  configuration file contains the following options:  sparkpost  =  [\n     secret  =   your-sparkpost-key ,\n],", 
            "title": "SparkPost Driver"
        }, 
        {
            "location": "/mail/#ses-driver", 
            "text": "To use the Amazon SES driver you must first install the Amazon AWS SDK for PHP. You may install this library by adding the following line to your  composer.json  file's  require  section and running the  composer update  command:  aws/aws-sdk-php :  ~3.0   Next, set the  driver  option in your  config/mail.php  configuration file to  ses  and verify that your  config/services.php  configuration file contains the following options:  ses  =  [\n     key  =   your-ses-key ,\n     secret  =   your-ses-secret ,\n     region  =   ses-region ,  // e.g. us-east-1\n],", 
            "title": "SES Driver"
        }, 
        {
            "location": "/mail/#generating-mailables", 
            "text": "In Laravel, each type of email sent by your application is represented as a \"mailable\" class. These classes are stored in the  app/Mail  directory. Don't worry if you don't see this directory in your application, since it will be generated for you when you create your first mailable class using the  make:mail  command:  php artisan make:mail OrderShipped", 
            "title": "Generating Mailables"
        }, 
        {
            "location": "/mail/#writing-mailables", 
            "text": "All of a mailable class' configuration is done in the  build  method. Within this method, you may call various methods such as  from ,  subject ,  view , and  attach  to configure the email's presentation and delivery.", 
            "title": "Writing Mailables"
        }, 
        {
            "location": "/mail/#configuring-the-sender", 
            "text": "", 
            "title": "Configuring The Sender"
        }, 
        {
            "location": "/mail/#using-the-from-method", 
            "text": "First, let's explore configuring the sender of the email. Or, in other words, who the email is going to be \"from\". There are two ways to configure the sender. First, you may use the  from  method within your mailable class'  build  method:  /**   * Build the message.   *   * @return $this   */ \npublic   function   build ()  {       return   $ this - from ( example@example.com )                   - view ( emails.orders.shipped ) ;  }", 
            "title": "Using The from Method"
        }, 
        {
            "location": "/mail/#using-a-global-from-address", 
            "text": "However, if your application uses the same \"from\" address for all of its emails, it can become cumbersome to call the  from  method in each mailable class you generate. Instead, you may specify a global \"from\" address in your  config/mail.php  configuration file. This address will be used if no other \"from\" address is specified within the mailable class:  from  =  [ address  =   example@example.com ,  name  =   App Name ],", 
            "title": "Using A Global from Address"
        }, 
        {
            "location": "/mail/#configuring-the-view", 
            "text": "Within a mailable class'  build  method, you may use the  view  method to specify which template should be used when rendering the email's contents. Since each email typically uses a  Blade template  to render its contents, you have the full power and convenience of the Blade templating engine when building your email's HTML:  /**   * Build the message.   *   * @return $this   */ \npublic   function   build ()  {       return   $ this - view ( emails.orders.shipped ) ;  }    {tip} You may wish to create a  resources/views/emails  directory to house all of your email templates; however, you are free to place them wherever you wish within your  resources/views  directory.", 
            "title": "Configuring The View"
        }, 
        {
            "location": "/mail/#plain-text-emails", 
            "text": "If you would like to define a plain-text version of your email, you may use the  text  method. Like the  view  method, the  text  method accepts a template name which will be used to render the contents of the email. You are free to define both a HTML and plain-text version of your message:  /**   * Build the message.   *   * @return $this   */ \npublic   function   build ()  {       return   $ this - view ( emails.orders.shipped )                   - text ( emails.orders.shipped_plain ) ;  }", 
            "title": "Plain Text Emails"
        }, 
        {
            "location": "/mail/#view-data", 
            "text": "", 
            "title": "View Data"
        }, 
        {
            "location": "/mail/#via-public-properties", 
            "text": "Typically, you will want to pass some data to your view that you can utilize when rendering the email's HTML. There are two ways you may make data available to your view. First, any public property defined on your mailable class will automatically be made available to the view. So, for example, you may pass data into your mailable class' constructor and set that data to public properties defined on the class:  ? php  namespace   App \\ Mail ;  use   App \\ Order ;  use   Illuminate \\ Bus \\ Queueable ;  use   Illuminate \\ Mail \\ Mailable ;  use   Illuminate \\ Queue \\ SerializesModels ;  class   OrderShipped   extends   Mailable  { \n     use   Queueable ,   SerializesModels ; \n\n     /**       * The order instance.       *       * @var Order       */ \n     public   $order ; \n\n     /**       * Create a new message instance.       *       * @return void       */ \n     public   function   __construct ( Order   $order ) \n     { \n         $this - order   =   $order ; \n     } \n\n     /**       * Build the message.       *       * @return $this       */ \n     public   function   build () \n     { \n         return   $this - view ( emails.orders.shipped ); \n     }  }   Once the data has been set to a public property, it will automatically be available in your view, so you may access it like you would access any other data in your Blade templates:  div \n    Price:  {{   $ order- price   }}  /div", 
            "title": "Via Public Properties"
        }, 
        {
            "location": "/mail/#via-the-with-method", 
            "text": "If you would like to customize the format of your email's data before it is sent to the template, you may manually pass your data to the view via the  with  method. Typically, you will still pass data via the mailable class' constructor; however, you should set this data to  protected  or  private  properties so the data is not automatically made available to the template. Then, when calling the  with  method, pass an array of data that you wish to make available to the template:  ? php  namespace   App \\ Mail ;  use   App \\ Order ;  use   Illuminate \\ Bus \\ Queueable ;  use   Illuminate \\ Mail \\ Mailable ;  use   Illuminate \\ Queue \\ SerializesModels ;  class   OrderShipped   extends   Mailable  { \n     use   Queueable ,   SerializesModels ; \n\n     /**       * The order instance.       *       * @var Order       */ \n     protected   $order ; \n\n     /**       * Create a new message instance.       *       * @return void       */ \n     public   function   __construct ( Order   $order ) \n     { \n         $this - order   =   $order ; \n     } \n\n     /**       * Build the message.       *       * @return $this       */ \n     public   function   build () \n     { \n         return   $this - view ( emails.orders.shipped ) \n                     - with ([ \n                         orderName   =   $this - order - name , \n                         orderPrice   =   $this - order - price , \n                     ]); \n     }  }   Once the data has been passed to the  with  method, it will automatically be available in your view, so you may access it like you would access any other data in your Blade templates:  div \n    Price:  {{   $ orderPrice   }}  /div", 
            "title": "Via The with Method:"
        }, 
        {
            "location": "/mail/#attachments", 
            "text": "To add attachments to an email, use the  attach  method within the mailable class'  build  method. The  attach  method accepts the full path to the file as its first argument:      /**\n     * Build the message.\n     *\n     * @return $this\n     */\n    public function build()\n    {\n        return $this- view( emails.orders.shipped )\n                    - attach( /path/to/file );\n    }  When attaching files to a message, you may also specify the display name and / or MIME type by passing an  array  as the second argument to the  attach  method:      /**\n     * Build the message.\n     *\n     * @return $this\n     */\n    public function build()\n    {\n        return $this- view( emails.orders.shipped )\n                    - attach( /path/to/file , [\n                         as  =   name.pdf ,\n                         mime  =   application/pdf ,\n                    ]);\n    }", 
            "title": "Attachments"
        }, 
        {
            "location": "/mail/#raw-data-attachments", 
            "text": "The  attachData  method may be used to attach a raw string of bytes as an attachment. For example, you might use this method if you have generated a PDF in memory and want to attach it to the email without writing it to disk. The  attachData  method accepts the raw data bytes as its first argument, the name of the file as its second argument, and an array of options as its third argument:      /**\n     * Build the message.\n     *\n     * @return $this\n     */\n    public function build()\n    {\n        return $this- view( emails.orders.shipped )\n                    - attachData($this- pdf,  name.pdf , [\n                         mime  =   application/pdf ,\n                    ]);\n    }", 
            "title": "Raw Data Attachments"
        }, 
        {
            "location": "/mail/#inline-attachments", 
            "text": "Embedding inline images into your emails is typically cumbersome; however, Laravel provides a convenient way to attach images to your emails and retrieving the appropriate CID. To embed an inline image, use the  embed  method on the  $message  variable within your email template. Laravel automatically makes the  $message  variable available to all of your email templates, so you don't need to worry about passing it in manually:  body \n    Here is an image:\n\n     img   src= {{   $ message- embed ( $ pathToFile )   }}  /body", 
            "title": "Inline Attachments"
        }, 
        {
            "location": "/mail/#embedding-raw-data-attachments", 
            "text": "If you already have a raw data string you wish to embed into an email template, you may use the  embedData  method on the  $message  variable:  body \n    Here is an image from raw data:\n\n     img   src= {{   $ message- embedData ( $ data ,   $ name )   }}  /body", 
            "title": "Embedding Raw Data Attachments"
        }, 
        {
            "location": "/mail/#markdown-mailables", 
            "text": "Markdown mailable messages allow you to take advantage of the pre-built templates and components of mail notifications in your mailables. Since the messages are written in Markdown, Laravel is able to render beautiful, responsive HTML templates for the messages while also automatically generating a plain-text counterpart.", 
            "title": "Markdown Mailables"
        }, 
        {
            "location": "/mail/#generating-markdown-mailables", 
            "text": "To generate a mailable with a corresponding Markdown template, you may use the  --markdown  option of the  make:mail  Artisan command:  php artisan make:mail OrderShipped --markdown=emails.orders.shipped  Then, when configuring the mailable within its  build  method, call the  markdown  method instead of the  view  method. The  markdown  methods accepts the name of the Markdown template and an optional array of data to make available to the template:  /**   * Build the message.   *   * @return $this   */ \npublic   function   build ()  {       return   $ this - from ( example@example.com )                   - markdown ( emails.orders.shipped ) ;  }", 
            "title": "Generating Markdown Mailables"
        }, 
        {
            "location": "/mail/#writing-markdown-messages", 
            "text": "Markdown mailables use a combination of Blade components and Markdown syntax which allow you to easily construct mail messages while leveraging Laravel's pre-crafted components:  @ component ( mail :: message )  # Order Shipped  Your   order   has   been   shipped !  @ component ( mail :: button ,   [ url   =   $ url ])  View   Order  @ endcomponent  Thanks , br  {{   config ( app . name )   }}  @ endcomponent", 
            "title": "Writing Markdown Messages"
        }, 
        {
            "location": "/mail/#button-component", 
            "text": "The button component renders a centered button link. The component accepts two arguments, a  url  and an optional  color . Supported colors are  blue ,  green , and  red . You may add as many button components to a message as you wish:  @ component ( mail :: button ,   [ url   =   $ url ,   color   =   green ])  View   Order  @ endcomponent", 
            "title": "Button Component"
        }, 
        {
            "location": "/mail/#panel-component", 
            "text": "The panel component renders the given block of text in a panel that has a slightly different background color than the rest of the message. This allows you to draw attention to a given block of text:  @ component ( mail :: panel )  This   is   the   panel   content .  @ endcomponent", 
            "title": "Panel Component"
        }, 
        {
            "location": "/mail/#table-component", 
            "text": "The table component allows you to transform a Markdown table into an HTML table. The component accepts the Markdown table as its content. Table column alignment is supported using the default Markdown table alignment syntax:  @ component ( mail :: table )  |   Laravel         |   Table           |   Example    |  |   -------------   |:-------------:|   --------:|  |   Col   2   is        |   Centered        |   $ 10        |  |   Col   3   is        |   Right - Aligned   |   $ 20        |  @ endcomponent", 
            "title": "Table Component"
        }, 
        {
            "location": "/mail/#customizing-the-components", 
            "text": "You may export all of the Markdown mail components to your own application for customization. To export the components, use the  vendor:publish  Artisan command to publish the  laravel-mail  asset tag:  php artisan vendor:publish --tag=laravel-mail  This command will publish the Markdown mail components to the  resources/views/vendor/mail  directory. The  mail  directory will contain a  html  and a  markdown  directory, each containing their respective representations of every available component. You are free to customize these components however you like.", 
            "title": "Customizing The Components"
        }, 
        {
            "location": "/mail/#customizing-the-css", 
            "text": "After exporting the components, the  resources/views/vendor/mail/html/themes  directory will contain a  default.css  file. You may customize the CSS in this file and your styles will automatically be in-lined within the HTML representations of your Markdown mail messages.   {tip} If you would like to build an entirely new theme for the Markdown components, simply write a new CSS file within the  html/themes  directory and change the  theme  option of your  mail  configuration file.", 
            "title": "Customizing The CSS"
        }, 
        {
            "location": "/mail/#sending-mail", 
            "text": "To send a message, use the  to  method on the  Mail   facade . The  to  method accepts an email address, a user instance, or a collection of users. If you pass an object or collection of objects, the mailer will automatically use their  email  and  name  properties when setting the email recipients, so make sure these attributes are available on your objects. Once you have specified your recipients, you may pass an instance of your mailable class to the  send  method:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ Order ;  use   App \\ Mail \\ OrderShipped ;  use   Illuminate \\ Http \\ Request ;  use   Illuminate \\ Support \\ Facades \\ Mail ;  use   App \\ Http \\ Controllers \\ Controller ;  class   OrderController   extends   Controller  { \n     /**       * Ship the given order.       *       * @param  Request  $request       * @param  int  $orderId       * @return Response       */ \n     public   function   ship ( Request   $request ,   $orderId ) \n     { \n         $order   =   Order :: findOrFail ( $orderId ); \n\n         // Ship order... \n\n         Mail :: to ( $request - user ()) - send ( new   OrderShipped ( $order )); \n     }  }   Of course, you are not limited to just specifying the \"to\" recipients when sending a message. You are free to set \"to\", \"cc\", and \"bcc\" recipients all within a single, chained method call:  Mail::to($request- user())\n    - cc($moreUsers)\n    - bcc($evenMoreUsers)\n    - send(new OrderShipped($order));", 
            "title": "Sending Mail"
        }, 
        {
            "location": "/mail/#queueing-mail", 
            "text": "", 
            "title": "Queueing Mail"
        }, 
        {
            "location": "/mail/#queueing-a-mail-message", 
            "text": "Since sending email messages can drastically lengthen the response time of your application, many developers choose to queue email messages for background sending. Laravel makes this easy using its built-in  unified queue API . To queue a mail message, use the  queue  method on the  Mail  facade after specifying the message's recipients:  Mail::to($request- user())\n    - cc($moreUsers)\n    - bcc($evenMoreUsers)\n    - queue(new OrderShipped($order));  This method will automatically take care of pushing a job onto the queue so the message is sent in the background. Of course, you will need to  configure your queues  before using this feature.", 
            "title": "Queueing A Mail Message"
        }, 
        {
            "location": "/mail/#delayed-message-queueing", 
            "text": "If you wish to delay the delivery of a queued email message, you may use the  later  method. As its first argument, the  later  method accepts a  DateTime  instance indicating when the message should be sent:  $ when   =   Carbon \\ Carbon :: now () - addMinutes ( 10 );  Mail :: to ($ request- user ()) \n     - cc ($ moreUsers ) \n     - bcc ($ evenMoreUsers ) \n     - later ($ when ,   new   OrderShipped ($ order ));", 
            "title": "Delayed Message Queueing"
        }, 
        {
            "location": "/mail/#pushing-to-specific-queues", 
            "text": "Since all mailable classes generated using the  make:mail  command make use of the  Illuminate\\Bus\\Queueable  trait, you may call the  onQueue  and  onConnection  methods on any mailable class instance, allowing you to specify the connection and queue name for the message:  $message = (new OrderShipped($order))\n                - onConnection( sqs )\n                - onQueue( emails );\n\nMail::to($request- user())\n    - cc($moreUsers)\n    - bcc($evenMoreUsers)\n    - queue($message);", 
            "title": "Pushing To Specific Queues"
        }, 
        {
            "location": "/mail/#queueing-by-default", 
            "text": "If you have mailable classes that you want to always be queued, you may implement the  ShouldQueue  contract on the class. Now, even if you call the  send  method when mailing, the mailable will still be queued since it implements the contract:  use   Illuminate \\ Contracts \\ Queue \\ ShouldQueue ;  class   OrderShipped   extends   Mailable   implements   ShouldQueue  { \n     //  }", 
            "title": "Queueing By Default"
        }, 
        {
            "location": "/mail/#mail-local-development", 
            "text": "When developing an application that sends email, you probably don't want to actually send emails to live email addresses. Laravel provides several ways to \"disable\" the actual sending of emails during local development.", 
            "title": "Mail &amp; Local Development"
        }, 
        {
            "location": "/mail/#log-driver", 
            "text": "Instead of sending your emails, the  log  mail driver will write all email messages to your log files for inspection. For more information on configuring your application per environment, check out the  configuration documentation .", 
            "title": "Log Driver"
        }, 
        {
            "location": "/mail/#universal-to", 
            "text": "Another solution provided by Laravel is to set a universal recipient of all emails sent by the framework. This way, all the emails generated by your application will be sent to a specific address, instead of the address actually specified when sending the message. This can be done via the  to  option in your  config/mail.php  configuration file:  to  =  [\n     address  =   example@example.com ,\n     name  =   Example \n],", 
            "title": "Universal To"
        }, 
        {
            "location": "/mail/#mailtrap", 
            "text": "Finally, you may use a service like  Mailtrap  and the  smtp  driver to send your email messages to a \"dummy\" mailbox where you may view them in a true email client. This approach has the benefit of allowing you to actually inspect the final emails in Mailtrap's message viewer.", 
            "title": "Mailtrap"
        }, 
        {
            "location": "/mail/#events", 
            "text": "Laravel fires an event just before sending mail messages. Remember, this event is fired when the mail is  sent , not when it is queued. You may register an event listener for this event in your  EventServiceProvider :  /**   * The event listener mappings for the application.   *   * @var array   */ \nprotected   $ listen   =   [       Illuminate\\Mail\\Events\\MessageSending   =   [           App\\Listeners\\LogSentMessage ,       ] ,  ];", 
            "title": "Events"
        }, 
        {
            "location": "/middleware/", 
            "text": "Middleware\n\n\n\n\nIntroduction\n\n\nDefining Middleware\n\n\nRegistering Middleware\n\n\nGlobal Middleware\n\n\nAssigning Middleware To Routes\n\n\nMiddleware Groups\n\n\n\n\n\n\nMiddleware Parameters\n\n\nTerminable Middleware\n\n\n\n\n\n\nIntroduction\n\n\nMiddleware provide a convenient mechanism for filtering HTTP requests entering your application. For example, Laravel includes a middleware that verifies the user of your application is authenticated. If the user is not authenticated, the middleware will redirect the user to the login screen. However, if the user is authenticated, the middleware will allow the request to proceed further into the application.\n\n\nOf course, additional middleware can be written to perform a variety of tasks besides authentication. A CORS middleware might be responsible for adding the proper headers to all responses leaving your application. A logging middleware might log all incoming requests to your application.\n\n\nThere are several middleware included in the Laravel framework, including middleware for authentication and CSRF protection. All of these middleware are located in the \napp/Http/Middleware\n directory.\n\n\n\n\nDefining Middleware\n\n\nTo create a new middleware, use the \nmake:middleware\n Artisan command:\n\n\nphp artisan make:middleware CheckAge\n\n\n\n\n\nThis command will place a new \nCheckAge\n class within your \napp/Http/Middleware\n directory. In this middleware, we will only allow access to the route if the supplied \nage\n is greater than 200. Otherwise, we will redirect the users back to the \nhome\n URI.\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nMiddleware\n;\n\n\n\nuse\n \nClosure\n;\n\n\n\nclass\n \nCheckAge\n\n\n{\n\n    \n/**\n\n\n     * Handle an incoming request.\n\n\n     *\n\n\n     * @param  \\Illuminate\\Http\\Request  $request\n\n\n     * @param  \\Closure  $next\n\n\n     * @return mixed\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandle\n(\n$request\n,\n \nClosure\n \n$next\n)\n\n    \n{\n\n        \nif\n \n(\n$request\n-\nage\n \n=\n \n200\n)\n \n{\n\n            \nreturn\n \nredirect\n(\nhome\n);\n\n        \n}\n\n\n        \nreturn\n \n$next\n(\n$request\n);\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\nAs you can see, if the given \nage\n is less than or equal to \n200\n, the middleware will return an HTTP redirect to the client; otherwise, the request will be passed further into the application. To pass the request deeper into the application (allowing the middleware to \"pass\"), simply call the \n$next\n callback with the \n$request\n.\n\n\nIt's best to envision middleware as a series of \"layers\" HTTP requests must pass through before they hit your application. Each layer can examine the request and even reject it entirely.\n\n\nBefore \n After Middleware\n\n\nWhether a middleware runs before or after a request depends on the middleware itself. For example, the following middleware would perform some task \nbefore\n the request is handled by the application:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nMiddleware\n;\n\n\n\nuse\n \nClosure\n;\n\n\n\nclass\n \nBeforeMiddleware\n\n\n{\n\n    \npublic\n \nfunction\n \nhandle\n(\n$request\n,\n \nClosure\n \n$next\n)\n\n    \n{\n\n        \n// Perform action\n\n\n        \nreturn\n \n$next\n(\n$request\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nHowever, this middleware would perform its task \nafter\n the request is handled by the application:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nMiddleware\n;\n\n\n\nuse\n \nClosure\n;\n\n\n\nclass\n \nAfterMiddleware\n\n\n{\n\n    \npublic\n \nfunction\n \nhandle\n(\n$request\n,\n \nClosure\n \n$next\n)\n\n    \n{\n\n        \n$response\n \n=\n \n$next\n(\n$request\n);\n\n\n        \n// Perform action\n\n\n        \nreturn\n \n$response\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nRegistering Middleware\n\n\n\n\nGlobal Middleware\n\n\nIf you want a middleware to run during every HTTP request to your application, simply list the middleware class in the \n$middleware\n property of your \napp/Http/Kernel.php\n class.\n\n\n\n\nAssigning Middleware To Routes\n\n\nIf you would like to assign middleware to specific routes, you should first assign the middleware a key in your \napp/Http/Kernel.php\n file. By default, the \n$routeMiddleware\n property of this class contains entries for the middleware included with Laravel. To add your own, simply append it to this list and assign it a key of your choosing. For example:\n\n\n// Within App\\Http\\Kernel Class...\n\nprotected $routeMiddleware = [\n    \nauth\n =\n \\Illuminate\\Auth\\Middleware\\Authenticate::class,\n    \nauth.basic\n =\n \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class,\n    \nbindings\n =\n \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\n    \ncan\n =\n \\Illuminate\\Auth\\Middleware\\Authorize::class,\n    \nguest\n =\n \\App\\Http\\Middleware\\RedirectIfAuthenticated::class,\n    \nthrottle\n =\n \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,\n];\n\n\n\n\n\nOnce the middleware has been defined in the HTTP kernel, you may use the \nmiddleware\n method to assign middleware to a route:\n\n\nRoute::get(\nadmin/profile\n, function () {\n    //\n})-\nmiddleware(\nauth\n);\n\n\n\n\n\nYou may also assign multiple middleware to the route:\n\n\nRoute::get(\n/\n, function () {\n    //\n})-\nmiddleware(\nfirst\n, \nsecond\n);\n\n\n\n\n\nWhen assigning middleware, you may also pass the fully qualified class name:\n\n\nuse\n \nApp\n\\\nHttp\n\\\nMiddleware\n\\\nCheckAge\n;\n\n\n\nRoute\n::\nget\n(\nadmin/profile\n,\n \nfunction\n \n()\n \n{\n\n    \n//\n\n\n}\n)\n-\nmiddleware\n(\nCheckAge\n::\nclass\n);\n\n\n\n\n\n\n\n\nMiddleware Groups\n\n\nSometimes you may want to group several middleware under a single key to make them easier to assign to routes. You may do this using the \n$middlewareGroups\n property of your HTTP kernel.\n\n\nOut of the box, Laravel comes with \nweb\n and \napi\n middleware groups that contains common middleware you may want to apply to your web UI and API routes:\n\n\n/**\n\n\n * The application\ns route middleware groups.\n\n\n *\n\n\n * @var array\n\n\n */\n\nprotected\n \n$\nmiddlewareGroups\n \n=\n \n[\n\n\n    \nweb\n \n=\n \n[\n\n\n        \n\\\nApp\n\\\nHttp\n\\\nMiddleware\n\\\nEncryptCookies\n:\n:\nclass\n,\n\n\n        \n\\\nIlluminate\n\\\nCookie\n\\\nMiddleware\n\\\nAddQueuedCookiesToResponse\n:\n:\nclass\n,\n\n\n        \n\\\nIlluminate\n\\\nSession\n\\\nMiddleware\n\\\nStartSession\n:\n:\nclass\n,\n\n\n        \n\\\nIlluminate\n\\\nView\n\\\nMiddleware\n\\\nShareErrorsFromSession\n:\n:\nclass\n,\n\n\n        \n\\\nApp\n\\\nHttp\n\\\nMiddleware\n\\\nVerifyCsrfToken\n:\n:\nclass\n,\n\n\n        \n\\\nIlluminate\n\\\nRouting\n\\\nMiddleware\n\\\nSubstituteBindings\n:\n:\nclass\n,\n\n\n    \n]\n,\n\n\n\n    \napi\n \n=\n \n[\n\n\n        \nthrottle:60,1\n,\n\n\n        \nauth:api\n,\n\n\n    \n]\n,\n\n\n];\n\n\n\n\n\n\nMiddleware groups may be assigned to routes and controller actions using the same syntax as individual middleware. Again, middleware groups simply make it more convenient to assign many middleware to a route at once:\n\n\nRoute::get(\n/\n, function () {\n    //\n})-\nmiddleware(\nweb\n);\n\nRoute::group([\nmiddleware\n =\n [\nweb\n]], function () {\n    //\n});\n\n\n\n\n\n\n\n{tip} Out of the box, the \nweb\n middleware group is automatically applied to your \nroutes/web.php\n file by the \nRouteServiceProvider\n.\n\n\n\n\n\n\nMiddleware Parameters\n\n\nMiddleware can also receive additional parameters. For example, if your application needs to verify that the authenticated user has a given \"role\" before performing a given action, you could create a \nCheckRole\n middleware that receives a role name as an additional argument.\n\n\nAdditional middleware parameters will be passed to the middleware after the \n$next\n argument:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nMiddleware\n;\n\n\n\nuse\n \nClosure\n;\n\n\n\nclass\n \nCheckRole\n\n\n{\n\n    \n/**\n\n\n     * Handle the incoming request.\n\n\n     *\n\n\n     * @param  \\Illuminate\\Http\\Request  $request\n\n\n     * @param  \\Closure  $next\n\n\n     * @param  string  $role\n\n\n     * @return mixed\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandle\n(\n$request\n,\n \nClosure\n \n$next\n,\n \n$role\n)\n\n    \n{\n\n        \nif\n \n(\n!\n \n$request\n-\nuser\n()\n-\nhasRole\n(\n$role\n))\n \n{\n\n            \n// Redirect...\n\n        \n}\n\n\n        \nreturn\n \n$next\n(\n$request\n);\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\nMiddleware parameters may be specified when defining the route by separating the middleware name and parameters with a \n:\n. Multiple parameters should be delimited by commas:\n\n\nRoute\n::\nput\n(\npost/{id}\n,\n \nfunction\n \n($\nid\n)\n \n{\n\n    \n//\n\n\n}\n)\n-\nmiddleware\n(\nrole:editor\n);\n\n\n\n\n\n\n\n\nTerminable Middleware\n\n\nSometimes a middleware may need to do some work after the HTTP response has been sent to the browser. For example, the \"session\" middleware included with Laravel writes the session data to storage after the response has been sent to the browser. If you define a \nterminate\n method on your middleware, it will automatically be called after the response is sent to the browser.\n\n\n?\nphp\n\n\n\nnamespace\n \nIlluminate\n\\\nSession\n\\\nMiddleware\n;\n\n\n\nuse\n \nClosure\n;\n\n\n\nclass\n \nStartSession\n\n\n{\n\n    \npublic\n \nfunction\n \nhandle\n(\n$request\n,\n \nClosure\n \n$next\n)\n\n    \n{\n\n        \nreturn\n \n$next\n(\n$request\n);\n\n    \n}\n\n\n    \npublic\n \nfunction\n \nterminate\n(\n$request\n,\n \n$response\n)\n\n    \n{\n\n        \n// Store the session data...\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe \nterminate\n method should receive both the request and the response. Once you have defined a terminable middleware, you should add it to the list of global middleware in your HTTP kernel.\n\n\nWhen calling the \nterminate\n method on your middleware, Laravel will resolve a fresh instance of the middleware from the \nservice container\n. If you would like to use the same middleware instance when the \nhandle\n and \nterminate\n methods are called, register the middleware with the container using the container's \nsingleton\n method.", 
            "title": "Middleware"
        }, 
        {
            "location": "/middleware/#middleware", 
            "text": "Introduction  Defining Middleware  Registering Middleware  Global Middleware  Assigning Middleware To Routes  Middleware Groups    Middleware Parameters  Terminable Middleware", 
            "title": "Middleware"
        }, 
        {
            "location": "/middleware/#introduction", 
            "text": "Middleware provide a convenient mechanism for filtering HTTP requests entering your application. For example, Laravel includes a middleware that verifies the user of your application is authenticated. If the user is not authenticated, the middleware will redirect the user to the login screen. However, if the user is authenticated, the middleware will allow the request to proceed further into the application.  Of course, additional middleware can be written to perform a variety of tasks besides authentication. A CORS middleware might be responsible for adding the proper headers to all responses leaving your application. A logging middleware might log all incoming requests to your application.  There are several middleware included in the Laravel framework, including middleware for authentication and CSRF protection. All of these middleware are located in the  app/Http/Middleware  directory.", 
            "title": "Introduction"
        }, 
        {
            "location": "/middleware/#defining-middleware", 
            "text": "To create a new middleware, use the  make:middleware  Artisan command:  php artisan make:middleware CheckAge  This command will place a new  CheckAge  class within your  app/Http/Middleware  directory. In this middleware, we will only allow access to the route if the supplied  age  is greater than 200. Otherwise, we will redirect the users back to the  home  URI.  ? php  namespace   App \\ Http \\ Middleware ;  use   Closure ;  class   CheckAge  { \n     /**       * Handle an incoming request.       *       * @param  \\Illuminate\\Http\\Request  $request       * @param  \\Closure  $next       * @return mixed       */ \n     public   function   handle ( $request ,   Closure   $next ) \n     { \n         if   ( $request - age   =   200 )   { \n             return   redirect ( home ); \n         } \n\n         return   $next ( $request ); \n     }  }   As you can see, if the given  age  is less than or equal to  200 , the middleware will return an HTTP redirect to the client; otherwise, the request will be passed further into the application. To pass the request deeper into the application (allowing the middleware to \"pass\"), simply call the  $next  callback with the  $request .  It's best to envision middleware as a series of \"layers\" HTTP requests must pass through before they hit your application. Each layer can examine the request and even reject it entirely.", 
            "title": "Defining Middleware"
        }, 
        {
            "location": "/middleware/#before-after-middleware", 
            "text": "Whether a middleware runs before or after a request depends on the middleware itself. For example, the following middleware would perform some task  before  the request is handled by the application:  ? php  namespace   App \\ Http \\ Middleware ;  use   Closure ;  class   BeforeMiddleware  { \n     public   function   handle ( $request ,   Closure   $next ) \n     { \n         // Perform action \n\n         return   $next ( $request ); \n     }  }   However, this middleware would perform its task  after  the request is handled by the application:  ? php  namespace   App \\ Http \\ Middleware ;  use   Closure ;  class   AfterMiddleware  { \n     public   function   handle ( $request ,   Closure   $next ) \n     { \n         $response   =   $next ( $request ); \n\n         // Perform action \n\n         return   $response ; \n     }  }", 
            "title": "Before &amp; After Middleware"
        }, 
        {
            "location": "/middleware/#registering-middleware", 
            "text": "", 
            "title": "Registering Middleware"
        }, 
        {
            "location": "/middleware/#global-middleware", 
            "text": "If you want a middleware to run during every HTTP request to your application, simply list the middleware class in the  $middleware  property of your  app/Http/Kernel.php  class.", 
            "title": "Global Middleware"
        }, 
        {
            "location": "/middleware/#assigning-middleware-to-routes", 
            "text": "If you would like to assign middleware to specific routes, you should first assign the middleware a key in your  app/Http/Kernel.php  file. By default, the  $routeMiddleware  property of this class contains entries for the middleware included with Laravel. To add your own, simply append it to this list and assign it a key of your choosing. For example:  // Within App\\Http\\Kernel Class...\n\nprotected $routeMiddleware = [\n     auth  =  \\Illuminate\\Auth\\Middleware\\Authenticate::class,\n     auth.basic  =  \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class,\n     bindings  =  \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,\n     can  =  \\Illuminate\\Auth\\Middleware\\Authorize::class,\n     guest  =  \\App\\Http\\Middleware\\RedirectIfAuthenticated::class,\n     throttle  =  \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,\n];  Once the middleware has been defined in the HTTP kernel, you may use the  middleware  method to assign middleware to a route:  Route::get( admin/profile , function () {\n    //\n})- middleware( auth );  You may also assign multiple middleware to the route:  Route::get( / , function () {\n    //\n})- middleware( first ,  second );  When assigning middleware, you may also pass the fully qualified class name:  use   App \\ Http \\ Middleware \\ CheckAge ;  Route :: get ( admin/profile ,   function   ()   { \n     //  } ) - middleware ( CheckAge :: class );", 
            "title": "Assigning Middleware To Routes"
        }, 
        {
            "location": "/middleware/#middleware-groups", 
            "text": "Sometimes you may want to group several middleware under a single key to make them easier to assign to routes. You may do this using the  $middlewareGroups  property of your HTTP kernel.  Out of the box, Laravel comes with  web  and  api  middleware groups that contains common middleware you may want to apply to your web UI and API routes:  /**   * The application s route middleware groups.   *   * @var array   */ \nprotected   $ middlewareGroups   =   [       web   =   [           \\ App \\ Http \\ Middleware \\ EncryptCookies : : class ,           \\ Illuminate \\ Cookie \\ Middleware \\ AddQueuedCookiesToResponse : : class ,           \\ Illuminate \\ Session \\ Middleware \\ StartSession : : class ,           \\ Illuminate \\ View \\ Middleware \\ ShareErrorsFromSession : : class ,           \\ App \\ Http \\ Middleware \\ VerifyCsrfToken : : class ,           \\ Illuminate \\ Routing \\ Middleware \\ SubstituteBindings : : class ,       ] ,       api   =   [           throttle:60,1 ,           auth:api ,       ] ,  ];   Middleware groups may be assigned to routes and controller actions using the same syntax as individual middleware. Again, middleware groups simply make it more convenient to assign many middleware to a route at once:  Route::get( / , function () {\n    //\n})- middleware( web );\n\nRoute::group([ middleware  =  [ web ]], function () {\n    //\n});   {tip} Out of the box, the  web  middleware group is automatically applied to your  routes/web.php  file by the  RouteServiceProvider .", 
            "title": "Middleware Groups"
        }, 
        {
            "location": "/middleware/#middleware-parameters", 
            "text": "Middleware can also receive additional parameters. For example, if your application needs to verify that the authenticated user has a given \"role\" before performing a given action, you could create a  CheckRole  middleware that receives a role name as an additional argument.  Additional middleware parameters will be passed to the middleware after the  $next  argument:  ? php  namespace   App \\ Http \\ Middleware ;  use   Closure ;  class   CheckRole  { \n     /**       * Handle the incoming request.       *       * @param  \\Illuminate\\Http\\Request  $request       * @param  \\Closure  $next       * @param  string  $role       * @return mixed       */ \n     public   function   handle ( $request ,   Closure   $next ,   $role ) \n     { \n         if   ( !   $request - user () - hasRole ( $role ))   { \n             // Redirect... \n         } \n\n         return   $next ( $request ); \n     }  }   Middleware parameters may be specified when defining the route by separating the middleware name and parameters with a  : . Multiple parameters should be delimited by commas:  Route :: put ( post/{id} ,   function   ($ id )   { \n     //  } ) - middleware ( role:editor );", 
            "title": "Middleware Parameters"
        }, 
        {
            "location": "/middleware/#terminable-middleware", 
            "text": "Sometimes a middleware may need to do some work after the HTTP response has been sent to the browser. For example, the \"session\" middleware included with Laravel writes the session data to storage after the response has been sent to the browser. If you define a  terminate  method on your middleware, it will automatically be called after the response is sent to the browser.  ? php  namespace   Illuminate \\ Session \\ Middleware ;  use   Closure ;  class   StartSession  { \n     public   function   handle ( $request ,   Closure   $next ) \n     { \n         return   $next ( $request ); \n     } \n\n     public   function   terminate ( $request ,   $response ) \n     { \n         // Store the session data... \n     }  }   The  terminate  method should receive both the request and the response. Once you have defined a terminable middleware, you should add it to the list of global middleware in your HTTP kernel.  When calling the  terminate  method on your middleware, Laravel will resolve a fresh instance of the middleware from the  service container . If you would like to use the same middleware instance when the  handle  and  terminate  methods are called, register the middleware with the container using the container's  singleton  method.", 
            "title": "Terminable Middleware"
        }, 
        {
            "location": "/migrations/", 
            "text": "Database: Migrations\n\n\n\n\nIntroduction\n\n\nGenerating Migrations\n\n\nMigration Structure\n\n\nRunning Migrations\n\n\nRolling Back Migrations\n\n\n\n\n\n\nTables\n\n\nCreating Tables\n\n\nRenaming / Dropping Tables\n\n\n\n\n\n\nColumns\n\n\nCreating Columns\n\n\nColumn Modifiers\n\n\nModifying Columns\n\n\nDropping Columns\n\n\n\n\n\n\nIndexes\n\n\nCreating Indexes\n\n\nDropping Indexes\n\n\nForeign Key Constraints\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nMigrations are like version control for your database, allowing your team to easily modify and share the application's database schema. Migrations are typically paired with Laravel's schema builder to easily build your application's database schema. If you have ever had to tell a teammate to manually add a column to their local database schema, you've faced the problem that database migrations solve.\n\n\nThe Laravel \nSchema\n \nfacade\n provides database agnostic support for creating and manipulating tables across all of Laravel's supported database systems.\n\n\n\n\nGenerating Migrations\n\n\nTo create a migration, use the \nmake:migration\n \nArtisan command\n:\n\n\nphp artisan make:migration create_users_table\n\n\n\n\n\nThe new migration will be placed in your \ndatabase/migrations\n directory. Each migration file name contains a timestamp which allows Laravel to determine the order of the migrations.\n\n\nThe \n--table\n and \n--create\n options may also be used to indicate the name of the table and whether the migration will be creating a new table. These options simply pre-fill the generated migration stub file with the specified table:\n\n\nphp artisan make:migration create_users_table --create=users\n\nphp artisan make:migration add_votes_to_users_table --table=users\n\n\n\n\n\nIf you would like to specify a custom output path for the generated migration, you may use the \n--path\n option when executing the \nmake:migration\n command. The given path should be relative to your application's base path.\n\n\n\n\nMigration Structure\n\n\nA migration class contains two methods: \nup\n and \ndown\n. The \nup\n method is used to add new tables, columns, or indexes to your database, while the \ndown\n method should simply reverse the operations performed by the \nup\n method.\n\n\nWithin both of these methods you may use the Laravel schema builder to expressively create and modify tables. To learn about all of the methods available on the \nSchema\n builder, \ncheck out its documentation\n. For example, this migration example creates a \nflights\n table:\n\n\n?\nphp\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nSchema\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nSchema\n\\\nBlueprint\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nMigrations\n\\\nMigration\n;\n\n\n\nclass\n \nCreateFlightsTable\n \nextends\n \nMigration\n\n\n{\n\n    \n/**\n\n\n     * Run the migrations.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nup\n()\n\n    \n{\n\n        \nSchema\n::\ncreate\n(\nflights\n,\n \nfunction\n \n(\nBlueprint\n \n$table\n)\n \n{\n\n            \n$table\n-\nincrements\n(\nid\n);\n\n            \n$table\n-\nstring\n(\nname\n);\n\n            \n$table\n-\nstring\n(\nairline\n);\n\n            \n$table\n-\ntimestamps\n();\n\n        \n});\n\n    \n}\n\n\n    \n/**\n\n\n     * Reverse the migrations.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \ndown\n()\n\n    \n{\n\n        \nSchema\n::\ndrop\n(\nflights\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nRunning Migrations\n\n\nTo run all of your outstanding migrations, execute the \nmigrate\n Artisan command:\n\n\nphp artisan migrate\n\n\n\n\n\n\n\n{note} If you are using the \nHomestead virtual machine\n, you should run this command from within your virtual machine.\n\n\n\n\nForcing Migrations To Run In Production\n\n\nSome migration operations are destructive, which means they may cause you to lose data. In order to protect you from running these commands against your production database, you will be prompted for confirmation before the commands are executed. To force the commands to run without a prompt, use the \n--force\n flag:\n\n\nphp artisan migrate --force\n\n\n\n\n\n\n\nRolling Back Migrations\n\n\nTo rollback the latest migration operation, you may use the \nrollback\n command. This command rolls back the last \"batch\" of migrations, which may include multiple migration files:\n\n\nphp artisan migrate:rollback\n\n\n\n\n\nYou may rollback a limited number of migrations by providing the \nstep\n option to the \nrollback\n command. For example, the following command will rollback the last five migrations:\n\n\nphp artisan migrate:rollback --step=5\n\n\n\n\n\nThe \nmigrate:reset\n command will roll back all of your application's migrations:\n\n\nphp artisan migrate:reset\n\n\n\n\n\nRollback \n Migrate In Single Command\n\n\nThe \nmigrate:refresh\n command will roll back all of your migrations and then execute the \nmigrate\n command. This command effectively re-creates your entire database:\n\n\nphp artisan migrate:refresh\n\n// Refresh the database and run all database seeds...\nphp artisan migrate:refresh --seed\n\n\n\n\n\nYou may rollback \n re-migrate a limited number of migrations by providing the \nstep\n option to the \nrefresh\n command. For example, the following command will rollback \n re-migrate the last five migrations:\n\n\nphp artisan migrate:refresh --step=5\n\n\n\n\n\n\n\nTables\n\n\n\n\nCreating Tables\n\n\nTo create a new database table, use the \ncreate\n method on the \nSchema\n facade. The \ncreate\n method accepts two arguments. The first is the name of the table, while the second is a \nClosure\n which receives a \nBlueprint\n object that may be used to define the new table:\n\n\nSchema::create(\nusers\n, function (Blueprint $table) {\n    $table-\nincrements(\nid\n);\n});\n\n\n\n\n\nOf course, when creating the table, you may use any of the schema builder's \ncolumn methods\n to define the table's columns.\n\n\nChecking For Table / Column Existence\n\n\nYou may easily check for the existence of a table or column using the \nhasTable\n and \nhasColumn\n methods:\n\n\nif (Schema::hasTable(\nusers\n)) {\n    //\n}\n\nif (Schema::hasColumn(\nusers\n, \nemail\n)) {\n    //\n}\n\n\n\n\n\nConnection \n Storage Engine\n\n\nIf you want to perform a schema operation on a database connection that is not your default connection, use the \nconnection\n method:\n\n\nSchema::connection(\nfoo\n)-\ncreate(\nusers\n, function (Blueprint $table) {\n    $table-\nincrements(\nid\n);\n});\n\n\n\n\n\nYou may use the \nengine\n property on the schema builder to define the table's storage engine:\n\n\nSchema::create(\nusers\n, function (Blueprint $table) {\n    $table-\nengine = \nInnoDB\n;\n\n    $table-\nincrements(\nid\n);\n});\n\n\n\n\n\n\n\nRenaming / Dropping Tables\n\n\nTo rename an existing database table, use the \nrename\n method:\n\n\nSchema\n::\nrename\n($\nfrom\n,\n \n$\nto\n);\n\n\n\n\n\n\nTo drop an existing table, you may use the \ndrop\n or \ndropIfExists\n methods:\n\n\nSchema\n::\ndrop\n(\nusers\n);\n\n\n\nSchema\n::\ndropIfExists\n(\nusers\n);\n\n\n\n\n\n\nRenaming Tables With Foreign Keys\n\n\nBefore renaming a table, you should verify that any foreign key constraints on the table have an explicit name in your migration files instead of letting Laravel assign a convention based name. Otherwise, the foreign key constraint name will refer to the old table name.\n\n\n\n\nColumns\n\n\n\n\nCreating Columns\n\n\nThe \ntable\n method on the \nSchema\n facade may be used to update existing tables. Like the \ncreate\n method, the \ntable\n method accepts two arguments: the name of the table and a \nClosure\n that receives a \nBlueprint\n instance you may use to add columns to the table:\n\n\nSchema::table(\nusers\n, function (Blueprint $table) {\n    $table-\nstring(\nemail\n);\n});\n\n\n\n\n\nAvailable Column Types\n\n\nOf course, the schema builder contains a variety of column types that you may specify when building your tables:\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$table-\nbigIncrements('id');\n\n\nIncrementing ID (primary key) using a \"UNSIGNED BIG INTEGER\" equivalent.\n\n\n\n\n\n\n$table-\nbigInteger('votes');\n\n\nBIGINT equivalent for the database.\n\n\n\n\n\n\n$table-\nbinary('data');\n\n\nBLOB equivalent for the database.\n\n\n\n\n\n\n$table-\nboolean('confirmed');\n\n\nBOOLEAN equivalent for the database.\n\n\n\n\n\n\n$table-\nchar('name', 4);\n\n\nCHAR equivalent with a length.\n\n\n\n\n\n\n$table-\ndate('created_at');\n\n\nDATE equivalent for the database.\n\n\n\n\n\n\n$table-\ndateTime('created_at');\n\n\nDATETIME equivalent for the database.\n\n\n\n\n\n\n$table-\ndateTimeTz('created_at');\n\n\nDATETIME (with timezone) equivalent for the database.\n\n\n\n\n\n\n$table-\ndecimal('amount', 5, 2);\n\n\nDECIMAL equivalent with a precision and scale.\n\n\n\n\n\n\n$table-\ndouble('column', 15, 8);\n\n\nDOUBLE equivalent with precision, 15 digits in total and 8 after the decimal point.\n\n\n\n\n\n\n$table-\nenum('choices', ['foo', 'bar']);\n\n\nENUM equivalent for the database.\n\n\n\n\n\n\n$table-\nfloat('amount', 8, 2);\n\n\nFLOAT equivalent for the database, 8 digits in total and 2 after the decimal point.\n\n\n\n\n\n\n$table-\nincrements('id');\n\n\nIncrementing ID (primary key) using a \"UNSIGNED INTEGER\" equivalent.\n\n\n\n\n\n\n$table-\ninteger('votes');\n\n\nINTEGER equivalent for the database.\n\n\n\n\n\n\n$table-\nipAddress('visitor');\n\n\nIP address equivalent for the database.\n\n\n\n\n\n\n$table-\njson('options');\n\n\nJSON equivalent for the database.\n\n\n\n\n\n\n$table-\njsonb('options');\n\n\nJSONB equivalent for the database.\n\n\n\n\n\n\n$table-\nlongText('description');\n\n\nLONGTEXT equivalent for the database.\n\n\n\n\n\n\n$table-\nmacAddress('device');\n\n\nMAC address equivalent for the database.\n\n\n\n\n\n\n$table-\nmediumIncrements('id');\n\n\nIncrementing ID (primary key) using a \"UNSIGNED MEDIUM INTEGER\" equivalent.\n\n\n\n\n\n\n$table-\nmediumInteger('numbers');\n\n\nMEDIUMINT equivalent for the database.\n\n\n\n\n\n\n$table-\nmediumText('description');\n\n\nMEDIUMTEXT equivalent for the database.\n\n\n\n\n\n\n$table-\nmorphs('taggable');\n\n\nAdds unsigned INTEGER \ntaggable_id\n and STRING \ntaggable_type\n.\n\n\n\n\n\n\n$table-\nnullableMorphs('taggable');\n\n\nNullable versions of the \nmorphs()\n columns.\n\n\n\n\n\n\n$table-\nnullableTimestamps();\n\n\nNullable versions of the \ntimestamps()\n columns.\n\n\n\n\n\n\n$table-\nrememberToken();\n\n\nAdds \nremember_token\n as VARCHAR(100) NULL.\n\n\n\n\n\n\n$table-\nsmallIncrements('id');\n\n\nIncrementing ID (primary key) using a \"UNSIGNED SMALL INTEGER\" equivalent.\n\n\n\n\n\n\n$table-\nsmallInteger('votes');\n\n\nSMALLINT equivalent for the database.\n\n\n\n\n\n\n$table-\nsoftDeletes();\n\n\nAdds nullable \ndeleted_at\n column for soft deletes.\n\n\n\n\n\n\n$table-\nstring('email');\n\n\nVARCHAR equivalent column.\n\n\n\n\n\n\n$table-\nstring('name', 100);\n\n\nVARCHAR equivalent with a length.\n\n\n\n\n\n\n$table-\ntext('description');\n\n\nTEXT equivalent for the database.\n\n\n\n\n\n\n$table-\ntime('sunrise');\n\n\nTIME equivalent for the database.\n\n\n\n\n\n\n$table-\ntimeTz('sunrise');\n\n\nTIME (with timezone) equivalent for the database.\n\n\n\n\n\n\n$table-\ntinyInteger('numbers');\n\n\nTINYINT equivalent for the database.\n\n\n\n\n\n\n$table-\ntimestamp('added_on');\n\n\nTIMESTAMP equivalent for the database.\n\n\n\n\n\n\n$table-\ntimestampTz('added_on');\n\n\nTIMESTAMP (with timezone) equivalent for the database.\n\n\n\n\n\n\n$table-\ntimestamps();\n\n\nAdds nullable \ncreated_at\n and \nupdated_at\n columns.\n\n\n\n\n\n\n$table-\ntimestampsTz();\n\n\nAdds nullable \ncreated_at\n and \nupdated_at\n (with timezone) columns.\n\n\n\n\n\n\n$table-\nunsignedBigInteger('votes');\n\n\nUnsigned BIGINT equivalent for the database.\n\n\n\n\n\n\n$table-\nunsignedInteger('votes');\n\n\nUnsigned INT equivalent for the database.\n\n\n\n\n\n\n$table-\nunsignedMediumInteger('votes');\n\n\nUnsigned MEDIUMINT equivalent for the database.\n\n\n\n\n\n\n$table-\nunsignedSmallInteger('votes');\n\n\nUnsigned SMALLINT equivalent for the database.\n\n\n\n\n\n\n$table-\nunsignedTinyInteger('votes');\n\n\nUnsigned TINYINT equivalent for the database.\n\n\n\n\n\n\n$table-\nuuid('id');\n\n\nUUID equivalent for the database.\n\n\n\n\n\n\n\n\n\n\nColumn Modifiers\n\n\nIn addition to the column types listed above, there are several column \"modifiers\" you may use while adding a column to a database table. For example, to make the column \"nullable\", you may use the \nnullable\n method:\n\n\nSchema::table(\nusers\n, function (Blueprint $table) {\n    $table-\nstring(\nemail\n)-\nnullable();\n});\n\n\n\n\n\nBelow is a list of all the available column modifiers. This list does not include the \nindex modifiers\n:\n\n\n\n\n\n\n\n\nModifier\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-\nafter('column')\n\n\nPlace the column \"after\" another column (MySQL Only)\n\n\n\n\n\n\n-\ncomment('my comment')\n\n\nAdd a comment to a column\n\n\n\n\n\n\n-\ndefault($value)\n\n\nSpecify a \"default\" value for the column\n\n\n\n\n\n\n-\nfirst()\n\n\nPlace the column \"first\" in the table (MySQL Only)\n\n\n\n\n\n\n-\nnullable()\n\n\nAllow NULL values to be inserted into the column\n\n\n\n\n\n\n-\nstoredAs($expression)\n\n\nCreate a stored generated column (MySQL Only)\n\n\n\n\n\n\n-\nunsigned()\n\n\nSet \ninteger\n columns to \nUNSIGNED\n\n\n\n\n\n\n-\nvirtualAs($expression)\n\n\nCreate a virtual generated column (MySQL Only)\n\n\n\n\n\n\n\n\n\n\n\n\nModifying Columns\n\n\nPrerequisites\n\n\nBefore modifying a column, be sure to add the \ndoctrine/dbal\n dependency to your \ncomposer.json\n file. The Doctrine DBAL library is used to determine the current state of the column and create the SQL queries needed to make the specified adjustments to the column:\n\n\ncomposer require doctrine/dbal\n\n\n\n\n\nUpdating Column Attributes\n\n\nThe \nchange\n method allows you to modify some existing column types to a new type or modify the column's attributes. For example, you may wish to increase the size of a string column. To see the \nchange\n method in action, let's increase the size of the \nname\n column from 25 to 50:\n\n\nSchema::table(\nusers\n, function (Blueprint $table) {\n    $table-\nstring(\nname\n, 50)-\nchange();\n});\n\n\n\n\n\nWe could also modify a column to be nullable:\n\n\nSchema::table(\nusers\n, function (Blueprint $table) {\n    $table-\nstring(\nname\n, 50)-\nnullable()-\nchange();\n});\n\n\n\n\n\n\n\n{note} The following column types can not be \"changed\": char, double, enum, mediumInteger, timestamp, tinyInteger, ipAddress, json, jsonb, macAddress, mediumIncrements, morphs, nullableMorphs, nullableTimestamps, softDeletes, timeTz, timestampTz, timestamps, timestampsTz, unsignedMediumInteger, unsignedTinyInteger, uuid.\n\n\n\n\n\n\nRenaming Columns\n\n\nTo rename a column, you may use the \nrenameColumn\n method on the Schema builder. Before renaming a column, be sure to add the \ndoctrine/dbal\n dependency to your \ncomposer.json\n file:\n\n\nSchema::table(\nusers\n, function (Blueprint $table) {\n    $table-\nrenameColumn(\nfrom\n, \nto\n);\n});\n\n\n\n\n\n\n\n{note} Renaming any column in a table that also has a column of type \nenum\n is not currently supported.\n\n\n\n\n\n\nDropping Columns\n\n\nTo drop a column, use the \ndropColumn\n method on the Schema builder. Before dropping columns from a SQLite database, you will need to add the \ndoctrine/dbal\n dependency to your \ncomposer.json\n file and run the \ncomposer update\n command in your terminal to install the library:\n\n\nSchema::table(\nusers\n, function (Blueprint $table) {\n    $table-\ndropColumn(\nvotes\n);\n});\n\n\n\n\n\nYou may drop multiple columns from a table by passing an array of column names to the \ndropColumn\n method:\n\n\nSchema::table(\nusers\n, function (Blueprint $table) {\n    $table-\ndropColumn([\nvotes\n, \navatar\n, \nlocation\n]);\n});\n\n\n\n\n\n\n\n{note} Dropping or modifying multiple columns within a single migration while using a SQLite database is not supported.\n\n\n\n\n\n\nIndexes\n\n\n\n\nCreating Indexes\n\n\nThe schema builder supports several types of indexes. First, let's look at an example that specifies a column's values should be unique. To create the index, we can simply chain the \nunique\n method onto the column definition:\n\n\n$table-\nstring(\nemail\n)-\nunique();\n\n\n\n\n\nAlternatively, you may create the index after defining the column. For example:\n\n\n$table-\nunique(\nemail\n);\n\n\n\n\n\nYou may even pass an array of columns to an index method to create a compound index:\n\n\n$table-\nindex([\naccount_id\n, \ncreated_at\n]);\n\n\n\n\n\nLaravel will automatically generate a reasonable index name, but you may pass a second argument to the method to specify the name yourself:\n\n\n$table-\nindex(\nemail\n, \nmy_index_name\n);\n\n\n\n\n\nAvailable Index Types\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$table-\nprimary('id');\n\n\nAdd a primary key.\n\n\n\n\n\n\n$table-\nprimary(['first', 'last']);\n\n\nAdd composite keys.\n\n\n\n\n\n\n$table-\nunique('email');\n\n\nAdd a unique index.\n\n\n\n\n\n\n$table-\nunique('state', 'my_index_name');\n\n\nAdd a custom index name.\n\n\n\n\n\n\n$table-\nunique(['first', 'last']);\n\n\nAdd a composite unique index.\n\n\n\n\n\n\n$table-\nindex('state');\n\n\nAdd a basic index.\n\n\n\n\n\n\n\n\nIndex Lengths \n MySQL / MariaDB\n\n\nLaravel uses the \nutf8mb4\n character set by default, which includes support for storing \"emojis\" in the database. If you are running a version of MySQL older than the 5.7.7 release or MariaDB older than the 10.2.2 release, you may need to manually configure the default string length generated by migrations in order for MySQL to create indexes for them. You may configure this by calling the \nSchema::defaultStringLength\n method within your \nAppServiceProvider\n:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nSchema\n;\n\n\n\n/**\n\n\n * Bootstrap any application services.\n\n\n *\n\n\n * @return void\n\n\n */\n\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n    \nSchema\n:\n:\ndefaultStringLength\n(\n191\n);\n\n\n}\n\n\n\n\n\n\nAlternatively, you may enable the \ninnodb_large_prefix\n option for your database. Refer to your database's documentation for instructions on how to properly enable this option.\n\n\n\n\nDropping Indexes\n\n\nTo drop an index, you must specify the index's name. By default, Laravel automatically assigns a reasonable name to the indexes. Simply concatenate the table name, the name of the indexed column, and the index type. Here are some examples:\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$table-\ndropPrimary('users_id_primary');\n\n\nDrop a primary key from the \"users\" table.\n\n\n\n\n\n\n$table-\ndropUnique('users_email_unique');\n\n\nDrop a unique index from the \"users\" table.\n\n\n\n\n\n\n$table-\ndropIndex('geo_state_index');\n\n\nDrop a basic index from the \"geo\" table.\n\n\n\n\n\n\n\n\nIf you pass an array of columns into a method that drops indexes, the conventional index name will be generated based on the table name, columns and key type:\n\n\nSchema::table(\ngeo\n, function (Blueprint $table) {\n    $table-\ndropIndex([\nstate\n]); // Drops index \ngeo_state_index\n\n});\n\n\n\n\n\n\n\nForeign Key Constraints\n\n\nLaravel also provides support for creating foreign key constraints, which are used to force referential integrity at the database level. For example, let's define a \nuser_id\n column on the \nposts\n table that references the \nid\n column on a \nusers\n table:\n\n\nSchema::table(\nposts\n, function (Blueprint $table) {\n    $table-\ninteger(\nuser_id\n)-\nunsigned();\n\n    $table-\nforeign(\nuser_id\n)-\nreferences(\nid\n)-\non(\nusers\n);\n});\n\n\n\n\n\nYou may also specify the desired action for the \"on delete\" and \"on update\" properties of the constraint:\n\n\n$table-\nforeign(\nuser_id\n)\n      -\nreferences(\nid\n)-\non(\nusers\n)\n      -\nonDelete(\ncascade\n);\n\n\n\n\n\nTo drop a foreign key, you may use the \ndropForeign\n method. Foreign key constraints use the same naming convention as indexes. So, we will concatenate the table name and the columns in the constraint then suffix the name with \"_foreign\":\n\n\n$table-\ndropForeign(\nposts_user_id_foreign\n);\n\n\n\n\n\nOr, you may pass an array value which will automatically use the conventional constraint name when dropping:\n\n\n$table-\ndropForeign([\nuser_id\n]);\n\n\n\n\n\nYou may enable or disable foreign key constraints within your migrations by using the following methods:\n\n\nSchema\n::\nenableForeignKeyConstraints\n();\n\n\n\nSchema\n::\ndisableForeignKeyConstraints\n();", 
            "title": "Migrations"
        }, 
        {
            "location": "/migrations/#database-migrations", 
            "text": "Introduction  Generating Migrations  Migration Structure  Running Migrations  Rolling Back Migrations    Tables  Creating Tables  Renaming / Dropping Tables    Columns  Creating Columns  Column Modifiers  Modifying Columns  Dropping Columns    Indexes  Creating Indexes  Dropping Indexes  Foreign Key Constraints", 
            "title": "Database: Migrations"
        }, 
        {
            "location": "/migrations/#introduction", 
            "text": "Migrations are like version control for your database, allowing your team to easily modify and share the application's database schema. Migrations are typically paired with Laravel's schema builder to easily build your application's database schema. If you have ever had to tell a teammate to manually add a column to their local database schema, you've faced the problem that database migrations solve.  The Laravel  Schema   facade  provides database agnostic support for creating and manipulating tables across all of Laravel's supported database systems.", 
            "title": "Introduction"
        }, 
        {
            "location": "/migrations/#generating-migrations", 
            "text": "To create a migration, use the  make:migration   Artisan command :  php artisan make:migration create_users_table  The new migration will be placed in your  database/migrations  directory. Each migration file name contains a timestamp which allows Laravel to determine the order of the migrations.  The  --table  and  --create  options may also be used to indicate the name of the table and whether the migration will be creating a new table. These options simply pre-fill the generated migration stub file with the specified table:  php artisan make:migration create_users_table --create=users\n\nphp artisan make:migration add_votes_to_users_table --table=users  If you would like to specify a custom output path for the generated migration, you may use the  --path  option when executing the  make:migration  command. The given path should be relative to your application's base path.", 
            "title": "Generating Migrations"
        }, 
        {
            "location": "/migrations/#migration-structure", 
            "text": "A migration class contains two methods:  up  and  down . The  up  method is used to add new tables, columns, or indexes to your database, while the  down  method should simply reverse the operations performed by the  up  method.  Within both of these methods you may use the Laravel schema builder to expressively create and modify tables. To learn about all of the methods available on the  Schema  builder,  check out its documentation . For example, this migration example creates a  flights  table:  ? php  use   Illuminate \\ Support \\ Facades \\ Schema ;  use   Illuminate \\ Database \\ Schema \\ Blueprint ;  use   Illuminate \\ Database \\ Migrations \\ Migration ;  class   CreateFlightsTable   extends   Migration  { \n     /**       * Run the migrations.       *       * @return void       */ \n     public   function   up () \n     { \n         Schema :: create ( flights ,   function   ( Blueprint   $table )   { \n             $table - increments ( id ); \n             $table - string ( name ); \n             $table - string ( airline ); \n             $table - timestamps (); \n         }); \n     } \n\n     /**       * Reverse the migrations.       *       * @return void       */ \n     public   function   down () \n     { \n         Schema :: drop ( flights ); \n     }  }", 
            "title": "Migration Structure"
        }, 
        {
            "location": "/migrations/#running-migrations", 
            "text": "To run all of your outstanding migrations, execute the  migrate  Artisan command:  php artisan migrate   {note} If you are using the  Homestead virtual machine , you should run this command from within your virtual machine.", 
            "title": "Running Migrations"
        }, 
        {
            "location": "/migrations/#forcing-migrations-to-run-in-production", 
            "text": "Some migration operations are destructive, which means they may cause you to lose data. In order to protect you from running these commands against your production database, you will be prompted for confirmation before the commands are executed. To force the commands to run without a prompt, use the  --force  flag:  php artisan migrate --force", 
            "title": "Forcing Migrations To Run In Production"
        }, 
        {
            "location": "/migrations/#rolling-back-migrations", 
            "text": "To rollback the latest migration operation, you may use the  rollback  command. This command rolls back the last \"batch\" of migrations, which may include multiple migration files:  php artisan migrate:rollback  You may rollback a limited number of migrations by providing the  step  option to the  rollback  command. For example, the following command will rollback the last five migrations:  php artisan migrate:rollback --step=5  The  migrate:reset  command will roll back all of your application's migrations:  php artisan migrate:reset", 
            "title": "Rolling Back Migrations"
        }, 
        {
            "location": "/migrations/#rollback-migrate-in-single-command", 
            "text": "The  migrate:refresh  command will roll back all of your migrations and then execute the  migrate  command. This command effectively re-creates your entire database:  php artisan migrate:refresh\n\n// Refresh the database and run all database seeds...\nphp artisan migrate:refresh --seed  You may rollback   re-migrate a limited number of migrations by providing the  step  option to the  refresh  command. For example, the following command will rollback   re-migrate the last five migrations:  php artisan migrate:refresh --step=5", 
            "title": "Rollback &amp; Migrate In Single Command"
        }, 
        {
            "location": "/migrations/#tables", 
            "text": "", 
            "title": "Tables"
        }, 
        {
            "location": "/migrations/#creating-tables", 
            "text": "To create a new database table, use the  create  method on the  Schema  facade. The  create  method accepts two arguments. The first is the name of the table, while the second is a  Closure  which receives a  Blueprint  object that may be used to define the new table:  Schema::create( users , function (Blueprint $table) {\n    $table- increments( id );\n});  Of course, when creating the table, you may use any of the schema builder's  column methods  to define the table's columns.", 
            "title": "Creating Tables"
        }, 
        {
            "location": "/migrations/#checking-for-table-column-existence", 
            "text": "You may easily check for the existence of a table or column using the  hasTable  and  hasColumn  methods:  if (Schema::hasTable( users )) {\n    //\n}\n\nif (Schema::hasColumn( users ,  email )) {\n    //\n}", 
            "title": "Checking For Table / Column Existence"
        }, 
        {
            "location": "/migrations/#connection-storage-engine", 
            "text": "If you want to perform a schema operation on a database connection that is not your default connection, use the  connection  method:  Schema::connection( foo )- create( users , function (Blueprint $table) {\n    $table- increments( id );\n});  You may use the  engine  property on the schema builder to define the table's storage engine:  Schema::create( users , function (Blueprint $table) {\n    $table- engine =  InnoDB ;\n\n    $table- increments( id );\n});", 
            "title": "Connection &amp; Storage Engine"
        }, 
        {
            "location": "/migrations/#renaming-dropping-tables", 
            "text": "To rename an existing database table, use the  rename  method:  Schema :: rename ($ from ,   $ to );   To drop an existing table, you may use the  drop  or  dropIfExists  methods:  Schema :: drop ( users );  Schema :: dropIfExists ( users );", 
            "title": "Renaming / Dropping Tables"
        }, 
        {
            "location": "/migrations/#renaming-tables-with-foreign-keys", 
            "text": "Before renaming a table, you should verify that any foreign key constraints on the table have an explicit name in your migration files instead of letting Laravel assign a convention based name. Otherwise, the foreign key constraint name will refer to the old table name.", 
            "title": "Renaming Tables With Foreign Keys"
        }, 
        {
            "location": "/migrations/#columns", 
            "text": "", 
            "title": "Columns"
        }, 
        {
            "location": "/migrations/#creating-columns", 
            "text": "The  table  method on the  Schema  facade may be used to update existing tables. Like the  create  method, the  table  method accepts two arguments: the name of the table and a  Closure  that receives a  Blueprint  instance you may use to add columns to the table:  Schema::table( users , function (Blueprint $table) {\n    $table- string( email );\n});", 
            "title": "Creating Columns"
        }, 
        {
            "location": "/migrations/#available-column-types", 
            "text": "Of course, the schema builder contains a variety of column types that you may specify when building your tables:     Command  Description      $table- bigIncrements('id');  Incrementing ID (primary key) using a \"UNSIGNED BIG INTEGER\" equivalent.    $table- bigInteger('votes');  BIGINT equivalent for the database.    $table- binary('data');  BLOB equivalent for the database.    $table- boolean('confirmed');  BOOLEAN equivalent for the database.    $table- char('name', 4);  CHAR equivalent with a length.    $table- date('created_at');  DATE equivalent for the database.    $table- dateTime('created_at');  DATETIME equivalent for the database.    $table- dateTimeTz('created_at');  DATETIME (with timezone) equivalent for the database.    $table- decimal('amount', 5, 2);  DECIMAL equivalent with a precision and scale.    $table- double('column', 15, 8);  DOUBLE equivalent with precision, 15 digits in total and 8 after the decimal point.    $table- enum('choices', ['foo', 'bar']);  ENUM equivalent for the database.    $table- float('amount', 8, 2);  FLOAT equivalent for the database, 8 digits in total and 2 after the decimal point.    $table- increments('id');  Incrementing ID (primary key) using a \"UNSIGNED INTEGER\" equivalent.    $table- integer('votes');  INTEGER equivalent for the database.    $table- ipAddress('visitor');  IP address equivalent for the database.    $table- json('options');  JSON equivalent for the database.    $table- jsonb('options');  JSONB equivalent for the database.    $table- longText('description');  LONGTEXT equivalent for the database.    $table- macAddress('device');  MAC address equivalent for the database.    $table- mediumIncrements('id');  Incrementing ID (primary key) using a \"UNSIGNED MEDIUM INTEGER\" equivalent.    $table- mediumInteger('numbers');  MEDIUMINT equivalent for the database.    $table- mediumText('description');  MEDIUMTEXT equivalent for the database.    $table- morphs('taggable');  Adds unsigned INTEGER  taggable_id  and STRING  taggable_type .    $table- nullableMorphs('taggable');  Nullable versions of the  morphs()  columns.    $table- nullableTimestamps();  Nullable versions of the  timestamps()  columns.    $table- rememberToken();  Adds  remember_token  as VARCHAR(100) NULL.    $table- smallIncrements('id');  Incrementing ID (primary key) using a \"UNSIGNED SMALL INTEGER\" equivalent.    $table- smallInteger('votes');  SMALLINT equivalent for the database.    $table- softDeletes();  Adds nullable  deleted_at  column for soft deletes.    $table- string('email');  VARCHAR equivalent column.    $table- string('name', 100);  VARCHAR equivalent with a length.    $table- text('description');  TEXT equivalent for the database.    $table- time('sunrise');  TIME equivalent for the database.    $table- timeTz('sunrise');  TIME (with timezone) equivalent for the database.    $table- tinyInteger('numbers');  TINYINT equivalent for the database.    $table- timestamp('added_on');  TIMESTAMP equivalent for the database.    $table- timestampTz('added_on');  TIMESTAMP (with timezone) equivalent for the database.    $table- timestamps();  Adds nullable  created_at  and  updated_at  columns.    $table- timestampsTz();  Adds nullable  created_at  and  updated_at  (with timezone) columns.    $table- unsignedBigInteger('votes');  Unsigned BIGINT equivalent for the database.    $table- unsignedInteger('votes');  Unsigned INT equivalent for the database.    $table- unsignedMediumInteger('votes');  Unsigned MEDIUMINT equivalent for the database.    $table- unsignedSmallInteger('votes');  Unsigned SMALLINT equivalent for the database.    $table- unsignedTinyInteger('votes');  Unsigned TINYINT equivalent for the database.    $table- uuid('id');  UUID equivalent for the database.", 
            "title": "Available Column Types"
        }, 
        {
            "location": "/migrations/#column-modifiers", 
            "text": "In addition to the column types listed above, there are several column \"modifiers\" you may use while adding a column to a database table. For example, to make the column \"nullable\", you may use the  nullable  method:  Schema::table( users , function (Blueprint $table) {\n    $table- string( email )- nullable();\n});  Below is a list of all the available column modifiers. This list does not include the  index modifiers :     Modifier  Description      - after('column')  Place the column \"after\" another column (MySQL Only)    - comment('my comment')  Add a comment to a column    - default($value)  Specify a \"default\" value for the column    - first()  Place the column \"first\" in the table (MySQL Only)    - nullable()  Allow NULL values to be inserted into the column    - storedAs($expression)  Create a stored generated column (MySQL Only)    - unsigned()  Set  integer  columns to  UNSIGNED    - virtualAs($expression)  Create a virtual generated column (MySQL Only)", 
            "title": "Column Modifiers"
        }, 
        {
            "location": "/migrations/#modifying-columns", 
            "text": "", 
            "title": "Modifying Columns"
        }, 
        {
            "location": "/migrations/#prerequisites", 
            "text": "Before modifying a column, be sure to add the  doctrine/dbal  dependency to your  composer.json  file. The Doctrine DBAL library is used to determine the current state of the column and create the SQL queries needed to make the specified adjustments to the column:  composer require doctrine/dbal", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/migrations/#updating-column-attributes", 
            "text": "The  change  method allows you to modify some existing column types to a new type or modify the column's attributes. For example, you may wish to increase the size of a string column. To see the  change  method in action, let's increase the size of the  name  column from 25 to 50:  Schema::table( users , function (Blueprint $table) {\n    $table- string( name , 50)- change();\n});  We could also modify a column to be nullable:  Schema::table( users , function (Blueprint $table) {\n    $table- string( name , 50)- nullable()- change();\n});   {note} The following column types can not be \"changed\": char, double, enum, mediumInteger, timestamp, tinyInteger, ipAddress, json, jsonb, macAddress, mediumIncrements, morphs, nullableMorphs, nullableTimestamps, softDeletes, timeTz, timestampTz, timestamps, timestampsTz, unsignedMediumInteger, unsignedTinyInteger, uuid.", 
            "title": "Updating Column Attributes"
        }, 
        {
            "location": "/migrations/#renaming-columns", 
            "text": "To rename a column, you may use the  renameColumn  method on the Schema builder. Before renaming a column, be sure to add the  doctrine/dbal  dependency to your  composer.json  file:  Schema::table( users , function (Blueprint $table) {\n    $table- renameColumn( from ,  to );\n});   {note} Renaming any column in a table that also has a column of type  enum  is not currently supported.", 
            "title": "Renaming Columns"
        }, 
        {
            "location": "/migrations/#dropping-columns", 
            "text": "To drop a column, use the  dropColumn  method on the Schema builder. Before dropping columns from a SQLite database, you will need to add the  doctrine/dbal  dependency to your  composer.json  file and run the  composer update  command in your terminal to install the library:  Schema::table( users , function (Blueprint $table) {\n    $table- dropColumn( votes );\n});  You may drop multiple columns from a table by passing an array of column names to the  dropColumn  method:  Schema::table( users , function (Blueprint $table) {\n    $table- dropColumn([ votes ,  avatar ,  location ]);\n});   {note} Dropping or modifying multiple columns within a single migration while using a SQLite database is not supported.", 
            "title": "Dropping Columns"
        }, 
        {
            "location": "/migrations/#indexes", 
            "text": "", 
            "title": "Indexes"
        }, 
        {
            "location": "/migrations/#creating-indexes", 
            "text": "The schema builder supports several types of indexes. First, let's look at an example that specifies a column's values should be unique. To create the index, we can simply chain the  unique  method onto the column definition:  $table- string( email )- unique();  Alternatively, you may create the index after defining the column. For example:  $table- unique( email );  You may even pass an array of columns to an index method to create a compound index:  $table- index([ account_id ,  created_at ]);  Laravel will automatically generate a reasonable index name, but you may pass a second argument to the method to specify the name yourself:  $table- index( email ,  my_index_name );", 
            "title": "Creating Indexes"
        }, 
        {
            "location": "/migrations/#available-index-types", 
            "text": "Command  Description      $table- primary('id');  Add a primary key.    $table- primary(['first', 'last']);  Add composite keys.    $table- unique('email');  Add a unique index.    $table- unique('state', 'my_index_name');  Add a custom index name.    $table- unique(['first', 'last']);  Add a composite unique index.    $table- index('state');  Add a basic index.", 
            "title": "Available Index Types"
        }, 
        {
            "location": "/migrations/#index-lengths-mysql-mariadb", 
            "text": "Laravel uses the  utf8mb4  character set by default, which includes support for storing \"emojis\" in the database. If you are running a version of MySQL older than the 5.7.7 release or MariaDB older than the 10.2.2 release, you may need to manually configure the default string length generated by migrations in order for MySQL to create indexes for them. You may configure this by calling the  Schema::defaultStringLength  method within your  AppServiceProvider :  use   Illuminate \\ Support \\ Facades \\ Schema ;  /**   * Bootstrap any application services.   *   * @return void   */  public   function   boot ()  { \n     Schema : : defaultStringLength ( 191 );  }   Alternatively, you may enable the  innodb_large_prefix  option for your database. Refer to your database's documentation for instructions on how to properly enable this option.", 
            "title": "Index Lengths &amp; MySQL / MariaDB"
        }, 
        {
            "location": "/migrations/#dropping-indexes", 
            "text": "To drop an index, you must specify the index's name. By default, Laravel automatically assigns a reasonable name to the indexes. Simply concatenate the table name, the name of the indexed column, and the index type. Here are some examples:     Command  Description      $table- dropPrimary('users_id_primary');  Drop a primary key from the \"users\" table.    $table- dropUnique('users_email_unique');  Drop a unique index from the \"users\" table.    $table- dropIndex('geo_state_index');  Drop a basic index from the \"geo\" table.     If you pass an array of columns into a method that drops indexes, the conventional index name will be generated based on the table name, columns and key type:  Schema::table( geo , function (Blueprint $table) {\n    $table- dropIndex([ state ]); // Drops index  geo_state_index \n});", 
            "title": "Dropping Indexes"
        }, 
        {
            "location": "/migrations/#foreign-key-constraints", 
            "text": "Laravel also provides support for creating foreign key constraints, which are used to force referential integrity at the database level. For example, let's define a  user_id  column on the  posts  table that references the  id  column on a  users  table:  Schema::table( posts , function (Blueprint $table) {\n    $table- integer( user_id )- unsigned();\n\n    $table- foreign( user_id )- references( id )- on( users );\n});  You may also specify the desired action for the \"on delete\" and \"on update\" properties of the constraint:  $table- foreign( user_id )\n      - references( id )- on( users )\n      - onDelete( cascade );  To drop a foreign key, you may use the  dropForeign  method. Foreign key constraints use the same naming convention as indexes. So, we will concatenate the table name and the columns in the constraint then suffix the name with \"_foreign\":  $table- dropForeign( posts_user_id_foreign );  Or, you may pass an array value which will automatically use the conventional constraint name when dropping:  $table- dropForeign([ user_id ]);  You may enable or disable foreign key constraints within your migrations by using the following methods:  Schema :: enableForeignKeyConstraints ();  Schema :: disableForeignKeyConstraints ();", 
            "title": "Foreign Key Constraints"
        }, 
        {
            "location": "/mix/", 
            "text": "Compiling Assets (Laravel Mix)\n\n\n\n\nIntroduction\n\n\nInstallation \n Setup\n\n\nRunning Mix\n\n\nWorking With Stylesheets\n\n\nLess\n\n\nSass\n\n\nPlain CSS\n\n\nSource Maps\n\n\n\n\n\n\nWorking With JavaScript\n\n\nCode Splitting\n\n\nCustom Webpack Configuration\n\n\n\n\n\n\nCopying Files \n Directories\n\n\nVersioning / Cache Busting\n\n\nNotifications\n\n\n\n\n\n\nIntroduction\n\n\nLaravel Mix provides a fluent API for defining Webpack build steps for your Laravel application using several common CSS and JavaScript pre-processors. Through simple method chaining, you can fluently define your asset pipeline. For example:\n\n\nmix.js(\nresources/assets/js/app.js\n, \npublic/js\n)\n   .sass(\nresources/assets/sass/app.scss\n, \npublic/css\n);\n\n\n\n\n\nIf you've ever been confused and overwhelmed about getting started with Webpack and asset compilation, you will love Laravel Mix. However, you are not required to use it while developing your application. Of course, you are free to use any asset pipeline tool you wish, or even none at all.\n\n\n\n\nInstallation \n Setup\n\n\nInstalling Node\n\n\nBefore triggering Mix, you must first ensure that Node.js and NPM are installed on your machine.\n\n\nnode -v\nnpm -v\n\n\n\n\n\nBy default, Laravel Homestead includes everything you need; however, if you aren't using Vagrant, then you can easily install the latest version of Node and NPM using simple graphical installers from \ntheir download page\n.\n\n\nLaravel Mix\n\n\nThe only remaining step is to install Laravel Mix. Within a fresh installation of Laravel, you'll find a \npackage.json\n file in the root of your directory structure. The default \npackage.json\n file includes everything you need to get started. Think of this like your \ncomposer.json\n file, except it defines Node dependencies instead of PHP. You may install the dependencies it references by running:\n\n\nnpm install\n\n\n\n\n\nIf you are developing on a Windows system or you are running your VM on a Windows host system, you may need to run the \nnpm install\n command with the \n--no-bin-links\n switch enabled:\n\n\nnpm install --no-bin-links\n\n\n\n\n\n\n\nRunning Mix\n\n\nMix is a configuration layer on top of \nWebpack\n, so to run your Mix tasks you only need to execute one of the NPM scripts that is included with the default Laravel \npackage.json\n file:\n\n\n// Run all Mix tasks...\nnpm run dev\n\n// Run all Mix tasks and minify output...\nnpm run production\n\n\n\n\n\nWatching Assets For Changes\n\n\nThe \nnpm run watch\n command will continue running in your terminal and watch all relevant files for changes. Webpack will then automatically recompile your assets when it detects a change:\n\n\nnpm run watch\n\n\n\n\n\n\n\nWorking With Stylesheets\n\n\nThe \nwebpack.mix.js\n file is your entry point for all asset compilation. Think of it as a light configuration wrapper around Webpack. Mix tasks can be chained together to define exactly how your assets should be compiled.\n\n\n\n\nLess\n\n\nThe \nless\n method may be used to compile \nLess\n into CSS. Let's compile our primary \napp.less\n file to \npublic/css/app.css\n.\n\n\nmix.less(\nresources/assets/less/app.less\n, \npublic/css\n);\n\n\n\n\n\nMultiple calls to the \nless\n method may be used to compile multiple files:\n\n\nmix.less(\nresources/assets/less/app.less\n, \npublic/css\n)\n   .less(\nresources/assets/less/admin.less\n, \npublic/css\n);\n\n\n\n\n\nIf you wish to customize the file name of the compiled CSS, you may pass a full file path as the second argument to the \nless\n method:\n\n\nmix.less(\nresources/assets/less/app.less\n, \npublic/stylesheets/styles.css\n);\n\n\n\n\n\n\n\nSass\n\n\nThe \nsass\n method allows you to compile \nSass\n into CSS. You may use the method like so:\n\n\nmix.sass(\nresources/assets/sass/app.scss\n, \npublic/css\n);\n\n\n\n\n\nAgain, like the \nless\n method, you may compile multiple Sass files into their own respective CSS files and even customize the output directory of the resulting CSS:\n\n\nmix.sass(\nresources/assets/sass/app.sass\n, \npublic/css\n)\n   .sass(\nresources/assets/sass/admin.sass\n, \npublic/css/admin\n);\n\n\n\n\n\n\n\nPlain CSS\n\n\nIf you would just like to combine some plain CSS stylesheets into a single file, you may use the \ncombine\n method. This method also supports concatenating JavaScript files:\n\n\nmix.combine([\n    \npublic/css/vendor/normalize.css\n,\n    \npublic/css/vendor/videojs.css\n\n], \npublic/css/all.css\n);\n\n\n\n\n\n\n\nSource Maps\n\n\nThough disabled by default, source maps may be activated by calling the \nmix.sourceMaps()\n method in your \nwebpack.mix.js\n file. Though it comes with a compile/performance cost, this will provide extra debugging information to your browser's developer tools when using compiled assets.\n\n\nmix.js(\nresources/assets/js/app.js\n, \npublic/js\n)\n   .sourceMaps();\n\n\n\n\n\n\n\nWorking With JavaScript\n\n\nMix provides several features to help you work with your JavaScript files, such as compiling ECMAScript 2015, module bundling, minification, and simply concatenating plain JavaScript files. Even better, this all works seamlessly, without requiring an ounce of custom configuration:\n\n\nmix.js(\nresources/assets/js/app.js\n, \npublic/js\n);\n\n\n\n\n\nWith this single line of code, you may now take advantage of:\n\n\n\n- ES2015 syntax.\n- Compilation of `.vue` files.\n- Minification for production environments.\n\n\n\n\n\n\nCode Splitting\n\n\nOne potential downside to bundling all application-specific JavaScript with your vendor libraries is that it makes long-term caching more difficult. For example, a single update to your application code will force the browser to re-download all of your vendor libraries even if they haven't changed.\n\n\nIf you intend to make frequent updates to your application's JavaScript, you should consider extracting all of your vendor libraries into their file. This way, a change to your application code will not affect the caching of your large \nvendor.js\n file. Mix's \nextract\n method makes this a breeze:\n\n\nmix.js(\nresources/assets/js/app.js\n, \npublic/js\n)\n   .extract([\nvue\n])\n\n\n\n\n\nThe \nextract\n method accepts an array of all libraries or modules that you wish to extract into a \nvendor.js\n file. Using the above snippet as an example, Mix will generate the following files:\n\n\n\n- `public/js/manifest.js`: *The Webpack manifest runtime*\n- `public/js/vendor.js`: *Your vendor libraries*\n- `public/js/app.js`: *Your application code*\n\n\n\n\nTo avoid JavaScript errors, be sure to load these files in the proper order:\n\n\nscript\n \nsrc=\n/js/manifest.js\n/script\n\n\nscript\n \nsrc=\n/js/vendor.js\n/script\n\n\nscript\n \nsrc=\n/js/app.js\n/script\n\n\n\n\n\n\n\n\nCustom Webpack Configuration\n\n\nBehind the scenes, Laravel Mix references a pre-configured \nwebpack.config.js\n file to get you up and running as quickly as possible. Occasionally, you may need to manually modify this file. You might have a special loader or plugin that needs to be referenced, or maybe you prefer to use Stylus instead of Sass. In such instances, you have two choices:\n\n\nMerging\n\n\nMix provides a useful \nwebpackConfig\n method that allows you to merge any short Webpack configuration overrides. This is a particularly appealing choice, as it doesn't require you to copy and maintain your own copy of the \nwebpack.config.js\n file. The \nwebpackConfig\n method accepts an object, which should contain any \nWebpack-specific configuration\n that you wish to apply.\n\n\nmix.webpackConfig({\n    resolve: {\n        modules: [\n            path.resolve(__dirname, \nvendor/laravel/spark/resources/assets/js\n)\n        ]\n    }\n});\n\n\n\n\n\nReference Your Own Configuration\n\n\nA second option is to copy Mix's \nwebpack.config.js\n into your project root.\n\n\ncp node_modules/laravel-mix/setup/webpack.config.js ./\n\n\n\n\n\nNext, you'll need to update the NPM scripts in your \npackage.json\n to ensure that they no longer reference Mix's configuration file directly. Simply remove the \n--config=\"node_modules/laravel-mix/setup/webpack.config.js\"\n entry from the commands. Once this has been done, you may freely modify your configuration file as needed.\n\n\n\n\nCopying Files \n Directories\n\n\nThe \ncopy\n method may be used to copy files and directories to new locations. This can be useful when a particular asset within your \nnode_modules\n directory needs to be relocated to your \npublic\n folder.\n\n\nmix.copy(\nnode_modules/foo/bar.css\n, \npublic/css/bar.css\n);\n\n\n\n\n\n\n\nVersioning / Cache Busting\n\n\nMany developers suffix their compiled assets with a timestamp or unique token to force browsers to load the fresh assets instead of serving stale copies of the code. Mix can handle this for you using the \nversion\n method.\n\n\nThe \nversion\n method will automatically append a unique hash to the filenames of all compiled files, allowing for more convenient cache busting:\n\n\nmix.js(\nresources/assets/js/app.js\n, \npublic/js\n)\n   .version();\n\n\n\n\n\nAfter generating the versioned file, you won't know the exact file name. So, you should use Laravel's global \nmix\n function within your \nviews\n to load the appropriately hashed asset. The \nmix\n function will automatically determine the current name of the hashed file:\n\n\nlink rel=\nstylesheet\n href=\n{{\n \nmix\n(\n/css/app.css\n)\n \n}}\n\n\n\n\n\n\nBecause versioned files are usually unnecessary in development, you may wish to instruct the versioning process to only run during \nnpm run production\n:\n\n\nmix.js(\nresources/assets/js/app.js\n, \npublic/js\n);\n\nif (mix.config.inProduction) {\n    mix.version();\n}\n\n\n\n\n\n\n\nNotifications\n\n\nWhen available, Mix will automatically display OS notifications for each bundle. This will give you instant feedback, as to whether the compilation was successful or not. However, there may be instances when you'd prefer to disable these notifications. One such example might be triggering Mix on your production server. Notifications may be deactivated, via the \ndisableNotifications\n method.\n\n\nmix.disableNotifications();", 
            "title": "Mix"
        }, 
        {
            "location": "/mix/#compiling-assets-laravel-mix", 
            "text": "Introduction  Installation   Setup  Running Mix  Working With Stylesheets  Less  Sass  Plain CSS  Source Maps    Working With JavaScript  Code Splitting  Custom Webpack Configuration    Copying Files   Directories  Versioning / Cache Busting  Notifications", 
            "title": "Compiling Assets (Laravel Mix)"
        }, 
        {
            "location": "/mix/#introduction", 
            "text": "Laravel Mix provides a fluent API for defining Webpack build steps for your Laravel application using several common CSS and JavaScript pre-processors. Through simple method chaining, you can fluently define your asset pipeline. For example:  mix.js( resources/assets/js/app.js ,  public/js )\n   .sass( resources/assets/sass/app.scss ,  public/css );  If you've ever been confused and overwhelmed about getting started with Webpack and asset compilation, you will love Laravel Mix. However, you are not required to use it while developing your application. Of course, you are free to use any asset pipeline tool you wish, or even none at all.", 
            "title": "Introduction"
        }, 
        {
            "location": "/mix/#installation-setup", 
            "text": "", 
            "title": "Installation &amp; Setup"
        }, 
        {
            "location": "/mix/#installing-node", 
            "text": "Before triggering Mix, you must first ensure that Node.js and NPM are installed on your machine.  node -v\nnpm -v  By default, Laravel Homestead includes everything you need; however, if you aren't using Vagrant, then you can easily install the latest version of Node and NPM using simple graphical installers from  their download page .", 
            "title": "Installing Node"
        }, 
        {
            "location": "/mix/#laravel-mix", 
            "text": "The only remaining step is to install Laravel Mix. Within a fresh installation of Laravel, you'll find a  package.json  file in the root of your directory structure. The default  package.json  file includes everything you need to get started. Think of this like your  composer.json  file, except it defines Node dependencies instead of PHP. You may install the dependencies it references by running:  npm install  If you are developing on a Windows system or you are running your VM on a Windows host system, you may need to run the  npm install  command with the  --no-bin-links  switch enabled:  npm install --no-bin-links", 
            "title": "Laravel Mix"
        }, 
        {
            "location": "/mix/#running-mix", 
            "text": "Mix is a configuration layer on top of  Webpack , so to run your Mix tasks you only need to execute one of the NPM scripts that is included with the default Laravel  package.json  file:  // Run all Mix tasks...\nnpm run dev\n\n// Run all Mix tasks and minify output...\nnpm run production", 
            "title": "Running Mix"
        }, 
        {
            "location": "/mix/#watching-assets-for-changes", 
            "text": "The  npm run watch  command will continue running in your terminal and watch all relevant files for changes. Webpack will then automatically recompile your assets when it detects a change:  npm run watch", 
            "title": "Watching Assets For Changes"
        }, 
        {
            "location": "/mix/#working-with-stylesheets", 
            "text": "The  webpack.mix.js  file is your entry point for all asset compilation. Think of it as a light configuration wrapper around Webpack. Mix tasks can be chained together to define exactly how your assets should be compiled.", 
            "title": "Working With Stylesheets"
        }, 
        {
            "location": "/mix/#less", 
            "text": "The  less  method may be used to compile  Less  into CSS. Let's compile our primary  app.less  file to  public/css/app.css .  mix.less( resources/assets/less/app.less ,  public/css );  Multiple calls to the  less  method may be used to compile multiple files:  mix.less( resources/assets/less/app.less ,  public/css )\n   .less( resources/assets/less/admin.less ,  public/css );  If you wish to customize the file name of the compiled CSS, you may pass a full file path as the second argument to the  less  method:  mix.less( resources/assets/less/app.less ,  public/stylesheets/styles.css );", 
            "title": "Less"
        }, 
        {
            "location": "/mix/#sass", 
            "text": "The  sass  method allows you to compile  Sass  into CSS. You may use the method like so:  mix.sass( resources/assets/sass/app.scss ,  public/css );  Again, like the  less  method, you may compile multiple Sass files into their own respective CSS files and even customize the output directory of the resulting CSS:  mix.sass( resources/assets/sass/app.sass ,  public/css )\n   .sass( resources/assets/sass/admin.sass ,  public/css/admin );", 
            "title": "Sass"
        }, 
        {
            "location": "/mix/#plain-css", 
            "text": "If you would just like to combine some plain CSS stylesheets into a single file, you may use the  combine  method. This method also supports concatenating JavaScript files:  mix.combine([\n     public/css/vendor/normalize.css ,\n     public/css/vendor/videojs.css \n],  public/css/all.css );", 
            "title": "Plain CSS"
        }, 
        {
            "location": "/mix/#source-maps", 
            "text": "Though disabled by default, source maps may be activated by calling the  mix.sourceMaps()  method in your  webpack.mix.js  file. Though it comes with a compile/performance cost, this will provide extra debugging information to your browser's developer tools when using compiled assets.  mix.js( resources/assets/js/app.js ,  public/js )\n   .sourceMaps();", 
            "title": "Source Maps"
        }, 
        {
            "location": "/mix/#working-with-javascript", 
            "text": "Mix provides several features to help you work with your JavaScript files, such as compiling ECMAScript 2015, module bundling, minification, and simply concatenating plain JavaScript files. Even better, this all works seamlessly, without requiring an ounce of custom configuration:  mix.js( resources/assets/js/app.js ,  public/js );  With this single line of code, you may now take advantage of:  \n- ES2015 syntax.\n- Compilation of `.vue` files.\n- Minification for production environments.", 
            "title": "Working With JavaScript"
        }, 
        {
            "location": "/mix/#code-splitting", 
            "text": "One potential downside to bundling all application-specific JavaScript with your vendor libraries is that it makes long-term caching more difficult. For example, a single update to your application code will force the browser to re-download all of your vendor libraries even if they haven't changed.  If you intend to make frequent updates to your application's JavaScript, you should consider extracting all of your vendor libraries into their file. This way, a change to your application code will not affect the caching of your large  vendor.js  file. Mix's  extract  method makes this a breeze:  mix.js( resources/assets/js/app.js ,  public/js )\n   .extract([ vue ])  The  extract  method accepts an array of all libraries or modules that you wish to extract into a  vendor.js  file. Using the above snippet as an example, Mix will generate the following files:  \n- `public/js/manifest.js`: *The Webpack manifest runtime*\n- `public/js/vendor.js`: *Your vendor libraries*\n- `public/js/app.js`: *Your application code*  To avoid JavaScript errors, be sure to load these files in the proper order:  script   src= /js/manifest.js /script  script   src= /js/vendor.js /script  script   src= /js/app.js /script", 
            "title": "Code Splitting"
        }, 
        {
            "location": "/mix/#custom-webpack-configuration", 
            "text": "Behind the scenes, Laravel Mix references a pre-configured  webpack.config.js  file to get you up and running as quickly as possible. Occasionally, you may need to manually modify this file. You might have a special loader or plugin that needs to be referenced, or maybe you prefer to use Stylus instead of Sass. In such instances, you have two choices:", 
            "title": "Custom Webpack Configuration"
        }, 
        {
            "location": "/mix/#merging", 
            "text": "Mix provides a useful  webpackConfig  method that allows you to merge any short Webpack configuration overrides. This is a particularly appealing choice, as it doesn't require you to copy and maintain your own copy of the  webpack.config.js  file. The  webpackConfig  method accepts an object, which should contain any  Webpack-specific configuration  that you wish to apply.  mix.webpackConfig({\n    resolve: {\n        modules: [\n            path.resolve(__dirname,  vendor/laravel/spark/resources/assets/js )\n        ]\n    }\n});", 
            "title": "Merging"
        }, 
        {
            "location": "/mix/#reference-your-own-configuration", 
            "text": "A second option is to copy Mix's  webpack.config.js  into your project root.  cp node_modules/laravel-mix/setup/webpack.config.js ./  Next, you'll need to update the NPM scripts in your  package.json  to ensure that they no longer reference Mix's configuration file directly. Simply remove the  --config=\"node_modules/laravel-mix/setup/webpack.config.js\"  entry from the commands. Once this has been done, you may freely modify your configuration file as needed.", 
            "title": "Reference Your Own Configuration"
        }, 
        {
            "location": "/mix/#copying-files-directories", 
            "text": "The  copy  method may be used to copy files and directories to new locations. This can be useful when a particular asset within your  node_modules  directory needs to be relocated to your  public  folder.  mix.copy( node_modules/foo/bar.css ,  public/css/bar.css );", 
            "title": "Copying Files &amp; Directories"
        }, 
        {
            "location": "/mix/#versioning-cache-busting", 
            "text": "Many developers suffix their compiled assets with a timestamp or unique token to force browsers to load the fresh assets instead of serving stale copies of the code. Mix can handle this for you using the  version  method.  The  version  method will automatically append a unique hash to the filenames of all compiled files, allowing for more convenient cache busting:  mix.js( resources/assets/js/app.js ,  public/js )\n   .version();  After generating the versioned file, you won't know the exact file name. So, you should use Laravel's global  mix  function within your  views  to load the appropriately hashed asset. The  mix  function will automatically determine the current name of the hashed file:  link rel= stylesheet  href= {{   mix ( /css/app.css )   }}   Because versioned files are usually unnecessary in development, you may wish to instruct the versioning process to only run during  npm run production :  mix.js( resources/assets/js/app.js ,  public/js );\n\nif (mix.config.inProduction) {\n    mix.version();\n}", 
            "title": "Versioning / Cache Busting"
        }, 
        {
            "location": "/mix/#notifications", 
            "text": "When available, Mix will automatically display OS notifications for each bundle. This will give you instant feedback, as to whether the compilation was successful or not. However, there may be instances when you'd prefer to disable these notifications. One such example might be triggering Mix on your production server. Notifications may be deactivated, via the  disableNotifications  method.  mix.disableNotifications();", 
            "title": "Notifications"
        }, 
        {
            "location": "/mocking/", 
            "text": "Mocking\n\n\n\n\nIntroduction\n\n\nBus Fake\n\n\nEvent Fake\n\n\nMail Fake\n\n\nNotification Fake\n\n\nQueue Fake\n\n\nFacades\n\n\n\n\n\n\nIntroduction\n\n\nWhen testing Laravel applications, you may wish to \"mock\" certain aspects of your application so they are not actually executed during a given test. For example, when testing a controller that dispatches an event, you may wish to mock the event listeners so they are not actually executed during the test. This allows you to only test the controller's HTTP response without worrying about the execution of the event listeners, since the event listeners can be tested in their own test case.\n\n\nLaravel provides helpers for mocking events, jobs, and facades out of the box. These helpers primarily provide a convenience layer over Mockery so you do not have to manually make complicated Mockery method calls. Of course, you are free to use \nMockery\n or PHPUnit to create your own mocks or spies.\n\n\n\n\nBus Fake\n\n\nAs an alternative to mocking, you may use the \nBus\n facade's \nfake\n method to prevent jobs from being dispatched. When using fakes, assertions are made after the code under test is executed:\n\n\n?\nphp\n\n\n\nnamespace\n \nTests\n\\\nFeature\n;\n\n\n\nuse\n \nTests\n\\\nTestCase\n;\n\n\nuse\n \nApp\n\\\nJobs\n\\\nShipOrder\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nBus\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nWithoutMiddleware\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseMigrations\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseTransactions\n;\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \npublic\n \nfunction\n \ntestOrderShipping\n()\n\n    \n{\n\n        \nBus\n::\nfake\n();\n\n\n        \n// Perform order shipping...\n\n\n        \nBus\n::\nassertDispatched\n(\nShipOrder\n::\nclass\n,\n \nfunction\n \n(\n$job\n)\n \nuse\n \n(\n$order\n)\n \n{\n\n            \nreturn\n \n$job\n-\norder\n-\nid\n \n===\n \n$order\n-\nid\n;\n\n        \n});\n\n\n        \n// Assert a job was not dispatched...\n\n        \nBus\n::\nassertNotDispatched\n(\nAnotherJob\n::\nclass\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nEvent Fake\n\n\nAs an alternative to mocking, you may use the \nEvent\n facade's \nfake\n method to prevent all event listeners from executing. You may then assert that events were dispatched and even inspect the data they received. When using fakes, assertions are made after the code under test is executed:\n\n\n?\nphp\n\n\n\nnamespace\n \nTests\n\\\nFeature\n;\n\n\n\nuse\n \nTests\n\\\nTestCase\n;\n\n\nuse\n \nApp\n\\\nEvents\n\\\nOrderShipped\n;\n\n\nuse\n \nApp\n\\\nEvents\n\\\nOrderFailedToShip\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nEvent\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nWithoutMiddleware\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseMigrations\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseTransactions\n;\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \n/**\n\n\n     * Test order shipping.\n\n\n     */\n\n    \npublic\n \nfunction\n \ntestOrderShipping\n()\n\n    \n{\n\n        \nEvent\n::\nfake\n();\n\n\n        \n// Perform order shipping...\n\n\n        \nEvent\n::\nassertDispatched\n(\nOrderShipped\n::\nclass\n,\n \nfunction\n \n(\n$e\n)\n \nuse\n \n(\n$order\n)\n \n{\n\n            \nreturn\n \n$e\n-\norder\n-\nid\n \n===\n \n$order\n-\nid\n;\n\n        \n});\n\n\n        \nEvent\n::\nassertNotDispatched\n(\nOrderFailedToShip\n::\nclass\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nMail Fake\n\n\nYou may use the \nMail\n facade's \nfake\n method to prevent mail from being sent. You may then assert that \nmailables\n were sent to users and even inspect the data they received. When using fakes, assertions are made after the code under test is executed:\n\n\n?\nphp\n\n\n\nnamespace\n \nTests\n\\\nFeature\n;\n\n\n\nuse\n \nTests\n\\\nTestCase\n;\n\n\nuse\n \nApp\n\\\nMail\n\\\nOrderShipped\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nMail\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nWithoutMiddleware\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseMigrations\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseTransactions\n;\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \npublic\n \nfunction\n \ntestOrderShipping\n()\n\n    \n{\n\n        \nMail\n::\nfake\n();\n\n\n        \n// Perform order shipping...\n\n\n        \nMail\n::\nassertSent\n(\nOrderShipped\n::\nclass\n,\n \nfunction\n \n(\n$mail\n)\n \nuse\n \n(\n$order\n)\n \n{\n\n            \nreturn\n \n$mail\n-\norder\n-\nid\n \n===\n \n$order\n-\nid\n;\n\n        \n});\n\n\n        \n// Assert a message was sent to the given users...\n\n        \nMail\n::\nassertSent\n(\nOrderShipped\n::\nclass\n,\n \nfunction\n \n(\n$mail\n)\n \nuse\n \n(\n$user\n)\n \n{\n\n            \nreturn\n \n$mail\n-\nhasTo\n(\n$user\n-\nemail\n)\n \n\n                   \n$mail\n-\nhasCc\n(\n...\n)\n \n\n                   \n$mail\n-\nhasBcc\n(\n...\n);\n\n        \n});\n\n\n        \n// Assert a mailable was not sent...\n\n        \nMail\n::\nassertNotSent\n(\nAnotherMailable\n::\nclass\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nNotification Fake\n\n\nYou may use the \nNotification\n facade's \nfake\n method to prevent notifications from being sent. You may then assert that \nnotifications\n were sent to users and even inspect the data they received. When using fakes, assertions are made after the code under test is executed:\n\n\n?\nphp\n\n\n\nnamespace\n \nTests\n\\\nFeature\n;\n\n\n\nuse\n \nTests\n\\\nTestCase\n;\n\n\nuse\n \nApp\n\\\nNotifications\n\\\nOrderShipped\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nNotification\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nWithoutMiddleware\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseMigrations\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseTransactions\n;\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \npublic\n \nfunction\n \ntestOrderShipping\n()\n\n    \n{\n\n        \nNotification\n::\nfake\n();\n\n\n        \n// Perform order shipping...\n\n\n        \nNotification\n::\nassertSentTo\n(\n\n            \n$user\n,\n\n            \nOrderShipped\n::\nclass\n,\n\n            \nfunction\n \n(\n$notification\n,\n \n$channels\n)\n \nuse\n \n(\n$order\n)\n \n{\n\n                \nreturn\n \n$notification\n-\norder\n-\nid\n \n===\n \n$order\n-\nid\n;\n\n            \n}\n\n        \n);\n\n\n        \n// Assert a notification was sent to the given users...\n\n        \nNotification\n::\nassertSentTo\n(\n\n            \n[\n$user\n],\n \nOrderShipped\n::\nclass\n\n        \n);\n\n\n        \n// Assert a notification was not sent...\n\n        \nNotification\n::\nassertNotSentTo\n(\n\n            \n[\n$user\n],\n \nAnotherNotification\n::\nclass\n\n        \n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nQueue Fake\n\n\nAs an alternative to mocking, you may use the \nQueue\n facade's \nfake\n method to prevent jobs from being queued. You may then assert that jobs were pushed to the queue and even inspect the data they received. When using fakes, assertions are made after the code under test is executed:\n\n\n?\nphp\n\n\n\nnamespace\n \nTests\n\\\nFeature\n;\n\n\n\nuse\n \nTests\n\\\nTestCase\n;\n\n\nuse\n \nApp\n\\\nJobs\n\\\nShipOrder\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nQueue\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nWithoutMiddleware\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseMigrations\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseTransactions\n;\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \npublic\n \nfunction\n \ntestOrderShipping\n()\n\n    \n{\n\n        \nQueue\n::\nfake\n();\n\n\n        \n// Perform order shipping...\n\n\n        \nQueue\n::\nassertPushed\n(\nShipOrder\n::\nclass\n,\n \nfunction\n \n(\n$job\n)\n \nuse\n \n(\n$order\n)\n \n{\n\n            \nreturn\n \n$job\n-\norder\n-\nid\n \n===\n \n$order\n-\nid\n;\n\n        \n});\n\n\n        \n// Assert a job was pushed to a given queue...\n\n        \nQueue\n::\nassertPushedOn\n(\nqueue-name\n,\n \nShipOrder\n::\nclass\n);\n\n\n        \n// Assert a job was not pushed...\n\n        \nQueue\n::\nassertNotPushed\n(\nAnotherJob\n::\nclass\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nFacades\n\n\nUnlike traditional static method calls, \nfacades\n may be mocked. This provides a great advantage over traditional static methods and grants you the same testability you would have if you were using dependency injection. When testing, you may often want to mock a call to a Laravel facade in one of your controllers. For example, consider the following controller action:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nCache\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Show a list of all users of the application.\n\n\n     *\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nindex\n()\n\n    \n{\n\n        \n$value\n \n=\n \nCache\n::\nget\n(\nkey\n);\n\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nWe can mock the call to the \nCache\n facade by using the \nshouldReceive\n method, which will return an instance of a \nMockery\n mock. Since facades are actually resolved and managed by the Laravel \nservice container\n, they have much more testability than a typical static class. For example, let's mock our call to the \nCache\n facade's \nget\n method:\n\n\n?\nphp\n\n\n\nnamespace\n \nTests\n\\\nFeature\n;\n\n\n\nuse\n \nTests\n\\\nTestCase\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nCache\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nWithoutMiddleware\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseMigrations\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseTransactions\n;\n\n\n\nclass\n \nUserControllerTest\n \nextends\n \nTestCase\n\n\n{\n\n    \npublic\n \nfunction\n \ntestGetIndex\n()\n\n    \n{\n\n        \nCache\n::\nshouldReceive\n(\nget\n)\n\n                    \n-\nonce\n()\n\n                    \n-\nwith\n(\nkey\n)\n\n                    \n-\nandReturn\n(\nvalue\n);\n\n\n        \n$response\n \n=\n \n$this\n-\nget\n(\n/users\n);\n\n\n        \n// ...\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n{note} You should not mock the \nRequest\n facade. Instead, pass the input you desire into the HTTP helper methods such as \nget\n and \npost\n when running your test. Likewise, instead of mocking the \nConfig\n facade, simply call the \nConfig::set\n method in your tests.", 
            "title": "Mocking"
        }, 
        {
            "location": "/mocking/#mocking", 
            "text": "Introduction  Bus Fake  Event Fake  Mail Fake  Notification Fake  Queue Fake  Facades", 
            "title": "Mocking"
        }, 
        {
            "location": "/mocking/#introduction", 
            "text": "When testing Laravel applications, you may wish to \"mock\" certain aspects of your application so they are not actually executed during a given test. For example, when testing a controller that dispatches an event, you may wish to mock the event listeners so they are not actually executed during the test. This allows you to only test the controller's HTTP response without worrying about the execution of the event listeners, since the event listeners can be tested in their own test case.  Laravel provides helpers for mocking events, jobs, and facades out of the box. These helpers primarily provide a convenience layer over Mockery so you do not have to manually make complicated Mockery method calls. Of course, you are free to use  Mockery  or PHPUnit to create your own mocks or spies.", 
            "title": "Introduction"
        }, 
        {
            "location": "/mocking/#bus-fake", 
            "text": "As an alternative to mocking, you may use the  Bus  facade's  fake  method to prevent jobs from being dispatched. When using fakes, assertions are made after the code under test is executed:  ? php  namespace   Tests \\ Feature ;  use   Tests \\ TestCase ;  use   App \\ Jobs \\ ShipOrder ;  use   Illuminate \\ Support \\ Facades \\ Bus ;  use   Illuminate \\ Foundation \\ Testing \\ WithoutMiddleware ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseMigrations ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseTransactions ;  class   ExampleTest   extends   TestCase  { \n     public   function   testOrderShipping () \n     { \n         Bus :: fake (); \n\n         // Perform order shipping... \n\n         Bus :: assertDispatched ( ShipOrder :: class ,   function   ( $job )   use   ( $order )   { \n             return   $job - order - id   ===   $order - id ; \n         }); \n\n         // Assert a job was not dispatched... \n         Bus :: assertNotDispatched ( AnotherJob :: class ); \n     }  }", 
            "title": "Bus Fake"
        }, 
        {
            "location": "/mocking/#event-fake", 
            "text": "As an alternative to mocking, you may use the  Event  facade's  fake  method to prevent all event listeners from executing. You may then assert that events were dispatched and even inspect the data they received. When using fakes, assertions are made after the code under test is executed:  ? php  namespace   Tests \\ Feature ;  use   Tests \\ TestCase ;  use   App \\ Events \\ OrderShipped ;  use   App \\ Events \\ OrderFailedToShip ;  use   Illuminate \\ Support \\ Facades \\ Event ;  use   Illuminate \\ Foundation \\ Testing \\ WithoutMiddleware ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseMigrations ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseTransactions ;  class   ExampleTest   extends   TestCase  { \n     /**       * Test order shipping.       */ \n     public   function   testOrderShipping () \n     { \n         Event :: fake (); \n\n         // Perform order shipping... \n\n         Event :: assertDispatched ( OrderShipped :: class ,   function   ( $e )   use   ( $order )   { \n             return   $e - order - id   ===   $order - id ; \n         }); \n\n         Event :: assertNotDispatched ( OrderFailedToShip :: class ); \n     }  }", 
            "title": "Event Fake"
        }, 
        {
            "location": "/mocking/#mail-fake", 
            "text": "You may use the  Mail  facade's  fake  method to prevent mail from being sent. You may then assert that  mailables  were sent to users and even inspect the data they received. When using fakes, assertions are made after the code under test is executed:  ? php  namespace   Tests \\ Feature ;  use   Tests \\ TestCase ;  use   App \\ Mail \\ OrderShipped ;  use   Illuminate \\ Support \\ Facades \\ Mail ;  use   Illuminate \\ Foundation \\ Testing \\ WithoutMiddleware ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseMigrations ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseTransactions ;  class   ExampleTest   extends   TestCase  { \n     public   function   testOrderShipping () \n     { \n         Mail :: fake (); \n\n         // Perform order shipping... \n\n         Mail :: assertSent ( OrderShipped :: class ,   function   ( $mail )   use   ( $order )   { \n             return   $mail - order - id   ===   $order - id ; \n         }); \n\n         // Assert a message was sent to the given users... \n         Mail :: assertSent ( OrderShipped :: class ,   function   ( $mail )   use   ( $user )   { \n             return   $mail - hasTo ( $user - email )   \n                    $mail - hasCc ( ... )   \n                    $mail - hasBcc ( ... ); \n         }); \n\n         // Assert a mailable was not sent... \n         Mail :: assertNotSent ( AnotherMailable :: class ); \n     }  }", 
            "title": "Mail Fake"
        }, 
        {
            "location": "/mocking/#notification-fake", 
            "text": "You may use the  Notification  facade's  fake  method to prevent notifications from being sent. You may then assert that  notifications  were sent to users and even inspect the data they received. When using fakes, assertions are made after the code under test is executed:  ? php  namespace   Tests \\ Feature ;  use   Tests \\ TestCase ;  use   App \\ Notifications \\ OrderShipped ;  use   Illuminate \\ Support \\ Facades \\ Notification ;  use   Illuminate \\ Foundation \\ Testing \\ WithoutMiddleware ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseMigrations ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseTransactions ;  class   ExampleTest   extends   TestCase  { \n     public   function   testOrderShipping () \n     { \n         Notification :: fake (); \n\n         // Perform order shipping... \n\n         Notification :: assertSentTo ( \n             $user , \n             OrderShipped :: class , \n             function   ( $notification ,   $channels )   use   ( $order )   { \n                 return   $notification - order - id   ===   $order - id ; \n             } \n         ); \n\n         // Assert a notification was sent to the given users... \n         Notification :: assertSentTo ( \n             [ $user ],   OrderShipped :: class \n         ); \n\n         // Assert a notification was not sent... \n         Notification :: assertNotSentTo ( \n             [ $user ],   AnotherNotification :: class \n         ); \n     }  }", 
            "title": "Notification Fake"
        }, 
        {
            "location": "/mocking/#queue-fake", 
            "text": "As an alternative to mocking, you may use the  Queue  facade's  fake  method to prevent jobs from being queued. You may then assert that jobs were pushed to the queue and even inspect the data they received. When using fakes, assertions are made after the code under test is executed:  ? php  namespace   Tests \\ Feature ;  use   Tests \\ TestCase ;  use   App \\ Jobs \\ ShipOrder ;  use   Illuminate \\ Support \\ Facades \\ Queue ;  use   Illuminate \\ Foundation \\ Testing \\ WithoutMiddleware ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseMigrations ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseTransactions ;  class   ExampleTest   extends   TestCase  { \n     public   function   testOrderShipping () \n     { \n         Queue :: fake (); \n\n         // Perform order shipping... \n\n         Queue :: assertPushed ( ShipOrder :: class ,   function   ( $job )   use   ( $order )   { \n             return   $job - order - id   ===   $order - id ; \n         }); \n\n         // Assert a job was pushed to a given queue... \n         Queue :: assertPushedOn ( queue-name ,   ShipOrder :: class ); \n\n         // Assert a job was not pushed... \n         Queue :: assertNotPushed ( AnotherJob :: class ); \n     }  }", 
            "title": "Queue Fake"
        }, 
        {
            "location": "/mocking/#facades", 
            "text": "Unlike traditional static method calls,  facades  may be mocked. This provides a great advantage over traditional static methods and grants you the same testability you would have if you were using dependency injection. When testing, you may often want to mock a call to a Laravel facade in one of your controllers. For example, consider the following controller action:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Support \\ Facades \\ Cache ;  class   UserController   extends   Controller  { \n     /**       * Show a list of all users of the application.       *       * @return Response       */ \n     public   function   index () \n     { \n         $value   =   Cache :: get ( key ); \n\n         // \n     }  }   We can mock the call to the  Cache  facade by using the  shouldReceive  method, which will return an instance of a  Mockery  mock. Since facades are actually resolved and managed by the Laravel  service container , they have much more testability than a typical static class. For example, let's mock our call to the  Cache  facade's  get  method:  ? php  namespace   Tests \\ Feature ;  use   Tests \\ TestCase ;  use   Illuminate \\ Support \\ Facades \\ Cache ;  use   Illuminate \\ Foundation \\ Testing \\ WithoutMiddleware ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseMigrations ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseTransactions ;  class   UserControllerTest   extends   TestCase  { \n     public   function   testGetIndex () \n     { \n         Cache :: shouldReceive ( get ) \n                     - once () \n                     - with ( key ) \n                     - andReturn ( value ); \n\n         $response   =   $this - get ( /users ); \n\n         // ... \n     }  }    {note} You should not mock the  Request  facade. Instead, pass the input you desire into the HTTP helper methods such as  get  and  post  when running your test. Likewise, instead of mocking the  Config  facade, simply call the  Config::set  method in your tests.", 
            "title": "Facades"
        }, 
        {
            "location": "/notifications/", 
            "text": "Notifications\n\n\n\n\nIntroduction\n\n\nCreating Notifications\n\n\nSending Notifications\n\n\nUsing The Notifiable Trait\n\n\nUsing The Notification Facade\n\n\nSpecifying Delivery Channels\n\n\nQueueing Notifications\n\n\n\n\n\n\nMail Notifications\n\n\nFormatting Mail Messages\n\n\nCustomizing The Recipient\n\n\nCustomizing The Subject\n\n\nCustomizing The Templates\n\n\n\n\n\n\nMarkdown Mail Notifications\n\n\nGenerating The Message\n\n\nWriting The Message\n\n\nCustomizing The Components\n\n\n\n\n\n\nDatabase Notifications\n\n\nPrerequisites\n\n\nFormatting Database Notifications\n\n\nAccessing The Notifications\n\n\nMarking Notifications As Read\n\n\n\n\n\n\nBroadcast Notifications\n\n\nPrerequisites\n\n\nFormatting Broadcast Notifications\n\n\nListening For Notifications\n\n\n\n\n\n\nSMS Notifications\n\n\nPrerequisites\n\n\nFormatting SMS Notifications\n\n\nCustomizing The \"From\" Number\n\n\nRouting SMS Notifications\n\n\n\n\n\n\nSlack Notifications\n\n\nPrerequisites\n\n\nFormatting Slack Notifications\n\n\nSlack Attachments\n\n\nRouting Slack Notifications\n\n\n\n\n\n\nNotification Events\n\n\nCustom Channels\n\n\n\n\n\n\nIntroduction\n\n\nIn addition to support for \nsending email\n, Laravel provides support for sending notifications across a variety of delivery channels, including mail, SMS (via \nNexmo\n), and \nSlack\n. Notifications may also be stored in a database so they may be displayed in your web interface.\n\n\nTypically, notifications should be short, informational messages that notify users of something that occurred in your application. For example, if you are writing a billing application, you might send an \"Invoice Paid\" notification to your users via the email and SMS channels.\n\n\n\n\nCreating Notifications\n\n\nIn Laravel, each notification is represented by a single class (typically stored in the \napp/Notifications\n directory). Don't worry if you don't see this directory in your application, it will be created for you when you run the \nmake:notification\n Artisan command:\n\n\nphp artisan make:notification InvoicePaid\n\n\n\n\n\nThis command will place a fresh notification class in your \napp/Notifications\n directory. Each notification class contains a \nvia\n method and a variable number of message building methods (such as \ntoMail\n or \ntoDatabase\n) that convert the notification to a message optimized for that particular channel.\n\n\n\n\nSending Notifications\n\n\n\n\nUsing The Notifiable Trait\n\n\nNotifications may be sent in two ways: using the \nnotify\n method of the \nNotifiable\n trait or using the \nNotification\n \nfacade\n. First, let's explore using the trait:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nNotifications\n\\\nNotifiable\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nAuth\n\\\nUser\n \nas\n \nAuthenticatable\n;\n\n\n\nclass\n \nUser\n \nextends\n \nAuthenticatable\n\n\n{\n\n    \nuse\n \nNotifiable\n;\n\n\n}\n\n\n\n\n\n\nThis trait is utilized by the default \nApp\\User\n model and contains one method that may be used to send notifications: \nnotify\n. The \nnotify\n method expects to receive a notification instance:\n\n\nuse App\\Notifications\\InvoicePaid;\n\n$user-\nnotify(new InvoicePaid($invoice));\n\n\n\n\n\n\n\n{tip} Remember, you may use the \nIlluminate\\Notifications\\Notifiable\n trait on any of your models. You are not limited to only including it on your \nUser\n model.\n\n\n\n\n\n\nUsing The Notification Facade\n\n\nAlternatively, you may send notifications via the \nNotification\n \nfacade\n. This is useful primarily when you need to send a notification to multiple notifiable entities such as a collection of users. To send notifications using the facade, pass all of the notifiable entities and the notification instance to the \nsend\n method:\n\n\nNotification\n::\nsend\n($\nusers\n,\n \nnew\n \nInvoicePaid\n($\ninvoice\n));\n\n\n\n\n\n\n\n\nSpecifying Delivery Channels\n\n\nEvery notification class has a \nvia\n method that determines on which channels the notification will be delivered. Out of the box, notifications may be sent on the \nmail\n, \ndatabase\n, \nbroadcast\n, \nnexmo\n, and \nslack\n channels.\n\n\n\n\n{tip} If you would like to use other delivery channels such as Telegram or Pusher, check out the community driven \nLaravel Notification Channels website\n.\n\n\n\n\nThe \nvia\n method receives a \n$notifiable\n instance, which will be an instance of the class to which the notification is being sent. You may use \n$notifiable\n to determine which channels the notification should be delivered on:\n\n\n/**\n\n\n * Get the notification\ns delivery channels.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return array\n\n\n */\n\npublic\n \nfunction\n \nvia\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \nreturn\n \n$\nnotifiable\n-\nprefers_sms\n \n?\n \n[\nnexmo\n]\n \n:\n \n[\nmail\n,\n \ndatabase\n];\n\n\n}\n\n\n\n\n\n\n\n\nQueueing Notifications\n\n\n\n\n{note} Before queueing notifications you should configure your queue and \nstart a worker\n.\n\n\n\n\nSending notifications can take time, especially if the channel needs an external API call to deliver the notification. To speed up your application's response time, let your notification be queued by adding the \nShouldQueue\n interface and \nQueueable\n trait to your class. The interface and trait are already imported for all notifications generated using \nmake:notification\n, so you may immediately add them to your notification class:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nNotifications\n;\n\n\n\nuse\n \nIlluminate\n\\\nBus\n\\\nQueueable\n;\n\n\nuse\n \nIlluminate\n\\\nNotifications\n\\\nNotification\n;\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nQueue\n\\\nShouldQueue\n;\n\n\n\nclass\n \nInvoicePaid\n \nextends\n \nNotification\n \nimplements\n \nShouldQueue\n\n\n{\n\n    \nuse\n \nQueueable\n;\n\n\n    \n// ...\n\n\n}\n\n\n\n\n\n\nOnce the \nShouldQueue\n interface has been added to your notification, you may send the notification like normal. Laravel will detect the \nShouldQueue\n interface on the class and automatically queue the delivery of the notification:\n\n\n$user-\nnotify(new InvoicePaid($invoice));\n\n\n\n\n\nIf you would like to delay the delivery of the notification, you may chain the \ndelay\n method onto your notification instantiation:\n\n\n$\nwhen\n \n=\n \nCarbon\n::\nnow\n()\n-\naddMinutes\n(\n10\n);\n\n\n\n$\nuser-\nnotify\n((\nnew\n \nInvoicePaid\n($\ninvoice\n))\n-\ndelay\n($\nwhen\n));\n\n\n\n\n\n\n\n\nMail Notifications\n\n\n\n\nFormatting Mail Messages\n\n\nIf a notification supports being sent as an email, you should define a \ntoMail\n method on the notification class. This method will receive a \n$notifiable\n entity and should return a \nIlluminate\\Notifications\\Messages\\MailMessage\n instance. Mail messages may contain lines of text as well as a \"call to action\". Let's take a look at an example \ntoMail\n method:\n\n\n/**\n\n\n * Get the mail representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n\n\n */\n\npublic\n \nfunction\n \ntoMail\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \n$\nurl\n \n=\n \nurl\n(\n/invoice/\n.\n$\nthis\n-\ninvoice\n-\nid\n)\n;\n\n\n\n    \nreturn\n \n(\nnew\n \nMailMessage\n)\n\n\n                \n-\ngreeting\n(\nHello!\n)\n\n\n                \n-\nline\n(\nOne of your invoices has been paid!\n)\n\n\n                \n-\naction\n(\nView Invoice\n,\n \n$\nurl\n)\n\n\n                \n-\nline\n(\nThank you for using our application!\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\n{tip} Note we are using \n$this-\ninvoice-\nid\n in our \nmessage\n method. You may pass any data your notification needs to generate its message into the notification's constructor.\n\n\n\n\nIn this example, we register a greeting, a line of text, a call to action, and then another line of text. These methods provided by the \nMailMessage\n object make it simple and fast to format small transactional emails. The mail channel will then translate the message components into a nice, responsive HTML email template with a plain-text counterpart. Here is an example of an email generated by the \nmail\n channel:\n\n\n\n\n\n\n{tip} When sending mail notifications, be sure to set the \nname\n value in your \nconfig/app.php\n configuration file. This value will be used in the header and footer of your mail notification messages.\n\n\n\n\nOther Notification Formatting Options\n\n\nInstead of defining the \"lines\" of text in the notification class, you may use the \nview\n method to specify a custom template that should be used to render the notification email:\n\n\n/**\n\n\n * Get the mail representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n\n\n */\n\npublic\n \nfunction\n \ntoMail\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \nreturn\n \n(\nnew\n \nMailMessage\n)-\nview\n(\n\n\n        \nemails.name\n,\n \n[\ninvoice\n \n=\n \n$\nthis\n-\ninvoice\n]\n\n\n    \n)\n;\n\n\n}\n\n\n\n\n\n\nIn addition, you may return a \nmailable object\n from the \ntoMail\n method:\n\n\nuse App\\Mail\\InvoicePaid as Mailable;\n\n/**\n * Get the mail representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return Mailable\n */\npublic function toMail($notifiable)\n{\n    return new Mailable($this-\ninvoice)-\nto($this-\nuser-\nemail);\n}\n\n\n\n\n\n\n\nError Messages\n\n\nSome notifications inform users of errors, such as a failed invoice payment. You may indicate that a mail message is regarding an error by calling the \nerror\n method when building your message. When using the \nerror\n method on a mail message, the call to action button will be red instead of blue:\n\n\n/**\n\n\n * Get the mail representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return \\Illuminate\\Notifications\\Message\n\n\n */\n\npublic\n \nfunction\n \ntoMail\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \nreturn\n \n(\nnew\n \nMailMessage\n)\n\n\n                \n-\nerror\n()\n\n\n                \n-\nsubject\n(\nNotification Subject\n)\n\n\n                \n-\nline\n(\n...\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nCustomizing The Recipient\n\n\nWhen sending notifications via the \nmail\n channel, the notification system will automatically look for an \nemail\n property on your notifiable entity. You may customize which email address is used to deliver the notification by defining a \nrouteNotificationForMail\n method on the entity:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nNotifications\n\\\nNotifiable\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nAuth\n\\\nUser\n \nas\n \nAuthenticatable\n;\n\n\n\nclass\n \nUser\n \nextends\n \nAuthenticatable\n\n\n{\n\n    \nuse\n \nNotifiable\n;\n\n\n    \n/**\n\n\n     * Route notifications for the mail channel.\n\n\n     *\n\n\n     * @return string\n\n\n     */\n\n    \npublic\n \nfunction\n \nrouteNotificationForMail\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nemail_address\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nCustomizing The Subject\n\n\nBy default, the email's subject is the class name of the notification formatted to \"title case\". So, if your notification class is named \nInvoicePaid\n, the email's subject will be \nInvoice Paid\n. If you would like to specify an explicit subject for the message, you may call the \nsubject\n method when building your message:\n\n\n/**\n\n\n * Get the mail representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n\n\n */\n\npublic\n \nfunction\n \ntoMail\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \nreturn\n \n(\nnew\n \nMailMessage\n)\n\n\n                \n-\nsubject\n(\nNotification Subject\n)\n\n\n                \n-\nline\n(\n...\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nCustomizing The Templates\n\n\nYou can modify the HTML and plain-text template used by mail notifications by publishing the notification package's resources. After running this command, the mail notification templates will be located in the \nresources/views/vendor/notifications\n directory:\n\n\nphp artisan vendor:publish --tag=laravel-notifications\n\n\n\n\n\n\n\nMarkdown Mail Notifications\n\n\nMarkdown mail notifications allow you to take advantage of the pre-built templates of mail notifications, while giving you more freedom to write longer, customized messages. Since the messages are written in Markdown, Laravel is able to render beautiful, responsive HTML templates for the messages while also automatically generating a plain-text counterpart.\n\n\n\n\nGenerating The Message\n\n\nTo generate a notification with a corresponding Markdown template, you may use the \n--markdown\n option of the \nmake:notification\n Artisan command:\n\n\nphp artisan make:notification InvoicePaid --markdown=mail.invoice.paid\n\n\n\n\n\nLike all other mail notifications, notifications that use Markdown templates should define a \ntoMail\n method on their notification class. However, instead of using the \nline\n and \naction\n methods to construct the notification, use the \nmarkdown\n method to specify the name of the Markdown template that should be used:\n\n\n/**\n\n\n * Get the mail representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return \\Illuminate\\Notifications\\Messages\\MailMessage\n\n\n */\n\npublic\n \nfunction\n \ntoMail\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \n$\nurl\n \n=\n \nurl\n(\n/invoice/\n.\n$\nthis\n-\ninvoice\n-\nid\n)\n;\n\n\n\n    \nreturn\n \n(\nnew\n \nMailMessage\n)\n\n\n                \n-\nsubject\n(\nInvoice Paid\n)\n\n\n                \n-\nmarkdown\n(\nmail.invoice.paid\n,\n \n[\nurl\n \n=\n \n$\nurl\n]\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nWriting The Message\n\n\nMarkdown mail notifications use a combination of Blade components and Markdown syntax which allow you to easily construct notifications while leveraging Laravel's pre-crafted notification components:\n\n\n@\ncomponent\n(\nmail\n::\nmessage\n)\n\n\n# Invoice Paid\n\n\n\nYour\n \ninvoice\n \nhas\n \nbeen\n \npaid\n!\n\n\n\n@\ncomponent\n(\nmail\n::\nbutton\n,\n \n[\nurl\n \n=\n \n$\nurl\n])\n\n\nView\n \nInvoice\n\n\n@\nendcomponent\n\n\n\nThanks\n,\nbr\n\n\n{{\n \nconfig\n(\napp\n.\nname\n)\n \n}}\n\n\n@\nendcomponent\n\n\n\n\n\n\nButton Component\n\n\nThe button component renders a centered button link. The component accepts two arguments, a \nurl\n and an optional \ncolor\n. Supported colors are \nblue\n, \ngreen\n, and \nred\n. You may add as many button components to a notification as you wish:\n\n\n@\ncomponent\n(\nmail\n::\nbutton\n,\n \n[\nurl\n \n=\n \n$\nurl\n,\n \ncolor\n \n=\n \ngreen\n])\n\n\nView\n \nInvoice\n\n\n@\nendcomponent\n\n\n\n\n\n\nPanel Component\n\n\nThe panel component renders the given block of text in a panel that has a slightly different background color than the rest of the notification. This allows you to draw attention to a given block of text:\n\n\n@\ncomponent\n(\nmail\n::\npanel\n)\n\n\nThis\n \nis\n \nthe\n \npanel\n \ncontent\n.\n\n\n@\nendcomponent\n\n\n\n\n\n\nTable Component\n\n\nThe table component allows you to transform a Markdown table into an HTML table. The component accepts the Markdown table as its content. Table column alignment is supported using the default Markdown table alignment syntax:\n\n\n@\ncomponent\n(\nmail\n::\ntable\n)\n\n\n|\n \nLaravel\n       \n|\n \nTable\n         \n|\n \nExample\n  \n|\n\n\n|\n \n-------------\n \n|:-------------:|\n \n--------:|\n\n\n|\n \nCol\n \n2\n \nis\n      \n|\n \nCentered\n      \n|\n \n$\n10\n      \n|\n\n\n|\n \nCol\n \n3\n \nis\n      \n|\n \nRight\n-\nAligned\n \n|\n \n$\n20\n      \n|\n\n\n@\nendcomponent\n\n\n\n\n\n\n\n\nCustomizing The Components\n\n\nYou may export all of the Markdown notification components to your own application for customization. To export the components, use the \nvendor:publish\n Artisan command to publish the \nlaravel-mail\n asset tag:\n\n\nphp artisan vendor:publish --tag=laravel-mail\n\n\n\n\n\nThis command will publish the Markdown mail components to the \nresources/views/vendor/mail\n directory. The \nmail\n directory will contain a \nhtml\n and a \nmarkdown\n directory, each containing their respective representations of every available component. You are free to customize these components however you like.\n\n\nCustomizing The CSS\n\n\nAfter exporting the components, the \nresources/views/vendor/mail/html/themes\n directory will contain a \ndefault.css\n file. You may customize the CSS in this file and your styles will automatically be in-lined within the HTML representations of your Markdown notifications.\n\n\n\n\n{tip} If you would like to build an entirely new theme for the Markdown components, simply write a new CSS file within the \nhtml/themes\n directory and change the \ntheme\n option of your \nmail\n configuration file.\n\n\n\n\n\n\nDatabase Notifications\n\n\n\n\nPrerequisites\n\n\nThe \ndatabase\n notification channel stores the notification information in a database table. This table will contain information such as the notification type as well as custom JSON data that describes the notification.\n\n\nYou can query the table to display the notifications in your application's user interface. But, before you can do that, you will need to create a database table to hold your notifications. You may use the \nnotifications:table\n command to generate a migration with the proper table schema:\n\n\nphp artisan notifications:table\n\nphp artisan migrate\n\n\n\n\n\n\n\nFormatting Database Notifications\n\n\nIf a notification supports being stored in a database table, you should define a \ntoDatabase\n or \ntoArray\n method on the notification class. This method will receive a \n$notifiable\n entity and should return a plain PHP array. The returned array will be encoded as JSON and stored in the \ndata\n column of your \nnotifications\n table. Let's take a look at an example \ntoArray\n method:\n\n\n/**\n\n\n * Get the array representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return array\n\n\n */\n\npublic\n \nfunction\n \ntoArray\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \nreturn\n \n[\n\n\n        \ninvoice_id\n \n=\n \n$\nthis\n-\ninvoice\n-\nid\n,\n\n\n        \namount\n \n=\n \n$\nthis\n-\ninvoice\n-\namount\n,\n\n\n    \n];\n\n\n}\n\n\n\n\n\n\ntoDatabase\n Vs. \ntoArray\n\n\nThe \ntoArray\n method is also used by the \nbroadcast\n channel to determine which data to broadcast to your JavaScript client. If you would like to have two different array representations for the \ndatabase\n and \nbroadcast\n channels, you should define a \ntoDatabase\n method instead of a \ntoArray\n method.\n\n\n\n\nAccessing The Notifications\n\n\nOnce notifications are stored in the database, you need a convenient way to access them from your notifiable entities. The \nIlluminate\\Notifications\\Notifiable\n trait, which is included on Laravel's default \nApp\\User\n model, includes a \nnotifications\n Eloquent relationship that returns the notifications for the entity. To fetch notifications, you may access this method like any other Eloquent relationship. By default, notifications will be sorted by the \ncreated_at\n timestamp:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\nforeach\n \n($\nuser-\nnotifications\n \nas\n \n$\nnotification\n)\n \n{\n\n    \necho\n \n$notification-\ntype\n;\n\n\n}\n\n\n\n\n\n\nIf you want to retrieve only the \"unread\" notifications, you may use the \nunreadNotifications\n relationship. Again, these notifications will be sorted by the \ncreated_at\n timestamp:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\nforeach\n \n($\nuser-\nunreadNotifications\n \nas\n \n$\nnotification\n)\n \n{\n\n    \necho\n \n$notification-\ntype\n;\n\n\n}\n\n\n\n\n\n\n\n\n{tip} To access your notifications from your JavaScript client, you should define a notification controller for your application which returns the notifications for a notifiable entity, such as the current user. You may then make an HTTP request to that controller's URI from your JavaScript client.\n\n\n\n\n\n\nMarking Notifications As Read\n\n\nTypically, you will want to mark a notification as \"read\" when a user views it. The \nIlluminate\\Notifications\\Notifiable\n trait provides a \nmarkAsRead\n method, which updates the \nread_at\n column on the notification's database record:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\nforeach\n \n($\nuser-\nunreadNotifications\n \nas\n \n$\nnotification\n)\n \n{\n\n    \n$notification-\nmarkAsRead()\n;\n\n\n}\n\n\n\n\n\n\nHowever, instead of looping through each notification, you may use the \nmarkAsRead\n method directly on a collection of notifications:\n\n\n$user-\nunreadNotifications-\nmarkAsRead();\n\n\n\n\n\nYou may also use a mass-update query to mark all of the notifications as read without retrieving them from the database:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\n$\nuser-\nunreadNotifications\n()\n-\nupdate\n(\n[\nread_at\n \n=\n \nCarbon\n::now\n()\n]\n);\n\n\n\n\n\n\nOf course, you may \ndelete\n the notifications to remove them from the table entirely:\n\n\n$user-\nnotifications()-\ndelete();\n\n\n\n\n\n\n\nBroadcast Notifications\n\n\n\n\nPrerequisites\n\n\nBefore broadcasting notifications, you should configure and be familiar with Laravel's \nevent broadcasting\n services. Event broadcasting provides a way to react to server-side fired Laravel events from your JavaScript client.\n\n\n\n\nFormatting Broadcast Notifications\n\n\nThe \nbroadcast\n channel broadcasts notifications using Laravel's \nevent broadcasting\n services, allowing your JavaScript client to catch notifications in realtime. If a notification supports broadcasting, you should define a \ntoBroadcast\n method on the notification class. This method will receive a \n$notifiable\n entity and should return a \nBroadcastMessage\n instance. The returned data will be encoded as JSON and broadcast to your JavaScript client. Let's take a look at an example \ntoBroadcast\n method:\n\n\nuse Illuminate\\Notifications\\Messages\\BroadcastMessage;\n\n/**\n * Get the broadcastable representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return BroadcastMessage\n */\npublic function toBroadcast($notifiable)\n{\n    return new BroadcastMessage([\n        \ninvoice_id\n =\n $this-\ninvoice-\nid,\n        \namount\n =\n $this-\ninvoice-\namount,\n    ]);\n}\n\n\n\n\n\nBroadcast Queue Configuration\n\n\nAll broadcast notifications are queued for broadcasting. If you would like to configure the queue connection or queue name that is used to the queue the broadcast operation, you may use the \nonConnection\n and \nonQueue\n methods of the \nBroadcastMessage\n:\n\n\nreturn new BroadcastMessage($data)\n                -\nonConnection(\nsqs\n)\n                -\nonQueue(\nbroadcasts\n);\n\n\n\n\n\n\n\n{tip} In addition to the data you specify, broadcast notifications will also contain a \ntype\n field containing the class name of the notification.\n\n\n\n\n\n\nListening For Notifications\n\n\nNotifications will broadcast on a private channel formatted using a \n{notifiable}.{id}\n convention. So, if you are sending a notification to a \nApp\\User\n instance with an ID of \n1\n, the notification will be broadcast on the \nApp.User.1\n private channel. When using \nLaravel Echo\n, you may easily listen for notifications on a channel using the \nnotification\n helper method:\n\n\nEcho.private(\nApp.User.\n + userId)\n    .notification((notification) =\n {\n        console.log(notification.type);\n    });\n\n\n\n\n\nCustomizing The Notification Channel\n\n\nIf you would like to customize which channels a notifiable entity receives its broadcast notifications on, you may define a \nreceivesBroadcastNotificationsOn\n method on the notifiable entity:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nNotifications\n\\\nNotifiable\n;\n\n\nuse\n \nIlluminate\n\\\nBroadcasting\n\\\nPrivateChannel\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nAuth\n\\\nUser\n \nas\n \nAuthenticatable\n;\n\n\n\nclass\n \nUser\n \nextends\n \nAuthenticatable\n\n\n{\n\n    \nuse\n \nNotifiable\n;\n\n\n    \n/**\n\n\n     * The channels the user receives notification broadcasts on.\n\n\n     *\n\n\n     * @return array\n\n\n     */\n\n    \npublic\n \nfunction\n \nreceivesBroadcastNotificationsOn\n()\n\n    \n{\n\n        \nreturn\n \n[\n\n            \nnew\n \nPrivateChannel\n(\nusers.\n.\n$this\n-\nid\n),\n\n        \n];\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nSMS Notifications\n\n\n\n\nPrerequisites\n\n\nSending SMS notifications in Laravel is powered by \nNexmo\n. Before you can send notifications via Nexmo, you need to install the \nnexmo/client\n Composer package and add a few configuration options to your \nconfig/services.php\n configuration file. You may copy the example configuration below to get started:\n\n\nnexmo\n =\n [\n    \nkey\n =\n env(\nNEXMO_KEY\n),\n    \nsecret\n =\n env(\nNEXMO_SECRET\n),\n    \nsms_from\n =\n \n15556666666\n,\n],\n\n\n\n\n\nThe \nsms_from\n option is the phone number that your SMS messages will be sent from. You should generate a phone number for your application in the Nexmo control panel.\n\n\n\n\nFormatting SMS Notifications\n\n\nIf a notification supports being sent as a SMS, you should define a \ntoNexmo\n method on the notification class. This method will receive a \n$notifiable\n entity and should return a \nIlluminate\\Notifications\\Messages\\NexmoMessage\n instance:\n\n\n/**\n\n\n * Get the Nexmo / SMS representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return NexmoMessage\n\n\n */\n\npublic\n \nfunction\n \ntoNexmo\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \nreturn\n \n(\nnew\n \nNexmoMessage\n)\n\n\n                \n-\ncontent\n(\nYour SMS message content\n)\n;\n\n\n}\n\n\n\n\n\n\nUnicode Content\n\n\nIf your SMS message will contain unicode characters, you should call the \nunicode\n method when constructing the \nNexmoMessage\n instance:\n\n\n/**\n\n\n * Get the Nexmo / SMS representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return NexmoMessage\n\n\n */\n\npublic\n \nfunction\n \ntoNexmo\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \nreturn\n \n(\nnew\n \nNexmoMessage\n)\n\n\n                \n-\ncontent\n(\nYour unicode message\n)\n\n\n                \n-\nunicode\n()\n;\n\n\n}\n\n\n\n\n\n\n\n\nCustomizing The \"From\" Number\n\n\nIf you would like to send some notifications from a phone number that is different from the phone number specified in your \nconfig/services.php\n file, you may use the \nfrom\n method on a \nNexmoMessage\n instance:\n\n\n/**\n\n\n * Get the Nexmo / SMS representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return NexmoMessage\n\n\n */\n\npublic\n \nfunction\n \ntoNexmo\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \nreturn\n \n(\nnew\n \nNexmoMessage\n)\n\n\n                \n-\ncontent\n(\nYour SMS message content\n)\n\n\n                \n-\nfrom\n(\n15554443333\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nRouting SMS Notifications\n\n\nWhen sending notifications via the \nnexmo\n channel, the notification system will automatically look for a \nphone_number\n attribute on the notifiable entity. If you would like to customize the phone number the notification is delivered to, define a \nrouteNotificationForNexmo\n method on the entity:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nNotifications\n\\\nNotifiable\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nAuth\n\\\nUser\n \nas\n \nAuthenticatable\n;\n\n\n\nclass\n \nUser\n \nextends\n \nAuthenticatable\n\n\n{\n\n    \nuse\n \nNotifiable\n;\n\n\n    \n/**\n\n\n     * Route notifications for the Nexmo channel.\n\n\n     *\n\n\n     * @return string\n\n\n     */\n\n    \npublic\n \nfunction\n \nrouteNotificationForNexmo\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nphone\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nSlack Notifications\n\n\n\n\nPrerequisites\n\n\nBefore you can send notifications via Slack, you must install the Guzzle HTTP library via Composer:\n\n\ncomposer require guzzlehttp/guzzle\n\n\n\n\n\nYou will also need to configure an \"Incoming Webhook\" integration for your Slack team. This integration will provide you with a URL you may use when \nrouting Slack notifications\n.\n\n\n\n\nFormatting Slack Notifications\n\n\nIf a notification supports being sent as a Slack message, you should define a \ntoSlack\n method on the notification class. This method will receive a \n$notifiable\n entity and should return a \nIlluminate\\Notifications\\Messages\\SlackMessage\n instance. Slack messages may contain text content as well as an \"attachment\" that formats additional text or an array of fields. Let's take a look at a basic \ntoSlack\n example:\n\n\n/**\n\n\n * Get the Slack representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return SlackMessage\n\n\n */\n\npublic\n \nfunction\n \ntoSlack\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \nreturn\n \n(\nnew\n \nSlackMessage\n)\n\n\n                \n-\ncontent\n(\nOne of your invoices has been paid!\n)\n;\n\n\n}\n\n\n\n\n\n\nIn this example we are just sending a single line of text to Slack, which will create a message that looks like the following:\n\n\n\n\nCustomizing The Sender \n Recipient\n\n\nYou may use the \nfrom\n and \nto\n methods to customize the sender and recipient. The \nfrom\n method accepts a username and emoji identifier, while the \nto\n method accepts a channel or username:\n\n\n/**\n\n\n * Get the Slack representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return SlackMessage\n\n\n */\n\npublic\n \nfunction\n \ntoSlack\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \nreturn\n \n(\nnew\n \nSlackMessage\n)\n\n\n                \n-\nfrom\n(\nGhost\n,\n \n:ghost:\n)\n\n\n                \n-\nto\n(\n#other\n)\n\n\n                \n-\ncontent\n(\nThis will be sent to #other\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nSlack Attachments\n\n\nYou may also add \"attachments\" to Slack messages. Attachments provide richer formatting options than simple text messages. In this example, we will send an error notification about an exception that occurred in an application, including a link to view more details about the exception:\n\n\n/**\n\n\n * Get the Slack representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return SlackMessage\n\n\n */\n\npublic\n \nfunction\n \ntoSlack\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \n$\nurl\n \n=\n \nurl\n(\n/exceptions/\n.\n$\nthis\n-\nexception\n-\nid\n)\n;\n\n\n\n    \nreturn\n \n(\nnew\n \nSlackMessage\n)\n\n\n                \n-\nerror\n()\n\n\n                \n-\ncontent\n(\nWhoops! Something went wrong.\n)\n\n\n                \n-\nattachment\n(\nfunction\n \n(\n$\nattachment\n)\n \nuse\n \n(\n$\nurl\n)\n \n{\n\n\n                    \n$\nattachment\n-\ntitle\n(\nException: File Not Found\n,\n \n$\nurl\n)\n\n\n                               \n-\ncontent\n(\nFile [background.jpg] was not found.\n)\n;\n\n\n                \n}\n)\n;\n\n\n}\n\n\n\n\n\n\nThe example above will generate a Slack message that looks like the following:\n\n\n\n\nAttachments also allow you to specify an array of data that should be presented to the user. The given data will be presented in a table-style format for easy reading:\n\n\n/**\n\n\n * Get the Slack representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return SlackMessage\n\n\n */\n\n\npublic\n \nfunction\n \ntoSlack\n(\n$\nnotifiable\n)\n\n\n{\n\n    \n$\nurl\n \n=\n \nurl\n(\n/invoices/\n.\n$\nthis-\ninvoice-\nid\n);\n\n\n    \nreturn\n \n(\nnew\n \nSlackMessage\n)\n\n                \n-\nsuccess\n()\n\n                \n-\ncontent\n(\nOne of your invoices has been paid!\n)\n\n                \n-\nattachment\n(\nfunction\n \n(\n$\nattachment\n)\n \nuse\n \n(\n$\nurl\n)\n \n{\n\n                    \n$\nattachment-\ntitle\n(\nInvoice 1322\n,\n \n$\nurl\n)\n\n                               \n-\nfields\n([\n\n                                    \nTitle\n \n=\n \nServer Expenses\n,\n\n                                    \nAmount\n \n=\n \n$1,234\n,\n\n                                    \nVia\n \n=\n \nAmerican Express\n,\n\n                                    \nWas Overdue\n \n=\n \n:-1:\n,\n\n                                \n]);\n\n                \n});\n\n\n}\n\n\n\n\n\n\nThe example above will create a Slack message that looks like the following:\n\n\n\n\nMarkdown Attachment Content\n\n\nIf some of your attachment fields contain Markdown, you may use the \nmarkdown\n method to instruct Slack to parse and display the given attachment fields as Markdown formatted text:\n\n\n/**\n\n\n * Get the Slack representation of the notification.\n\n\n *\n\n\n * @param  mixed  $notifiable\n\n\n * @return SlackMessage\n\n\n */\n\npublic\n \nfunction\n \ntoSlack\n(\n$\nnotifiable\n)\n\n\n{\n\n\n    \n$\nurl\n \n=\n \nurl\n(\n/exceptions/\n.\n$\nthis\n-\nexception\n-\nid\n)\n;\n\n\n\n    \nreturn\n \n(\nnew\n \nSlackMessage\n)\n\n\n                \n-\nerror\n()\n\n\n                \n-\ncontent\n(\nWhoops! Something went wrong.\n)\n\n\n                \n-\nattachment\n(\nfunction\n \n(\n$\nattachment\n)\n \nuse\n \n(\n$\nurl\n)\n \n{\n\n\n                    \n$\nattachment\n-\ntitle\n(\nException: File Not Found\n,\n \n$\nurl\n)\n\n\n                               \n-\ncontent\n(\nFile [background.jpg] was **not found**.\n)\n\n\n                               \n-\nmarkdown\n(\n[\ntitle\n,\n \ntext\n]\n)\n;\n\n\n                \n}\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nRouting Slack Notifications\n\n\nTo route Slack notifications to the proper location, define a \nrouteNotificationForSlack\n method on your notifiable entity. This should return the webhook URL to which the notification should be delivered. Webhook URLs may be generated by adding an \"Incoming Webhook\" service to your Slack team:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nNotifications\n\\\nNotifiable\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nAuth\n\\\nUser\n \nas\n \nAuthenticatable\n;\n\n\n\nclass\n \nUser\n \nextends\n \nAuthenticatable\n\n\n{\n\n    \nuse\n \nNotifiable\n;\n\n\n    \n/**\n\n\n     * Route notifications for the Slack channel.\n\n\n     *\n\n\n     * @return string\n\n\n     */\n\n    \npublic\n \nfunction\n \nrouteNotificationForSlack\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nslack_webhook_url\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nNotification Events\n\n\nWhen a notification is sent, the \nIlluminate\\Notifications\\Events\\NotificationSent\n event is fired by the notification system. This contains the \"notifiable\" entity and the notification instance itself. You may register listeners for this event in your \nEventServiceProvider\n:\n\n\n/**\n\n\n * The event listener mappings for the application.\n\n\n *\n\n\n * @var array\n\n\n */\n\nprotected\n \n$\nlisten\n \n=\n \n[\n\n\n    \nIlluminate\\Notifications\\Events\\NotificationSent\n \n=\n \n[\n\n\n        \nApp\\Listeners\\LogNotification\n,\n\n\n    \n]\n,\n\n\n];\n\n\n\n\n\n\n\n\n{tip} After registering listeners in your \nEventServiceProvider\n, use the \nevent:generate\n Artisan command to quickly generate listener classes.\n\n\n\n\nWithin an event listener, you may access the \nnotifiable\n, \nnotification\n, and \nchannel\n properties on the event to learn more about the notification recipient or the notification itself:\n\n\n/**\n\n\n * Handle the event.\n\n\n *\n\n\n * @param  NotificationSent  $event\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nhandle\n(\nNotificationSent\n \n$\nevent\n)\n\n\n{\n\n\n    \n//\n \n$\nevent\n-\nchannel\n\n\n    \n//\n \n$\nevent\n-\nnotifiable\n\n\n    \n//\n \n$\nevent\n-\nnotification\n\n\n}\n\n\n\n\n\n\n\n\nCustom Channels\n\n\nLaravel ships with a handful of notification channels, but you may want to write your own drivers to deliver notifications via other channels. Laravel makes it simple. To get started, define a class that contains a \nsend\n method. The method should receive two arguments: a \n$notifiable\n and a \n$notification\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nChannels\n;\n\n\n\nuse\n \nIlluminate\n\\\nNotifications\n\\\nNotification\n;\n\n\n\nclass\n \nVoiceChannel\n\n\n{\n\n    \n/**\n\n\n     * Send the given notification.\n\n\n     *\n\n\n     * @param  mixed  $notifiable\n\n\n     * @param  \\Illuminate\\Notifications\\Notification  $notification\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nsend\n(\n$notifiable\n,\n \nNotification\n \n$notification\n)\n\n    \n{\n\n        \n$message\n \n=\n \n$notification\n-\ntoVoice\n(\n$notifiable\n);\n\n\n        \n// Send notification to the $notifiable instance...\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOnce your notification channel class has been defined, you may simply return the class name from the \nvia\n method of any of your notifications:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nNotifications\n;\n\n\n\nuse\n \nIlluminate\n\\\nBus\n\\\nQueueable\n;\n\n\nuse\n \nApp\n\\\nChannels\n\\\nVoiceChannel\n;\n\n\nuse\n \nApp\n\\\nChannels\n\\\nMessages\n\\\nVoiceMessage\n;\n\n\nuse\n \nIlluminate\n\\\nNotifications\n\\\nNotification\n;\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nQueue\n\\\nShouldQueue\n;\n\n\n\nclass\n \nInvoicePaid\n \nextends\n \nNotification\n\n\n{\n\n    \nuse\n \nQueueable\n;\n\n\n    \n/**\n\n\n     * Get the notification channels.\n\n\n     *\n\n\n     * @param  mixed  $notifiable\n\n\n     * @return array|string\n\n\n     */\n\n    \npublic\n \nfunction\n \nvia\n(\n$notifiable\n)\n\n    \n{\n\n        \nreturn\n \n[\nVoiceChannel\n::\nclass\n];\n\n    \n}\n\n\n    \n/**\n\n\n     * Get the voice representation of the notification.\n\n\n     *\n\n\n     * @param  mixed  $notifiable\n\n\n     * @return VoiceMessage\n\n\n     */\n\n    \npublic\n \nfunction\n \ntoVoice\n(\n$notifiable\n)\n\n    \n{\n\n        \n// ...\n\n    \n}\n\n\n}", 
            "title": "Notifications"
        }, 
        {
            "location": "/notifications/#notifications", 
            "text": "Introduction  Creating Notifications  Sending Notifications  Using The Notifiable Trait  Using The Notification Facade  Specifying Delivery Channels  Queueing Notifications    Mail Notifications  Formatting Mail Messages  Customizing The Recipient  Customizing The Subject  Customizing The Templates    Markdown Mail Notifications  Generating The Message  Writing The Message  Customizing The Components    Database Notifications  Prerequisites  Formatting Database Notifications  Accessing The Notifications  Marking Notifications As Read    Broadcast Notifications  Prerequisites  Formatting Broadcast Notifications  Listening For Notifications    SMS Notifications  Prerequisites  Formatting SMS Notifications  Customizing The \"From\" Number  Routing SMS Notifications    Slack Notifications  Prerequisites  Formatting Slack Notifications  Slack Attachments  Routing Slack Notifications    Notification Events  Custom Channels", 
            "title": "Notifications"
        }, 
        {
            "location": "/notifications/#introduction", 
            "text": "In addition to support for  sending email , Laravel provides support for sending notifications across a variety of delivery channels, including mail, SMS (via  Nexmo ), and  Slack . Notifications may also be stored in a database so they may be displayed in your web interface.  Typically, notifications should be short, informational messages that notify users of something that occurred in your application. For example, if you are writing a billing application, you might send an \"Invoice Paid\" notification to your users via the email and SMS channels.", 
            "title": "Introduction"
        }, 
        {
            "location": "/notifications/#creating-notifications", 
            "text": "In Laravel, each notification is represented by a single class (typically stored in the  app/Notifications  directory). Don't worry if you don't see this directory in your application, it will be created for you when you run the  make:notification  Artisan command:  php artisan make:notification InvoicePaid  This command will place a fresh notification class in your  app/Notifications  directory. Each notification class contains a  via  method and a variable number of message building methods (such as  toMail  or  toDatabase ) that convert the notification to a message optimized for that particular channel.", 
            "title": "Creating Notifications"
        }, 
        {
            "location": "/notifications/#sending-notifications", 
            "text": "", 
            "title": "Sending Notifications"
        }, 
        {
            "location": "/notifications/#using-the-notifiable-trait", 
            "text": "Notifications may be sent in two ways: using the  notify  method of the  Notifiable  trait or using the  Notification   facade . First, let's explore using the trait:  ? php  namespace   App ;  use   Illuminate \\ Notifications \\ Notifiable ;  use   Illuminate \\ Foundation \\ Auth \\ User   as   Authenticatable ;  class   User   extends   Authenticatable  { \n     use   Notifiable ;  }   This trait is utilized by the default  App\\User  model and contains one method that may be used to send notifications:  notify . The  notify  method expects to receive a notification instance:  use App\\Notifications\\InvoicePaid;\n\n$user- notify(new InvoicePaid($invoice));   {tip} Remember, you may use the  Illuminate\\Notifications\\Notifiable  trait on any of your models. You are not limited to only including it on your  User  model.", 
            "title": "Using The Notifiable Trait"
        }, 
        {
            "location": "/notifications/#using-the-notification-facade", 
            "text": "Alternatively, you may send notifications via the  Notification   facade . This is useful primarily when you need to send a notification to multiple notifiable entities such as a collection of users. To send notifications using the facade, pass all of the notifiable entities and the notification instance to the  send  method:  Notification :: send ($ users ,   new   InvoicePaid ($ invoice ));", 
            "title": "Using The Notification Facade"
        }, 
        {
            "location": "/notifications/#specifying-delivery-channels", 
            "text": "Every notification class has a  via  method that determines on which channels the notification will be delivered. Out of the box, notifications may be sent on the  mail ,  database ,  broadcast ,  nexmo , and  slack  channels.   {tip} If you would like to use other delivery channels such as Telegram or Pusher, check out the community driven  Laravel Notification Channels website .   The  via  method receives a  $notifiable  instance, which will be an instance of the class to which the notification is being sent. You may use  $notifiable  to determine which channels the notification should be delivered on:  /**   * Get the notification s delivery channels.   *   * @param  mixed  $notifiable   * @return array   */ \npublic   function   via ( $ notifiable )  {       return   $ notifiable - prefers_sms   ?   [ nexmo ]   :   [ mail ,   database ];  }", 
            "title": "Specifying Delivery Channels"
        }, 
        {
            "location": "/notifications/#queueing-notifications", 
            "text": "{note} Before queueing notifications you should configure your queue and  start a worker .   Sending notifications can take time, especially if the channel needs an external API call to deliver the notification. To speed up your application's response time, let your notification be queued by adding the  ShouldQueue  interface and  Queueable  trait to your class. The interface and trait are already imported for all notifications generated using  make:notification , so you may immediately add them to your notification class:  ? php  namespace   App \\ Notifications ;  use   Illuminate \\ Bus \\ Queueable ;  use   Illuminate \\ Notifications \\ Notification ;  use   Illuminate \\ Contracts \\ Queue \\ ShouldQueue ;  class   InvoicePaid   extends   Notification   implements   ShouldQueue  { \n     use   Queueable ; \n\n     // ...  }   Once the  ShouldQueue  interface has been added to your notification, you may send the notification like normal. Laravel will detect the  ShouldQueue  interface on the class and automatically queue the delivery of the notification:  $user- notify(new InvoicePaid($invoice));  If you would like to delay the delivery of the notification, you may chain the  delay  method onto your notification instantiation:  $ when   =   Carbon :: now () - addMinutes ( 10 );  $ user- notify (( new   InvoicePaid ($ invoice )) - delay ($ when ));", 
            "title": "Queueing Notifications"
        }, 
        {
            "location": "/notifications/#mail-notifications", 
            "text": "", 
            "title": "Mail Notifications"
        }, 
        {
            "location": "/notifications/#formatting-mail-messages", 
            "text": "If a notification supports being sent as an email, you should define a  toMail  method on the notification class. This method will receive a  $notifiable  entity and should return a  Illuminate\\Notifications\\Messages\\MailMessage  instance. Mail messages may contain lines of text as well as a \"call to action\". Let's take a look at an example  toMail  method:  /**   * Get the mail representation of the notification.   *   * @param  mixed  $notifiable   * @return \\Illuminate\\Notifications\\Messages\\MailMessage   */ \npublic   function   toMail ( $ notifiable )  {       $ url   =   url ( /invoice/ . $ this - invoice - id ) ;       return   ( new   MailMessage )                   - greeting ( Hello! )                   - line ( One of your invoices has been paid! )                   - action ( View Invoice ,   $ url )                   - line ( Thank you for using our application! ) ;  }    {tip} Note we are using  $this- invoice- id  in our  message  method. You may pass any data your notification needs to generate its message into the notification's constructor.   In this example, we register a greeting, a line of text, a call to action, and then another line of text. These methods provided by the  MailMessage  object make it simple and fast to format small transactional emails. The mail channel will then translate the message components into a nice, responsive HTML email template with a plain-text counterpart. Here is an example of an email generated by the  mail  channel:    {tip} When sending mail notifications, be sure to set the  name  value in your  config/app.php  configuration file. This value will be used in the header and footer of your mail notification messages.", 
            "title": "Formatting Mail Messages"
        }, 
        {
            "location": "/notifications/#other-notification-formatting-options", 
            "text": "Instead of defining the \"lines\" of text in the notification class, you may use the  view  method to specify a custom template that should be used to render the notification email:  /**   * Get the mail representation of the notification.   *   * @param  mixed  $notifiable   * @return \\Illuminate\\Notifications\\Messages\\MailMessage   */ \npublic   function   toMail ( $ notifiable )  {       return   ( new   MailMessage )- view (           emails.name ,   [ invoice   =   $ this - invoice ]       ) ;  }   In addition, you may return a  mailable object  from the  toMail  method:  use App\\Mail\\InvoicePaid as Mailable;\n\n/**\n * Get the mail representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return Mailable\n */\npublic function toMail($notifiable)\n{\n    return new Mailable($this- invoice)- to($this- user- email);\n}", 
            "title": "Other Notification Formatting Options"
        }, 
        {
            "location": "/notifications/#error-messages", 
            "text": "Some notifications inform users of errors, such as a failed invoice payment. You may indicate that a mail message is regarding an error by calling the  error  method when building your message. When using the  error  method on a mail message, the call to action button will be red instead of blue:  /**   * Get the mail representation of the notification.   *   * @param  mixed  $notifiable   * @return \\Illuminate\\Notifications\\Message   */ \npublic   function   toMail ( $ notifiable )  {       return   ( new   MailMessage )                   - error ()                   - subject ( Notification Subject )                   - line ( ... ) ;  }", 
            "title": "Error Messages"
        }, 
        {
            "location": "/notifications/#customizing-the-recipient", 
            "text": "When sending notifications via the  mail  channel, the notification system will automatically look for an  email  property on your notifiable entity. You may customize which email address is used to deliver the notification by defining a  routeNotificationForMail  method on the entity:  ? php  namespace   App ;  use   Illuminate \\ Notifications \\ Notifiable ;  use   Illuminate \\ Foundation \\ Auth \\ User   as   Authenticatable ;  class   User   extends   Authenticatable  { \n     use   Notifiable ; \n\n     /**       * Route notifications for the mail channel.       *       * @return string       */ \n     public   function   routeNotificationForMail () \n     { \n         return   $this - email_address ; \n     }  }", 
            "title": "Customizing The Recipient"
        }, 
        {
            "location": "/notifications/#customizing-the-subject", 
            "text": "By default, the email's subject is the class name of the notification formatted to \"title case\". So, if your notification class is named  InvoicePaid , the email's subject will be  Invoice Paid . If you would like to specify an explicit subject for the message, you may call the  subject  method when building your message:  /**   * Get the mail representation of the notification.   *   * @param  mixed  $notifiable   * @return \\Illuminate\\Notifications\\Messages\\MailMessage   */ \npublic   function   toMail ( $ notifiable )  {       return   ( new   MailMessage )                   - subject ( Notification Subject )                   - line ( ... ) ;  }", 
            "title": "Customizing The Subject"
        }, 
        {
            "location": "/notifications/#customizing-the-templates", 
            "text": "You can modify the HTML and plain-text template used by mail notifications by publishing the notification package's resources. After running this command, the mail notification templates will be located in the  resources/views/vendor/notifications  directory:  php artisan vendor:publish --tag=laravel-notifications", 
            "title": "Customizing The Templates"
        }, 
        {
            "location": "/notifications/#markdown-mail-notifications", 
            "text": "Markdown mail notifications allow you to take advantage of the pre-built templates of mail notifications, while giving you more freedom to write longer, customized messages. Since the messages are written in Markdown, Laravel is able to render beautiful, responsive HTML templates for the messages while also automatically generating a plain-text counterpart.", 
            "title": "Markdown Mail Notifications"
        }, 
        {
            "location": "/notifications/#generating-the-message", 
            "text": "To generate a notification with a corresponding Markdown template, you may use the  --markdown  option of the  make:notification  Artisan command:  php artisan make:notification InvoicePaid --markdown=mail.invoice.paid  Like all other mail notifications, notifications that use Markdown templates should define a  toMail  method on their notification class. However, instead of using the  line  and  action  methods to construct the notification, use the  markdown  method to specify the name of the Markdown template that should be used:  /**   * Get the mail representation of the notification.   *   * @param  mixed  $notifiable   * @return \\Illuminate\\Notifications\\Messages\\MailMessage   */ \npublic   function   toMail ( $ notifiable )  {       $ url   =   url ( /invoice/ . $ this - invoice - id ) ;       return   ( new   MailMessage )                   - subject ( Invoice Paid )                   - markdown ( mail.invoice.paid ,   [ url   =   $ url ] ) ;  }", 
            "title": "Generating The Message"
        }, 
        {
            "location": "/notifications/#writing-the-message", 
            "text": "Markdown mail notifications use a combination of Blade components and Markdown syntax which allow you to easily construct notifications while leveraging Laravel's pre-crafted notification components:  @ component ( mail :: message )  # Invoice Paid  Your   invoice   has   been   paid !  @ component ( mail :: button ,   [ url   =   $ url ])  View   Invoice  @ endcomponent  Thanks , br  {{   config ( app . name )   }}  @ endcomponent", 
            "title": "Writing The Message"
        }, 
        {
            "location": "/notifications/#button-component", 
            "text": "The button component renders a centered button link. The component accepts two arguments, a  url  and an optional  color . Supported colors are  blue ,  green , and  red . You may add as many button components to a notification as you wish:  @ component ( mail :: button ,   [ url   =   $ url ,   color   =   green ])  View   Invoice  @ endcomponent", 
            "title": "Button Component"
        }, 
        {
            "location": "/notifications/#panel-component", 
            "text": "The panel component renders the given block of text in a panel that has a slightly different background color than the rest of the notification. This allows you to draw attention to a given block of text:  @ component ( mail :: panel )  This   is   the   panel   content .  @ endcomponent", 
            "title": "Panel Component"
        }, 
        {
            "location": "/notifications/#table-component", 
            "text": "The table component allows you to transform a Markdown table into an HTML table. The component accepts the Markdown table as its content. Table column alignment is supported using the default Markdown table alignment syntax:  @ component ( mail :: table )  |   Laravel         |   Table           |   Example    |  |   -------------   |:-------------:|   --------:|  |   Col   2   is        |   Centered        |   $ 10        |  |   Col   3   is        |   Right - Aligned   |   $ 20        |  @ endcomponent", 
            "title": "Table Component"
        }, 
        {
            "location": "/notifications/#customizing-the-components", 
            "text": "You may export all of the Markdown notification components to your own application for customization. To export the components, use the  vendor:publish  Artisan command to publish the  laravel-mail  asset tag:  php artisan vendor:publish --tag=laravel-mail  This command will publish the Markdown mail components to the  resources/views/vendor/mail  directory. The  mail  directory will contain a  html  and a  markdown  directory, each containing their respective representations of every available component. You are free to customize these components however you like.", 
            "title": "Customizing The Components"
        }, 
        {
            "location": "/notifications/#customizing-the-css", 
            "text": "After exporting the components, the  resources/views/vendor/mail/html/themes  directory will contain a  default.css  file. You may customize the CSS in this file and your styles will automatically be in-lined within the HTML representations of your Markdown notifications.   {tip} If you would like to build an entirely new theme for the Markdown components, simply write a new CSS file within the  html/themes  directory and change the  theme  option of your  mail  configuration file.", 
            "title": "Customizing The CSS"
        }, 
        {
            "location": "/notifications/#database-notifications", 
            "text": "", 
            "title": "Database Notifications"
        }, 
        {
            "location": "/notifications/#prerequisites", 
            "text": "The  database  notification channel stores the notification information in a database table. This table will contain information such as the notification type as well as custom JSON data that describes the notification.  You can query the table to display the notifications in your application's user interface. But, before you can do that, you will need to create a database table to hold your notifications. You may use the  notifications:table  command to generate a migration with the proper table schema:  php artisan notifications:table\n\nphp artisan migrate", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/notifications/#formatting-database-notifications", 
            "text": "If a notification supports being stored in a database table, you should define a  toDatabase  or  toArray  method on the notification class. This method will receive a  $notifiable  entity and should return a plain PHP array. The returned array will be encoded as JSON and stored in the  data  column of your  notifications  table. Let's take a look at an example  toArray  method:  /**   * Get the array representation of the notification.   *   * @param  mixed  $notifiable   * @return array   */ \npublic   function   toArray ( $ notifiable )  {       return   [           invoice_id   =   $ this - invoice - id ,           amount   =   $ this - invoice - amount ,       ];  }", 
            "title": "Formatting Database Notifications"
        }, 
        {
            "location": "/notifications/#todatabase-vs-toarray", 
            "text": "The  toArray  method is also used by the  broadcast  channel to determine which data to broadcast to your JavaScript client. If you would like to have two different array representations for the  database  and  broadcast  channels, you should define a  toDatabase  method instead of a  toArray  method.", 
            "title": "toDatabase Vs. toArray"
        }, 
        {
            "location": "/notifications/#accessing-the-notifications", 
            "text": "Once notifications are stored in the database, you need a convenient way to access them from your notifiable entities. The  Illuminate\\Notifications\\Notifiable  trait, which is included on Laravel's default  App\\User  model, includes a  notifications  Eloquent relationship that returns the notifications for the entity. To fetch notifications, you may access this method like any other Eloquent relationship. By default, notifications will be sorted by the  created_at  timestamp:  $ user   =   App \\ User :: find ( 1 );  foreach   ($ user- notifications   as   $ notification )   { \n     echo   $notification- type ;  }   If you want to retrieve only the \"unread\" notifications, you may use the  unreadNotifications  relationship. Again, these notifications will be sorted by the  created_at  timestamp:  $ user   =   App \\ User :: find ( 1 );  foreach   ($ user- unreadNotifications   as   $ notification )   { \n     echo   $notification- type ;  }    {tip} To access your notifications from your JavaScript client, you should define a notification controller for your application which returns the notifications for a notifiable entity, such as the current user. You may then make an HTTP request to that controller's URI from your JavaScript client.", 
            "title": "Accessing The Notifications"
        }, 
        {
            "location": "/notifications/#marking-notifications-as-read", 
            "text": "Typically, you will want to mark a notification as \"read\" when a user views it. The  Illuminate\\Notifications\\Notifiable  trait provides a  markAsRead  method, which updates the  read_at  column on the notification's database record:  $ user   =   App \\ User :: find ( 1 );  foreach   ($ user- unreadNotifications   as   $ notification )   { \n     $notification- markAsRead() ;  }   However, instead of looping through each notification, you may use the  markAsRead  method directly on a collection of notifications:  $user- unreadNotifications- markAsRead();  You may also use a mass-update query to mark all of the notifications as read without retrieving them from the database:  $ user   =   App \\ User :: find ( 1 );  $ user- unreadNotifications () - update ( [ read_at   =   Carbon ::now () ] );   Of course, you may  delete  the notifications to remove them from the table entirely:  $user- notifications()- delete();", 
            "title": "Marking Notifications As Read"
        }, 
        {
            "location": "/notifications/#broadcast-notifications", 
            "text": "", 
            "title": "Broadcast Notifications"
        }, 
        {
            "location": "/notifications/#prerequisites_1", 
            "text": "Before broadcasting notifications, you should configure and be familiar with Laravel's  event broadcasting  services. Event broadcasting provides a way to react to server-side fired Laravel events from your JavaScript client.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/notifications/#formatting-broadcast-notifications", 
            "text": "The  broadcast  channel broadcasts notifications using Laravel's  event broadcasting  services, allowing your JavaScript client to catch notifications in realtime. If a notification supports broadcasting, you should define a  toBroadcast  method on the notification class. This method will receive a  $notifiable  entity and should return a  BroadcastMessage  instance. The returned data will be encoded as JSON and broadcast to your JavaScript client. Let's take a look at an example  toBroadcast  method:  use Illuminate\\Notifications\\Messages\\BroadcastMessage;\n\n/**\n * Get the broadcastable representation of the notification.\n *\n * @param  mixed  $notifiable\n * @return BroadcastMessage\n */\npublic function toBroadcast($notifiable)\n{\n    return new BroadcastMessage([\n         invoice_id  =  $this- invoice- id,\n         amount  =  $this- invoice- amount,\n    ]);\n}", 
            "title": "Formatting Broadcast Notifications"
        }, 
        {
            "location": "/notifications/#broadcast-queue-configuration", 
            "text": "All broadcast notifications are queued for broadcasting. If you would like to configure the queue connection or queue name that is used to the queue the broadcast operation, you may use the  onConnection  and  onQueue  methods of the  BroadcastMessage :  return new BroadcastMessage($data)\n                - onConnection( sqs )\n                - onQueue( broadcasts );   {tip} In addition to the data you specify, broadcast notifications will also contain a  type  field containing the class name of the notification.", 
            "title": "Broadcast Queue Configuration"
        }, 
        {
            "location": "/notifications/#listening-for-notifications", 
            "text": "Notifications will broadcast on a private channel formatted using a  {notifiable}.{id}  convention. So, if you are sending a notification to a  App\\User  instance with an ID of  1 , the notification will be broadcast on the  App.User.1  private channel. When using  Laravel Echo , you may easily listen for notifications on a channel using the  notification  helper method:  Echo.private( App.User.  + userId)\n    .notification((notification) =  {\n        console.log(notification.type);\n    });", 
            "title": "Listening For Notifications"
        }, 
        {
            "location": "/notifications/#customizing-the-notification-channel", 
            "text": "If you would like to customize which channels a notifiable entity receives its broadcast notifications on, you may define a  receivesBroadcastNotificationsOn  method on the notifiable entity:  ? php  namespace   App ;  use   Illuminate \\ Notifications \\ Notifiable ;  use   Illuminate \\ Broadcasting \\ PrivateChannel ;  use   Illuminate \\ Foundation \\ Auth \\ User   as   Authenticatable ;  class   User   extends   Authenticatable  { \n     use   Notifiable ; \n\n     /**       * The channels the user receives notification broadcasts on.       *       * @return array       */ \n     public   function   receivesBroadcastNotificationsOn () \n     { \n         return   [ \n             new   PrivateChannel ( users. . $this - id ), \n         ]; \n     }  }", 
            "title": "Customizing The Notification Channel"
        }, 
        {
            "location": "/notifications/#sms-notifications", 
            "text": "", 
            "title": "SMS Notifications"
        }, 
        {
            "location": "/notifications/#prerequisites_2", 
            "text": "Sending SMS notifications in Laravel is powered by  Nexmo . Before you can send notifications via Nexmo, you need to install the  nexmo/client  Composer package and add a few configuration options to your  config/services.php  configuration file. You may copy the example configuration below to get started:  nexmo  =  [\n     key  =  env( NEXMO_KEY ),\n     secret  =  env( NEXMO_SECRET ),\n     sms_from  =   15556666666 ,\n],  The  sms_from  option is the phone number that your SMS messages will be sent from. You should generate a phone number for your application in the Nexmo control panel.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/notifications/#formatting-sms-notifications", 
            "text": "If a notification supports being sent as a SMS, you should define a  toNexmo  method on the notification class. This method will receive a  $notifiable  entity and should return a  Illuminate\\Notifications\\Messages\\NexmoMessage  instance:  /**   * Get the Nexmo / SMS representation of the notification.   *   * @param  mixed  $notifiable   * @return NexmoMessage   */ \npublic   function   toNexmo ( $ notifiable )  {       return   ( new   NexmoMessage )                   - content ( Your SMS message content ) ;  }", 
            "title": "Formatting SMS Notifications"
        }, 
        {
            "location": "/notifications/#unicode-content", 
            "text": "If your SMS message will contain unicode characters, you should call the  unicode  method when constructing the  NexmoMessage  instance:  /**   * Get the Nexmo / SMS representation of the notification.   *   * @param  mixed  $notifiable   * @return NexmoMessage   */ \npublic   function   toNexmo ( $ notifiable )  {       return   ( new   NexmoMessage )                   - content ( Your unicode message )                   - unicode () ;  }", 
            "title": "Unicode Content"
        }, 
        {
            "location": "/notifications/#customizing-the-from-number", 
            "text": "If you would like to send some notifications from a phone number that is different from the phone number specified in your  config/services.php  file, you may use the  from  method on a  NexmoMessage  instance:  /**   * Get the Nexmo / SMS representation of the notification.   *   * @param  mixed  $notifiable   * @return NexmoMessage   */ \npublic   function   toNexmo ( $ notifiable )  {       return   ( new   NexmoMessage )                   - content ( Your SMS message content )                   - from ( 15554443333 ) ;  }", 
            "title": "Customizing The \"From\" Number"
        }, 
        {
            "location": "/notifications/#routing-sms-notifications", 
            "text": "When sending notifications via the  nexmo  channel, the notification system will automatically look for a  phone_number  attribute on the notifiable entity. If you would like to customize the phone number the notification is delivered to, define a  routeNotificationForNexmo  method on the entity:  ? php  namespace   App ;  use   Illuminate \\ Notifications \\ Notifiable ;  use   Illuminate \\ Foundation \\ Auth \\ User   as   Authenticatable ;  class   User   extends   Authenticatable  { \n     use   Notifiable ; \n\n     /**       * Route notifications for the Nexmo channel.       *       * @return string       */ \n     public   function   routeNotificationForNexmo () \n     { \n         return   $this - phone ; \n     }  }", 
            "title": "Routing SMS Notifications"
        }, 
        {
            "location": "/notifications/#slack-notifications", 
            "text": "", 
            "title": "Slack Notifications"
        }, 
        {
            "location": "/notifications/#prerequisites_3", 
            "text": "Before you can send notifications via Slack, you must install the Guzzle HTTP library via Composer:  composer require guzzlehttp/guzzle  You will also need to configure an \"Incoming Webhook\" integration for your Slack team. This integration will provide you with a URL you may use when  routing Slack notifications .", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/notifications/#formatting-slack-notifications", 
            "text": "If a notification supports being sent as a Slack message, you should define a  toSlack  method on the notification class. This method will receive a  $notifiable  entity and should return a  Illuminate\\Notifications\\Messages\\SlackMessage  instance. Slack messages may contain text content as well as an \"attachment\" that formats additional text or an array of fields. Let's take a look at a basic  toSlack  example:  /**   * Get the Slack representation of the notification.   *   * @param  mixed  $notifiable   * @return SlackMessage   */ \npublic   function   toSlack ( $ notifiable )  {       return   ( new   SlackMessage )                   - content ( One of your invoices has been paid! ) ;  }   In this example we are just sending a single line of text to Slack, which will create a message that looks like the following:", 
            "title": "Formatting Slack Notifications"
        }, 
        {
            "location": "/notifications/#customizing-the-sender-recipient", 
            "text": "You may use the  from  and  to  methods to customize the sender and recipient. The  from  method accepts a username and emoji identifier, while the  to  method accepts a channel or username:  /**   * Get the Slack representation of the notification.   *   * @param  mixed  $notifiable   * @return SlackMessage   */ \npublic   function   toSlack ( $ notifiable )  {       return   ( new   SlackMessage )                   - from ( Ghost ,   :ghost: )                   - to ( #other )                   - content ( This will be sent to #other ) ;  }", 
            "title": "Customizing The Sender &amp; Recipient"
        }, 
        {
            "location": "/notifications/#slack-attachments", 
            "text": "You may also add \"attachments\" to Slack messages. Attachments provide richer formatting options than simple text messages. In this example, we will send an error notification about an exception that occurred in an application, including a link to view more details about the exception:  /**   * Get the Slack representation of the notification.   *   * @param  mixed  $notifiable   * @return SlackMessage   */ \npublic   function   toSlack ( $ notifiable )  {       $ url   =   url ( /exceptions/ . $ this - exception - id ) ;       return   ( new   SlackMessage )                   - error ()                   - content ( Whoops! Something went wrong. )                   - attachment ( function   ( $ attachment )   use   ( $ url )   {                       $ attachment - title ( Exception: File Not Found ,   $ url )                                  - content ( File [background.jpg] was not found. ) ;                   } ) ;  }   The example above will generate a Slack message that looks like the following:   Attachments also allow you to specify an array of data that should be presented to the user. The given data will be presented in a table-style format for easy reading:  /**   * Get the Slack representation of the notification.   *   * @param  mixed  $notifiable   * @return SlackMessage   */  public   function   toSlack ( $ notifiable )  { \n     $ url   =   url ( /invoices/ . $ this- invoice- id ); \n\n     return   ( new   SlackMessage ) \n                 - success () \n                 - content ( One of your invoices has been paid! ) \n                 - attachment ( function   ( $ attachment )   use   ( $ url )   { \n                     $ attachment- title ( Invoice 1322 ,   $ url ) \n                                - fields ([ \n                                     Title   =   Server Expenses , \n                                     Amount   =   $1,234 , \n                                     Via   =   American Express , \n                                     Was Overdue   =   :-1: , \n                                 ]); \n                 });  }   The example above will create a Slack message that looks like the following:", 
            "title": "Slack Attachments"
        }, 
        {
            "location": "/notifications/#markdown-attachment-content", 
            "text": "If some of your attachment fields contain Markdown, you may use the  markdown  method to instruct Slack to parse and display the given attachment fields as Markdown formatted text:  /**   * Get the Slack representation of the notification.   *   * @param  mixed  $notifiable   * @return SlackMessage   */ \npublic   function   toSlack ( $ notifiable )  {       $ url   =   url ( /exceptions/ . $ this - exception - id ) ;       return   ( new   SlackMessage )                   - error ()                   - content ( Whoops! Something went wrong. )                   - attachment ( function   ( $ attachment )   use   ( $ url )   {                       $ attachment - title ( Exception: File Not Found ,   $ url )                                  - content ( File [background.jpg] was **not found**. )                                  - markdown ( [ title ,   text ] ) ;                   } ) ;  }", 
            "title": "Markdown Attachment Content"
        }, 
        {
            "location": "/notifications/#routing-slack-notifications", 
            "text": "To route Slack notifications to the proper location, define a  routeNotificationForSlack  method on your notifiable entity. This should return the webhook URL to which the notification should be delivered. Webhook URLs may be generated by adding an \"Incoming Webhook\" service to your Slack team:  ? php  namespace   App ;  use   Illuminate \\ Notifications \\ Notifiable ;  use   Illuminate \\ Foundation \\ Auth \\ User   as   Authenticatable ;  class   User   extends   Authenticatable  { \n     use   Notifiable ; \n\n     /**       * Route notifications for the Slack channel.       *       * @return string       */ \n     public   function   routeNotificationForSlack () \n     { \n         return   $this - slack_webhook_url ; \n     }  }", 
            "title": "Routing Slack Notifications"
        }, 
        {
            "location": "/notifications/#notification-events", 
            "text": "When a notification is sent, the  Illuminate\\Notifications\\Events\\NotificationSent  event is fired by the notification system. This contains the \"notifiable\" entity and the notification instance itself. You may register listeners for this event in your  EventServiceProvider :  /**   * The event listener mappings for the application.   *   * @var array   */ \nprotected   $ listen   =   [       Illuminate\\Notifications\\Events\\NotificationSent   =   [           App\\Listeners\\LogNotification ,       ] ,  ];    {tip} After registering listeners in your  EventServiceProvider , use the  event:generate  Artisan command to quickly generate listener classes.   Within an event listener, you may access the  notifiable ,  notification , and  channel  properties on the event to learn more about the notification recipient or the notification itself:  /**   * Handle the event.   *   * @param  NotificationSent  $event   * @return void   */ \npublic   function   handle ( NotificationSent   $ event )  {       //   $ event - channel       //   $ event - notifiable       //   $ event - notification  }", 
            "title": "Notification Events"
        }, 
        {
            "location": "/notifications/#custom-channels", 
            "text": "Laravel ships with a handful of notification channels, but you may want to write your own drivers to deliver notifications via other channels. Laravel makes it simple. To get started, define a class that contains a  send  method. The method should receive two arguments: a  $notifiable  and a  $notification :  ? php  namespace   App \\ Channels ;  use   Illuminate \\ Notifications \\ Notification ;  class   VoiceChannel  { \n     /**       * Send the given notification.       *       * @param  mixed  $notifiable       * @param  \\Illuminate\\Notifications\\Notification  $notification       * @return void       */ \n     public   function   send ( $notifiable ,   Notification   $notification ) \n     { \n         $message   =   $notification - toVoice ( $notifiable ); \n\n         // Send notification to the $notifiable instance... \n     }  }   Once your notification channel class has been defined, you may simply return the class name from the  via  method of any of your notifications:  ? php  namespace   App \\ Notifications ;  use   Illuminate \\ Bus \\ Queueable ;  use   App \\ Channels \\ VoiceChannel ;  use   App \\ Channels \\ Messages \\ VoiceMessage ;  use   Illuminate \\ Notifications \\ Notification ;  use   Illuminate \\ Contracts \\ Queue \\ ShouldQueue ;  class   InvoicePaid   extends   Notification  { \n     use   Queueable ; \n\n     /**       * Get the notification channels.       *       * @param  mixed  $notifiable       * @return array|string       */ \n     public   function   via ( $notifiable ) \n     { \n         return   [ VoiceChannel :: class ]; \n     } \n\n     /**       * Get the voice representation of the notification.       *       * @param  mixed  $notifiable       * @return VoiceMessage       */ \n     public   function   toVoice ( $notifiable ) \n     { \n         // ... \n     }  }", 
            "title": "Custom Channels"
        }, 
        {
            "location": "/packages/", 
            "text": "Package Development\n\n\n\n\nIntroduction\n\n\nA Note On Facades\n\n\n\n\n\n\nService Providers\n\n\nRouting\n\n\nResources\n\n\nConfiguration\n\n\nMigrations\n\n\nRoutes\n\n\nTranslations\n\n\nViews\n\n\n\n\n\n\nCommands\n\n\nPublic Assets\n\n\nPublishing File Groups\n\n\n\n\n\n\nIntroduction\n\n\nPackages are the primary way of adding functionality to Laravel. Packages might be anything from a great way to work with dates like \nCarbon\n, or an entire BDD testing framework like \nBehat\n.\n\n\nOf course, there are different types of packages. Some packages are stand-alone, meaning they work with any PHP framework. Carbon and Behat are examples of stand-alone packages. Any of these packages may be used with Laravel by simply requesting them in your \ncomposer.json\n file.\n\n\nOn the other hand, other packages are specifically intended for use with Laravel. These packages may have routes, controllers, views, and configuration specifically intended to enhance a Laravel application. This guide primarily covers the development of those packages that are Laravel specific.\n\n\n\n\nA Note On Facades\n\n\nWhen writing a Laravel application, it generally does not matter if you use contracts or facades since both provide essentially equal levels of testability. However, when writing packages, it is best to use \ncontracts\n instead of \nfacades\n. Since your package will not have access to all of Laravel's testing helpers, it will be easier to mock or stub a contract than to mock a facade.\n\n\n\n\nService Providers\n\n\nService providers\n are the connection points between your package and Laravel. A service provider is responsible for binding things into Laravel's \nservice container\n and informing Laravel where to load package resources such as views, configuration, and localization files.\n\n\nA service provider extends the \nIlluminate\\Support\\ServiceProvider\n class and contains two methods: \nregister\n and \nboot\n. The base \nServiceProvider\n class is located in the \nilluminate/support\n Composer package, which you should add to your own package's dependencies. To learn more about the structure and purpose of service providers, check out \ntheir documentation\n.\n\n\n\n\nRouting\n\n\nTo define routes for your package, pass the routes file path to the \nloadRoutesFrom\n method from within your package service provider's \nboot\n method. From within your routes file, you may use the \nIlluminate\\Support\\Facades\\Route\n facade to \nregister routes\n just as you would within a typical Laravel application:\n\n\n/**\n\n\n * Perform post-registration booting of services.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n\n    \n$\nthis\n-\nloadRoutesFrom\n(\n__DIR__\n.\n/path/to/routes.php\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nResources\n\n\n\n\nConfiguration\n\n\nTypically, you will need to publish your package's configuration file to the application's own \nconfig\n directory. This will allow users of your package to easily override your default configuration options. To allow your configuration files to be published, call the \npublishes\n method from the \nboot\n method of your service provider:\n\n\n/**\n\n\n * Perform post-registration booting of services.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n\n    \n$\nthis\n-\npublishes\n(\n[\n\n\n        \n__DIR__\n.\n/path/to/config/courier.php\n \n=\n \nconfig_path\n(\ncourier.php\n),\n\n\n    \n]\n)\n;\n\n\n}\n\n\n\n\n\n\nNow, when users of your package execute Laravel's \nvendor:publish\n command, your file will be copied to the specified publish location. Of course, once your configuration has been published, its values may be accessed like any other configuration file:\n\n\n$value = config(\ncourier.option\n);\n\n\n\n\n\n\n\n{note} You should not define Closures in your configuration files. They can not be serialized correctly when users execute the \nconfig:cache\n Artisan command.\n\n\n\n\nDefault Package Configuration\n\n\nYou may also merge your own package configuration file with the application's published copy. This will allow your users to define only the options they actually want to override in the published copy of the configuration. To merge the configurations, use the \nmergeConfigFrom\n method within your service provider's \nregister\n method:\n\n\n/**\n\n\n * Register bindings in the container.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nregister\n()\n\n\n{\n\n\n    \n$\nthis\n-\nmergeConfigFrom\n(\n\n\n        \n__DIR__\n.\n/path/to/config/courier.php\n,\n \ncourier\n\n\n    \n)\n;\n\n\n}\n\n\n\n\n\n\n\n\n{note} This method only merges the first level of the configuration array. If your users partially define a multi-dimensional configuration array, the missing options will not be merged.\n\n\n\n\n\n\nRoutes\n\n\nIf your package contains routes, you may load them using the \nloadRoutesFrom\n method. This method will automatically determine if the application's routes are cached and will not load your routes file if the routes have already been cached:\n\n\n/**\n\n\n * Perform post-registration booting of services.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n\n    \n$\nthis\n-\nloadRoutesFrom\n(\n__DIR__\n.\n/routes.php\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nMigrations\n\n\nIf your package contains \ndatabase migrations\n, you may use the \nloadMigrationsFrom\n method to inform Laravel how to load them. The \nloadMigrationsFrom\n method accepts the path to your package's migrations as its only argument:\n\n\n/**\n\n\n * Perform post-registration booting of services.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n\n    \n$\nthis\n-\nloadMigrationsFrom\n(\n__DIR__\n.\n/path/to/migrations\n)\n;\n\n\n}\n\n\n\n\n\n\nOnce your package's migrations have been registered, they will automatically be run when the \nphp artisan migrate\n command is executed. You do not need to export them to the application's main \ndatabase/migrations\n directory.\n\n\n\n\nTranslations\n\n\nIf your package contains \ntranslation files\n, you may use the \nloadTranslationsFrom\n method to inform Laravel how to load them. For example, if your package is named \ncourier\n, you should add the following to your service provider's \nboot\n method:\n\n\n/**\n\n\n * Perform post-registration booting of services.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n\n    \n$\nthis\n-\nloadTranslationsFrom\n(\n__DIR__\n.\n/path/to/translations\n,\n \ncourier\n)\n;\n\n\n}\n\n\n\n\n\n\nPackage translations are referenced using the \npackage::file.line\n syntax convention. So, you may load the \ncourier\n package's \nwelcome\n line from the \nmessages\n file like so:\n\n\necho\n \ntrans\n(\ncourier::messages.welcome\n);\n\n\n\n\n\n\nPublishing Translations\n\n\nIf you would like to publish your package's translations to the application's \nresources/lang/vendor\n directory, you may use the service provider's \npublishes\n method. The \npublishes\n method accepts an array of package paths and their desired publish locations. For example, to publish the translation files for the \ncourier\n package, you may do the following:\n\n\n/**\n\n\n * Perform post-registration booting of services.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n\n    \n$\nthis\n-\nloadTranslationsFrom\n(\n__DIR__\n.\n/path/to/translations\n,\n \ncourier\n)\n;\n\n\n\n    \n$\nthis\n-\npublishes\n(\n[\n\n\n        \n__DIR__\n.\n/path/to/translations\n \n=\n \nresource_path\n(\nlang/vendor/courier\n),\n\n\n    \n]\n)\n;\n\n\n}\n\n\n\n\n\n\nNow, when users of your package execute Laravel's \nvendor:publish\n Artisan command, your package's translations will be published to the specified publish location.\n\n\n\n\nViews\n\n\nTo register your package's \nviews\n with Laravel, you need to tell Laravel where the views are located. You may do this using the service provider's \nloadViewsFrom\n method. The \nloadViewsFrom\n method accepts two arguments: the path to your view templates and your package's name. For example, if your package's name is \ncourier\n, you would add the following to your service provider's \nboot\n method:\n\n\n/**\n\n\n * Perform post-registration booting of services.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n\n    \n$\nthis\n-\nloadViewsFrom\n(\n__DIR__\n.\n/path/to/views\n,\n \ncourier\n)\n;\n\n\n}\n\n\n\n\n\n\nPackage views are referenced using the \npackage::view\n syntax convention. So, once your view path is registered in a service provider, you may load the \nadmin\n view from the \ncourier\n package like so:\n\n\nRoute\n::\nget\n(\nadmin\n,\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \nview(\ncourier\n:\n:\nadmin\n);\n\n\n}\n);\n\n\n\n\n\n\nOverriding Package Views\n\n\nWhen you use the \nloadViewsFrom\n method, Laravel actually registers two locations for your views: the application's \nresources/views/vendor\n directory and the directory you specify. So, using the \ncourier\n example, Laravel will first check if a custom version of the view has been provided by the developer in \nresources/views/vendor/courier\n. Then, if the view has not been customized, Laravel will search the package view directory you specified in your call to \nloadViewsFrom\n. This makes it easy for package users to customize / override your package's views.\n\n\nPublishing Views\n\n\nIf you would like to make your views available for publishing to the application's \nresources/views/vendor\n directory, you may use the service provider's \npublishes\n method. The \npublishes\n method accepts an array of package view paths and their desired publish locations:\n\n\n/**\n\n\n * Perform post-registration booting of services.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n\n    \n$\nthis\n-\nloadViewsFrom\n(\n__DIR__\n.\n/path/to/views\n,\n \ncourier\n)\n;\n\n\n\n    \n$\nthis\n-\npublishes\n(\n[\n\n\n        \n__DIR__\n.\n/path/to/views\n \n=\n \nresource_path\n(\nviews/vendor/courier\n),\n\n\n    \n]\n)\n;\n\n\n}\n\n\n\n\n\n\nNow, when users of your package execute Laravel's \nvendor:publish\n Artisan command, your package's views will be copied to the specified publish location.\n\n\n\n\nCommands\n\n\nTo register your package's Artisan commands with Laravel, you may use the \ncommands\n method. This method expects an array of command class names. Once the commands have been registered, you may execute them using the \nArtisan CLI\n:\n\n\n/**\n\n\n * Bootstrap the application services.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n\n    \nif\n \n(\n$\nthis\n-\napp\n-\nrunningInConsole\n())\n \n{\n\n\n        \n$\nthis\n-\ncommands\n(\n[\n\n\n            \nFooCommand\n:\n:\nclass\n,\n\n\n            \nBarCommand\n:\n:\nclass\n,\n\n\n        \n]\n)\n;\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nPublic Assets\n\n\nYour package may have assets such as JavaScript, CSS, and images. To publish these assets to the application's \npublic\n directory, use the service provider's \npublishes\n method. In this example, we will also add a \npublic\n asset group tag, which may be used to publish groups of related assets:\n\n\n/**\n\n\n * Perform post-registration booting of services.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n\n    \n$\nthis\n-\npublishes\n(\n[\n\n\n        \n__DIR__\n.\n/path/to/assets\n \n=\n \npublic_path\n(\nvendor/courier\n),\n\n\n    \n]\n,\n \npublic\n)\n;\n\n\n}\n\n\n\n\n\n\nNow, when your package's users execute the \nvendor:publish\n command, your assets will be copied to the specified publish location. Since you will typically need to overwrite the assets every time the package is updated, you may use the \n--force\n flag:\n\n\nphp artisan vendor:publish --tag=public --force\n\n\n\n\n\n\n\nPublishing File Groups\n\n\nYou may want to publish groups of package assets and resources separately. For instance, you might want to allow your users to publish your package's configuration files without being forced to publish your package's assets. You may do this by \"tagging\" them when calling the \npublishes\n method from a package's service provider. For example, let's use tags to define two publish groups in the \nboot\n method of a package service provider:\n\n\n/**\n\n\n * Perform post-registration booting of services.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n\n    \n$\nthis\n-\npublishes\n(\n[\n\n\n        \n__DIR__\n.\n/../config/package.php\n \n=\n \nconfig_path\n(\npackage.php\n)\n\n\n    \n]\n,\n \nconfig\n)\n;\n\n\n\n    \n$\nthis\n-\npublishes\n(\n[\n\n\n        \n__DIR__\n.\n/../database/migrations/\n \n=\n \ndatabase_path\n(\nmigrations\n)\n\n\n    \n]\n,\n \nmigrations\n)\n;\n\n\n}\n\n\n\n\n\n\nNow your users may publish these groups separately by referencing their tag when executing the \nvendor:publish\n command:\n\n\nphp artisan vendor:publish --tag=config", 
            "title": "Packages"
        }, 
        {
            "location": "/packages/#package-development", 
            "text": "Introduction  A Note On Facades    Service Providers  Routing  Resources  Configuration  Migrations  Routes  Translations  Views    Commands  Public Assets  Publishing File Groups", 
            "title": "Package Development"
        }, 
        {
            "location": "/packages/#introduction", 
            "text": "Packages are the primary way of adding functionality to Laravel. Packages might be anything from a great way to work with dates like  Carbon , or an entire BDD testing framework like  Behat .  Of course, there are different types of packages. Some packages are stand-alone, meaning they work with any PHP framework. Carbon and Behat are examples of stand-alone packages. Any of these packages may be used with Laravel by simply requesting them in your  composer.json  file.  On the other hand, other packages are specifically intended for use with Laravel. These packages may have routes, controllers, views, and configuration specifically intended to enhance a Laravel application. This guide primarily covers the development of those packages that are Laravel specific.", 
            "title": "Introduction"
        }, 
        {
            "location": "/packages/#a-note-on-facades", 
            "text": "When writing a Laravel application, it generally does not matter if you use contracts or facades since both provide essentially equal levels of testability. However, when writing packages, it is best to use  contracts  instead of  facades . Since your package will not have access to all of Laravel's testing helpers, it will be easier to mock or stub a contract than to mock a facade.", 
            "title": "A Note On Facades"
        }, 
        {
            "location": "/packages/#service-providers", 
            "text": "Service providers  are the connection points between your package and Laravel. A service provider is responsible for binding things into Laravel's  service container  and informing Laravel where to load package resources such as views, configuration, and localization files.  A service provider extends the  Illuminate\\Support\\ServiceProvider  class and contains two methods:  register  and  boot . The base  ServiceProvider  class is located in the  illuminate/support  Composer package, which you should add to your own package's dependencies. To learn more about the structure and purpose of service providers, check out  their documentation .", 
            "title": "Service Providers"
        }, 
        {
            "location": "/packages/#routing", 
            "text": "To define routes for your package, pass the routes file path to the  loadRoutesFrom  method from within your package service provider's  boot  method. From within your routes file, you may use the  Illuminate\\Support\\Facades\\Route  facade to  register routes  just as you would within a typical Laravel application:  /**   * Perform post-registration booting of services.   *   * @return void   */ \npublic   function   boot ()  {       $ this - loadRoutesFrom ( __DIR__ . /path/to/routes.php ) ;  }", 
            "title": "Routing"
        }, 
        {
            "location": "/packages/#resources", 
            "text": "", 
            "title": "Resources"
        }, 
        {
            "location": "/packages/#configuration", 
            "text": "Typically, you will need to publish your package's configuration file to the application's own  config  directory. This will allow users of your package to easily override your default configuration options. To allow your configuration files to be published, call the  publishes  method from the  boot  method of your service provider:  /**   * Perform post-registration booting of services.   *   * @return void   */ \npublic   function   boot ()  {       $ this - publishes ( [           __DIR__ . /path/to/config/courier.php   =   config_path ( courier.php ),       ] ) ;  }   Now, when users of your package execute Laravel's  vendor:publish  command, your file will be copied to the specified publish location. Of course, once your configuration has been published, its values may be accessed like any other configuration file:  $value = config( courier.option );   {note} You should not define Closures in your configuration files. They can not be serialized correctly when users execute the  config:cache  Artisan command.", 
            "title": "Configuration"
        }, 
        {
            "location": "/packages/#default-package-configuration", 
            "text": "You may also merge your own package configuration file with the application's published copy. This will allow your users to define only the options they actually want to override in the published copy of the configuration. To merge the configurations, use the  mergeConfigFrom  method within your service provider's  register  method:  /**   * Register bindings in the container.   *   * @return void   */ \npublic   function   register ()  {       $ this - mergeConfigFrom (           __DIR__ . /path/to/config/courier.php ,   courier       ) ;  }    {note} This method only merges the first level of the configuration array. If your users partially define a multi-dimensional configuration array, the missing options will not be merged.", 
            "title": "Default Package Configuration"
        }, 
        {
            "location": "/packages/#routes", 
            "text": "If your package contains routes, you may load them using the  loadRoutesFrom  method. This method will automatically determine if the application's routes are cached and will not load your routes file if the routes have already been cached:  /**   * Perform post-registration booting of services.   *   * @return void   */ \npublic   function   boot ()  {       $ this - loadRoutesFrom ( __DIR__ . /routes.php ) ;  }", 
            "title": "Routes"
        }, 
        {
            "location": "/packages/#migrations", 
            "text": "If your package contains  database migrations , you may use the  loadMigrationsFrom  method to inform Laravel how to load them. The  loadMigrationsFrom  method accepts the path to your package's migrations as its only argument:  /**   * Perform post-registration booting of services.   *   * @return void   */ \npublic   function   boot ()  {       $ this - loadMigrationsFrom ( __DIR__ . /path/to/migrations ) ;  }   Once your package's migrations have been registered, they will automatically be run when the  php artisan migrate  command is executed. You do not need to export them to the application's main  database/migrations  directory.", 
            "title": "Migrations"
        }, 
        {
            "location": "/packages/#translations", 
            "text": "If your package contains  translation files , you may use the  loadTranslationsFrom  method to inform Laravel how to load them. For example, if your package is named  courier , you should add the following to your service provider's  boot  method:  /**   * Perform post-registration booting of services.   *   * @return void   */ \npublic   function   boot ()  {       $ this - loadTranslationsFrom ( __DIR__ . /path/to/translations ,   courier ) ;  }   Package translations are referenced using the  package::file.line  syntax convention. So, you may load the  courier  package's  welcome  line from the  messages  file like so:  echo   trans ( courier::messages.welcome );", 
            "title": "Translations"
        }, 
        {
            "location": "/packages/#publishing-translations", 
            "text": "If you would like to publish your package's translations to the application's  resources/lang/vendor  directory, you may use the service provider's  publishes  method. The  publishes  method accepts an array of package paths and their desired publish locations. For example, to publish the translation files for the  courier  package, you may do the following:  /**   * Perform post-registration booting of services.   *   * @return void   */ \npublic   function   boot ()  {       $ this - loadTranslationsFrom ( __DIR__ . /path/to/translations ,   courier ) ;       $ this - publishes ( [           __DIR__ . /path/to/translations   =   resource_path ( lang/vendor/courier ),       ] ) ;  }   Now, when users of your package execute Laravel's  vendor:publish  Artisan command, your package's translations will be published to the specified publish location.", 
            "title": "Publishing Translations"
        }, 
        {
            "location": "/packages/#views", 
            "text": "To register your package's  views  with Laravel, you need to tell Laravel where the views are located. You may do this using the service provider's  loadViewsFrom  method. The  loadViewsFrom  method accepts two arguments: the path to your view templates and your package's name. For example, if your package's name is  courier , you would add the following to your service provider's  boot  method:  /**   * Perform post-registration booting of services.   *   * @return void   */ \npublic   function   boot ()  {       $ this - loadViewsFrom ( __DIR__ . /path/to/views ,   courier ) ;  }   Package views are referenced using the  package::view  syntax convention. So, once your view path is registered in a service provider, you may load the  admin  view from the  courier  package like so:  Route :: get ( admin ,   function   ()   { \n     return   view( courier : : admin );  } );", 
            "title": "Views"
        }, 
        {
            "location": "/packages/#overriding-package-views", 
            "text": "When you use the  loadViewsFrom  method, Laravel actually registers two locations for your views: the application's  resources/views/vendor  directory and the directory you specify. So, using the  courier  example, Laravel will first check if a custom version of the view has been provided by the developer in  resources/views/vendor/courier . Then, if the view has not been customized, Laravel will search the package view directory you specified in your call to  loadViewsFrom . This makes it easy for package users to customize / override your package's views.", 
            "title": "Overriding Package Views"
        }, 
        {
            "location": "/packages/#publishing-views", 
            "text": "If you would like to make your views available for publishing to the application's  resources/views/vendor  directory, you may use the service provider's  publishes  method. The  publishes  method accepts an array of package view paths and their desired publish locations:  /**   * Perform post-registration booting of services.   *   * @return void   */ \npublic   function   boot ()  {       $ this - loadViewsFrom ( __DIR__ . /path/to/views ,   courier ) ;       $ this - publishes ( [           __DIR__ . /path/to/views   =   resource_path ( views/vendor/courier ),       ] ) ;  }   Now, when users of your package execute Laravel's  vendor:publish  Artisan command, your package's views will be copied to the specified publish location.", 
            "title": "Publishing Views"
        }, 
        {
            "location": "/packages/#commands", 
            "text": "To register your package's Artisan commands with Laravel, you may use the  commands  method. This method expects an array of command class names. Once the commands have been registered, you may execute them using the  Artisan CLI :  /**   * Bootstrap the application services.   *   * @return void   */ \npublic   function   boot ()  {       if   ( $ this - app - runningInConsole ())   {           $ this - commands ( [               FooCommand : : class ,               BarCommand : : class ,           ] ) ;       }  }", 
            "title": "Commands"
        }, 
        {
            "location": "/packages/#public-assets", 
            "text": "Your package may have assets such as JavaScript, CSS, and images. To publish these assets to the application's  public  directory, use the service provider's  publishes  method. In this example, we will also add a  public  asset group tag, which may be used to publish groups of related assets:  /**   * Perform post-registration booting of services.   *   * @return void   */ \npublic   function   boot ()  {       $ this - publishes ( [           __DIR__ . /path/to/assets   =   public_path ( vendor/courier ),       ] ,   public ) ;  }   Now, when your package's users execute the  vendor:publish  command, your assets will be copied to the specified publish location. Since you will typically need to overwrite the assets every time the package is updated, you may use the  --force  flag:  php artisan vendor:publish --tag=public --force", 
            "title": "Public Assets"
        }, 
        {
            "location": "/packages/#publishing-file-groups", 
            "text": "You may want to publish groups of package assets and resources separately. For instance, you might want to allow your users to publish your package's configuration files without being forced to publish your package's assets. You may do this by \"tagging\" them when calling the  publishes  method from a package's service provider. For example, let's use tags to define two publish groups in the  boot  method of a package service provider:  /**   * Perform post-registration booting of services.   *   * @return void   */ \npublic   function   boot ()  {       $ this - publishes ( [           __DIR__ . /../config/package.php   =   config_path ( package.php )       ] ,   config ) ;       $ this - publishes ( [           __DIR__ . /../database/migrations/   =   database_path ( migrations )       ] ,   migrations ) ;  }   Now your users may publish these groups separately by referencing their tag when executing the  vendor:publish  command:  php artisan vendor:publish --tag=config", 
            "title": "Publishing File Groups"
        }, 
        {
            "location": "/pagination/", 
            "text": "Pagination\n\n\n\n\nIntroduction\n\n\nBasic Usage\n\n\nPaginating Query Builder Results\n\n\nPaginating Eloquent Results\n\n\nManually Creating A Paginator\n\n\n\n\n\n\nDisplaying Pagination Results\n\n\nConverting Results To JSON\n\n\n\n\n\n\nCustomizing The Pagination View\n\n\nPaginator Instance Methods\n\n\n\n\n\n\nIntroduction\n\n\nIn other frameworks, pagination can be very painful. Laravel's paginator is integrated with the \nquery builder\n and \nEloquent ORM\n and provides convenient, easy-to-use pagination of database results out of the box. The HTML generated by the paginator is compatible with the \nBootstrap CSS framework\n.\n\n\n\n\nBasic Usage\n\n\n\n\nPaginating Query Builder Results\n\n\nThere are several ways to paginate items. The simplest is by using the \npaginate\n method on the \nquery builder\n or an \nEloquent query\n. The \npaginate\n method automatically takes care of setting the proper limit and offset based on the current page being viewed by the user. By default, the current page is detected by the value of the \npage\n query string argument on the HTTP request. Of course, this value is automatically detected by Laravel, and is also automatically inserted into links generated by the paginator.\n\n\nIn this example, the only argument passed to the \npaginate\n method is the number of items you would like displayed \"per page\". In this case, let's specify that we would like to display \n15\n items per page:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nDB\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Show all of the users for the application.\n\n\n     *\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nindex\n()\n\n    \n{\n\n        \n$users\n \n=\n \nDB\n::\ntable\n(\nusers\n)\n-\npaginate\n(\n15\n);\n\n\n        \nreturn\n \nview\n(\nuser.index\n,\n \n[\nusers\n \n=\n \n$users\n]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n{note} Currently, pagination operations that use a \ngroupBy\n statement cannot be executed efficiently by Laravel. If you need to use a \ngroupBy\n with a paginated result set, it is recommended that you query the database and create a paginator manually.\n\n\n\n\n\"Simple Pagination\"\n\n\nIf you only need to display simple \"Next\" and \"Previous\" links in your pagination view, you may use the \nsimplePaginate\n method to perform a more efficient query. This is very useful for large datasets when you do not need to display a link for each page number when rendering your view:\n\n\n$\nusers\n \n=\n \nDB\n::\ntable\n(\nusers\n)\n-\nsimplePaginate\n(\n15\n);\n\n\n\n\n\n\n\n\nPaginating Eloquent Results\n\n\nYou may also paginate \nEloquent\n queries. In this example, we will paginate the \nUser\n model with \n15\n items per page. As you can see, the syntax is nearly identical to paginating query builder results:\n\n\n$\nusers\n \n=\n \nApp\n\\\nUser\n::\npaginate\n(\n15\n);\n\n\n\n\n\n\nOf course, you may call \npaginate\n after setting other constraints on the query, such as \nwhere\n clauses:\n\n\n$\nusers\n \n=\n \nUser\n::\nwhere\n(\nvotes\n,\n \n,\n \n100\n)\n-\npaginate\n(\n15\n);\n\n\n\n\n\n\nYou may also use the \nsimplePaginate\n method when paginating Eloquent models:\n\n\n$\nusers\n \n=\n \nUser\n::\nwhere\n(\nvotes\n,\n \n,\n \n100\n)\n-\nsimplePaginate\n(\n15\n);\n\n\n\n\n\n\n\n\nManually Creating A Paginator\n\n\nSometimes you may wish to create a pagination instance manually, passing it an array of items. You may do so by creating either an \nIlluminate\\Pagination\\Paginator\n or \nIlluminate\\Pagination\\LengthAwarePaginator\n instance, depending on your needs.\n\n\nThe \nPaginator\n class does not need to know the total number of items in the result set; however, because of this, the class does not have methods for retrieving the index of the last page. The \nLengthAwarePaginator\n accepts almost the same arguments as the \nPaginator\n; however, it does require a count of the total number of items in the result set.\n\n\nIn other words, the \nPaginator\n corresponds to the \nsimplePaginate\n method on the query builder and Eloquent, while the \nLengthAwarePaginator\n corresponds to the \npaginate\n method.\n\n\n\n\n{note} When manually creating a paginator instance, you should manually \"slice\" the array of results you pass to the paginator. If you're unsure how to do this, check out the \narray_slice\n PHP function.\n\n\n\n\n\n\nDisplaying Pagination Results\n\n\nWhen calling the \npaginate\n method, you will receive an instance of \nIlluminate\\Pagination\\LengthAwarePaginator\n. When calling the \nsimplePaginate\n method, you will receive an instance of \nIlluminate\\Pagination\\Paginator\n. These objects provide several methods that describe the result set. In addition to these helpers methods, the paginator instances are iterators and may be looped as an array. So, once you have retrieved the results, you may display the results and render the page links using \nBlade\n:\n\n\ndiv\n \nclass\n=\ncontainer\n\n    \n@\nforeach\n \n(\n$\nusers\n \nas\n \n$\nuser\n)\n\n        \n{{\n \n$\nuser\n-\nname\n \n}}\n\n    \n@\nendforeach\n\n\n/\ndiv\n\n\n\n{{\n \n$\nusers\n-\nlinks\n()\n \n}}\n\n\n\n\n\n\nThe \nlinks\n method will render the links to the rest of the pages in the result set. Each of these links will already contain the proper \npage\n query string variable. Remember, the HTML generated by the \nlinks\n method is compatible with the \nBootstrap CSS framework\n.\n\n\nCustomizing The Paginator URI\n\n\nThe \nwithPath\n method allows you to customize the URI used by the paginator when generating links. For example, if you want the paginator to generate links like \nhttp://example.com/custom/url?page=N\n, you should pass \ncustom/url\n to the \nwithPath\n method:\n\n\nRoute\n::\nget\n(\nusers\n,\n \nfunction\n \n()\n \n{\n\n    \n$users\n \n=\n \nApp\\\nUser\n:\n:\npaginate\n(\n15\n);\n\n\n    \n$users-\nwithPath(\ncustom/url\n)\n;\n\n\n    \n//\n\n\n}\n);\n\n\n\n\n\n\nAppending To Pagination Links\n\n\nYou may append to the query string of pagination links using the \nappends\n method. For example, to append \nsort=votes\n to each pagination link, you should make the following call to \nappends\n:\n\n\n{{\n \n$\nusers-\nappends\n([\nsort\n \n=\n \nvotes\n])-\nlinks\n()\n \n}}\n\n\n\n\n\n\nIf you wish to append a \"hash fragment\" to the paginator's URLs, you may use the \nfragment\n method. For example, to append \n#foo\n to the end of each pagination link, make the following call to the \nfragment\n method:\n\n\n{{\n \n$\nusers-\nfragment\n(\nfoo\n)-\nlinks\n()\n \n}}\n\n\n\n\n\n\n\n\nConverting Results To JSON\n\n\nThe Laravel paginator result classes implement the \nIlluminate\\Contracts\\Support\\Jsonable\n Interface contract and expose the \ntoJson\n method, so it's very easy to convert your pagination results to JSON. You may also convert a paginator instance to JSON by simply returning it from a route or controller action:\n\n\nRoute\n::\nget\n(\nusers\n,\n \nfunction\n \n()\n \n{\n\n    \nreturn\n \nApp\\\nUser\n:\n:\npaginate\n();\n\n\n}\n);\n\n\n\n\n\n\nThe JSON from the paginator will include meta information such as \ntotal\n, \ncurrent_page\n, \nlast_page\n, and more. The actual result objects will be available via the \ndata\n key in the JSON array. Here is an example of the JSON created by returning a paginator instance from a route:\n\n\n{\n   \ntotal\n: 50,\n   \nper_page\n: 15,\n   \ncurrent_page\n: 1,\n   \nlast_page\n: 4,\n   \nnext_page_url\n: \nhttp://laravel.app?page=2\n,\n   \nprev_page_url\n: null,\n   \nfrom\n: 1,\n   \nto\n: 15,\n   \ndata\n:[\n        {\n            // Result Object\n        },\n        {\n            // Result Object\n        }\n   ]\n}\n\n\n\n\n\n\n\nCustomizing The Pagination View\n\n\nBy default, the views rendered to display the pagination links are compatible with the Bootstrap CSS framework. However, if you are not using Bootstrap, you are free to define your own views to render these links. When calling the \nlinks\n method on a paginator instance, pass the view name as the first argument to the method:\n\n\n{{\n \n$\npaginator-\nlinks\n(\nview.name\n)\n \n}}\n\n\n\n// Passing data to the view...\n\n\n{{\n \n$\npaginator-\nlinks\n(\nview.name\n,\n \n[\nfoo\n \n=\n \nbar\n])\n \n}}\n\n\n\n\n\n\nHowever, the easiest way to customize the pagination views is by exporting them to your \nresources/views/vendor\n directory using the \nvendor:publish\n command:\n\n\nphp artisan vendor:publish --tag=laravel-pagination\n\n\n\n\n\nThis command will place the views in the \nresources/views/vendor/pagination\n directory. The \ndefault.blade.php\n file within this directory corresponds to the default pagination view. Simply edit this file to modify the pagination HTML.\n\n\n\n\nPaginator Instance Methods\n\n\nEach paginator instance provides additional pagination information via the following methods:\n\n\n\n\n$results-\ncount()\n\n\n$results-\ncurrentPage()\n\n\n$results-\nfirstItem()\n\n\n$results-\nhasMorePages()\n\n\n$results-\nlastItem()\n\n\n$results-\nlastPage() (Not available when using simplePaginate)\n\n\n$results-\nnextPageUrl()\n\n\n$results-\nperPage()\n\n\n$results-\npreviousPageUrl()\n\n\n$results-\ntotal() (Not available when using simplePaginate)\n\n\n$results-\nurl($page)", 
            "title": "Pagination"
        }, 
        {
            "location": "/pagination/#pagination", 
            "text": "Introduction  Basic Usage  Paginating Query Builder Results  Paginating Eloquent Results  Manually Creating A Paginator    Displaying Pagination Results  Converting Results To JSON    Customizing The Pagination View  Paginator Instance Methods", 
            "title": "Pagination"
        }, 
        {
            "location": "/pagination/#introduction", 
            "text": "In other frameworks, pagination can be very painful. Laravel's paginator is integrated with the  query builder  and  Eloquent ORM  and provides convenient, easy-to-use pagination of database results out of the box. The HTML generated by the paginator is compatible with the  Bootstrap CSS framework .", 
            "title": "Introduction"
        }, 
        {
            "location": "/pagination/#basic-usage", 
            "text": "", 
            "title": "Basic Usage"
        }, 
        {
            "location": "/pagination/#paginating-query-builder-results", 
            "text": "There are several ways to paginate items. The simplest is by using the  paginate  method on the  query builder  or an  Eloquent query . The  paginate  method automatically takes care of setting the proper limit and offset based on the current page being viewed by the user. By default, the current page is detected by the value of the  page  query string argument on the HTTP request. Of course, this value is automatically detected by Laravel, and is also automatically inserted into links generated by the paginator.  In this example, the only argument passed to the  paginate  method is the number of items you would like displayed \"per page\". In this case, let's specify that we would like to display  15  items per page:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Support \\ Facades \\ DB ;  use   App \\ Http \\ Controllers \\ Controller ;  class   UserController   extends   Controller  { \n     /**       * Show all of the users for the application.       *       * @return Response       */ \n     public   function   index () \n     { \n         $users   =   DB :: table ( users ) - paginate ( 15 ); \n\n         return   view ( user.index ,   [ users   =   $users ]); \n     }  }    {note} Currently, pagination operations that use a  groupBy  statement cannot be executed efficiently by Laravel. If you need to use a  groupBy  with a paginated result set, it is recommended that you query the database and create a paginator manually.", 
            "title": "Paginating Query Builder Results"
        }, 
        {
            "location": "/pagination/#simple-pagination", 
            "text": "If you only need to display simple \"Next\" and \"Previous\" links in your pagination view, you may use the  simplePaginate  method to perform a more efficient query. This is very useful for large datasets when you do not need to display a link for each page number when rendering your view:  $ users   =   DB :: table ( users ) - simplePaginate ( 15 );", 
            "title": "\"Simple Pagination\""
        }, 
        {
            "location": "/pagination/#paginating-eloquent-results", 
            "text": "You may also paginate  Eloquent  queries. In this example, we will paginate the  User  model with  15  items per page. As you can see, the syntax is nearly identical to paginating query builder results:  $ users   =   App \\ User :: paginate ( 15 );   Of course, you may call  paginate  after setting other constraints on the query, such as  where  clauses:  $ users   =   User :: where ( votes ,   ,   100 ) - paginate ( 15 );   You may also use the  simplePaginate  method when paginating Eloquent models:  $ users   =   User :: where ( votes ,   ,   100 ) - simplePaginate ( 15 );", 
            "title": "Paginating Eloquent Results"
        }, 
        {
            "location": "/pagination/#manually-creating-a-paginator", 
            "text": "Sometimes you may wish to create a pagination instance manually, passing it an array of items. You may do so by creating either an  Illuminate\\Pagination\\Paginator  or  Illuminate\\Pagination\\LengthAwarePaginator  instance, depending on your needs.  The  Paginator  class does not need to know the total number of items in the result set; however, because of this, the class does not have methods for retrieving the index of the last page. The  LengthAwarePaginator  accepts almost the same arguments as the  Paginator ; however, it does require a count of the total number of items in the result set.  In other words, the  Paginator  corresponds to the  simplePaginate  method on the query builder and Eloquent, while the  LengthAwarePaginator  corresponds to the  paginate  method.   {note} When manually creating a paginator instance, you should manually \"slice\" the array of results you pass to the paginator. If you're unsure how to do this, check out the  array_slice  PHP function.", 
            "title": "Manually Creating A Paginator"
        }, 
        {
            "location": "/pagination/#displaying-pagination-results", 
            "text": "When calling the  paginate  method, you will receive an instance of  Illuminate\\Pagination\\LengthAwarePaginator . When calling the  simplePaginate  method, you will receive an instance of  Illuminate\\Pagination\\Paginator . These objects provide several methods that describe the result set. In addition to these helpers methods, the paginator instances are iterators and may be looped as an array. So, once you have retrieved the results, you may display the results and render the page links using  Blade :  div   class = container \n     @ foreach   ( $ users   as   $ user ) \n         {{   $ user - name   }} \n     @ endforeach  / div  {{   $ users - links ()   }}   The  links  method will render the links to the rest of the pages in the result set. Each of these links will already contain the proper  page  query string variable. Remember, the HTML generated by the  links  method is compatible with the  Bootstrap CSS framework .", 
            "title": "Displaying Pagination Results"
        }, 
        {
            "location": "/pagination/#customizing-the-paginator-uri", 
            "text": "The  withPath  method allows you to customize the URI used by the paginator when generating links. For example, if you want the paginator to generate links like  http://example.com/custom/url?page=N , you should pass  custom/url  to the  withPath  method:  Route :: get ( users ,   function   ()   { \n     $users   =   App\\ User : : paginate ( 15 ); \n\n     $users- withPath( custom/url ) ; \n\n     //  } );", 
            "title": "Customizing The Paginator URI"
        }, 
        {
            "location": "/pagination/#appending-to-pagination-links", 
            "text": "You may append to the query string of pagination links using the  appends  method. For example, to append  sort=votes  to each pagination link, you should make the following call to  appends :  {{   $ users- appends ([ sort   =   votes ])- links ()   }}   If you wish to append a \"hash fragment\" to the paginator's URLs, you may use the  fragment  method. For example, to append  #foo  to the end of each pagination link, make the following call to the  fragment  method:  {{   $ users- fragment ( foo )- links ()   }}", 
            "title": "Appending To Pagination Links"
        }, 
        {
            "location": "/pagination/#converting-results-to-json", 
            "text": "The Laravel paginator result classes implement the  Illuminate\\Contracts\\Support\\Jsonable  Interface contract and expose the  toJson  method, so it's very easy to convert your pagination results to JSON. You may also convert a paginator instance to JSON by simply returning it from a route or controller action:  Route :: get ( users ,   function   ()   { \n     return   App\\ User : : paginate ();  } );   The JSON from the paginator will include meta information such as  total ,  current_page ,  last_page , and more. The actual result objects will be available via the  data  key in the JSON array. Here is an example of the JSON created by returning a paginator instance from a route:  {\n    total : 50,\n    per_page : 15,\n    current_page : 1,\n    last_page : 4,\n    next_page_url :  http://laravel.app?page=2 ,\n    prev_page_url : null,\n    from : 1,\n    to : 15,\n    data :[\n        {\n            // Result Object\n        },\n        {\n            // Result Object\n        }\n   ]\n}", 
            "title": "Converting Results To JSON"
        }, 
        {
            "location": "/pagination/#customizing-the-pagination-view", 
            "text": "By default, the views rendered to display the pagination links are compatible with the Bootstrap CSS framework. However, if you are not using Bootstrap, you are free to define your own views to render these links. When calling the  links  method on a paginator instance, pass the view name as the first argument to the method:  {{   $ paginator- links ( view.name )   }}  // Passing data to the view...  {{   $ paginator- links ( view.name ,   [ foo   =   bar ])   }}   However, the easiest way to customize the pagination views is by exporting them to your  resources/views/vendor  directory using the  vendor:publish  command:  php artisan vendor:publish --tag=laravel-pagination  This command will place the views in the  resources/views/vendor/pagination  directory. The  default.blade.php  file within this directory corresponds to the default pagination view. Simply edit this file to modify the pagination HTML.", 
            "title": "Customizing The Pagination View"
        }, 
        {
            "location": "/pagination/#paginator-instance-methods", 
            "text": "Each paginator instance provides additional pagination information via the following methods:   $results- count()  $results- currentPage()  $results- firstItem()  $results- hasMorePages()  $results- lastItem()  $results- lastPage() (Not available when using simplePaginate)  $results- nextPageUrl()  $results- perPage()  $results- previousPageUrl()  $results- total() (Not available when using simplePaginate)  $results- url($page)", 
            "title": "Paginator Instance Methods"
        }, 
        {
            "location": "/passport/", 
            "text": "API Authentication (Passport)\n\n\n\n\nIntroduction\n\n\nInstallation\n\n\nFrontend Quickstart\n\n\n\n\n\n\nConfiguration\n\n\nToken Lifetimes\n\n\n\n\n\n\nIssuing Access Tokens\n\n\nManaging Clients\n\n\nRequesting Tokens\n\n\nRefreshing Tokens\n\n\n\n\n\n\nPassword Grant Tokens\n\n\nCreating A Password Grant Client\n\n\nRequesting Tokens\n\n\nRequesting All Scopes\n\n\n\n\n\n\nImplicit Grant Tokens\n\n\nClient Credentials Grant Tokens\n\n\nPersonal Access Tokens\n\n\nCreating A Personal Access Client\n\n\nManaging Personal Access Tokens\n\n\n\n\n\n\nProtecting Routes\n\n\nVia Middleware\n\n\nPassing The Access Token\n\n\n\n\n\n\nToken Scopes\n\n\nDefining Scopes\n\n\nAssigning Scopes To Tokens\n\n\nChecking Scopes\n\n\n\n\n\n\nConsuming Your API With JavaScript\n\n\nEvents\n\n\nTesting\n\n\n\n\n\n\nIntroduction\n\n\nLaravel already makes it easy to perform authentication via traditional login forms, but what about APIs? APIs typically use tokens to authenticate users and do not maintain session state between requests. Laravel makes API authentication a breeze using Laravel Passport, which provides a full OAuth2 server implementation for your Laravel application in a matter of minutes. Passport is built on top of the \nLeague OAuth2 server\n that is maintained by Alex Bilbie.\n\n\n\n\n{note} This documentation assumes you are already familiar with OAuth2. If you do not know anything about OAuth2, consider familiarizing yourself with the general terminology and features of OAuth2 before continuing.\n\n\n\n\n\n\nInstallation\n\n\nTo get started, install Passport via the Composer package manager:\n\n\ncomposer require laravel/passport\n\n\n\n\n\nNext, register the Passport service provider in the \nproviders\n array of your \nconfig/app.php\n configuration file:\n\n\nLaravel\\Passport\\PassportServiceProvider::class,\n\n\n\n\n\nThe Passport service provider registers its own database migration directory with the framework, so you should migrate your database after registering the provider. The Passport migrations will create the tables your application needs to store clients and access tokens:\n\n\nphp artisan migrate\n\n\n\n\n\n\n\n{note} If you are not going to use Passport's default migrations, you should call the \nPassport::ignoreMigrations\n method in the \nregister\n method of your \nAppServiceProvider\n. You may export the default migrations using \nphp artisan vendor:publish --tag=passport-migrations\n.\n\n\n\n\nNext, you should run the \npassport:install\n command. This command will create the encryption keys needed to generate secure access tokens. In addition, the command will create \"personal access\" and \"password grant\" clients which will be used to generate access tokens:\n\n\nphp artisan passport:install\n\n\n\n\n\nAfter running this command, add the \nLaravel\\Passport\\HasApiTokens\n trait to your \nApp\\User\n model. This trait will provide a few helper methods to your model which allow you to inspect the authenticated user's token and scopes:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nLaravel\n\\\nPassport\n\\\nHasApiTokens\n;\n\n\nuse\n \nIlluminate\n\\\nNotifications\n\\\nNotifiable\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nAuth\n\\\nUser\n \nas\n \nAuthenticatable\n;\n\n\n\nclass\n \nUser\n \nextends\n \nAuthenticatable\n\n\n{\n\n    \nuse\n \nHasApiTokens\n,\n \nNotifiable\n;\n\n\n}\n\n\n\n\n\n\nNext, you should call the \nPassport::routes\n method within the \nboot\n method of your \nAuthServiceProvider\n. This method will register the routes necessary to issue access tokens and revoke access tokens, clients, and personal access tokens:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nLaravel\n\\\nPassport\n\\\nPassport\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nGate\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nSupport\n\\\nProviders\n\\\nAuthServiceProvider\n \nas\n \nServiceProvider\n;\n\n\n\nclass\n \nAuthServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * The policy mappings for the application.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$policies\n \n=\n \n[\n\n        \nApp\\Model\n \n=\n \nApp\\Policies\\ModelPolicy\n,\n\n    \n];\n\n\n    \n/**\n\n\n     * Register any authentication / authorization services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \n$this\n-\nregisterPolicies\n();\n\n\n        \nPassport\n::\nroutes\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nFinally, in your \nconfig/auth.php\n configuration file, you should set the \ndriver\n option of the \napi\n authentication guard to \npassport\n. This will instruct your application to use Passport's \nTokenGuard\n when authenticating incoming API requests:\n\n\nguards\n =\n [\n    \nweb\n =\n [\n        \ndriver\n =\n \nsession\n,\n        \nprovider\n =\n \nusers\n,\n    ],\n\n    \napi\n =\n [\n        \ndriver\n =\n \npassport\n,\n        \nprovider\n =\n \nusers\n,\n    ],\n],\n\n\n\n\n\n\n\nFrontend Quickstart\n\n\n\n\n{note} In order to use the Passport Vue components, you must be using the \nVue\n JavaScript framework. These components also use the Bootstrap CSS framework. However, even if you are not using these tools, the components serve as a valuable reference for your own frontend implementation.\n\n\n\n\nPassport ships with a JSON API that you may use to allow your users to create clients and personal access tokens. However, it can be time consuming to code a frontend to interact with these APIs. So, Passport also includes pre-built \nVue\n components you may use as an example implementation or starting point for your own implementation.\n\n\nTo publish the Passport Vue components, use the \nvendor:publish\n Artisan command:\n\n\nphp artisan vendor:publish --tag=passport-components\n\n\n\n\n\nThe published components will be placed in your \nresources/assets/js/components\n directory. Once the components have been published, you should register them in your \nresources/assets/js/app.js\n file:\n\n\nVue.component(\n    \npassport-clients\n,\n    require(\n./components/passport/Clients.vue\n)\n);\n\nVue.component(\n    \npassport-authorized-clients\n,\n    require(\n./components/passport/AuthorizedClients.vue\n)\n);\n\nVue.component(\n    \npassport-personal-access-tokens\n,\n    require(\n./components/passport/PersonalAccessTokens.vue\n)\n);\n\n\n\n\n\nAfter registering the components, make sure to run \nnpm run dev\n to recompile your assets. Once you have recompiled your assets, you may drop the components into one of your application's templates to get started creating clients and personal access tokens:\n\n\npassport-clients\n/passport-clients\n\n\npassport-authorized-clients\n/passport-authorized-clients\n\n\npassport-personal-access-tokens\n/passport-personal-access-tokens\n\n\n\n\n\n\n\n\nConfiguration\n\n\n\n\nToken Lifetimes\n\n\nBy default, Passport issues long-lived access tokens that never need to be refreshed. If you would like to configure a shorter token lifetime, you may use the \ntokensExpireIn\n and \nrefreshTokensExpireIn\n methods. These methods should be called from the \nboot\n method of your \nAuthServiceProvider\n:\n\n\nuse\n \nCarbon\n\\\nCarbon\n;\n\n\n\n/**\n\n\n * Register any authentication / authorization services.\n\n\n *\n\n\n * @return void\n\n\n */\n\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n    \n$this-\nregisterPolicies()\n;\n\n\n    \nPassport\n:\n:\nroutes\n();\n\n\n    \nPassport\n:\n:\ntokensExpireIn\n(\nCarbon\n::\nnow\n()\n-\naddDays\n(\n15\n));\n\n\n    \nPassport\n:\n:\nrefreshTokensExpireIn\n(\nCarbon\n::\nnow\n()\n-\naddDays\n(\n30\n));\n\n\n}\n\n\n\n\n\n\n\n\nIssuing Access Tokens\n\n\nUsing OAuth2 with authorization codes is how most developers are familiar with OAuth2. When using authorization codes, a client application will redirect a user to your server where they will either approve or deny the request to issue an access token to the client.\n\n\n\n\nManaging Clients\n\n\nFirst, developers building applications that need to interact with your application's API will need to register their application with yours by creating a \"client\". Typically, this consists of providing the name of their application and a URL that your application can redirect to after users approve their request for authorization.\n\n\nThe \npassport:client\n Command\n\n\nThe simplest way to create a client is using the \npassport:client\n Artisan command. This command may be used to create your own clients for testing your OAuth2 functionality. When you run the \nclient\n command, Passport will prompt you for more information about your client and will provide you with a client ID and secret:\n\n\nphp artisan passport:client\n\n\n\n\n\nJSON API\n\n\nSince your users will not be able to utilize the \nclient\n command, Passport provides a JSON API that you may use to create clients. This saves you the trouble of having to manually code controllers for creating, updating, and deleting clients.\n\n\nHowever, you will need to pair Passport's JSON API with your own frontend to provide a dashboard for your users to manage their clients. Below, we'll review all of the API endpoints for managing clients. For convenience, we'll use \nAxios\n to demonstrate making HTTP requests to the endpoints.\n\n\n\n\n{tip} If you don't want to implement the entire client management frontend yourself, you can use the \nfrontend quickstart\n to have a fully functional frontend in a matter of minutes.\n\n\n\n\nGET /oauth/clients\n\n\nThis route returns all of the clients for the authenticated user. This is primarily useful for listing all of the user's clients so that they may edit or delete them:\n\n\naxios.get(\n/oauth/clients\n)\n    .then(response =\n {\n        console.log(response.data);\n    });\n\n\n\n\n\nPOST /oauth/clients\n\n\nThis route is used to create new clients. It requires two pieces of data: the client's \nname\n and a \nredirect\n URL. The \nredirect\n URL is where the user will be redirected after approving or denying a request for authorization.\n\n\nWhen a client is created, it will be issued a client ID and client secret. These values will be used when requesting access tokens from your application. The client creation route will return the new client instance:\n\n\nconst data = {\n    name: \nClient Name\n,\n    redirect: \nhttp://example.com/callback\n\n};\n\naxios.post(\n/oauth/clients\n, data)\n    .then(response =\n {\n        console.log(response.data);\n    })\n    .catch (response =\n {\n        // List errors on response...\n    });\n\n\n\n\n\nPUT /oauth/clients/{client-id}\n\n\nThis route is used to update clients. It requires two pieces of data: the client's \nname\n and a \nredirect\n URL. The \nredirect\n URL is where the user will be redirected after approving or denying a request for authorization. The route will return the updated client instance:\n\n\nconst data = {\n    name: \nNew Client Name\n,\n    redirect: \nhttp://example.com/callback\n\n};\n\naxios.put(\n/oauth/clients/\n + clientId, data)\n    .then(response =\n {\n        console.log(response.data);\n    })\n    .catch (response =\n {\n        // List errors on response...\n    });\n\n\n\n\n\nDELETE /oauth/clients/{client-id}\n\n\nThis route is used to delete clients:\n\n\naxios.delete(\n/oauth/clients/\n + clientId)\n    .then(response =\n {\n        //\n    });\n\n\n\n\n\n\n\nRequesting Tokens\n\n\nRedirecting For Authorization\n\n\nOnce a client has been created, developers may use their client ID and secret to request an authorization code and access token from your application. First, the consuming application should make a redirect request to your application's \n/oauth/authorize\n route like so:\n\n\nRoute\n::\nget\n(\n/redirect\n,\n \nfunction\n \n()\n \n{\n\n    \n$query\n \n=\n \nhttp_build_query(\n[\n\n        \nclient_id\n \n=\n \nclient-id\n,\n\n        \nredirect_uri\n \n=\n \nhttp://example.com/callback\n,\n\n        \nresponse_type\n \n=\n \ncode\n,\n\n        \nscope\n \n=\n \n,\n\n    \n]\n)\n;\n\n\n    \nreturn\n \nredirect(\nhttp\n:\n//\nyour-app\n.\ncom\n/\noauth\n/\nauthorize\n?\n.\n$\nquery\n);\n\n\n}\n);\n\n\n\n\n\n\n\n\n{tip} Remember, the \n/oauth/authorize\n route is already defined by the \nPassport::routes\n method. You do not need to manually define this route.\n\n\n\n\nApproving The Request\n\n\nWhen receiving authorization requests, Passport will automatically display a template to the user allowing them to approve or deny the authorization request. If they approve the request, they will be redirected back to the \nredirect_uri\n that was specified by the consuming application. The \nredirect_uri\n must match the \nredirect\n URL that was specified when the client was created.\n\n\nIf you would like to customize the authorization approval screen, you may publish Passport's views using the \nvendor:publish\n Artisan command. The published views will be placed in \nresources/views/vendor/passport\n:\n\n\nphp artisan vendor:publish --tag=passport-views\n\n\n\n\n\nConverting Authorization Codes To Access Tokens\n\n\nIf the user approves the authorization request, they will be redirected back to the consuming application. The consumer should then issue a \nPOST\n request to your application to request an access token. The request should include the authorization code that was issued by your application when the user approved the authorization request. In this example, we'll use the Guzzle HTTP library to make the \nPOST\n request:\n\n\nRoute::get(\n/callback\n, function (Request $request) {\n    $http = new GuzzleHttp\\Client;\n\n    $response = $http-\npost(\nhttp://your-app.com/oauth/token\n, [\n        \nform_params\n =\n [\n            \ngrant_type\n =\n \nauthorization_code\n,\n            \nclient_id\n =\n \nclient-id\n,\n            \nclient_secret\n =\n \nclient-secret\n,\n            \nredirect_uri\n =\n \nhttp://example.com/callback\n,\n            \ncode\n =\n $request-\ncode,\n        ],\n    ]);\n\n    return json_decode((string) $response-\ngetBody(), true);\n});\n\n\n\n\n\nThis \n/oauth/token\n route will return a JSON response containing \naccess_token\n, \nrefresh_token\n, and \nexpires_in\n attributes. The \nexpires_in\n attribute contains the number of seconds until the access token expires.\n\n\n\n\n{tip} Like the \n/oauth/authorize\n route, the \n/oauth/token\n route is defined for you by the \nPassport::routes\n method. There is no need to manually define this route.\n\n\n\n\n\n\nRefreshing Tokens\n\n\nIf your application issues short-lived access tokens, users will need to refresh their access tokens via the refresh token that was provided to them when the access token was issued. In this example, we'll use the Guzzle HTTP library to refresh the token:\n\n\n$http = new GuzzleHttp\\Client;\n\n$response = $http-\npost(\nhttp://your-app.com/oauth/token\n, [\n    \nform_params\n =\n [\n        \ngrant_type\n =\n \nrefresh_token\n,\n        \nrefresh_token\n =\n \nthe-refresh-token\n,\n        \nclient_id\n =\n \nclient-id\n,\n        \nclient_secret\n =\n \nclient-secret\n,\n        \nscope\n =\n \n,\n    ],\n]);\n\nreturn json_decode((string) $response-\ngetBody(), true);\n\n\n\n\n\nThis \n/oauth/token\n route will return a JSON response containing \naccess_token\n, \nrefresh_token\n, and \nexpires_in\n attributes. The \nexpires_in\n attribute contains the number of seconds until the access token expires.\n\n\n\n\nPassword Grant Tokens\n\n\nThe OAuth2 password grant allows your other first-party clients, such as a mobile application, to obtain an access token using an e-mail address / username and password. This allows you to issue access tokens securely to your first-party clients without requiring your users to go through the entire OAuth2 authorization code redirect flow.\n\n\n\n\nCreating A Password Grant Client\n\n\nBefore your application can issue tokens via the password grant, you will need to create a password grant client. You may do this using the \npassport:client\n command with the \n--password\n option. If you have already run the \npassport:install\n command, you do not need to run this command:\n\n\nphp artisan passport:client --password\n\n\n\n\n\n\n\nRequesting Tokens\n\n\nOnce you have created a password grant client, you may request an access token by issuing a \nPOST\n request to the \n/oauth/token\n route with the user's email address and password. Remember, this route is already registered by the \nPassport::routes\n method so there is no need to define it manually. If the request is successful, you will receive an \naccess_token\n and \nrefresh_token\n in the JSON response from the server:\n\n\n$http = new GuzzleHttp\\Client;\n\n$response = $http-\npost(\nhttp://your-app.com/oauth/token\n, [\n    \nform_params\n =\n [\n        \ngrant_type\n =\n \npassword\n,\n        \nclient_id\n =\n \nclient-id\n,\n        \nclient_secret\n =\n \nclient-secret\n,\n        \nusername\n =\n \ntaylor@laravel.com\n,\n        \npassword\n =\n \nmy-password\n,\n        \nscope\n =\n \n,\n    ],\n]);\n\nreturn json_decode((string) $response-\ngetBody(), true);\n\n\n\n\n\n\n\n{tip} Remember, access tokens are long-lived by default. However, you are free to \nconfigure your maximum access token lifetime\n if needed.\n\n\n\n\n\n\nRequesting All Scopes\n\n\nWhen using the password grant, you may wish to authorize the token for all of the scopes supported by your application. You can do this by requesting the \n*\n scope. If you request the \n*\n scope, the \ncan\n method on the token instance will always return \ntrue\n. This scope may only be assigned to a token that is issued using the \npassword\n grant:\n\n\n$response = $http-\npost(\nhttp://your-app.com/oauth/token\n, [\n    \nform_params\n =\n [\n        \ngrant_type\n =\n \npassword\n,\n        \nclient_id\n =\n \nclient-id\n,\n        \nclient_secret\n =\n \nclient-secret\n,\n        \nusername\n =\n \ntaylor@laravel.com\n,\n        \npassword\n =\n \nmy-password\n,\n        \nscope\n =\n \n*\n,\n    ],\n]);\n\n\n\n\n\n\n\nImplicit Grant Tokens\n\n\nThe implicit grant is similar to the authorization code grant; however, the token is returned to the client without exchanging an authorization code. This grant is most commonly used for JavaScript or mobile applications where the client credentials can't be securely stored. To enable the grant, call the \nenableImplicitGrant\n method in your \nAuthServiceProvider\n:\n\n\n/**\n\n\n * Register any authentication / authorization services.\n\n\n *\n\n\n * @return void\n\n\n */\n\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n    \n$this-\nregisterPolicies()\n;\n\n\n    \nPassport\n:\n:\nroutes\n();\n\n\n    \nPassport\n:\n:\nenableImplicitGrant\n();\n\n\n}\n\n\n\n\n\n\nOnce a grant has been enabled, developers may use their client ID to request an access token from your application. The consuming application should make a redirect request to your application's \n/oauth/authorize\n route like so:\n\n\nRoute\n::\nget\n(\n/redirect\n,\n \nfunction\n \n()\n \n{\n\n    \n$query\n \n=\n \nhttp_build_query(\n[\n\n        \nclient_id\n \n=\n \nclient-id\n,\n\n        \nredirect_uri\n \n=\n \nhttp://example.com/callback\n,\n\n        \nresponse_type\n \n=\n \ntoken\n,\n\n        \nscope\n \n=\n \n,\n\n    \n]\n)\n;\n\n\n    \nreturn\n \nredirect(\nhttp\n:\n//\nyour-app\n.\ncom\n/\noauth\n/\nauthorize\n?\n.\n$\nquery\n);\n\n\n}\n);\n\n\n\n\n\n\n\n\n{tip} Remember, the \n/oauth/authorize\n route is already defined by the \nPassport::routes\n method. You do not need to manually define this route.\n\n\n\n\n\n\nClient Credentials Grant Tokens\n\n\nThe client credentials grant is suitable for machine-to-machine authentication. For example, you might use this grant in a scheduled job which is performing maintenance tasks over an API. To retrieve a token, make a request to the \noauth/token\n endpoint:\n\n\n$guzzle = new GuzzleHttp\\Client;\n\n$response = $guzzle-\npost(\nhttp://your-app.com/oauth/token\n, [\n    \nform_params\n =\n [\n        \ngrant_type\n =\n \nclient_credentials\n,\n        \nclient_id\n =\n \nclient-id\n,\n        \nclient_secret\n =\n \nclient-secret\n,\n        \nscope\n =\n \nyour-scope\n,\n    ],\n]);\n\necho json_decode((string) $response-\ngetBody(), true);\n\n\n\n\n\n\n\nPersonal Access Tokens\n\n\nSometimes, your users may want to issue access tokens to themselves without going through the typical authorization code redirect flow. Allowing users to issue tokens to themselves via your application's UI can be useful for allowing users to experiment with your API or may serve as a simpler approach to issuing access tokens in general.\n\n\n\n\n{note} Personal access tokens are always long-lived. Their lifetime is not modified when using the \ntokensExpireIn\n or \nrefreshTokensExpireIn\n methods.\n\n\n\n\n\n\nCreating A Personal Access Client\n\n\nBefore your application can issue personal access tokens, you will need to create a personal access client. You may do this using the \npassport:client\n command with the \n--personal\n option. If you have already run the \npassport:install\n command, you do not need to run this command:\n\n\nphp artisan passport:client --personal\n\n\n\n\n\n\n\nManaging Personal Access Tokens\n\n\nOnce you have created a personal access client, you may issue tokens for a given user using the \ncreateToken\n method on the \nUser\n model instance. The \ncreateToken\n method accepts the name of the token as its first argument and an optional array of \nscopes\n as its second argument:\n\n\n$\nuser\n \n=\n \nApp\n\\\nUser\n::\nfind\n(\n1\n);\n\n\n\n//\n \nCreating\n \na\n \ntoken\n \nwithout\n \nscopes\n...\n\n\n$\ntoken\n \n=\n \n$\nuser-\ncreateToken\n(\nToken Name\n)\n-\naccessToken\n;\n\n\n\n//\n \nCreating\n \na\n \ntoken\n \nwith\n \nscopes\n...\n\n\n$\ntoken\n \n=\n \n$\nuser-\ncreateToken\n(\nMy Token\n,\n \n[\nplace-orders\n]\n)\n-\naccessToken\n;\n\n\n\n\n\n\nJSON API\n\n\nPassport also includes a JSON API for managing personal access tokens. You may pair this with your own frontend to offer your users a dashboard for managing personal access tokens. Below, we'll review all of the API endpoints for managing personal access tokens. For convenience, we'll use \nAxios\n to demonstrate making HTTP requests to the endpoints.\n\n\n\n\n{tip} If you don't want to implement the personal access token frontend yourself, you can use the \nfrontend quickstart\n to have a fully functional frontend in a matter of minutes.\n\n\n\n\nGET /oauth/scopes\n\n\nThis route returns all of the \nscopes\n defined for your application. You may use this route to list the scopes a user may assign to a personal access token:\n\n\naxios.get(\n/oauth/scopes\n)\n    .then(response =\n {\n        console.log(response.data);\n    });\n\n\n\n\n\nGET /oauth/personal-access-tokens\n\n\nThis route returns all of the personal access tokens that the authenticated user has created. This is primarily useful for listing all of the user's token so that they may edit or delete them:\n\n\naxios.get(\n/oauth/personal-access-tokens\n)\n    .then(response =\n {\n        console.log(response.data);\n    });\n\n\n\n\n\nPOST /oauth/personal-access-tokens\n\n\nThis route creates new personal access tokens. It requires two pieces of data: the token's \nname\n and the \nscopes\n that should be assigned to the token:\n\n\nconst data = {\n    name: \nToken Name\n,\n    scopes: []\n};\n\naxios.post(\n/oauth/personal-access-tokens\n, data)\n    .then(response =\n {\n        console.log(response.data.accessToken);\n    })\n    .catch (response =\n {\n        // List errors on response...\n    });\n\n\n\n\n\nDELETE /oauth/personal-access-tokens/{token-id}\n\n\nThis route may be used to delete personal access tokens:\n\n\naxios.delete(\n/oauth/personal-access-tokens/\n + tokenId);\n\n\n\n\n\n\n\nProtecting Routes\n\n\n\n\nVia Middleware\n\n\nPassport includes an \nauthentication guard\n that will validate access tokens on incoming requests. Once you have configured the \napi\n guard to use the \npassport\n driver, you only need to specify the \nauth:api\n middleware on any routes that require a valid access token:\n\n\nRoute\n::\nget\n(\n/user\n,\n \nfunction\n \n()\n \n{\n\n    \n//\n\n\n}\n)\n-\nmiddleware\n(\nauth:api\n);\n\n\n\n\n\n\n\n\nPassing The Access Token\n\n\nWhen calling routes that are protected by Passport, your application's API consumers should specify their access token as a \nBearer\n token in the \nAuthorization\n header of their request. For example, when using the Guzzle HTTP library:\n\n\n$response = $client-\nrequest(\nGET\n, \n/api/user\n, [\n    \nheaders\n =\n [\n        \nAccept\n =\n \napplication/json\n,\n        \nAuthorization\n =\n \nBearer \n.$accessToken,\n    ],\n]);\n\n\n\n\n\n\n\nToken Scopes\n\n\n\n\nDefining Scopes\n\n\nScopes allow your API clients to request a specific set of permissions when requesting authorization to access an account. For example, if you are building an e-commerce application, not all API consumers will need the ability to place orders. Instead, you may allow the consumers to only request authorization to access order shipment statuses. In other words, scopes allow your application's users to limit the actions a third-party application can perform on their behalf.\n\n\nYou may define your API's scopes using the \nPassport::tokensCan\n method in the \nboot\n method of your \nAuthServiceProvider\n. The \ntokensCan\n method accepts an array of scope names and scope descriptions. The scope description may be anything you wish and will be displayed to users on the authorization approval screen:\n\n\nuse Laravel\\Passport\\Passport;\n\nPassport::tokensCan([\n    \nplace-orders\n =\n \nPlace orders\n,\n    \ncheck-status\n =\n \nCheck order status\n,\n]);\n\n\n\n\n\n\n\nAssigning Scopes To Tokens\n\n\nWhen Requesting Authorization Codes\n\n\nWhen requesting an access token using the authorization code grant, consumers should specify their desired scopes as the \nscope\n query string parameter. The \nscope\n parameter should be a space-delimited list of scopes:\n\n\nRoute\n::\nget\n(\n/redirect\n,\n \nfunction\n \n()\n \n{\n\n    \n$query\n \n=\n \nhttp_build_query(\n[\n\n        \nclient_id\n \n=\n \nclient-id\n,\n\n        \nredirect_uri\n \n=\n \nhttp://example.com/callback\n,\n\n        \nresponse_type\n \n=\n \ncode\n,\n\n        \nscope\n \n=\n \nplace-orders check-status\n,\n\n    \n]\n)\n;\n\n\n    \nreturn\n \nredirect(\nhttp\n:\n//\nyour-app\n.\ncom\n/\noauth\n/\nauthorize\n?\n.\n$\nquery\n);\n\n\n}\n);\n\n\n\n\n\n\nWhen Issuing Personal Access Tokens\n\n\nIf you are issuing personal access tokens using the \nUser\n model's \ncreateToken\n method, you may pass the array of desired scopes as the second argument to the method:\n\n\n$token = $user-\ncreateToken(\nMy Token\n, [\nplace-orders\n])-\naccessToken;\n\n\n\n\n\n\n\nChecking Scopes\n\n\nPassport includes two middleware that may be used to verify that an incoming request is authenticated with a token that has been granted a given scope. To get started, add the following middleware to the \n$routeMiddleware\n property of your \napp/Http/Kernel.php\n file:\n\n\nscopes\n =\n \\Laravel\\Passport\\Http\\Middleware\\CheckScopes::class,\n\nscope\n =\n \\Laravel\\Passport\\Http\\Middleware\\CheckForAnyScope::class,\n\n\n\n\n\nCheck For All Scopes\n\n\nThe \nscopes\n middleware may be assigned to a route to verify that the incoming request's access token has \nall\n of the listed scopes:\n\n\nRoute\n::\nget\n(\n/orders\n,\n \nfunction\n \n()\n \n{\n\n    \n//\n \nAccess\n \ntoken\n \nhas\n \nboth\n \ncheck-status\n \nand\n \nplace-orders\n \nscopes...\n\n\n}\n)\n-\nmiddleware\n(\nscopes:check-status,place-orders\n);\n\n\n\n\n\n\nCheck For Any Scopes\n\n\nThe \nscope\n middleware may be assigned to a route to verify that the incoming request's access token has \nat least one\n of the listed scopes:\n\n\nRoute\n::\nget\n(\n/orders\n,\n \nfunction\n \n()\n \n{\n\n    \n//\n \nAccess\n \ntoken\n \nhas\n \neither\n \ncheck-status\n \nor\n \nplace-orders\n \nscope...\n\n\n}\n)\n-\nmiddleware\n(\nscope:check-status,place-orders\n);\n\n\n\n\n\n\nChecking Scopes On A Token Instance\n\n\nOnce an access token authenticated request has entered your application, you may still check if the token has a given scope using the \ntokenCan\n method on the authenticated \nUser\n instance:\n\n\nuse Illuminate\\Http\\Request;\n\nRoute::get(\n/orders\n, function (Request $request) {\n    if ($request-\nuser()-\ntokenCan(\nplace-orders\n)) {\n        //\n    }\n});\n\n\n\n\n\n\n\nConsuming Your API With JavaScript\n\n\nWhen building an API, it can be extremely useful to be able to consume your own API from your JavaScript application. This approach to API development allows your own application to consume the same API that you are sharing with the world. The same API may be consumed by your web application, mobile applications, third-party applications, and any SDKs that you may publish on various package managers.\n\n\nTypically, if you want to consume your API from your JavaScript application, you would need to manually send an access token to the application and pass it with each request to your application. However, Passport includes a middleware that can handle this for you. All you need to do is add the \nCreateFreshApiToken\n middleware to your \nweb\n middleware group:\n\n\nweb\n =\n [\n    // Other middleware...\n    \\Laravel\\Passport\\Http\\Middleware\\CreateFreshApiToken::class,\n],\n\n\n\n\n\nThis Passport middleware will attach a \nlaravel_token\n cookie to your outgoing responses. This cookie contains an encrypted JWT that Passport will use to authenticate API requests from your JavaScript application. Now, you may make requests to your application's API without explicitly passing an access token:\n\n\naxios.get(\n/user\n)\n    .then(response =\n {\n        console.log(response.data);\n    });\n\n\n\n\n\nWhen using this method of authentication, Axios will automatically send the \nX-CSRF-TOKEN\n header. In addition, the default Laravel JavaScript scaffolding instructs Axios to send the \nX-Requested-With\n header:\n\n\nwindow.axios.defaults.headers.common = {\n    \nX-Requested-With\n: \nXMLHttpRequest\n,\n};\n\n\n\n\n\n\n\n{note} If you are using a different JavaScript framework, you should make sure it is configured to send the \nX-CSRF-TOKEN\n and \nX-Requested-With\n headers with every outgoing request.\n\n\n\n\n\n\nEvents\n\n\nPassport raises events when issuing access tokens and refresh tokens. You may use these events to prune or revoke other access tokens in your database. You may attach listeners to these events in your application's \nEventServiceProvider\n:\n\n\n/**\n\n\n * The event listener mappings for the application.\n\n\n *\n\n\n * @var array\n\n\n */\n\n\nprotected $listen = [\n\n\n    \nLaravel\\Passport\\Events\\AccessTokenCreated\n =\n [\n\n\n        \nApp\\Listeners\\RevokeOldTokens\n,\n\n\n    ],\n\n\n\n    \nLaravel\\Passport\\Events\\RefreshTokenCreated\n =\n [\n\n\n        \nApp\\Listeners\\PruneOldTokens\n,\n\n\n    ],\n\n\n];\n\n\n\n\n\n\n\n\nTesting\n\n\nPassport's \nactingAs\n method may be used to specify the currently authenticated user as well as its scopes. The first argument given to the \nactingAs\n method is the user instance and the second is an array of scopes that should be granted to the user's token:\n\n\npublic function testServerCreation()\n{\n    Passport::actingAs(\n        factory(User::class)-\ncreate(),\n        [\ncreate-servers\n]\n    );\n\n    $response = $this-\npost(\n/api/create-server\n);\n\n    $response-\nassertStatus(200);\n}", 
            "title": "Passport"
        }, 
        {
            "location": "/passport/#api-authentication-passport", 
            "text": "Introduction  Installation  Frontend Quickstart    Configuration  Token Lifetimes    Issuing Access Tokens  Managing Clients  Requesting Tokens  Refreshing Tokens    Password Grant Tokens  Creating A Password Grant Client  Requesting Tokens  Requesting All Scopes    Implicit Grant Tokens  Client Credentials Grant Tokens  Personal Access Tokens  Creating A Personal Access Client  Managing Personal Access Tokens    Protecting Routes  Via Middleware  Passing The Access Token    Token Scopes  Defining Scopes  Assigning Scopes To Tokens  Checking Scopes    Consuming Your API With JavaScript  Events  Testing", 
            "title": "API Authentication (Passport)"
        }, 
        {
            "location": "/passport/#introduction", 
            "text": "Laravel already makes it easy to perform authentication via traditional login forms, but what about APIs? APIs typically use tokens to authenticate users and do not maintain session state between requests. Laravel makes API authentication a breeze using Laravel Passport, which provides a full OAuth2 server implementation for your Laravel application in a matter of minutes. Passport is built on top of the  League OAuth2 server  that is maintained by Alex Bilbie.   {note} This documentation assumes you are already familiar with OAuth2. If you do not know anything about OAuth2, consider familiarizing yourself with the general terminology and features of OAuth2 before continuing.", 
            "title": "Introduction"
        }, 
        {
            "location": "/passport/#installation", 
            "text": "To get started, install Passport via the Composer package manager:  composer require laravel/passport  Next, register the Passport service provider in the  providers  array of your  config/app.php  configuration file:  Laravel\\Passport\\PassportServiceProvider::class,  The Passport service provider registers its own database migration directory with the framework, so you should migrate your database after registering the provider. The Passport migrations will create the tables your application needs to store clients and access tokens:  php artisan migrate   {note} If you are not going to use Passport's default migrations, you should call the  Passport::ignoreMigrations  method in the  register  method of your  AppServiceProvider . You may export the default migrations using  php artisan vendor:publish --tag=passport-migrations .   Next, you should run the  passport:install  command. This command will create the encryption keys needed to generate secure access tokens. In addition, the command will create \"personal access\" and \"password grant\" clients which will be used to generate access tokens:  php artisan passport:install  After running this command, add the  Laravel\\Passport\\HasApiTokens  trait to your  App\\User  model. This trait will provide a few helper methods to your model which allow you to inspect the authenticated user's token and scopes:  ? php  namespace   App ;  use   Laravel \\ Passport \\ HasApiTokens ;  use   Illuminate \\ Notifications \\ Notifiable ;  use   Illuminate \\ Foundation \\ Auth \\ User   as   Authenticatable ;  class   User   extends   Authenticatable  { \n     use   HasApiTokens ,   Notifiable ;  }   Next, you should call the  Passport::routes  method within the  boot  method of your  AuthServiceProvider . This method will register the routes necessary to issue access tokens and revoke access tokens, clients, and personal access tokens:  ? php  namespace   App \\ Providers ;  use   Laravel \\ Passport \\ Passport ;  use   Illuminate \\ Support \\ Facades \\ Gate ;  use   Illuminate \\ Foundation \\ Support \\ Providers \\ AuthServiceProvider   as   ServiceProvider ;  class   AuthServiceProvider   extends   ServiceProvider  { \n     /**       * The policy mappings for the application.       *       * @var array       */ \n     protected   $policies   =   [ \n         App\\Model   =   App\\Policies\\ModelPolicy , \n     ]; \n\n     /**       * Register any authentication / authorization services.       *       * @return void       */ \n     public   function   boot () \n     { \n         $this - registerPolicies (); \n\n         Passport :: routes (); \n     }  }   Finally, in your  config/auth.php  configuration file, you should set the  driver  option of the  api  authentication guard to  passport . This will instruct your application to use Passport's  TokenGuard  when authenticating incoming API requests:  guards  =  [\n     web  =  [\n         driver  =   session ,\n         provider  =   users ,\n    ],\n\n     api  =  [\n         driver  =   passport ,\n         provider  =   users ,\n    ],\n],", 
            "title": "Installation"
        }, 
        {
            "location": "/passport/#frontend-quickstart", 
            "text": "{note} In order to use the Passport Vue components, you must be using the  Vue  JavaScript framework. These components also use the Bootstrap CSS framework. However, even if you are not using these tools, the components serve as a valuable reference for your own frontend implementation.   Passport ships with a JSON API that you may use to allow your users to create clients and personal access tokens. However, it can be time consuming to code a frontend to interact with these APIs. So, Passport also includes pre-built  Vue  components you may use as an example implementation or starting point for your own implementation.  To publish the Passport Vue components, use the  vendor:publish  Artisan command:  php artisan vendor:publish --tag=passport-components  The published components will be placed in your  resources/assets/js/components  directory. Once the components have been published, you should register them in your  resources/assets/js/app.js  file:  Vue.component(\n     passport-clients ,\n    require( ./components/passport/Clients.vue )\n);\n\nVue.component(\n     passport-authorized-clients ,\n    require( ./components/passport/AuthorizedClients.vue )\n);\n\nVue.component(\n     passport-personal-access-tokens ,\n    require( ./components/passport/PersonalAccessTokens.vue )\n);  After registering the components, make sure to run  npm run dev  to recompile your assets. Once you have recompiled your assets, you may drop the components into one of your application's templates to get started creating clients and personal access tokens:  passport-clients /passport-clients  passport-authorized-clients /passport-authorized-clients  passport-personal-access-tokens /passport-personal-access-tokens", 
            "title": "Frontend Quickstart"
        }, 
        {
            "location": "/passport/#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/passport/#token-lifetimes", 
            "text": "By default, Passport issues long-lived access tokens that never need to be refreshed. If you would like to configure a shorter token lifetime, you may use the  tokensExpireIn  and  refreshTokensExpireIn  methods. These methods should be called from the  boot  method of your  AuthServiceProvider :  use   Carbon \\ Carbon ;  /**   * Register any authentication / authorization services.   *   * @return void   */  public   function   boot ()  { \n     $this- registerPolicies() ; \n\n     Passport : : routes (); \n\n     Passport : : tokensExpireIn ( Carbon :: now () - addDays ( 15 )); \n\n     Passport : : refreshTokensExpireIn ( Carbon :: now () - addDays ( 30 ));  }", 
            "title": "Token Lifetimes"
        }, 
        {
            "location": "/passport/#issuing-access-tokens", 
            "text": "Using OAuth2 with authorization codes is how most developers are familiar with OAuth2. When using authorization codes, a client application will redirect a user to your server where they will either approve or deny the request to issue an access token to the client.", 
            "title": "Issuing Access Tokens"
        }, 
        {
            "location": "/passport/#managing-clients", 
            "text": "First, developers building applications that need to interact with your application's API will need to register their application with yours by creating a \"client\". Typically, this consists of providing the name of their application and a URL that your application can redirect to after users approve their request for authorization.", 
            "title": "Managing Clients"
        }, 
        {
            "location": "/passport/#the-passportclient-command", 
            "text": "The simplest way to create a client is using the  passport:client  Artisan command. This command may be used to create your own clients for testing your OAuth2 functionality. When you run the  client  command, Passport will prompt you for more information about your client and will provide you with a client ID and secret:  php artisan passport:client", 
            "title": "The passport:client Command"
        }, 
        {
            "location": "/passport/#json-api", 
            "text": "Since your users will not be able to utilize the  client  command, Passport provides a JSON API that you may use to create clients. This saves you the trouble of having to manually code controllers for creating, updating, and deleting clients.  However, you will need to pair Passport's JSON API with your own frontend to provide a dashboard for your users to manage their clients. Below, we'll review all of the API endpoints for managing clients. For convenience, we'll use  Axios  to demonstrate making HTTP requests to the endpoints.   {tip} If you don't want to implement the entire client management frontend yourself, you can use the  frontend quickstart  to have a fully functional frontend in a matter of minutes.", 
            "title": "JSON API"
        }, 
        {
            "location": "/passport/#get-oauthclients", 
            "text": "This route returns all of the clients for the authenticated user. This is primarily useful for listing all of the user's clients so that they may edit or delete them:  axios.get( /oauth/clients )\n    .then(response =  {\n        console.log(response.data);\n    });", 
            "title": "GET /oauth/clients"
        }, 
        {
            "location": "/passport/#post-oauthclients", 
            "text": "This route is used to create new clients. It requires two pieces of data: the client's  name  and a  redirect  URL. The  redirect  URL is where the user will be redirected after approving or denying a request for authorization.  When a client is created, it will be issued a client ID and client secret. These values will be used when requesting access tokens from your application. The client creation route will return the new client instance:  const data = {\n    name:  Client Name ,\n    redirect:  http://example.com/callback \n};\n\naxios.post( /oauth/clients , data)\n    .then(response =  {\n        console.log(response.data);\n    })\n    .catch (response =  {\n        // List errors on response...\n    });", 
            "title": "POST /oauth/clients"
        }, 
        {
            "location": "/passport/#put-oauthclientsclient-id", 
            "text": "This route is used to update clients. It requires two pieces of data: the client's  name  and a  redirect  URL. The  redirect  URL is where the user will be redirected after approving or denying a request for authorization. The route will return the updated client instance:  const data = {\n    name:  New Client Name ,\n    redirect:  http://example.com/callback \n};\n\naxios.put( /oauth/clients/  + clientId, data)\n    .then(response =  {\n        console.log(response.data);\n    })\n    .catch (response =  {\n        // List errors on response...\n    });", 
            "title": "PUT /oauth/clients/{client-id}"
        }, 
        {
            "location": "/passport/#delete-oauthclientsclient-id", 
            "text": "This route is used to delete clients:  axios.delete( /oauth/clients/  + clientId)\n    .then(response =  {\n        //\n    });", 
            "title": "DELETE /oauth/clients/{client-id}"
        }, 
        {
            "location": "/passport/#requesting-tokens", 
            "text": "", 
            "title": "Requesting Tokens"
        }, 
        {
            "location": "/passport/#redirecting-for-authorization", 
            "text": "Once a client has been created, developers may use their client ID and secret to request an authorization code and access token from your application. First, the consuming application should make a redirect request to your application's  /oauth/authorize  route like so:  Route :: get ( /redirect ,   function   ()   { \n     $query   =   http_build_query( [ \n         client_id   =   client-id , \n         redirect_uri   =   http://example.com/callback , \n         response_type   =   code , \n         scope   =   , \n     ] ) ; \n\n     return   redirect( http : // your-app . com / oauth / authorize ? . $ query );  } );    {tip} Remember, the  /oauth/authorize  route is already defined by the  Passport::routes  method. You do not need to manually define this route.", 
            "title": "Redirecting For Authorization"
        }, 
        {
            "location": "/passport/#approving-the-request", 
            "text": "When receiving authorization requests, Passport will automatically display a template to the user allowing them to approve or deny the authorization request. If they approve the request, they will be redirected back to the  redirect_uri  that was specified by the consuming application. The  redirect_uri  must match the  redirect  URL that was specified when the client was created.  If you would like to customize the authorization approval screen, you may publish Passport's views using the  vendor:publish  Artisan command. The published views will be placed in  resources/views/vendor/passport :  php artisan vendor:publish --tag=passport-views", 
            "title": "Approving The Request"
        }, 
        {
            "location": "/passport/#converting-authorization-codes-to-access-tokens", 
            "text": "If the user approves the authorization request, they will be redirected back to the consuming application. The consumer should then issue a  POST  request to your application to request an access token. The request should include the authorization code that was issued by your application when the user approved the authorization request. In this example, we'll use the Guzzle HTTP library to make the  POST  request:  Route::get( /callback , function (Request $request) {\n    $http = new GuzzleHttp\\Client;\n\n    $response = $http- post( http://your-app.com/oauth/token , [\n         form_params  =  [\n             grant_type  =   authorization_code ,\n             client_id  =   client-id ,\n             client_secret  =   client-secret ,\n             redirect_uri  =   http://example.com/callback ,\n             code  =  $request- code,\n        ],\n    ]);\n\n    return json_decode((string) $response- getBody(), true);\n});  This  /oauth/token  route will return a JSON response containing  access_token ,  refresh_token , and  expires_in  attributes. The  expires_in  attribute contains the number of seconds until the access token expires.   {tip} Like the  /oauth/authorize  route, the  /oauth/token  route is defined for you by the  Passport::routes  method. There is no need to manually define this route.", 
            "title": "Converting Authorization Codes To Access Tokens"
        }, 
        {
            "location": "/passport/#refreshing-tokens", 
            "text": "If your application issues short-lived access tokens, users will need to refresh their access tokens via the refresh token that was provided to them when the access token was issued. In this example, we'll use the Guzzle HTTP library to refresh the token:  $http = new GuzzleHttp\\Client;\n\n$response = $http- post( http://your-app.com/oauth/token , [\n     form_params  =  [\n         grant_type  =   refresh_token ,\n         refresh_token  =   the-refresh-token ,\n         client_id  =   client-id ,\n         client_secret  =   client-secret ,\n         scope  =   ,\n    ],\n]);\n\nreturn json_decode((string) $response- getBody(), true);  This  /oauth/token  route will return a JSON response containing  access_token ,  refresh_token , and  expires_in  attributes. The  expires_in  attribute contains the number of seconds until the access token expires.", 
            "title": "Refreshing Tokens"
        }, 
        {
            "location": "/passport/#password-grant-tokens", 
            "text": "The OAuth2 password grant allows your other first-party clients, such as a mobile application, to obtain an access token using an e-mail address / username and password. This allows you to issue access tokens securely to your first-party clients without requiring your users to go through the entire OAuth2 authorization code redirect flow.", 
            "title": "Password Grant Tokens"
        }, 
        {
            "location": "/passport/#creating-a-password-grant-client", 
            "text": "Before your application can issue tokens via the password grant, you will need to create a password grant client. You may do this using the  passport:client  command with the  --password  option. If you have already run the  passport:install  command, you do not need to run this command:  php artisan passport:client --password", 
            "title": "Creating A Password Grant Client"
        }, 
        {
            "location": "/passport/#requesting-tokens_1", 
            "text": "Once you have created a password grant client, you may request an access token by issuing a  POST  request to the  /oauth/token  route with the user's email address and password. Remember, this route is already registered by the  Passport::routes  method so there is no need to define it manually. If the request is successful, you will receive an  access_token  and  refresh_token  in the JSON response from the server:  $http = new GuzzleHttp\\Client;\n\n$response = $http- post( http://your-app.com/oauth/token , [\n     form_params  =  [\n         grant_type  =   password ,\n         client_id  =   client-id ,\n         client_secret  =   client-secret ,\n         username  =   taylor@laravel.com ,\n         password  =   my-password ,\n         scope  =   ,\n    ],\n]);\n\nreturn json_decode((string) $response- getBody(), true);   {tip} Remember, access tokens are long-lived by default. However, you are free to  configure your maximum access token lifetime  if needed.", 
            "title": "Requesting Tokens"
        }, 
        {
            "location": "/passport/#requesting-all-scopes", 
            "text": "When using the password grant, you may wish to authorize the token for all of the scopes supported by your application. You can do this by requesting the  *  scope. If you request the  *  scope, the  can  method on the token instance will always return  true . This scope may only be assigned to a token that is issued using the  password  grant:  $response = $http- post( http://your-app.com/oauth/token , [\n     form_params  =  [\n         grant_type  =   password ,\n         client_id  =   client-id ,\n         client_secret  =   client-secret ,\n         username  =   taylor@laravel.com ,\n         password  =   my-password ,\n         scope  =   * ,\n    ],\n]);", 
            "title": "Requesting All Scopes"
        }, 
        {
            "location": "/passport/#implicit-grant-tokens", 
            "text": "The implicit grant is similar to the authorization code grant; however, the token is returned to the client without exchanging an authorization code. This grant is most commonly used for JavaScript or mobile applications where the client credentials can't be securely stored. To enable the grant, call the  enableImplicitGrant  method in your  AuthServiceProvider :  /**   * Register any authentication / authorization services.   *   * @return void   */  public   function   boot ()  { \n     $this- registerPolicies() ; \n\n     Passport : : routes (); \n\n     Passport : : enableImplicitGrant ();  }   Once a grant has been enabled, developers may use their client ID to request an access token from your application. The consuming application should make a redirect request to your application's  /oauth/authorize  route like so:  Route :: get ( /redirect ,   function   ()   { \n     $query   =   http_build_query( [ \n         client_id   =   client-id , \n         redirect_uri   =   http://example.com/callback , \n         response_type   =   token , \n         scope   =   , \n     ] ) ; \n\n     return   redirect( http : // your-app . com / oauth / authorize ? . $ query );  } );    {tip} Remember, the  /oauth/authorize  route is already defined by the  Passport::routes  method. You do not need to manually define this route.", 
            "title": "Implicit Grant Tokens"
        }, 
        {
            "location": "/passport/#client-credentials-grant-tokens", 
            "text": "The client credentials grant is suitable for machine-to-machine authentication. For example, you might use this grant in a scheduled job which is performing maintenance tasks over an API. To retrieve a token, make a request to the  oauth/token  endpoint:  $guzzle = new GuzzleHttp\\Client;\n\n$response = $guzzle- post( http://your-app.com/oauth/token , [\n     form_params  =  [\n         grant_type  =   client_credentials ,\n         client_id  =   client-id ,\n         client_secret  =   client-secret ,\n         scope  =   your-scope ,\n    ],\n]);\n\necho json_decode((string) $response- getBody(), true);", 
            "title": "Client Credentials Grant Tokens"
        }, 
        {
            "location": "/passport/#personal-access-tokens", 
            "text": "Sometimes, your users may want to issue access tokens to themselves without going through the typical authorization code redirect flow. Allowing users to issue tokens to themselves via your application's UI can be useful for allowing users to experiment with your API or may serve as a simpler approach to issuing access tokens in general.   {note} Personal access tokens are always long-lived. Their lifetime is not modified when using the  tokensExpireIn  or  refreshTokensExpireIn  methods.", 
            "title": "Personal Access Tokens"
        }, 
        {
            "location": "/passport/#creating-a-personal-access-client", 
            "text": "Before your application can issue personal access tokens, you will need to create a personal access client. You may do this using the  passport:client  command with the  --personal  option. If you have already run the  passport:install  command, you do not need to run this command:  php artisan passport:client --personal", 
            "title": "Creating A Personal Access Client"
        }, 
        {
            "location": "/passport/#managing-personal-access-tokens", 
            "text": "Once you have created a personal access client, you may issue tokens for a given user using the  createToken  method on the  User  model instance. The  createToken  method accepts the name of the token as its first argument and an optional array of  scopes  as its second argument:  $ user   =   App \\ User :: find ( 1 );  //   Creating   a   token   without   scopes ...  $ token   =   $ user- createToken ( Token Name ) - accessToken ;  //   Creating   a   token   with   scopes ...  $ token   =   $ user- createToken ( My Token ,   [ place-orders ] ) - accessToken ;", 
            "title": "Managing Personal Access Tokens"
        }, 
        {
            "location": "/passport/#json-api_1", 
            "text": "Passport also includes a JSON API for managing personal access tokens. You may pair this with your own frontend to offer your users a dashboard for managing personal access tokens. Below, we'll review all of the API endpoints for managing personal access tokens. For convenience, we'll use  Axios  to demonstrate making HTTP requests to the endpoints.   {tip} If you don't want to implement the personal access token frontend yourself, you can use the  frontend quickstart  to have a fully functional frontend in a matter of minutes.", 
            "title": "JSON API"
        }, 
        {
            "location": "/passport/#get-oauthscopes", 
            "text": "This route returns all of the  scopes  defined for your application. You may use this route to list the scopes a user may assign to a personal access token:  axios.get( /oauth/scopes )\n    .then(response =  {\n        console.log(response.data);\n    });", 
            "title": "GET /oauth/scopes"
        }, 
        {
            "location": "/passport/#get-oauthpersonal-access-tokens", 
            "text": "This route returns all of the personal access tokens that the authenticated user has created. This is primarily useful for listing all of the user's token so that they may edit or delete them:  axios.get( /oauth/personal-access-tokens )\n    .then(response =  {\n        console.log(response.data);\n    });", 
            "title": "GET /oauth/personal-access-tokens"
        }, 
        {
            "location": "/passport/#post-oauthpersonal-access-tokens", 
            "text": "This route creates new personal access tokens. It requires two pieces of data: the token's  name  and the  scopes  that should be assigned to the token:  const data = {\n    name:  Token Name ,\n    scopes: []\n};\n\naxios.post( /oauth/personal-access-tokens , data)\n    .then(response =  {\n        console.log(response.data.accessToken);\n    })\n    .catch (response =  {\n        // List errors on response...\n    });", 
            "title": "POST /oauth/personal-access-tokens"
        }, 
        {
            "location": "/passport/#delete-oauthpersonal-access-tokenstoken-id", 
            "text": "This route may be used to delete personal access tokens:  axios.delete( /oauth/personal-access-tokens/  + tokenId);", 
            "title": "DELETE /oauth/personal-access-tokens/{token-id}"
        }, 
        {
            "location": "/passport/#protecting-routes", 
            "text": "", 
            "title": "Protecting Routes"
        }, 
        {
            "location": "/passport/#via-middleware", 
            "text": "Passport includes an  authentication guard  that will validate access tokens on incoming requests. Once you have configured the  api  guard to use the  passport  driver, you only need to specify the  auth:api  middleware on any routes that require a valid access token:  Route :: get ( /user ,   function   ()   { \n     //  } ) - middleware ( auth:api );", 
            "title": "Via Middleware"
        }, 
        {
            "location": "/passport/#passing-the-access-token", 
            "text": "When calling routes that are protected by Passport, your application's API consumers should specify their access token as a  Bearer  token in the  Authorization  header of their request. For example, when using the Guzzle HTTP library:  $response = $client- request( GET ,  /api/user , [\n     headers  =  [\n         Accept  =   application/json ,\n         Authorization  =   Bearer  .$accessToken,\n    ],\n]);", 
            "title": "Passing The Access Token"
        }, 
        {
            "location": "/passport/#token-scopes", 
            "text": "", 
            "title": "Token Scopes"
        }, 
        {
            "location": "/passport/#defining-scopes", 
            "text": "Scopes allow your API clients to request a specific set of permissions when requesting authorization to access an account. For example, if you are building an e-commerce application, not all API consumers will need the ability to place orders. Instead, you may allow the consumers to only request authorization to access order shipment statuses. In other words, scopes allow your application's users to limit the actions a third-party application can perform on their behalf.  You may define your API's scopes using the  Passport::tokensCan  method in the  boot  method of your  AuthServiceProvider . The  tokensCan  method accepts an array of scope names and scope descriptions. The scope description may be anything you wish and will be displayed to users on the authorization approval screen:  use Laravel\\Passport\\Passport;\n\nPassport::tokensCan([\n     place-orders  =   Place orders ,\n     check-status  =   Check order status ,\n]);", 
            "title": "Defining Scopes"
        }, 
        {
            "location": "/passport/#assigning-scopes-to-tokens", 
            "text": "", 
            "title": "Assigning Scopes To Tokens"
        }, 
        {
            "location": "/passport/#when-requesting-authorization-codes", 
            "text": "When requesting an access token using the authorization code grant, consumers should specify their desired scopes as the  scope  query string parameter. The  scope  parameter should be a space-delimited list of scopes:  Route :: get ( /redirect ,   function   ()   { \n     $query   =   http_build_query( [ \n         client_id   =   client-id , \n         redirect_uri   =   http://example.com/callback , \n         response_type   =   code , \n         scope   =   place-orders check-status , \n     ] ) ; \n\n     return   redirect( http : // your-app . com / oauth / authorize ? . $ query );  } );", 
            "title": "When Requesting Authorization Codes"
        }, 
        {
            "location": "/passport/#when-issuing-personal-access-tokens", 
            "text": "If you are issuing personal access tokens using the  User  model's  createToken  method, you may pass the array of desired scopes as the second argument to the method:  $token = $user- createToken( My Token , [ place-orders ])- accessToken;", 
            "title": "When Issuing Personal Access Tokens"
        }, 
        {
            "location": "/passport/#checking-scopes", 
            "text": "Passport includes two middleware that may be used to verify that an incoming request is authenticated with a token that has been granted a given scope. To get started, add the following middleware to the  $routeMiddleware  property of your  app/Http/Kernel.php  file:  scopes  =  \\Laravel\\Passport\\Http\\Middleware\\CheckScopes::class, scope  =  \\Laravel\\Passport\\Http\\Middleware\\CheckForAnyScope::class,", 
            "title": "Checking Scopes"
        }, 
        {
            "location": "/passport/#check-for-all-scopes", 
            "text": "The  scopes  middleware may be assigned to a route to verify that the incoming request's access token has  all  of the listed scopes:  Route :: get ( /orders ,   function   ()   { \n     //   Access   token   has   both   check-status   and   place-orders   scopes...  } ) - middleware ( scopes:check-status,place-orders );", 
            "title": "Check For All Scopes"
        }, 
        {
            "location": "/passport/#check-for-any-scopes", 
            "text": "The  scope  middleware may be assigned to a route to verify that the incoming request's access token has  at least one  of the listed scopes:  Route :: get ( /orders ,   function   ()   { \n     //   Access   token   has   either   check-status   or   place-orders   scope...  } ) - middleware ( scope:check-status,place-orders );", 
            "title": "Check For Any Scopes"
        }, 
        {
            "location": "/passport/#checking-scopes-on-a-token-instance", 
            "text": "Once an access token authenticated request has entered your application, you may still check if the token has a given scope using the  tokenCan  method on the authenticated  User  instance:  use Illuminate\\Http\\Request;\n\nRoute::get( /orders , function (Request $request) {\n    if ($request- user()- tokenCan( place-orders )) {\n        //\n    }\n});", 
            "title": "Checking Scopes On A Token Instance"
        }, 
        {
            "location": "/passport/#consuming-your-api-with-javascript", 
            "text": "When building an API, it can be extremely useful to be able to consume your own API from your JavaScript application. This approach to API development allows your own application to consume the same API that you are sharing with the world. The same API may be consumed by your web application, mobile applications, third-party applications, and any SDKs that you may publish on various package managers.  Typically, if you want to consume your API from your JavaScript application, you would need to manually send an access token to the application and pass it with each request to your application. However, Passport includes a middleware that can handle this for you. All you need to do is add the  CreateFreshApiToken  middleware to your  web  middleware group:  web  =  [\n    // Other middleware...\n    \\Laravel\\Passport\\Http\\Middleware\\CreateFreshApiToken::class,\n],  This Passport middleware will attach a  laravel_token  cookie to your outgoing responses. This cookie contains an encrypted JWT that Passport will use to authenticate API requests from your JavaScript application. Now, you may make requests to your application's API without explicitly passing an access token:  axios.get( /user )\n    .then(response =  {\n        console.log(response.data);\n    });  When using this method of authentication, Axios will automatically send the  X-CSRF-TOKEN  header. In addition, the default Laravel JavaScript scaffolding instructs Axios to send the  X-Requested-With  header:  window.axios.defaults.headers.common = {\n     X-Requested-With :  XMLHttpRequest ,\n};   {note} If you are using a different JavaScript framework, you should make sure it is configured to send the  X-CSRF-TOKEN  and  X-Requested-With  headers with every outgoing request.", 
            "title": "Consuming Your API With JavaScript"
        }, 
        {
            "location": "/passport/#events", 
            "text": "Passport raises events when issuing access tokens and refresh tokens. You may use these events to prune or revoke other access tokens in your database. You may attach listeners to these events in your application's  EventServiceProvider :  /**   * The event listener mappings for the application.   *   * @var array   */  protected $listen = [       Laravel\\Passport\\Events\\AccessTokenCreated  =  [           App\\Listeners\\RevokeOldTokens ,      ],       Laravel\\Passport\\Events\\RefreshTokenCreated  =  [           App\\Listeners\\PruneOldTokens ,      ],  ];", 
            "title": "Events"
        }, 
        {
            "location": "/passport/#testing", 
            "text": "Passport's  actingAs  method may be used to specify the currently authenticated user as well as its scopes. The first argument given to the  actingAs  method is the user instance and the second is an array of scopes that should be granted to the user's token:  public function testServerCreation()\n{\n    Passport::actingAs(\n        factory(User::class)- create(),\n        [ create-servers ]\n    );\n\n    $response = $this- post( /api/create-server );\n\n    $response- assertStatus(200);\n}", 
            "title": "Testing"
        }, 
        {
            "location": "/passwords/", 
            "text": "Resetting Passwords\n\n\n\n\nIntroduction\n\n\nDatabase Considerations\n\n\nRouting\n\n\nViews\n\n\nAfter Resetting Passwords\n\n\nCustomization\n\n\n\n\n\n\nIntroduction\n\n\n\n\n{tip} \nWant to get started fast?\n Just run \nphp artisan make:auth\n in a fresh Laravel application and navigate your browser to \nhttp://your-app.dev/register\n or any other URL that is assigned to your application. This single command will take care of scaffolding your entire authentication system, including resetting passwords!\n\n\n\n\nMost web applications provide a way for users to reset their forgotten passwords. Rather than forcing you to re-implement this on each application, Laravel provides convenient methods for sending password reminders and performing password resets.\n\n\n\n\n{note} Before using the password reset features of Laravel, your user must use the \nIlluminate\\Notifications\\Notifiable\n trait.\n\n\n\n\n\n\nDatabase Considerations\n\n\nTo get started, verify that your \nApp\\User\n model implements the \nIlluminate\\Contracts\\Auth\\CanResetPassword\n contract. Of course, the \nApp\\User\n model included with the framework already implements this interface, and uses the \nIlluminate\\Auth\\Passwords\\CanResetPassword\n trait to include the methods needed to implement the interface.\n\n\nGenerating The Reset Token Table Migration\n\n\nNext, a table must be created to store the password reset tokens. The migration for this table is included with Laravel out of the box, and resides in the \ndatabase/migrations\n directory. So, all you need to do is run your database migrations:\n\n\nphp artisan migrate\n\n\n\n\n\n\n\nRouting\n\n\nLaravel includes \nAuth\\ForgotPasswordController\n and \nAuth\\ResetPasswordController\n classes that contains the logic necessary to e-mail password reset links and reset user passwords. All of the routes needed to perform password resets may be generated using the \nmake:auth\n Artisan command:\n\n\nphp artisan make:auth\n\n\n\n\n\n\n\nViews\n\n\nAgain, Laravel will generate all of the necessary views for password reset when the \nmake:auth\n command is executed. These views are placed in \nresources/views/auth/passwords\n. You are free to customize them as needed for your application.\n\n\n\n\nAfter Resetting Passwords\n\n\nOnce you have defined the routes and views to reset your user's passwords, you may simply access the route in your browser at \n/password/reset\n. The \nForgotPasswordController\n included with the framework already includes the logic to send the password reset link e-mails, while the \nResetPasswordController\n includes the logic to reset user passwords.\n\n\nAfter a password is reset, the user will automatically be logged into the application and redirected to \n/home\n. You can customize the post password reset redirect location by defining a \nredirectTo\n property on the \nResetPasswordController\n:\n\n\nprotected $redirectTo = \n/dashboard\n;\n\n\n\n\n\n\n\n{note} By default, password reset tokens expire after one hour. You may change this via the password reset \nexpire\n option in your \nconfig/auth.php\n file.\n\n\n\n\n\n\nCustomization\n\n\nAuthentication Guard Customization\n\n\nIn your \nauth.php\n configuration file, you may configure multiple \"guards\", which may be used to define authentication behavior for multiple user tables. You can customize the included \nResetPasswordController\n to use the guard of your choice by overriding the \nguard\n method on the controller. This method should return a guard instance:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nAuth\n;\n\n\n\nprotected\n \nfunction\n \nguard\n()\n\n\n{\n\n    \nreturn\n \nAuth\n:\n:\nguard\n(\nguard-name\n);\n\n\n}\n\n\n\n\n\n\nPassword Broker Customization\n\n\nIn your \nauth.php\n configuration file, you may configure multiple password \"brokers\", which may be used to reset passwords on multiple user tables. You can customize the included \nForgotPasswordController\n and \nResetPasswordController\n to use the broker of your choice by overriding the \nbroker\n method:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nPassword\n;\n\n\n\n/**\n\n\n * Get the broker to be used during password reset.\n\n\n *\n\n\n * @return PasswordBroker\n\n\n */\n\n\nprotected\n \nfunction\n \nbroker\n()\n\n\n{\n\n    \nreturn\n \nPassword\n:\n:\nbroker\n(\nname\n);\n\n\n}\n\n\n\n\n\n\nReset Email Customization\n\n\nYou may easily modify the notification class used to send the password reset link to the user. To get started, override the \nsendPasswordResetNotification\n method on your \nUser\n model. Within this method, you may send the notification using any notification class you choose. The password reset \n$token\n is the first argument received by the method:\n\n\n/**\n\n\n * Send the password reset notification.\n\n\n *\n\n\n * @param  string  $token\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nsendPasswordResetNotification\n(\n$\ntoken\n)\n\n\n{\n\n\n    \n$\nthis\n-\nnotify\n(\nnew\n \nResetPasswordNotification\n(\n$\ntoken\n))\n;\n\n\n}", 
            "title": "Passwords"
        }, 
        {
            "location": "/passwords/#resetting-passwords", 
            "text": "Introduction  Database Considerations  Routing  Views  After Resetting Passwords  Customization", 
            "title": "Resetting Passwords"
        }, 
        {
            "location": "/passwords/#introduction", 
            "text": "{tip}  Want to get started fast?  Just run  php artisan make:auth  in a fresh Laravel application and navigate your browser to  http://your-app.dev/register  or any other URL that is assigned to your application. This single command will take care of scaffolding your entire authentication system, including resetting passwords!   Most web applications provide a way for users to reset their forgotten passwords. Rather than forcing you to re-implement this on each application, Laravel provides convenient methods for sending password reminders and performing password resets.   {note} Before using the password reset features of Laravel, your user must use the  Illuminate\\Notifications\\Notifiable  trait.", 
            "title": "Introduction"
        }, 
        {
            "location": "/passwords/#database-considerations", 
            "text": "To get started, verify that your  App\\User  model implements the  Illuminate\\Contracts\\Auth\\CanResetPassword  contract. Of course, the  App\\User  model included with the framework already implements this interface, and uses the  Illuminate\\Auth\\Passwords\\CanResetPassword  trait to include the methods needed to implement the interface.", 
            "title": "Database Considerations"
        }, 
        {
            "location": "/passwords/#generating-the-reset-token-table-migration", 
            "text": "Next, a table must be created to store the password reset tokens. The migration for this table is included with Laravel out of the box, and resides in the  database/migrations  directory. So, all you need to do is run your database migrations:  php artisan migrate", 
            "title": "Generating The Reset Token Table Migration"
        }, 
        {
            "location": "/passwords/#routing", 
            "text": "Laravel includes  Auth\\ForgotPasswordController  and  Auth\\ResetPasswordController  classes that contains the logic necessary to e-mail password reset links and reset user passwords. All of the routes needed to perform password resets may be generated using the  make:auth  Artisan command:  php artisan make:auth", 
            "title": "Routing"
        }, 
        {
            "location": "/passwords/#views", 
            "text": "Again, Laravel will generate all of the necessary views for password reset when the  make:auth  command is executed. These views are placed in  resources/views/auth/passwords . You are free to customize them as needed for your application.", 
            "title": "Views"
        }, 
        {
            "location": "/passwords/#after-resetting-passwords", 
            "text": "Once you have defined the routes and views to reset your user's passwords, you may simply access the route in your browser at  /password/reset . The  ForgotPasswordController  included with the framework already includes the logic to send the password reset link e-mails, while the  ResetPasswordController  includes the logic to reset user passwords.  After a password is reset, the user will automatically be logged into the application and redirected to  /home . You can customize the post password reset redirect location by defining a  redirectTo  property on the  ResetPasswordController :  protected $redirectTo =  /dashboard ;   {note} By default, password reset tokens expire after one hour. You may change this via the password reset  expire  option in your  config/auth.php  file.", 
            "title": "After Resetting Passwords"
        }, 
        {
            "location": "/passwords/#customization", 
            "text": "", 
            "title": "Customization"
        }, 
        {
            "location": "/passwords/#authentication-guard-customization", 
            "text": "In your  auth.php  configuration file, you may configure multiple \"guards\", which may be used to define authentication behavior for multiple user tables. You can customize the included  ResetPasswordController  to use the guard of your choice by overriding the  guard  method on the controller. This method should return a guard instance:  use   Illuminate \\ Support \\ Facades \\ Auth ;  protected   function   guard ()  { \n     return   Auth : : guard ( guard-name );  }", 
            "title": "Authentication Guard Customization"
        }, 
        {
            "location": "/passwords/#password-broker-customization", 
            "text": "In your  auth.php  configuration file, you may configure multiple password \"brokers\", which may be used to reset passwords on multiple user tables. You can customize the included  ForgotPasswordController  and  ResetPasswordController  to use the broker of your choice by overriding the  broker  method:  use   Illuminate \\ Support \\ Facades \\ Password ;  /**   * Get the broker to be used during password reset.   *   * @return PasswordBroker   */  protected   function   broker ()  { \n     return   Password : : broker ( name );  }", 
            "title": "Password Broker Customization"
        }, 
        {
            "location": "/passwords/#reset-email-customization", 
            "text": "You may easily modify the notification class used to send the password reset link to the user. To get started, override the  sendPasswordResetNotification  method on your  User  model. Within this method, you may send the notification using any notification class you choose. The password reset  $token  is the first argument received by the method:  /**   * Send the password reset notification.   *   * @param  string  $token   * @return void   */ \npublic   function   sendPasswordResetNotification ( $ token )  {       $ this - notify ( new   ResetPasswordNotification ( $ token )) ;  }", 
            "title": "Reset Email Customization"
        }, 
        {
            "location": "/providers/", 
            "text": "Service Providers\n\n\n\n\nIntroduction\n\n\nWriting Service Providers\n\n\nThe Register Method\n\n\nThe Boot Method\n\n\n\n\n\n\nRegistering Providers\n\n\nDeferred Providers\n\n\n\n\n\n\nIntroduction\n\n\nService providers are the central place of all Laravel application bootstrapping. Your own application, as well as all of Laravel's core services are bootstrapped via service providers.\n\n\nBut, what do we mean by \"bootstrapped\"? In general, we mean \nregistering\n things, including registering service container bindings, event listeners, middleware, and even routes. Service providers are the central place to configure your application.\n\n\nIf you open the \nconfig/app.php\n file included with Laravel, you will see a \nproviders\n array. These are all of the service provider classes that will be loaded for your application. Of course, many of these are \"deferred\" providers, meaning they will not be loaded on every request, but only when the services they provide are actually needed.\n\n\nIn this overview you will learn how to write your own service providers and register them with your Laravel application.\n\n\n\n\nWriting Service Providers\n\n\nAll service providers extend the \nIlluminate\\Support\\ServiceProvider\n class. Most service providers contain a \nregister\n and a \nboot\n method. Within the \nregister\n method, you should \nonly bind things into the \nservice container\n. You should never attempt to register any event listeners, routes, or any other piece of functionality within the \nregister\n method.\n\n\nThe Artisan CLI can generate a new provider via the \nmake:provider\n command:\n\n\nphp artisan make:provider RiakServiceProvider\n\n\n\n\n\n\n\nThe Register Method\n\n\nAs mentioned previously, within the \nregister\n method, you should only bind things into the \nservice container\n. You should never attempt to register any event listeners, routes, or any other piece of functionality within the \nregister\n method. Otherwise, you may accidentally use a service that is provided by a service provider which has not loaded yet.\n\n\nLet's take a look at a basic service provider. Within any of your service provider methods, you always have access to the \n$app\n property which provides access to the service container:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nRiak\n\\\nConnection\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\n\nclass\n \nRiakServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Register bindings in the container.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n$this\n-\napp\n-\nsingleton\n(\nConnection\n::\nclass\n,\n \nfunction\n \n(\n$app\n)\n \n{\n\n            \nreturn\n \nnew\n \nConnection\n(\nconfig\n(\nriak\n));\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThis service provider only defines a \nregister\n method, and uses that method to define an implementation of \nRiak\\Connection\n in the service container. If you don't understand how the service container works, check out \nits documentation\n.\n\n\n\n\nThe Boot Method\n\n\nSo, what if we need to register a view composer within our service provider? This should be done within the \nboot\n method. \nThis method is called after all other service providers have been registered\n, meaning you have access to all other services that have been registered by the framework:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\n\nclass\n \nComposerServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Bootstrap any application services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nview\n()\n-\ncomposer\n(\nview\n,\n \nfunction\n \n()\n \n{\n\n            \n//\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nBoot Method Dependency Injection\n\n\nYou may type-hint dependencies for your service provider's \nboot\n method. The \nservice container\n will automatically inject any dependencies you need:\n\n\nuse Illuminate\\Contracts\\Routing\\ResponseFactory;\n\npublic function boot(ResponseFactory $response)\n{\n    $response-\nmacro(\ncaps\n, function ($value) {\n        //\n    });\n}\n\n\n\n\n\n\n\nRegistering Providers\n\n\nAll service providers are registered in the \nconfig/app.php\n configuration file. This file contains a \nproviders\n array where you can list the class names of your service providers. By default, a set of Laravel core service providers are listed in this array. These providers bootstrap the core Laravel components, such as the mailer, queue, cache, and others.\n\n\nTo register your provider, simply add it to the array:\n\n\nproviders\n =\n [\n    // Other Service Providers\n\n    App\\Providers\\ComposerServiceProvider::class,\n],\n\n\n\n\n\n\n\nDeferred Providers\n\n\nIf your provider is \nonly\n registering bindings in the \nservice container\n, you may choose to defer its registration until one of the registered bindings is actually needed. Deferring the loading of such a provider will improve the performance of your application, since it is not loaded from the filesystem on every request.\n\n\nLaravel compiles and stores a list of all of the services supplied by deferred service providers, along with the name of its service provider class. Then, only when you attempt to resolve one of these services does Laravel load the service provider.\n\n\nTo defer the loading of a provider, set the \ndefer\n property to \ntrue\n and define a \nprovides\n method. The \nprovides\n method should return the service container bindings registered by the provider:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nRiak\n\\\nConnection\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\n\nclass\n \nRiakServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Indicates if loading of the provider is deferred.\n\n\n     *\n\n\n     * @var bool\n\n\n     */\n\n    \nprotected\n \n$defer\n \n=\n \ntrue\n;\n\n\n    \n/**\n\n\n     * Register the service provider.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n$this\n-\napp\n-\nsingleton\n(\nConnection\n::\nclass\n,\n \nfunction\n \n(\n$app\n)\n \n{\n\n            \nreturn\n \nnew\n \nConnection\n(\n$app\n[\nconfig\n][\nriak\n]);\n\n        \n});\n\n    \n}\n\n\n    \n/**\n\n\n     * Get the services provided by the provider.\n\n\n     *\n\n\n     * @return array\n\n\n     */\n\n    \npublic\n \nfunction\n \nprovides\n()\n\n    \n{\n\n        \nreturn\n \n[\nConnection\n::\nclass\n];\n\n    \n}\n\n\n\n}", 
            "title": "Providers"
        }, 
        {
            "location": "/providers/#service-providers", 
            "text": "Introduction  Writing Service Providers  The Register Method  The Boot Method    Registering Providers  Deferred Providers", 
            "title": "Service Providers"
        }, 
        {
            "location": "/providers/#introduction", 
            "text": "Service providers are the central place of all Laravel application bootstrapping. Your own application, as well as all of Laravel's core services are bootstrapped via service providers.  But, what do we mean by \"bootstrapped\"? In general, we mean  registering  things, including registering service container bindings, event listeners, middleware, and even routes. Service providers are the central place to configure your application.  If you open the  config/app.php  file included with Laravel, you will see a  providers  array. These are all of the service provider classes that will be loaded for your application. Of course, many of these are \"deferred\" providers, meaning they will not be loaded on every request, but only when the services they provide are actually needed.  In this overview you will learn how to write your own service providers and register them with your Laravel application.", 
            "title": "Introduction"
        }, 
        {
            "location": "/providers/#writing-service-providers", 
            "text": "All service providers extend the  Illuminate\\Support\\ServiceProvider  class. Most service providers contain a  register  and a  boot  method. Within the  register  method, you should  only bind things into the  service container . You should never attempt to register any event listeners, routes, or any other piece of functionality within the  register  method.  The Artisan CLI can generate a new provider via the  make:provider  command:  php artisan make:provider RiakServiceProvider", 
            "title": "Writing Service Providers"
        }, 
        {
            "location": "/providers/#the-register-method", 
            "text": "As mentioned previously, within the  register  method, you should only bind things into the  service container . You should never attempt to register any event listeners, routes, or any other piece of functionality within the  register  method. Otherwise, you may accidentally use a service that is provided by a service provider which has not loaded yet.  Let's take a look at a basic service provider. Within any of your service provider methods, you always have access to the  $app  property which provides access to the service container:  ? php  namespace   App \\ Providers ;  use   Riak \\ Connection ;  use   Illuminate \\ Support \\ ServiceProvider ;  class   RiakServiceProvider   extends   ServiceProvider  { \n     /**       * Register bindings in the container.       *       * @return void       */ \n     public   function   register () \n     { \n         $this - app - singleton ( Connection :: class ,   function   ( $app )   { \n             return   new   Connection ( config ( riak )); \n         }); \n     }  }   This service provider only defines a  register  method, and uses that method to define an implementation of  Riak\\Connection  in the service container. If you don't understand how the service container works, check out  its documentation .", 
            "title": "The Register Method"
        }, 
        {
            "location": "/providers/#the-boot-method", 
            "text": "So, what if we need to register a view composer within our service provider? This should be done within the  boot  method.  This method is called after all other service providers have been registered , meaning you have access to all other services that have been registered by the framework:  ? php  namespace   App \\ Providers ;  use   Illuminate \\ Support \\ ServiceProvider ;  class   ComposerServiceProvider   extends   ServiceProvider  { \n     /**       * Bootstrap any application services.       *       * @return void       */ \n     public   function   boot () \n     { \n         view () - composer ( view ,   function   ()   { \n             // \n         }); \n     }  }", 
            "title": "The Boot Method"
        }, 
        {
            "location": "/providers/#boot-method-dependency-injection", 
            "text": "You may type-hint dependencies for your service provider's  boot  method. The  service container  will automatically inject any dependencies you need:  use Illuminate\\Contracts\\Routing\\ResponseFactory;\n\npublic function boot(ResponseFactory $response)\n{\n    $response- macro( caps , function ($value) {\n        //\n    });\n}", 
            "title": "Boot Method Dependency Injection"
        }, 
        {
            "location": "/providers/#registering-providers", 
            "text": "All service providers are registered in the  config/app.php  configuration file. This file contains a  providers  array where you can list the class names of your service providers. By default, a set of Laravel core service providers are listed in this array. These providers bootstrap the core Laravel components, such as the mailer, queue, cache, and others.  To register your provider, simply add it to the array:  providers  =  [\n    // Other Service Providers\n\n    App\\Providers\\ComposerServiceProvider::class,\n],", 
            "title": "Registering Providers"
        }, 
        {
            "location": "/providers/#deferred-providers", 
            "text": "If your provider is  only  registering bindings in the  service container , you may choose to defer its registration until one of the registered bindings is actually needed. Deferring the loading of such a provider will improve the performance of your application, since it is not loaded from the filesystem on every request.  Laravel compiles and stores a list of all of the services supplied by deferred service providers, along with the name of its service provider class. Then, only when you attempt to resolve one of these services does Laravel load the service provider.  To defer the loading of a provider, set the  defer  property to  true  and define a  provides  method. The  provides  method should return the service container bindings registered by the provider:  ? php  namespace   App \\ Providers ;  use   Riak \\ Connection ;  use   Illuminate \\ Support \\ ServiceProvider ;  class   RiakServiceProvider   extends   ServiceProvider  { \n     /**       * Indicates if loading of the provider is deferred.       *       * @var bool       */ \n     protected   $defer   =   true ; \n\n     /**       * Register the service provider.       *       * @return void       */ \n     public   function   register () \n     { \n         $this - app - singleton ( Connection :: class ,   function   ( $app )   { \n             return   new   Connection ( $app [ config ][ riak ]); \n         }); \n     } \n\n     /**       * Get the services provided by the provider.       *       * @return array       */ \n     public   function   provides () \n     { \n         return   [ Connection :: class ]; \n     }  }", 
            "title": "Deferred Providers"
        }, 
        {
            "location": "/queries/", 
            "text": "Database: Query Builder\n\n\n\n\nIntroduction\n\n\nRetrieving Results\n\n\nChunking Results\n\n\nAggregates\n\n\n\n\n\n\nSelects\n\n\nRaw Expressions\n\n\nJoins\n\n\nUnions\n\n\nWhere Clauses\n\n\nParameter Grouping\n\n\nWhere Exists Clauses\n\n\nJSON Where Clauses\n\n\n\n\n\n\nOrdering, Grouping, Limit, \n Offset\n\n\nConditional Clauses\n\n\nInserts\n\n\nUpdates\n\n\nUpdating JSON Columns\n\n\nIncrement \n Decrement\n\n\n\n\n\n\nDeletes\n\n\nPessimistic Locking\n\n\n\n\n\n\nIntroduction\n\n\nLaravel's database query builder provides a convenient, fluent interface to creating and running database queries. It can be used to perform most database operations in your application and works on all supported database systems.\n\n\nThe Laravel query builder uses PDO parameter binding to protect your application against SQL injection attacks. There is no need to clean strings being passed as bindings.\n\n\n\n\nRetrieving Results\n\n\nRetrieving All Rows From A Table\n\n\nYou may use the \ntable\n method on the \nDB\n facade to begin a query. The \ntable\n method returns a fluent query builder instance for the given table, allowing you to chain more constraints onto the query and then finally get the results using the \nget\n method:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nDB\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Show a list of all of the application\ns users.\n\n\n     *\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nindex\n()\n\n    \n{\n\n        \n$users\n \n=\n \nDB\n::\ntable\n(\nusers\n)\n-\nget\n();\n\n\n        \nreturn\n \nview\n(\nuser.index\n,\n \n[\nusers\n \n=\n \n$users\n]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe \nget\n method returns an \nIlluminate\\Support\\Collection\n containing the results where each result is an instance of the PHP \nStdClass\n object. You may access each column's value by accessing the column as a property of the object:\n\n\nforeach ($users as $user) {\n    echo $user-\nname;\n}\n\n\n\n\n\nRetrieving A Single Row / Column From A Table\n\n\nIf you just need to retrieve a single row from the database table, you may use the \nfirst\n method. This method will return a single \nStdClass\n object:\n\n\n$\nuser\n \n=\n \nDB\n::\ntable\n(\nusers\n)\n-\nwhere\n(\nname\n,\n \nJohn\n)\n-\nfirst\n();\n\n\n\necho\n \n$\nuser-\nname\n;\n\n\n\n\n\n\nIf you don't even need an entire row, you may extract a single value from a record using the \nvalue\n method. This method will return the value of the column directly:\n\n\n$\nemail\n \n=\n \nDB\n::\ntable\n(\nusers\n)\n-\nwhere\n(\nname\n,\n \nJohn\n)\n-\nvalue\n(\nemail\n);\n\n\n\n\n\n\nRetrieving A List Of Column Values\n\n\nIf you would like to retrieve a Collection containing the values of a single column, you may use the \npluck\n method. In this example, we'll retrieve a Collection of role titles:\n\n\n$\ntitles\n \n=\n \nDB\n::\ntable\n(\nroles\n)\n-\npluck\n(\ntitle\n);\n\n\n\nforeach\n \n($\ntitles\n \nas\n \n$\ntitle\n)\n \n{\n\n    \necho\n \n$title\n;\n\n\n}\n\n\n\n\n\n\nYou may also specify a custom key column for the returned Collection:\n\n\n$\nroles\n \n=\n \nDB\n::\ntable\n(\nroles\n)\n-\npluck\n(\ntitle\n,\n \nname\n);\n\n\n\nforeach\n \n($\nroles\n \nas\n \n$\nname\n \n=\n \n$\ntitle\n)\n \n{\n\n    \necho\n \n$title\n;\n\n\n}\n\n\n\n\n\n\n\n\nChunking Results\n\n\nIf you need to work with thousands of database records, consider using the \nchunk\n method. This method retrieves a small chunk of the results at a time and feeds each chunk into a \nClosure\n for processing. This method is very useful for writing \nArtisan commands\n that process thousands of records. For example, let's work with the entire \nusers\n table in chunks of 100 records at a time:\n\n\nDB::table(\nusers\n)-\norderBy(\nid\n)-\nchunk(100, function ($users) {\n    foreach ($users as $user) {\n        //\n    }\n});\n\n\n\n\n\nYou may stop further chunks from being processed by returning \nfalse\n from the \nClosure\n:\n\n\nDB::table(\nusers\n)-\norderBy(\nid\n)-\nchunk(100, function ($users) {\n    // Process the records...\n\n    return false;\n});\n\n\n\n\n\n\n\nAggregates\n\n\nThe query builder also provides a variety of aggregate methods such as \ncount\n, \nmax\n, \nmin\n, \navg\n, and \nsum\n. You may call any of these methods after constructing your query:\n\n\n$\nusers\n \n=\n \nDB\n::\ntable\n(\nusers\n)\n-\ncount\n();\n\n\n\n$\nprice\n \n=\n \nDB\n::\ntable\n(\norders\n)\n-\nmax\n(\nprice\n);\n\n\n\n\n\n\nOf course, you may combine these methods with other clauses:\n\n\n$price = DB::table(\norders\n)\n                -\nwhere(\nfinalized\n, 1)\n                -\navg(\nprice\n);\n\n\n\n\n\n\n\nSelects\n\n\nSpecifying A Select Clause\n\n\nOf course, you may not always want to select all columns from a database table. Using the \nselect\n method, you can specify a custom \nselect\n clause for the query:\n\n\n$\nusers\n \n=\n \nDB\n::\ntable\n(\nusers\n)\n-\nselect\n(\nname\n,\n \nemail as user_email\n)\n-\nget\n();\n\n\n\n\n\n\nThe \ndistinct\n method allows you to force the query to return distinct results:\n\n\n$\nusers\n \n=\n \nDB\n::\ntable\n(\nusers\n)\n-\ndistinct\n()\n-\nget\n();\n\n\n\n\n\n\nIf you already have a query builder instance and you wish to add a column to its existing select clause, you may use the \naddSelect\n method:\n\n\n$\nquery\n \n=\n \nDB\n::\ntable\n(\nusers\n)\n-\nselect\n(\nname\n);\n\n\n\n$\nusers\n \n=\n \n$\nquery-\naddSelect\n(\nage\n)\n-\nget\n();\n\n\n\n\n\n\n\n\nRaw Expressions\n\n\nSometimes you may need to use a raw expression in a query. These expressions will be injected into the query as strings, so be careful not to create any SQL injection points! To create a raw expression, you may use the \nDB::raw\n method:\n\n\n$users = DB::table(\nusers\n)\n                     -\nselect(DB::raw(\ncount(*) as user_count, status\n))\n                     -\nwhere(\nstatus\n, \n, 1)\n                     -\ngroupBy(\nstatus\n)\n                     -\nget();\n\n\n\n\n\n\n\nJoins\n\n\nInner Join Clause\n\n\nThe query builder may also be used to write join statements. To perform a basic \"inner join\", you may use the \njoin\n method on a query builder instance. The first argument passed to the \njoin\n method is the name of the table you need to join to, while the remaining arguments specify the column constraints for the join. Of course, as you can see, you can join to multiple tables in a single query:\n\n\n$users = DB::table(\nusers\n)\n            -\njoin(\ncontacts\n, \nusers.id\n, \n=\n, \ncontacts.user_id\n)\n            -\njoin(\norders\n, \nusers.id\n, \n=\n, \norders.user_id\n)\n            -\nselect(\nusers.*\n, \ncontacts.phone\n, \norders.price\n)\n            -\nget();\n\n\n\n\n\nLeft Join Clause\n\n\nIf you would like to perform a \"left join\" instead of an \"inner join\", use the \nleftJoin\n method. The \nleftJoin\n method has the same signature as the \njoin\n method:\n\n\n$users = DB::table(\nusers\n)\n            -\nleftJoin(\nposts\n, \nusers.id\n, \n=\n, \nposts.user_id\n)\n            -\nget();\n\n\n\n\n\nCross Join Clause\n\n\nTo perform a \"cross join\" use the \ncrossJoin\n method with the name of the table you wish to cross join to. Cross joins generate a cartesian product between the first table and the joined table:\n\n\n$users = DB::table(\nsizes\n)\n            -\ncrossJoin(\ncolours\n)\n            -\nget();\n\n\n\n\n\nAdvanced Join Clauses\n\n\nYou may also specify more advanced join clauses. To get started, pass a \nClosure\n as the second argument into the \njoin\n method. The \nClosure\n will receive a \nJoinClause\n object which allows you to specify constraints on the \njoin\n clause:\n\n\nDB::table(\nusers\n)\n        -\njoin(\ncontacts\n, function ($join) {\n            $join-\non(\nusers.id\n, \n=\n, \ncontacts.user_id\n)-\norOn(...);\n        })\n        -\nget();\n\n\n\n\n\nIf you would like to use a \"where\" style clause on your joins, you may use the \nwhere\n and \norWhere\n methods on a join. Instead of comparing two columns, these methods will compare the column against a value:\n\n\nDB::table(\nusers\n)\n        -\njoin(\ncontacts\n, function ($join) {\n            $join-\non(\nusers.id\n, \n=\n, \ncontacts.user_id\n)\n                 -\nwhere(\ncontacts.user_id\n, \n, 5);\n        })\n        -\nget();\n\n\n\n\n\n\n\nUnions\n\n\nThe query builder also provides a quick way to \"union\" two queries together. For example, you may create an initial query and use the \nunion\n method to union it with a second query:\n\n\n$first = DB::table(\nusers\n)\n            -\nwhereNull(\nfirst_name\n);\n\n$users = DB::table(\nusers\n)\n            -\nwhereNull(\nlast_name\n)\n            -\nunion($first)\n            -\nget();\n\n\n\n\n\n\n\n{tip} The \nunionAll\n method is also available and has the same method signature as \nunion\n.\n\n\n\n\n\n\nWhere Clauses\n\n\nSimple Where Clauses\n\n\nYou may use the \nwhere\n method on a query builder instance to add \nwhere\n clauses to the query. The most basic call to \nwhere\n requires three arguments. The first argument is the name of the column. The second argument is an operator, which can be any of the database's supported operators. Finally, the third argument is the value to evaluate against the column.\n\n\nFor example, here is a query that verifies the value of the \"votes\" column is equal to 100:\n\n\n$\nusers\n \n=\n \nDB\n::\ntable\n(\nusers\n)\n-\nwhere\n(\nvotes\n,\n \n=\n,\n \n100\n)\n-\nget\n();\n\n\n\n\n\n\nFor convenience, if you simply want to verify that a column is equal to a given value, you may pass the value directly as the second argument to the \nwhere\n method:\n\n\n$\nusers\n \n=\n \nDB\n::\ntable\n(\nusers\n)\n-\nwhere\n(\nvotes\n,\n \n100\n)\n-\nget\n();\n\n\n\n\n\n\nOf course, you may use a variety of other operators when writing a \nwhere\n clause:\n\n\n$users = DB::table(\nusers\n)\n                -\nwhere(\nvotes\n, \n=\n, 100)\n                -\nget();\n\n$users = DB::table(\nusers\n)\n                -\nwhere(\nvotes\n, \n, 100)\n                -\nget();\n\n$users = DB::table(\nusers\n)\n                -\nwhere(\nname\n, \nlike\n, \nT%\n)\n                -\nget();\n\n\n\n\n\nYou may also pass an array of conditions to the \nwhere\n function:\n\n\n$users = DB::table(\nusers\n)-\nwhere([\n    [\nstatus\n, \n=\n, \n1\n],\n    [\nsubscribed\n, \n, \n1\n],\n])-\nget();\n\n\n\n\n\nOr Statements\n\n\nYou may chain where constraints together as well as add \nor\n clauses to the query. The \norWhere\n method accepts the same arguments as the \nwhere\n method:\n\n\n$users = DB::table(\nusers\n)\n                    -\nwhere(\nvotes\n, \n, 100)\n                    -\norWhere(\nname\n, \nJohn\n)\n                    -\nget();\n\n\n\n\n\nAdditional Where Clauses\n\n\nwhereBetween\n\n\nThe \nwhereBetween\n method verifies that a column's value is between two values:\n\n\n$users = DB::table(\nusers\n)\n                    -\nwhereBetween(\nvotes\n, [1, 100])-\nget();\n\n\n\n\n\nwhereNotBetween\n\n\nThe \nwhereNotBetween\n method verifies that a column's value lies outside of two values:\n\n\n$users = DB::table(\nusers\n)\n                    -\nwhereNotBetween(\nvotes\n, [1, 100])\n                    -\nget();\n\n\n\n\n\nwhereIn / whereNotIn\n\n\nThe \nwhereIn\n method verifies that a given column's value is contained within the given array:\n\n\n$users = DB::table(\nusers\n)\n                    -\nwhereIn(\nid\n, [1, 2, 3])\n                    -\nget();\n\n\n\n\n\nThe \nwhereNotIn\n method verifies that the given column's value is \nnot\n contained in the given array:\n\n\n$users = DB::table(\nusers\n)\n                    -\nwhereNotIn(\nid\n, [1, 2, 3])\n                    -\nget();\n\n\n\n\n\nwhereNull / whereNotNull\n\n\nThe \nwhereNull\n method verifies that the value of the given column is \nNULL\n:\n\n\n$users = DB::table(\nusers\n)\n                    -\nwhereNull(\nupdated_at\n)\n                    -\nget();\n\n\n\n\n\nThe \nwhereNotNull\n method verifies that the column's value is not \nNULL\n:\n\n\n$users = DB::table(\nusers\n)\n                    -\nwhereNotNull(\nupdated_at\n)\n                    -\nget();\n\n\n\n\n\nwhereDate / whereMonth / whereDay / whereYear\n\n\nThe \nwhereDate\n method may be used to compare a column's value against a date:\n\n\n$users = DB::table(\nusers\n)\n                -\nwhereDate(\ncreated_at\n, \n2016-12-31\n)\n                -\nget();\n\n\n\n\n\nThe \nwhereMonth\n method may be used to compare a column's value against a specific month of a year:\n\n\n$users = DB::table(\nusers\n)\n                -\nwhereMonth(\ncreated_at\n, \n12\n)\n                -\nget();\n\n\n\n\n\nThe \nwhereDay\n method may be used to compare a column's value against a specific day of a month:\n\n\n$users = DB::table(\nusers\n)\n                -\nwhereDay(\ncreated_at\n, \n31\n)\n                -\nget();\n\n\n\n\n\nThe \nwhereYear\n method may be used to compare a column's value against a specific year:\n\n\n$users = DB::table(\nusers\n)\n                -\nwhereYear(\ncreated_at\n, \n2016\n)\n                -\nget();\n\n\n\n\n\nwhereColumn\n\n\nThe \nwhereColumn\n method may be used to verify that two columns are equal:\n\n\n$users = DB::table(\nusers\n)\n                -\nwhereColumn(\nfirst_name\n, \nlast_name\n)\n                -\nget();\n\n\n\n\n\nYou may also pass a comparison operator to the method:\n\n\n$users = DB::table(\nusers\n)\n                -\nwhereColumn(\nupdated_at\n, \n, \ncreated_at\n)\n                -\nget();\n\n\n\n\n\nThe \nwhereColumn\n method can also be passed an array of multiple conditions. These conditions will be joined using the \nand\n operator:\n\n\n$users = DB::table(\nusers\n)\n                -\nwhereColumn([\n                    [\nfirst_name\n, \n=\n, \nlast_name\n],\n                    [\nupdated_at\n, \n, \ncreated_at\n]\n                ])-\nget();\n\n\n\n\n\n\n\nParameter Grouping\n\n\nSometimes you may need to create more advanced where clauses such as \"where exists\" clauses or nested parameter groupings. The Laravel query builder can handle these as well. To get started, let's look at an example of grouping constraints within parenthesis:\n\n\nDB::table(\nusers\n)\n            -\nwhere(\nname\n, \n=\n, \nJohn\n)\n            -\norWhere(function ($query) {\n                $query-\nwhere(\nvotes\n, \n, 100)\n                      -\nwhere(\ntitle\n, \n, \nAdmin\n);\n            })\n            -\nget();\n\n\n\n\n\nAs you can see, passing a \nClosure\n into the \norWhere\n method instructs the query builder to begin a constraint group. The \nClosure\n will receive a query builder instance which you can use to set the constraints that should be contained within the parenthesis group. The example above will produce the following SQL:\n\n\nselect * from users where name = \nJohn\n or (votes \n 100 and title \n \nAdmin\n)\n\n\n\n\n\n\n\nWhere Exists Clauses\n\n\nThe \nwhereExists\n method allows you to write \nwhere exists\n SQL clauses. The \nwhereExists\n method accepts a \nClosure\n argument, which will receive a query builder instance allowing you to define the query that should be placed inside of the \"exists\" clause:\n\n\nDB::table(\nusers\n)\n            -\nwhereExists(function ($query) {\n                $query-\nselect(DB::raw(1))\n                      -\nfrom(\norders\n)\n                      -\nwhereRaw(\norders.user_id = users.id\n);\n            })\n            -\nget();\n\n\n\n\n\nThe query above will produce the following SQL:\n\n\nselect * from users\nwhere exists (\n    select 1 from orders where orders.user_id = users.id\n)\n\n\n\n\n\n\n\nJSON Where Clauses\n\n\nLaravel also supports querying JSON column types on databases that provide support for JSON column types. Currently, this includes MySQL 5.7 and Postgres. To query a JSON column, use the \n-\n operator:\n\n\n$users = DB::table(\nusers\n)\n                -\nwhere(\noptions-\nlanguage\n, \nen\n)\n                -\nget();\n\n$users = DB::table(\nusers\n)\n                -\nwhere(\npreferences-\ndining-\nmeal\n, \nsalad\n)\n                -\nget();\n\n\n\n\n\n\n\nOrdering, Grouping, Limit, \n Offset\n\n\norderBy\n\n\nThe \norderBy\n method allows you to sort the result of the query by a given column. The first argument to the \norderBy\n method should be the column you wish to sort by, while the second argument controls the direction of the sort and may be either \nasc\n or \ndesc\n:\n\n\n$users = DB::table(\nusers\n)\n                -\norderBy(\nname\n, \ndesc\n)\n                -\nget();\n\n\n\n\n\nlatest / oldest\n\n\nThe \nlatest\n and \noldest\n methods allow you to easily order results by date. By default, result will be ordered by the \ncreated_at\n column. Or, you may pass the column name that you wish to sort by:\n\n\n$user = DB::table(\nusers\n)\n                -\nlatest()\n                -\nfirst();\n\n\n\n\n\ninRandomOrder\n\n\nThe \ninRandomOrder\n method may be used to sort the query results randomly. For example, you may use this method to fetch a random user:\n\n\n$randomUser = DB::table(\nusers\n)\n                -\ninRandomOrder()\n                -\nfirst();\n\n\n\n\n\ngroupBy / having / havingRaw\n\n\nThe \ngroupBy\n and \nhaving\n methods may be used to group the query results. The \nhaving\n method's signature is similar to that of the \nwhere\n method:\n\n\n$users = DB::table(\nusers\n)\n                -\ngroupBy(\naccount_id\n)\n                -\nhaving(\naccount_id\n, \n, 100)\n                -\nget();\n\n\n\n\n\nThe \nhavingRaw\n method may be used to set a raw string as the value of the \nhaving\n clause. For example, we can find all of the departments with sales greater than $2,500:\n\n\n$users = DB::table(\norders\n)\n                -\nselect(\ndepartment\n, DB::raw(\nSUM(price) as total_sales\n))\n                -\ngroupBy(\ndepartment\n)\n                -\nhavingRaw(\nSUM(price) \n 2500\n)\n                -\nget();\n\n\n\n\n\nskip / take\n\n\nTo limit the number of results returned from the query, or to skip a given number of results in the query, you may use the \nskip\n and \ntake\n methods:\n\n\n$\nusers\n \n=\n \nDB\n::\ntable\n(\nusers\n)\n-\nskip\n(\n10\n)\n-\ntake\n(\n5\n)\n-\nget\n();\n\n\n\n\n\n\nAlternatively, you may use the \nlimit\n and \noffset\n methods:\n\n\n$users = DB::table(\nusers\n)\n                -\noffset(10)\n                -\nlimit(5)\n                -\nget();\n\n\n\n\n\n\n\nConditional Clauses\n\n\nSometimes you may want clauses to apply to a query only when something else is true. For instance you may only want to apply a \nwhere\n statement if a given input value is present on the incoming request. You may accomplish this using the \nwhen\n method:\n\n\n$role = $request-\ninput(\nrole\n);\n\n$users = DB::table(\nusers\n)\n                -\nwhen($role, function ($query) use ($role) {\n                    return $query-\nwhere(\nrole_id\n, $role);\n                })\n                -\nget();\n\n\n\n\n\nThe \nwhen\n method only executes the given Closure when the first parameter is \ntrue\n. If the first parameter is \nfalse\n, the Closure will not be executed.\n\n\nYou may pass another Closure as the third parameter to the \nwhen\n method. This Closure will execute if the first parameter evaluates as \nfalse\n. To illustrate how this feature may be used, we will use it to configure the default sorting of a query:\n\n\n$sortBy = null;\n\n$users = DB::table(\nusers\n)\n                -\nwhen($sortBy, function ($query) use ($sortBy) {\n                    return $query-\norderBy($sortBy);\n                }, function ($query) {\n                    return $query-\norderBy(\nname\n);\n                })\n                -\nget();\n\n\n\n\n\n\n\nInserts\n\n\nThe query builder also provides an \ninsert\n method for inserting records into the database table. The \ninsert\n method accepts an array of column names and values:\n\n\nDB::table(\nusers\n)-\ninsert(\n    [\nemail\n =\n \njohn@example.com\n, \nvotes\n =\n 0]\n);\n\n\n\n\n\nYou may even insert several records into the table with a single call to \ninsert\n by passing an array of arrays. Each array represents a row to be inserted into the table:\n\n\nDB::table(\nusers\n)-\ninsert([\n    [\nemail\n =\n \ntaylor@example.com\n, \nvotes\n =\n 0],\n    [\nemail\n =\n \ndayle@example.com\n, \nvotes\n =\n 0]\n]);\n\n\n\n\n\nAuto-Incrementing IDs\n\n\nIf the table has an auto-incrementing id, use the \ninsertGetId\n method to insert a record and then retrieve the ID:\n\n\n$id = DB::table(\nusers\n)-\ninsertGetId(\n    [\nemail\n =\n \njohn@example.com\n, \nvotes\n =\n 0]\n);\n\n\n\n\n\n\n\n{note} When using PostgreSQL the insertGetId method expects the auto-incrementing column to be named \nid\n. If you would like to retrieve the ID from a different \"sequence\", you may pass the sequence name as the second parameter to the \ninsertGetId\n method.\n\n\n\n\n\n\nUpdates\n\n\nOf course, in addition to inserting records into the database, the query builder can also update existing records using the \nupdate\n method. The \nupdate\n method, like the \ninsert\n method, accepts an array of column and value pairs containing the columns to be updated. You may constrain the \nupdate\n query using \nwhere\n clauses:\n\n\nDB::table(\nusers\n)\n            -\nwhere(\nid\n, 1)\n            -\nupdate([\nvotes\n =\n 1]);\n\n\n\n\n\n\n\nUpdating JSON Columns\n\n\nWhen updating a JSON column, you should use \n-\n syntax to access the appropriate key in the JSON object. This operation is only supported on databases that support JSON columns:\n\n\nDB::table(\nusers\n)\n            -\nwhere(\nid\n, 1)\n            -\nupdate([\noptions-\nenabled\n =\n true]);\n\n\n\n\n\n\n\nIncrement \n Decrement\n\n\nThe query builder also provides convenient methods for incrementing or decrementing the value of a given column. This is simply a shortcut, providing a more expressive and terse interface compared to manually writing the \nupdate\n statement.\n\n\nBoth of these methods accept at least one argument: the column to modify. A second argument may optionally be passed to control the amount by which the column should be incremented or decremented:\n\n\nDB\n::\ntable\n(\nusers\n)\n-\nincrement\n(\nvotes\n);\n\n\n\nDB\n::\ntable\n(\nusers\n)\n-\nincrement\n(\nvotes\n,\n \n5\n);\n\n\n\nDB\n::\ntable\n(\nusers\n)\n-\ndecrement\n(\nvotes\n);\n\n\n\nDB\n::\ntable\n(\nusers\n)\n-\ndecrement\n(\nvotes\n,\n \n5\n);\n\n\n\n\n\n\nYou may also specify additional columns to update during the operation:\n\n\nDB\n::\ntable\n(\nusers\n)\n-\nincrement\n(\nvotes\n,\n \n1\n,\n \n[\nname\n \n=\n \nJohn\n]\n);\n\n\n\n\n\n\n\n\nDeletes\n\n\nThe query builder may also be used to delete records from the table via the \ndelete\n method. You may constrain \ndelete\n statements by adding \nwhere\n clauses before calling the \ndelete\n method:\n\n\nDB\n::\ntable\n(\nusers\n)\n-\ndelete\n();\n\n\n\nDB\n::\ntable\n(\nusers\n)\n-\nwhere\n(\nvotes\n,\n \n,\n \n100\n)\n-\ndelete\n();\n\n\n\n\n\n\nIf you wish to truncate the entire table, which will remove all rows and reset the auto-incrementing ID to zero, you may use the \ntruncate\n method:\n\n\nDB\n::\ntable\n(\nusers\n)\n-\ntruncate\n();\n\n\n\n\n\n\n\n\nPessimistic Locking\n\n\nThe query builder also includes a few functions to help you do \"pessimistic locking\" on your \nselect\n statements. To run the statement with a \"shared lock\", you may use the \nsharedLock\n method on a query. A shared lock prevents the selected rows from being modified until your transaction commits:\n\n\nDB\n::\ntable\n(\nusers\n)\n-\nwhere\n(\nvotes\n,\n \n,\n \n100\n)\n-\nsharedLock\n()\n-\nget\n();\n\n\n\n\n\n\nAlternatively, you may use the \nlockForUpdate\n method. A \"for update\" lock prevents the rows from being modified or from being selected with another shared lock:\n\n\nDB\n::\ntable\n(\nusers\n)\n-\nwhere\n(\nvotes\n,\n \n,\n \n100\n)\n-\nlockForUpdate\n()\n-\nget\n();", 
            "title": "Queries"
        }, 
        {
            "location": "/queries/#database-query-builder", 
            "text": "Introduction  Retrieving Results  Chunking Results  Aggregates    Selects  Raw Expressions  Joins  Unions  Where Clauses  Parameter Grouping  Where Exists Clauses  JSON Where Clauses    Ordering, Grouping, Limit,   Offset  Conditional Clauses  Inserts  Updates  Updating JSON Columns  Increment   Decrement    Deletes  Pessimistic Locking", 
            "title": "Database: Query Builder"
        }, 
        {
            "location": "/queries/#introduction", 
            "text": "Laravel's database query builder provides a convenient, fluent interface to creating and running database queries. It can be used to perform most database operations in your application and works on all supported database systems.  The Laravel query builder uses PDO parameter binding to protect your application against SQL injection attacks. There is no need to clean strings being passed as bindings.", 
            "title": "Introduction"
        }, 
        {
            "location": "/queries/#retrieving-results", 
            "text": "", 
            "title": "Retrieving Results"
        }, 
        {
            "location": "/queries/#retrieving-all-rows-from-a-table", 
            "text": "You may use the  table  method on the  DB  facade to begin a query. The  table  method returns a fluent query builder instance for the given table, allowing you to chain more constraints onto the query and then finally get the results using the  get  method:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Support \\ Facades \\ DB ;  use   App \\ Http \\ Controllers \\ Controller ;  class   UserController   extends   Controller  { \n     /**       * Show a list of all of the application s users.       *       * @return Response       */ \n     public   function   index () \n     { \n         $users   =   DB :: table ( users ) - get (); \n\n         return   view ( user.index ,   [ users   =   $users ]); \n     }  }   The  get  method returns an  Illuminate\\Support\\Collection  containing the results where each result is an instance of the PHP  StdClass  object. You may access each column's value by accessing the column as a property of the object:  foreach ($users as $user) {\n    echo $user- name;\n}", 
            "title": "Retrieving All Rows From A Table"
        }, 
        {
            "location": "/queries/#retrieving-a-single-row-column-from-a-table", 
            "text": "If you just need to retrieve a single row from the database table, you may use the  first  method. This method will return a single  StdClass  object:  $ user   =   DB :: table ( users ) - where ( name ,   John ) - first ();  echo   $ user- name ;   If you don't even need an entire row, you may extract a single value from a record using the  value  method. This method will return the value of the column directly:  $ email   =   DB :: table ( users ) - where ( name ,   John ) - value ( email );", 
            "title": "Retrieving A Single Row / Column From A Table"
        }, 
        {
            "location": "/queries/#retrieving-a-list-of-column-values", 
            "text": "If you would like to retrieve a Collection containing the values of a single column, you may use the  pluck  method. In this example, we'll retrieve a Collection of role titles:  $ titles   =   DB :: table ( roles ) - pluck ( title );  foreach   ($ titles   as   $ title )   { \n     echo   $title ;  }   You may also specify a custom key column for the returned Collection:  $ roles   =   DB :: table ( roles ) - pluck ( title ,   name );  foreach   ($ roles   as   $ name   =   $ title )   { \n     echo   $title ;  }", 
            "title": "Retrieving A List Of Column Values"
        }, 
        {
            "location": "/queries/#chunking-results", 
            "text": "If you need to work with thousands of database records, consider using the  chunk  method. This method retrieves a small chunk of the results at a time and feeds each chunk into a  Closure  for processing. This method is very useful for writing  Artisan commands  that process thousands of records. For example, let's work with the entire  users  table in chunks of 100 records at a time:  DB::table( users )- orderBy( id )- chunk(100, function ($users) {\n    foreach ($users as $user) {\n        //\n    }\n});  You may stop further chunks from being processed by returning  false  from the  Closure :  DB::table( users )- orderBy( id )- chunk(100, function ($users) {\n    // Process the records...\n\n    return false;\n});", 
            "title": "Chunking Results"
        }, 
        {
            "location": "/queries/#aggregates", 
            "text": "The query builder also provides a variety of aggregate methods such as  count ,  max ,  min ,  avg , and  sum . You may call any of these methods after constructing your query:  $ users   =   DB :: table ( users ) - count ();  $ price   =   DB :: table ( orders ) - max ( price );   Of course, you may combine these methods with other clauses:  $price = DB::table( orders )\n                - where( finalized , 1)\n                - avg( price );", 
            "title": "Aggregates"
        }, 
        {
            "location": "/queries/#selects", 
            "text": "", 
            "title": "Selects"
        }, 
        {
            "location": "/queries/#specifying-a-select-clause", 
            "text": "Of course, you may not always want to select all columns from a database table. Using the  select  method, you can specify a custom  select  clause for the query:  $ users   =   DB :: table ( users ) - select ( name ,   email as user_email ) - get ();   The  distinct  method allows you to force the query to return distinct results:  $ users   =   DB :: table ( users ) - distinct () - get ();   If you already have a query builder instance and you wish to add a column to its existing select clause, you may use the  addSelect  method:  $ query   =   DB :: table ( users ) - select ( name );  $ users   =   $ query- addSelect ( age ) - get ();", 
            "title": "Specifying A Select Clause"
        }, 
        {
            "location": "/queries/#raw-expressions", 
            "text": "Sometimes you may need to use a raw expression in a query. These expressions will be injected into the query as strings, so be careful not to create any SQL injection points! To create a raw expression, you may use the  DB::raw  method:  $users = DB::table( users )\n                     - select(DB::raw( count(*) as user_count, status ))\n                     - where( status ,  , 1)\n                     - groupBy( status )\n                     - get();", 
            "title": "Raw Expressions"
        }, 
        {
            "location": "/queries/#joins", 
            "text": "", 
            "title": "Joins"
        }, 
        {
            "location": "/queries/#inner-join-clause", 
            "text": "The query builder may also be used to write join statements. To perform a basic \"inner join\", you may use the  join  method on a query builder instance. The first argument passed to the  join  method is the name of the table you need to join to, while the remaining arguments specify the column constraints for the join. Of course, as you can see, you can join to multiple tables in a single query:  $users = DB::table( users )\n            - join( contacts ,  users.id ,  = ,  contacts.user_id )\n            - join( orders ,  users.id ,  = ,  orders.user_id )\n            - select( users.* ,  contacts.phone ,  orders.price )\n            - get();", 
            "title": "Inner Join Clause"
        }, 
        {
            "location": "/queries/#left-join-clause", 
            "text": "If you would like to perform a \"left join\" instead of an \"inner join\", use the  leftJoin  method. The  leftJoin  method has the same signature as the  join  method:  $users = DB::table( users )\n            - leftJoin( posts ,  users.id ,  = ,  posts.user_id )\n            - get();", 
            "title": "Left Join Clause"
        }, 
        {
            "location": "/queries/#cross-join-clause", 
            "text": "To perform a \"cross join\" use the  crossJoin  method with the name of the table you wish to cross join to. Cross joins generate a cartesian product between the first table and the joined table:  $users = DB::table( sizes )\n            - crossJoin( colours )\n            - get();", 
            "title": "Cross Join Clause"
        }, 
        {
            "location": "/queries/#advanced-join-clauses", 
            "text": "You may also specify more advanced join clauses. To get started, pass a  Closure  as the second argument into the  join  method. The  Closure  will receive a  JoinClause  object which allows you to specify constraints on the  join  clause:  DB::table( users )\n        - join( contacts , function ($join) {\n            $join- on( users.id ,  = ,  contacts.user_id )- orOn(...);\n        })\n        - get();  If you would like to use a \"where\" style clause on your joins, you may use the  where  and  orWhere  methods on a join. Instead of comparing two columns, these methods will compare the column against a value:  DB::table( users )\n        - join( contacts , function ($join) {\n            $join- on( users.id ,  = ,  contacts.user_id )\n                 - where( contacts.user_id ,  , 5);\n        })\n        - get();", 
            "title": "Advanced Join Clauses"
        }, 
        {
            "location": "/queries/#unions", 
            "text": "The query builder also provides a quick way to \"union\" two queries together. For example, you may create an initial query and use the  union  method to union it with a second query:  $first = DB::table( users )\n            - whereNull( first_name );\n\n$users = DB::table( users )\n            - whereNull( last_name )\n            - union($first)\n            - get();   {tip} The  unionAll  method is also available and has the same method signature as  union .", 
            "title": "Unions"
        }, 
        {
            "location": "/queries/#where-clauses", 
            "text": "", 
            "title": "Where Clauses"
        }, 
        {
            "location": "/queries/#simple-where-clauses", 
            "text": "You may use the  where  method on a query builder instance to add  where  clauses to the query. The most basic call to  where  requires three arguments. The first argument is the name of the column. The second argument is an operator, which can be any of the database's supported operators. Finally, the third argument is the value to evaluate against the column.  For example, here is a query that verifies the value of the \"votes\" column is equal to 100:  $ users   =   DB :: table ( users ) - where ( votes ,   = ,   100 ) - get ();   For convenience, if you simply want to verify that a column is equal to a given value, you may pass the value directly as the second argument to the  where  method:  $ users   =   DB :: table ( users ) - where ( votes ,   100 ) - get ();   Of course, you may use a variety of other operators when writing a  where  clause:  $users = DB::table( users )\n                - where( votes ,  = , 100)\n                - get();\n\n$users = DB::table( users )\n                - where( votes ,  , 100)\n                - get();\n\n$users = DB::table( users )\n                - where( name ,  like ,  T% )\n                - get();  You may also pass an array of conditions to the  where  function:  $users = DB::table( users )- where([\n    [ status ,  = ,  1 ],\n    [ subscribed ,  ,  1 ],\n])- get();", 
            "title": "Simple Where Clauses"
        }, 
        {
            "location": "/queries/#or-statements", 
            "text": "You may chain where constraints together as well as add  or  clauses to the query. The  orWhere  method accepts the same arguments as the  where  method:  $users = DB::table( users )\n                    - where( votes ,  , 100)\n                    - orWhere( name ,  John )\n                    - get();", 
            "title": "Or Statements"
        }, 
        {
            "location": "/queries/#additional-where-clauses", 
            "text": "whereBetween  The  whereBetween  method verifies that a column's value is between two values:  $users = DB::table( users )\n                    - whereBetween( votes , [1, 100])- get();  whereNotBetween  The  whereNotBetween  method verifies that a column's value lies outside of two values:  $users = DB::table( users )\n                    - whereNotBetween( votes , [1, 100])\n                    - get();  whereIn / whereNotIn  The  whereIn  method verifies that a given column's value is contained within the given array:  $users = DB::table( users )\n                    - whereIn( id , [1, 2, 3])\n                    - get();  The  whereNotIn  method verifies that the given column's value is  not  contained in the given array:  $users = DB::table( users )\n                    - whereNotIn( id , [1, 2, 3])\n                    - get();  whereNull / whereNotNull  The  whereNull  method verifies that the value of the given column is  NULL :  $users = DB::table( users )\n                    - whereNull( updated_at )\n                    - get();  The  whereNotNull  method verifies that the column's value is not  NULL :  $users = DB::table( users )\n                    - whereNotNull( updated_at )\n                    - get();  whereDate / whereMonth / whereDay / whereYear  The  whereDate  method may be used to compare a column's value against a date:  $users = DB::table( users )\n                - whereDate( created_at ,  2016-12-31 )\n                - get();  The  whereMonth  method may be used to compare a column's value against a specific month of a year:  $users = DB::table( users )\n                - whereMonth( created_at ,  12 )\n                - get();  The  whereDay  method may be used to compare a column's value against a specific day of a month:  $users = DB::table( users )\n                - whereDay( created_at ,  31 )\n                - get();  The  whereYear  method may be used to compare a column's value against a specific year:  $users = DB::table( users )\n                - whereYear( created_at ,  2016 )\n                - get();  whereColumn  The  whereColumn  method may be used to verify that two columns are equal:  $users = DB::table( users )\n                - whereColumn( first_name ,  last_name )\n                - get();  You may also pass a comparison operator to the method:  $users = DB::table( users )\n                - whereColumn( updated_at ,  ,  created_at )\n                - get();  The  whereColumn  method can also be passed an array of multiple conditions. These conditions will be joined using the  and  operator:  $users = DB::table( users )\n                - whereColumn([\n                    [ first_name ,  = ,  last_name ],\n                    [ updated_at ,  ,  created_at ]\n                ])- get();", 
            "title": "Additional Where Clauses"
        }, 
        {
            "location": "/queries/#parameter-grouping", 
            "text": "Sometimes you may need to create more advanced where clauses such as \"where exists\" clauses or nested parameter groupings. The Laravel query builder can handle these as well. To get started, let's look at an example of grouping constraints within parenthesis:  DB::table( users )\n            - where( name ,  = ,  John )\n            - orWhere(function ($query) {\n                $query- where( votes ,  , 100)\n                      - where( title ,  ,  Admin );\n            })\n            - get();  As you can see, passing a  Closure  into the  orWhere  method instructs the query builder to begin a constraint group. The  Closure  will receive a query builder instance which you can use to set the constraints that should be contained within the parenthesis group. The example above will produce the following SQL:  select * from users where name =  John  or (votes   100 and title    Admin )", 
            "title": "Parameter Grouping"
        }, 
        {
            "location": "/queries/#where-exists-clauses", 
            "text": "The  whereExists  method allows you to write  where exists  SQL clauses. The  whereExists  method accepts a  Closure  argument, which will receive a query builder instance allowing you to define the query that should be placed inside of the \"exists\" clause:  DB::table( users )\n            - whereExists(function ($query) {\n                $query- select(DB::raw(1))\n                      - from( orders )\n                      - whereRaw( orders.user_id = users.id );\n            })\n            - get();  The query above will produce the following SQL:  select * from users\nwhere exists (\n    select 1 from orders where orders.user_id = users.id\n)", 
            "title": "Where Exists Clauses"
        }, 
        {
            "location": "/queries/#json-where-clauses", 
            "text": "Laravel also supports querying JSON column types on databases that provide support for JSON column types. Currently, this includes MySQL 5.7 and Postgres. To query a JSON column, use the  -  operator:  $users = DB::table( users )\n                - where( options- language ,  en )\n                - get();\n\n$users = DB::table( users )\n                - where( preferences- dining- meal ,  salad )\n                - get();", 
            "title": "JSON Where Clauses"
        }, 
        {
            "location": "/queries/#ordering-grouping-limit-offset", 
            "text": "", 
            "title": "Ordering, Grouping, Limit, &amp; Offset"
        }, 
        {
            "location": "/queries/#orderby", 
            "text": "The  orderBy  method allows you to sort the result of the query by a given column. The first argument to the  orderBy  method should be the column you wish to sort by, while the second argument controls the direction of the sort and may be either  asc  or  desc :  $users = DB::table( users )\n                - orderBy( name ,  desc )\n                - get();", 
            "title": "orderBy"
        }, 
        {
            "location": "/queries/#latest-oldest", 
            "text": "The  latest  and  oldest  methods allow you to easily order results by date. By default, result will be ordered by the  created_at  column. Or, you may pass the column name that you wish to sort by:  $user = DB::table( users )\n                - latest()\n                - first();", 
            "title": "latest / oldest"
        }, 
        {
            "location": "/queries/#inrandomorder", 
            "text": "The  inRandomOrder  method may be used to sort the query results randomly. For example, you may use this method to fetch a random user:  $randomUser = DB::table( users )\n                - inRandomOrder()\n                - first();", 
            "title": "inRandomOrder"
        }, 
        {
            "location": "/queries/#groupby-having-havingraw", 
            "text": "The  groupBy  and  having  methods may be used to group the query results. The  having  method's signature is similar to that of the  where  method:  $users = DB::table( users )\n                - groupBy( account_id )\n                - having( account_id ,  , 100)\n                - get();  The  havingRaw  method may be used to set a raw string as the value of the  having  clause. For example, we can find all of the departments with sales greater than $2,500:  $users = DB::table( orders )\n                - select( department , DB::raw( SUM(price) as total_sales ))\n                - groupBy( department )\n                - havingRaw( SUM(price)   2500 )\n                - get();", 
            "title": "groupBy / having / havingRaw"
        }, 
        {
            "location": "/queries/#skip-take", 
            "text": "To limit the number of results returned from the query, or to skip a given number of results in the query, you may use the  skip  and  take  methods:  $ users   =   DB :: table ( users ) - skip ( 10 ) - take ( 5 ) - get ();   Alternatively, you may use the  limit  and  offset  methods:  $users = DB::table( users )\n                - offset(10)\n                - limit(5)\n                - get();", 
            "title": "skip / take"
        }, 
        {
            "location": "/queries/#conditional-clauses", 
            "text": "Sometimes you may want clauses to apply to a query only when something else is true. For instance you may only want to apply a  where  statement if a given input value is present on the incoming request. You may accomplish this using the  when  method:  $role = $request- input( role );\n\n$users = DB::table( users )\n                - when($role, function ($query) use ($role) {\n                    return $query- where( role_id , $role);\n                })\n                - get();  The  when  method only executes the given Closure when the first parameter is  true . If the first parameter is  false , the Closure will not be executed.  You may pass another Closure as the third parameter to the  when  method. This Closure will execute if the first parameter evaluates as  false . To illustrate how this feature may be used, we will use it to configure the default sorting of a query:  $sortBy = null;\n\n$users = DB::table( users )\n                - when($sortBy, function ($query) use ($sortBy) {\n                    return $query- orderBy($sortBy);\n                }, function ($query) {\n                    return $query- orderBy( name );\n                })\n                - get();", 
            "title": "Conditional Clauses"
        }, 
        {
            "location": "/queries/#inserts", 
            "text": "The query builder also provides an  insert  method for inserting records into the database table. The  insert  method accepts an array of column names and values:  DB::table( users )- insert(\n    [ email  =   john@example.com ,  votes  =  0]\n);  You may even insert several records into the table with a single call to  insert  by passing an array of arrays. Each array represents a row to be inserted into the table:  DB::table( users )- insert([\n    [ email  =   taylor@example.com ,  votes  =  0],\n    [ email  =   dayle@example.com ,  votes  =  0]\n]);", 
            "title": "Inserts"
        }, 
        {
            "location": "/queries/#auto-incrementing-ids", 
            "text": "If the table has an auto-incrementing id, use the  insertGetId  method to insert a record and then retrieve the ID:  $id = DB::table( users )- insertGetId(\n    [ email  =   john@example.com ,  votes  =  0]\n);   {note} When using PostgreSQL the insertGetId method expects the auto-incrementing column to be named  id . If you would like to retrieve the ID from a different \"sequence\", you may pass the sequence name as the second parameter to the  insertGetId  method.", 
            "title": "Auto-Incrementing IDs"
        }, 
        {
            "location": "/queries/#updates", 
            "text": "Of course, in addition to inserting records into the database, the query builder can also update existing records using the  update  method. The  update  method, like the  insert  method, accepts an array of column and value pairs containing the columns to be updated. You may constrain the  update  query using  where  clauses:  DB::table( users )\n            - where( id , 1)\n            - update([ votes  =  1]);", 
            "title": "Updates"
        }, 
        {
            "location": "/queries/#updating-json-columns", 
            "text": "When updating a JSON column, you should use  -  syntax to access the appropriate key in the JSON object. This operation is only supported on databases that support JSON columns:  DB::table( users )\n            - where( id , 1)\n            - update([ options- enabled  =  true]);", 
            "title": "Updating JSON Columns"
        }, 
        {
            "location": "/queries/#increment-decrement", 
            "text": "The query builder also provides convenient methods for incrementing or decrementing the value of a given column. This is simply a shortcut, providing a more expressive and terse interface compared to manually writing the  update  statement.  Both of these methods accept at least one argument: the column to modify. A second argument may optionally be passed to control the amount by which the column should be incremented or decremented:  DB :: table ( users ) - increment ( votes );  DB :: table ( users ) - increment ( votes ,   5 );  DB :: table ( users ) - decrement ( votes );  DB :: table ( users ) - decrement ( votes ,   5 );   You may also specify additional columns to update during the operation:  DB :: table ( users ) - increment ( votes ,   1 ,   [ name   =   John ] );", 
            "title": "Increment &amp; Decrement"
        }, 
        {
            "location": "/queries/#deletes", 
            "text": "The query builder may also be used to delete records from the table via the  delete  method. You may constrain  delete  statements by adding  where  clauses before calling the  delete  method:  DB :: table ( users ) - delete ();  DB :: table ( users ) - where ( votes ,   ,   100 ) - delete ();   If you wish to truncate the entire table, which will remove all rows and reset the auto-incrementing ID to zero, you may use the  truncate  method:  DB :: table ( users ) - truncate ();", 
            "title": "Deletes"
        }, 
        {
            "location": "/queries/#pessimistic-locking", 
            "text": "The query builder also includes a few functions to help you do \"pessimistic locking\" on your  select  statements. To run the statement with a \"shared lock\", you may use the  sharedLock  method on a query. A shared lock prevents the selected rows from being modified until your transaction commits:  DB :: table ( users ) - where ( votes ,   ,   100 ) - sharedLock () - get ();   Alternatively, you may use the  lockForUpdate  method. A \"for update\" lock prevents the rows from being modified or from being selected with another shared lock:  DB :: table ( users ) - where ( votes ,   ,   100 ) - lockForUpdate () - get ();", 
            "title": "Pessimistic Locking"
        }, 
        {
            "location": "/queues/", 
            "text": "Queues\n\n\n\n\nIntroduction\n\n\nConnections Vs. Queues\n\n\nDriver Prerequisites\n\n\n\n\n\n\nCreating Jobs\n\n\nGenerating Job Classes\n\n\nClass Structure\n\n\n\n\n\n\nDispatching Jobs\n\n\nDelayed Dispatching\n\n\nCustomizing The Queue \n Connection\n\n\nSpecifying Max Job Attempts / Timeout Values\n\n\nError Handling\n\n\n\n\n\n\nRunning The Queue Worker\n\n\nQueue Priorities\n\n\nQueue Workers \n Deployment\n\n\nJob Expirations \n Timeouts\n\n\n\n\n\n\nSupervisor Configuration\n\n\nDealing With Failed Jobs\n\n\nCleaning Up After Failed Jobs\n\n\nFailed Job Events\n\n\nRetrying Failed Jobs\n\n\n\n\n\n\nJob Events\n\n\n\n\n\n\nIntroduction\n\n\nLaravel queues provide a unified API across a variety of different queue backends, such as Beanstalk, Amazon SQS, Redis, or even a relational database. Queues allow you to defer the processing of a time consuming task, such as sending an email, until a later time. Deferring these time consuming tasks drastically speeds up web requests to your application.\n\n\nThe queue configuration file is stored in \nconfig/queue.php\n. In this file you will find connection configurations for each of the queue drivers that are included with the framework, which includes a database, \nBeanstalkd\n, \nAmazon SQS\n, \nRedis\n,  and a synchronous driver that will execute jobs immediately (for local use). A \nnull\n queue driver is also included which simply discards queued jobs.\n\n\n\n\nConnections Vs. Queues\n\n\nBefore getting started with Laravel queues, it is important to understand the distinction between \"connections\" and \"queues\". In your \nconfig/queue.php\n configuration file, there is a \nconnections\n configuration option. This option defines a particular connection to a backend service such as Amazon SQS, Beanstalk, or Redis. However, any given queue connection may have multiple \"queues\" which may be thought of as different stacks or piles of queued jobs.\n\n\nNote that each connection configuration example in the \nqueue\n configuration file contains a \nqueue\n attribute. This is the default queue that jobs will be dispatched to when they are sent to a given connection. In other words, if you dispatch a job without explicitly defining which queue it should be dispatched to, the job will be placed on the queue that is defined in the \nqueue\n attribute of the connection configuration:\n\n\n// This job is sent to the default queue...\ndispatch(new Job);\n\n// This job is sent to the \nemails\n queue...\ndispatch((new Job)-\nonQueue(\nemails\n));\n\n\n\n\n\nSome applications may not need to ever push jobs onto multiple queues, instead preferring to have one simple queue. However, pushing jobs to multiple queues can be especially useful for applications that wish to prioritize or segment how jobs are processed, since the Laravel queue worker allows you to specify which queues it should process by priority. For example, if you push jobs to a \nhigh\n queue, you may run a worker that gives them higher processing priority:\n\n\nphp artisan queue:work --queue=high,default\n\n\n\n\n\n\n\nDriver Prerequisites\n\n\nDatabase\n\n\nIn order to use the \ndatabase\n queue driver, you will need a database table to hold the jobs. To generate a migration that creates this table, run the \nqueue:table\n Artisan command. Once the migration has been created, you may migrate your database using the \nmigrate\n command:\n\n\nphp artisan queue:table\n\nphp artisan migrate\n\n\n\n\n\nRedis\n\n\nIn order to use the \nredis\n queue driver, you should configure a Redis database connection in your \nconfig/database.php\n configuration file.\n\n\nIf your Redis queue connection uses a Redis Cluster, your queue names must contain a \nkey hash tag\n. This is required in order to ensure all of the Redis keys for a given queue are placed into the same hash slot:\n\n\nredis\n =\n [\n    \ndriver\n =\n \nredis\n,\n    \nconnection\n =\n \ndefault\n,\n    \nqueue\n =\n \n{default}\n,\n    \nretry_after\n =\n 90,\n],\n\n\n\n\n\nOther Driver Prerequisites\n\n\nThe following dependencies are needed for the listed queue drivers:\n\n\n\n- Amazon SQS: `aws/aws-sdk-php ~3.0`\n- Beanstalkd: `pda/pheanstalk ~3.0`\n- Redis: `predis/predis ~1.0`\n\n\n\n\n\n\nCreating Jobs\n\n\n\n\nGenerating Job Classes\n\n\nBy default, all of the queueable jobs for your application are stored in the \napp/Jobs\n directory. If the \napp/Jobs\n directory doesn't exist, it will be created when you run the \nmake:job\n Artisan command. You may generate a new queued job using the Artisan CLI:\n\n\nphp artisan make:job SendReminderEmail\n\n\n\n\n\nThe generated class will implement the \nIlluminate\\Contracts\\Queue\\ShouldQueue\n interface, indicating to Laravel that the job should be pushed onto the queue to run asynchronously.\n\n\n\n\nClass Structure\n\n\nJob classes are very simple, normally containing only a \nhandle\n method which is called when the job is processed by the queue. To get started, let's take a look at an example job class. In this example, we'll pretend we manage a podcast publishing service and need to process the uploaded podcast files before they are published:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nJobs\n;\n\n\n\nuse\n \nApp\n\\\nPodcast\n;\n\n\nuse\n \nApp\n\\\nAudioProcessor\n;\n\n\nuse\n \nIlluminate\n\\\nBus\n\\\nQueueable\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nSerializesModels\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nInteractsWithQueue\n;\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nQueue\n\\\nShouldQueue\n;\n\n\n\nclass\n \nProcessPodcast\n \nimplements\n \nShouldQueue\n\n\n{\n\n    \nuse\n \nInteractsWithQueue\n,\n \nQueueable\n,\n \nSerializesModels\n;\n\n\n    \nprotected\n \n$podcast\n;\n\n\n    \n/**\n\n\n     * Create a new job instance.\n\n\n     *\n\n\n     * @param  Podcast  $podcast\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nPodcast\n \n$podcast\n)\n\n    \n{\n\n        \n$this\n-\npodcast\n \n=\n \n$podcast\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Execute the job.\n\n\n     *\n\n\n     * @param  AudioProcessor  $processor\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandle\n(\nAudioProcessor\n \n$processor\n)\n\n    \n{\n\n        \n// Process uploaded podcast...\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIn this example, note that we were able to pass an \nEloquent model\n directly into the queued job's constructor. Because of the \nSerializesModels\n trait that the job is using, Eloquent models will be gracefully serialized and unserialized when the job is processing. If your queued job accepts an Eloquent model in its constructor, only the identifier for the model will be serialized onto the queue. When the job is actually handled, the queue system will automatically re-retrieve the full model instance from the database. It's all totally transparent to your application and prevents issues that can arise from serializing full Eloquent model instances.\n\n\nThe \nhandle\n method is called when the job is processed by the queue. Note that we are able to type-hint dependencies on the \nhandle\n method of the job. The Laravel \nservice container\n automatically injects these dependencies.\n\n\n\n\n{note} Binary data, such as raw image contents, should be passed through the \nbase64_encode\n function before being passed to a queued job. Otherwise, the job may not properly serialize to JSON when being placed on the queue.\n\n\n\n\n\n\nDispatching Jobs\n\n\nOnce you have written your job class, you may dispatch it using the \ndispatch\n helper. The only argument you need to pass to the \ndispatch\n helper is an instance of the job:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nJobs\n\\\nProcessPodcast\n;\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nPodcastController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Store a new podcast.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nstore\n(\nRequest\n \n$request\n)\n\n    \n{\n\n        \n// Create podcast...\n\n\n        \ndispatch\n(\nnew\n \nProcessPodcast\n(\n$podcast\n));\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n{tip} The \ndispatch\n helper provides the convenience of a short, globally available function, while also being extremely easy to test. Check out the Laravel \ntesting documentation\n to learn more.\n\n\n\n\n\n\nDelayed Dispatching\n\n\nIf you would like to delay the execution of a queued job, you may use the \ndelay\n method on your job instance. The \ndelay\n method is provided by the \nIlluminate\\Bus\\Queueable\n trait, which is included by default on all generated job classes. For example, let's specify that a job should not be available for processing until 10 minutes after it has been dispatched:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nCarbon\n\\\nCarbon\n;\n\n\nuse\n \nApp\n\\\nJobs\n\\\nProcessPodcast\n;\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nPodcastController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Store a new podcast.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nstore\n(\nRequest\n \n$request\n)\n\n    \n{\n\n        \n// Create podcast...\n\n\n        \n$job\n \n=\n \n(\nnew\n \nProcessPodcast\n(\n$podcast\n))\n\n                    \n-\ndelay\n(\nCarbon\n::\nnow\n()\n-\naddMinutes\n(\n10\n));\n\n\n        \ndispatch\n(\n$job\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n{note} The Amazon SQS queue service has a maximum delay time of 15 minutes.\n\n\n\n\n\n\nCustomizing The Queue \n Connection\n\n\nDispatching To A Particular Queue\n\n\nBy pushing jobs to different queues, you may \"categorize\" your queued jobs and even prioritize how many workers you assign to various queues. Keep in mind, this does not push jobs to different queue \"connections\" as defined by your queue configuration file, but only to specific queues within a single connection. To specify the queue, use the \nonQueue\n method on the job instance:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nJobs\n\\\nProcessPodcast\n;\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nPodcastController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Store a new podcast.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nstore\n(\nRequest\n \n$request\n)\n\n    \n{\n\n        \n// Create podcast...\n\n\n        \n$job\n \n=\n \n(\nnew\n \nProcessPodcast\n(\n$podcast\n))\n-\nonQueue\n(\nprocessing\n);\n\n\n        \ndispatch\n(\n$job\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDispatching To A Particular Connection\n\n\nIf you are working with multiple queue connections, you may specify which connection to push a job to. To specify the connection, use the \nonConnection\n method on the job instance:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nApp\n\\\nJobs\n\\\nProcessPodcast\n;\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nPodcastController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Store a new podcast.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nstore\n(\nRequest\n \n$request\n)\n\n    \n{\n\n        \n// Create podcast...\n\n\n        \n$job\n \n=\n \n(\nnew\n \nProcessPodcast\n(\n$podcast\n))\n-\nonConnection\n(\nsqs\n);\n\n\n        \ndispatch\n(\n$job\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOf course, you may chain the \nonConnection\n and \nonQueue\n methods to specify the connection and the queue for a job:\n\n\n$job = (new ProcessPodcast($podcast))\n                -\nonConnection(\nsqs\n)\n                -\nonQueue(\nprocessing\n);\n\n\n\n\n\n\n\nSpecifying Max Job Attempts / Timeout Values\n\n\nMax Attempts\n\n\nOne approach to specifying the maximum number of times a job may be attempted is via the \n--tries\n switch on the Artisan command line:\n\n\nphp artisan queue:work --tries=3\n\n\n\n\n\nHowever, you may take a more granular approach by defining the maximum number of attempts on the job class itself. If the maximum number of attempts is specified on the job, it will take precedence over the value provided on the command line:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nJobs\n;\n\n\n\nclass\n \nProcessPodcast\n \nimplements\n \nShouldQueue\n\n\n{\n\n    \n/**\n\n\n     * The number of times the job may be attempted.\n\n\n     *\n\n\n     * @var int\n\n\n     */\n\n    \npublic\n \n$tries\n \n=\n \n5\n;\n\n\n}\n\n\n\n\n\n\nTimeout\n\n\nLikewise, the maximum number of seconds that jobs can run may be specified using the \n--timeout\n switch on the Artisan command line:\n\n\nphp artisan queue:work --timeout=30\n\n\n\n\n\nHowever, you may also define the maximum number of seconds a job should be allowed to run on the job class itself. If the timeout is specified on the job, it will take precedence over any timeout specified on the command line:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nJobs\n;\n\n\n\nclass\n \nProcessPodcast\n \nimplements\n \nShouldQueue\n\n\n{\n\n    \n/**\n\n\n     * The number of seconds the job can run before timing out.\n\n\n     *\n\n\n     * @var int\n\n\n     */\n\n    \npublic\n \n$timeout\n \n=\n \n120\n;\n\n\n}\n\n\n\n\n\n\n\n\nError Handling\n\n\nIf an exception is thrown while the job is being processed, the job will automatically be released back onto the queue so it may be attempted again. The job will continue to be released until it has been attempted the maximum number of times allowed by your application. The maximum number of attempts is defined by the \n--tries\n switch used on the \nqueue:work\n Artisan command. Alternatively, the maximum number of attempts may be defined on the job class itself. More information on running the queue worker \ncan be found below\n.\n\n\n\n\nRunning The Queue Worker\n\n\nLaravel includes a queue worker that will process new jobs as they are pushed onto the queue. You may run the worker using the \nqueue:work\n Artisan command. Note that once the \nqueue:work\n command has started, it will continue to run until it is manually stopped or you close your terminal:\n\n\nphp artisan queue:work\n\n\n\n\n\n\n\n{tip} To keep the \nqueue:work\n process running permanently in the background, you should use a process monitor such as \nSupervisor\n to ensure that the queue worker does not stop running.\n\n\n\n\nRemember, queue workers are long-lived processes and store the booted application state in memory. As a result, they will not notice changes in your code base after they have been started. So, during your deployment process, be sure to \nrestart your queue workers\n.\n\n\nSpecifying The Connection \n Queue\n\n\nYou may also specify which queue connection the worker should utilize. The connection name passed to the \nwork\n command should correspond to one of the connections defined in your \nconfig/queue.php\n configuration file:\n\n\nphp artisan queue:work redis\n\n\n\n\n\nYou may customize your queue worker even further by only processing particular queues for a given connection. For example, if all of your emails are processed in an \nemails\n queue on your \nredis\n queue connection, you may issue the following command to start a worker that only processes only that queue:\n\n\nphp artisan queue:work redis --queue=emails\n\n\n\n\n\nResource Considerations\n\n\nDaemon queue workers do not \"reboot\" the framework before processing each job. Therefore, you should free any heavy resources after each job completes. For example, if you are doing image manipulation with the GD library, you should free the memory with \nimagedestroy\n when you are done.\n\n\n\n\nQueue Priorities\n\n\nSometimes you may wish to prioritize how your queues are processed. For example, in your \nconfig/queue.php\n you may set the default \nqueue\n for your \nredis\n connection to \nlow\n. However, occasionally you may wish to push a job to a \nhigh\n priority queue like so:\n\n\ndispatch((new Job)-\nonQueue(\nhigh\n));\n\n\n\n\n\nTo start a worker that verifies that all of the \nhigh\n queue jobs are processed before continuing to any jobs on the \nlow\n queue, pass a comma-delimited list of queue names to the \nwork\n command:\n\n\nphp artisan queue:work --queue=high,low\n\n\n\n\n\n\n\nQueue Workers \n Deployment\n\n\nSince queue workers are long-lived processes, they will not pick up changes to your code without being restarted. So, the simplest way to deploy an application using queue workers is to restart the workers during your deployment process. You may gracefully restart all of the workers by issuing the \nqueue:restart\n command:\n\n\nphp artisan queue:restart\n\n\n\n\n\nThis command will instruct all queue workers to gracefully \"die\" after they finish processing their current job so that no existing jobs are lost. Since the queue workers will die when the \nqueue:restart\n command is executed, you should be running a process manager such as \nSupervisor\n to automatically restart the queue workers.\n\n\n\n\nJob Expirations \n Timeouts\n\n\nJob Expiration\n\n\nIn your \nconfig/queue.php\n configuration file, each queue connection defines a \nretry_after\n option. This option specifies how many seconds the queue connection should wait before retrying a job that is being processed. For example, if the value of \nretry_after\n is set to \n90\n, the job will be released back onto the queue if it has been processing for 90 seconds without being deleted. Typically, you should set the \nretry_after\n value to the maximum number of seconds your jobs should reasonably take to complete processing.\n\n\n\n\n{note} The only queue connection which does not contain a \nretry_after\n value is Amazon SQS. SQS will retry the job based on the \nDefault Visibility Timeout\n which is managed within the AWS console.\n\n\n\n\nWorker Timeouts\n\n\nThe \nqueue:work\n Artisan command exposes a \n--timeout\n option. The \n--timeout\n option specifies how long the Laravel queue master process will wait before killing off a child queue worker that is processing a job. Sometimes a child queue process can become \"frozen\" for various reasons, such as an external HTTP call that is not responding. The \n--timeout\n option removes frozen processes that have exceeded that specified time limit:\n\n\nphp artisan queue:work --timeout=60\n\n\n\n\n\nThe \nretry_after\n configuration option and the \n--timeout\n CLI option are different, but work together to ensure that jobs are not lost and that jobs are only successfully processed once.\n\n\n\n\n{note} The \n--timeout\n value should always be at least several seconds shorter than your \nretry_after\n configuration value. This will ensure that a worker processing a given job is always killed before the job is retried. If your \n--timeout\n option is longer than your \nretry_after\n configuration value, your jobs may be processed twice.\n\n\n\n\nWorker Sleep Duration\n\n\nWhen jobs are available on the queue, the worker will keep processing jobs with no delay in between them. However, the \nsleep\n option determines how long the worker will \"sleep\" if there are no new jobs available:\n\n\nphp artisan queue:work --sleep=3\n\n\n\n\n\n\n\nSupervisor Configuration\n\n\nInstalling Supervisor\n\n\nSupervisor is a process monitor for the Linux operating system, and will automatically restart your \nqueue:work\n process if it fails. To install Supervisor on Ubuntu, you may use the following command:\n\n\nsudo apt-get install supervisor\n\n\n\n\n\n\n\n{tip} If configuring Supervisor yourself sounds overwhelming, consider using \nLaravel Forge\n, which will automatically install and configure Supervisor for your Laravel projects.\n\n\n\n\nConfiguring Supervisor\n\n\nSupervisor configuration files are typically stored in the \n/etc/supervisor/conf.d\n directory. Within this directory, you may create any number of configuration files that instruct supervisor how your processes should be monitored. For example, let's create a \nlaravel-worker.conf\n file that starts and monitors a \nqueue:work\n process:\n\n\n[program:laravel-worker]\n\n\nprocess_name\n=\n%(program_name)s_%(process_num)02d\n\n\ncommand\n=\nphp /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3\n\n\nautostart\n=\ntrue\n\n\nautorestart\n=\ntrue\n\n\nuser\n=\nforge\n\n\nnumprocs\n=\n8\n\n\nredirect_stderr\n=\ntrue\n\n\nstdout_logfile\n=\n/home/forge/app.com/worker.log\n\n\n\n\n\n\nIn this example, the \nnumprocs\n directive will instruct Supervisor to run 8 \nqueue:work\n processes and monitor all of them, automatically restarting them if they fail. Of course, you should change the \nqueue:work sqs\n portion of the \ncommand\n directive to reflect your desired queue connection.\n\n\nStarting Supervisor\n\n\nOnce the configuration file has been created, you may update the Supervisor configuration and start the processes using the following commands:\n\n\nsudo supervisorctl reread\n\nsudo supervisorctl update\n\nsudo supervisorctl start laravel-worker:*\n\n\n\n\n\nFor more information on Supervisor, consult the \nSupervisor documentation\n.\n\n\n\n\nDealing With Failed Jobs\n\n\nSometimes your queued jobs will fail. Don't worry, things don't always go as planned! Laravel includes a convenient way to specify the maximum number of times a job should be attempted. After a job has exceeded this amount of attempts, it will be inserted into the \nfailed_jobs\n database table. To create a migration for the \nfailed_jobs\n table, you may use the \nqueue:failed-table\n command:\n\n\nphp artisan queue:failed-table\n\nphp artisan migrate\n\n\n\n\n\nThen, when running your \nqueue worker\n, you should specify the maximum number of times a job should be attempted using the \n--tries\n switch on the \nqueue:work\n command. If you do not specify a value for the \n--tries\n option, jobs will be attempted indefinitely:\n\n\nphp artisan queue:work redis --tries=3\n\n\n\n\n\n\n\nCleaning Up After Failed Jobs\n\n\nYou may define a \nfailed\n method directly on your job class, allowing you to perform job specific clean-up when a failure occurs. This is the perfect location to send an alert to your users or revert any actions performed by the job. The \nException\n that caused the job to fail will be passed to the \nfailed\n method:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nJobs\n;\n\n\n\nuse\n \nException\n;\n\n\nuse\n \nApp\n\\\nPodcast\n;\n\n\nuse\n \nApp\n\\\nAudioProcessor\n;\n\n\nuse\n \nIlluminate\n\\\nBus\n\\\nQueueable\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nSerializesModels\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nInteractsWithQueue\n;\n\n\nuse\n \nIlluminate\n\\\nContracts\n\\\nQueue\n\\\nShouldQueue\n;\n\n\n\nclass\n \nProcessPodcast\n \nimplements\n \nShouldQueue\n\n\n{\n\n    \nuse\n \nInteractsWithQueue\n,\n \nQueueable\n,\n \nSerializesModels\n;\n\n\n    \nprotected\n \n$podcast\n;\n\n\n    \n/**\n\n\n     * Create a new job instance.\n\n\n     *\n\n\n     * @param  Podcast  $podcast\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nPodcast\n \n$podcast\n)\n\n    \n{\n\n        \n$this\n-\npodcast\n \n=\n \n$podcast\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Execute the job.\n\n\n     *\n\n\n     * @param  AudioProcessor  $processor\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandle\n(\nAudioProcessor\n \n$processor\n)\n\n    \n{\n\n        \n// Process uploaded podcast...\n\n    \n}\n\n\n    \n/**\n\n\n     * The job failed to process.\n\n\n     *\n\n\n     * @param  Exception  $exception\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nfailed\n(\nException\n \n$exception\n)\n\n    \n{\n\n        \n// Send user notification of failure, etc...\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nFailed Job Events\n\n\nIf you would like to register an event that will be called when a job fails, you may use the \nQueue::failing\n method. This event is a great opportunity to notify your team via email or \nHipChat\n. For example, we may attach a callback to this event from the \nAppServiceProvider\n that is included with Laravel:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nQueue\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nEvents\n\\\nJobFailed\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\n\nclass\n \nAppServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Bootstrap any application services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nQueue\n::\nfailing\n(\nfunction\n \n(\nJobFailed\n \n$event\n)\n \n{\n\n            \n// $event-\nconnectionName\n\n            \n// $event-\njob\n\n            \n// $event-\nexception\n\n        \n});\n\n    \n}\n\n\n    \n/**\n\n\n     * Register the service provider.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nRetrying Failed Jobs\n\n\nTo view all of your failed jobs that have been inserted into your \nfailed_jobs\n database table, you may use the \nqueue:failed\n Artisan command:\n\n\nphp artisan queue:failed\n\n\n\n\n\nThe \nqueue:failed\n command will list the job ID, connection, queue, and failure time. The job ID may be used to retry the failed job. For instance, to retry a failed job that has an ID of \n5\n, issue the following command:\n\n\nphp artisan queue:retry 5\n\n\n\n\n\nTo retry all of your failed jobs, execute the \nqueue:retry\n command and pass \nall\n as the ID:\n\n\nphp artisan queue:retry all\n\n\n\n\n\nIf you would like to delete a failed job, you may use the \nqueue:forget\n command:\n\n\nphp artisan queue:forget 5\n\n\n\n\n\nTo delete all of your failed jobs, you may use the \nqueue:flush\n command:\n\n\nphp artisan queue:flush\n\n\n\n\n\n\n\nJob Events\n\n\nUsing the \nbefore\n and \nafter\n methods on the \nQueue\n \nfacade\n, you may specify callbacks to be executed before or after a queued job is processed. These callbacks are a great opportunity to perform additional logging or increment statistics for a dashboard. Typically, you should call these methods from a \nservice provider\n. For example, we may use the \nAppServiceProvider\n that is included with Laravel:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nQueue\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nEvents\n\\\nJobProcessed\n;\n\n\nuse\n \nIlluminate\n\\\nQueue\n\\\nEvents\n\\\nJobProcessing\n;\n\n\n\nclass\n \nAppServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Bootstrap any application services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nQueue\n::\nbefore\n(\nfunction\n \n(\nJobProcessing\n \n$event\n)\n \n{\n\n            \n// $event-\nconnectionName\n\n            \n// $event-\njob\n\n            \n// $event-\njob-\npayload()\n\n        \n});\n\n\n        \nQueue\n::\nafter\n(\nfunction\n \n(\nJobProcessed\n \n$event\n)\n \n{\n\n            \n// $event-\nconnectionName\n\n            \n// $event-\njob\n\n            \n// $event-\njob-\npayload()\n\n        \n});\n\n    \n}\n\n\n    \n/**\n\n\n     * Register the service provider.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nUsing the \nlooping\n method on the \nQueue\n \nfacade\n, you may specify callbacks that execute before the worker attempts to fetch a job from a queue. For example, you might register a Closure to rollback any transactions that were left open by a previously failed job:\n\n\nQueue\n::\nlooping\n(\nfunction\n \n()\n \n{\n\n    \nwhile\n \n(\nDB\n:\n:\ntransactionLevel\n()\n \n \n0\n)\n \n{\n\n        \nDB\n::\nrollBack\n();\n\n    \n}\n\n\n}\n);", 
            "title": "Queues"
        }, 
        {
            "location": "/queues/#queues", 
            "text": "Introduction  Connections Vs. Queues  Driver Prerequisites    Creating Jobs  Generating Job Classes  Class Structure    Dispatching Jobs  Delayed Dispatching  Customizing The Queue   Connection  Specifying Max Job Attempts / Timeout Values  Error Handling    Running The Queue Worker  Queue Priorities  Queue Workers   Deployment  Job Expirations   Timeouts    Supervisor Configuration  Dealing With Failed Jobs  Cleaning Up After Failed Jobs  Failed Job Events  Retrying Failed Jobs    Job Events", 
            "title": "Queues"
        }, 
        {
            "location": "/queues/#introduction", 
            "text": "Laravel queues provide a unified API across a variety of different queue backends, such as Beanstalk, Amazon SQS, Redis, or even a relational database. Queues allow you to defer the processing of a time consuming task, such as sending an email, until a later time. Deferring these time consuming tasks drastically speeds up web requests to your application.  The queue configuration file is stored in  config/queue.php . In this file you will find connection configurations for each of the queue drivers that are included with the framework, which includes a database,  Beanstalkd ,  Amazon SQS ,  Redis ,  and a synchronous driver that will execute jobs immediately (for local use). A  null  queue driver is also included which simply discards queued jobs.", 
            "title": "Introduction"
        }, 
        {
            "location": "/queues/#connections-vs-queues", 
            "text": "Before getting started with Laravel queues, it is important to understand the distinction between \"connections\" and \"queues\". In your  config/queue.php  configuration file, there is a  connections  configuration option. This option defines a particular connection to a backend service such as Amazon SQS, Beanstalk, or Redis. However, any given queue connection may have multiple \"queues\" which may be thought of as different stacks or piles of queued jobs.  Note that each connection configuration example in the  queue  configuration file contains a  queue  attribute. This is the default queue that jobs will be dispatched to when they are sent to a given connection. In other words, if you dispatch a job without explicitly defining which queue it should be dispatched to, the job will be placed on the queue that is defined in the  queue  attribute of the connection configuration:  // This job is sent to the default queue...\ndispatch(new Job);\n\n// This job is sent to the  emails  queue...\ndispatch((new Job)- onQueue( emails ));  Some applications may not need to ever push jobs onto multiple queues, instead preferring to have one simple queue. However, pushing jobs to multiple queues can be especially useful for applications that wish to prioritize or segment how jobs are processed, since the Laravel queue worker allows you to specify which queues it should process by priority. For example, if you push jobs to a  high  queue, you may run a worker that gives them higher processing priority:  php artisan queue:work --queue=high,default", 
            "title": "Connections Vs. Queues"
        }, 
        {
            "location": "/queues/#driver-prerequisites", 
            "text": "", 
            "title": "Driver Prerequisites"
        }, 
        {
            "location": "/queues/#database", 
            "text": "In order to use the  database  queue driver, you will need a database table to hold the jobs. To generate a migration that creates this table, run the  queue:table  Artisan command. Once the migration has been created, you may migrate your database using the  migrate  command:  php artisan queue:table\n\nphp artisan migrate", 
            "title": "Database"
        }, 
        {
            "location": "/queues/#redis", 
            "text": "In order to use the  redis  queue driver, you should configure a Redis database connection in your  config/database.php  configuration file.  If your Redis queue connection uses a Redis Cluster, your queue names must contain a  key hash tag . This is required in order to ensure all of the Redis keys for a given queue are placed into the same hash slot:  redis  =  [\n     driver  =   redis ,\n     connection  =   default ,\n     queue  =   {default} ,\n     retry_after  =  90,\n],", 
            "title": "Redis"
        }, 
        {
            "location": "/queues/#other-driver-prerequisites", 
            "text": "The following dependencies are needed for the listed queue drivers:  \n- Amazon SQS: `aws/aws-sdk-php ~3.0`\n- Beanstalkd: `pda/pheanstalk ~3.0`\n- Redis: `predis/predis ~1.0`", 
            "title": "Other Driver Prerequisites"
        }, 
        {
            "location": "/queues/#creating-jobs", 
            "text": "", 
            "title": "Creating Jobs"
        }, 
        {
            "location": "/queues/#generating-job-classes", 
            "text": "By default, all of the queueable jobs for your application are stored in the  app/Jobs  directory. If the  app/Jobs  directory doesn't exist, it will be created when you run the  make:job  Artisan command. You may generate a new queued job using the Artisan CLI:  php artisan make:job SendReminderEmail  The generated class will implement the  Illuminate\\Contracts\\Queue\\ShouldQueue  interface, indicating to Laravel that the job should be pushed onto the queue to run asynchronously.", 
            "title": "Generating Job Classes"
        }, 
        {
            "location": "/queues/#class-structure", 
            "text": "Job classes are very simple, normally containing only a  handle  method which is called when the job is processed by the queue. To get started, let's take a look at an example job class. In this example, we'll pretend we manage a podcast publishing service and need to process the uploaded podcast files before they are published:  ? php  namespace   App \\ Jobs ;  use   App \\ Podcast ;  use   App \\ AudioProcessor ;  use   Illuminate \\ Bus \\ Queueable ;  use   Illuminate \\ Queue \\ SerializesModels ;  use   Illuminate \\ Queue \\ InteractsWithQueue ;  use   Illuminate \\ Contracts \\ Queue \\ ShouldQueue ;  class   ProcessPodcast   implements   ShouldQueue  { \n     use   InteractsWithQueue ,   Queueable ,   SerializesModels ; \n\n     protected   $podcast ; \n\n     /**       * Create a new job instance.       *       * @param  Podcast  $podcast       * @return void       */ \n     public   function   __construct ( Podcast   $podcast ) \n     { \n         $this - podcast   =   $podcast ; \n     } \n\n     /**       * Execute the job.       *       * @param  AudioProcessor  $processor       * @return void       */ \n     public   function   handle ( AudioProcessor   $processor ) \n     { \n         // Process uploaded podcast... \n     }  }   In this example, note that we were able to pass an  Eloquent model  directly into the queued job's constructor. Because of the  SerializesModels  trait that the job is using, Eloquent models will be gracefully serialized and unserialized when the job is processing. If your queued job accepts an Eloquent model in its constructor, only the identifier for the model will be serialized onto the queue. When the job is actually handled, the queue system will automatically re-retrieve the full model instance from the database. It's all totally transparent to your application and prevents issues that can arise from serializing full Eloquent model instances.  The  handle  method is called when the job is processed by the queue. Note that we are able to type-hint dependencies on the  handle  method of the job. The Laravel  service container  automatically injects these dependencies.   {note} Binary data, such as raw image contents, should be passed through the  base64_encode  function before being passed to a queued job. Otherwise, the job may not properly serialize to JSON when being placed on the queue.", 
            "title": "Class Structure"
        }, 
        {
            "location": "/queues/#dispatching-jobs", 
            "text": "Once you have written your job class, you may dispatch it using the  dispatch  helper. The only argument you need to pass to the  dispatch  helper is an instance of the job:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ Jobs \\ ProcessPodcast ;  use   Illuminate \\ Http \\ Request ;  use   App \\ Http \\ Controllers \\ Controller ;  class   PodcastController   extends   Controller  { \n     /**       * Store a new podcast.       *       * @param  Request  $request       * @return Response       */ \n     public   function   store ( Request   $request ) \n     { \n         // Create podcast... \n\n         dispatch ( new   ProcessPodcast ( $podcast )); \n     }  }    {tip} The  dispatch  helper provides the convenience of a short, globally available function, while also being extremely easy to test. Check out the Laravel  testing documentation  to learn more.", 
            "title": "Dispatching Jobs"
        }, 
        {
            "location": "/queues/#delayed-dispatching", 
            "text": "If you would like to delay the execution of a queued job, you may use the  delay  method on your job instance. The  delay  method is provided by the  Illuminate\\Bus\\Queueable  trait, which is included by default on all generated job classes. For example, let's specify that a job should not be available for processing until 10 minutes after it has been dispatched:  ? php  namespace   App \\ Http \\ Controllers ;  use   Carbon \\ Carbon ;  use   App \\ Jobs \\ ProcessPodcast ;  use   Illuminate \\ Http \\ Request ;  use   App \\ Http \\ Controllers \\ Controller ;  class   PodcastController   extends   Controller  { \n     /**       * Store a new podcast.       *       * @param  Request  $request       * @return Response       */ \n     public   function   store ( Request   $request ) \n     { \n         // Create podcast... \n\n         $job   =   ( new   ProcessPodcast ( $podcast )) \n                     - delay ( Carbon :: now () - addMinutes ( 10 )); \n\n         dispatch ( $job ); \n     }  }    {note} The Amazon SQS queue service has a maximum delay time of 15 minutes.", 
            "title": "Delayed Dispatching"
        }, 
        {
            "location": "/queues/#customizing-the-queue-connection", 
            "text": "", 
            "title": "Customizing The Queue &amp; Connection"
        }, 
        {
            "location": "/queues/#dispatching-to-a-particular-queue", 
            "text": "By pushing jobs to different queues, you may \"categorize\" your queued jobs and even prioritize how many workers you assign to various queues. Keep in mind, this does not push jobs to different queue \"connections\" as defined by your queue configuration file, but only to specific queues within a single connection. To specify the queue, use the  onQueue  method on the job instance:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ Jobs \\ ProcessPodcast ;  use   Illuminate \\ Http \\ Request ;  use   App \\ Http \\ Controllers \\ Controller ;  class   PodcastController   extends   Controller  { \n     /**       * Store a new podcast.       *       * @param  Request  $request       * @return Response       */ \n     public   function   store ( Request   $request ) \n     { \n         // Create podcast... \n\n         $job   =   ( new   ProcessPodcast ( $podcast )) - onQueue ( processing ); \n\n         dispatch ( $job ); \n     }  }", 
            "title": "Dispatching To A Particular Queue"
        }, 
        {
            "location": "/queues/#dispatching-to-a-particular-connection", 
            "text": "If you are working with multiple queue connections, you may specify which connection to push a job to. To specify the connection, use the  onConnection  method on the job instance:  ? php  namespace   App \\ Http \\ Controllers ;  use   App \\ Jobs \\ ProcessPodcast ;  use   Illuminate \\ Http \\ Request ;  use   App \\ Http \\ Controllers \\ Controller ;  class   PodcastController   extends   Controller  { \n     /**       * Store a new podcast.       *       * @param  Request  $request       * @return Response       */ \n     public   function   store ( Request   $request ) \n     { \n         // Create podcast... \n\n         $job   =   ( new   ProcessPodcast ( $podcast )) - onConnection ( sqs ); \n\n         dispatch ( $job ); \n     }  }   Of course, you may chain the  onConnection  and  onQueue  methods to specify the connection and the queue for a job:  $job = (new ProcessPodcast($podcast))\n                - onConnection( sqs )\n                - onQueue( processing );", 
            "title": "Dispatching To A Particular Connection"
        }, 
        {
            "location": "/queues/#specifying-max-job-attempts-timeout-values", 
            "text": "", 
            "title": "Specifying Max Job Attempts / Timeout Values"
        }, 
        {
            "location": "/queues/#max-attempts", 
            "text": "One approach to specifying the maximum number of times a job may be attempted is via the  --tries  switch on the Artisan command line:  php artisan queue:work --tries=3  However, you may take a more granular approach by defining the maximum number of attempts on the job class itself. If the maximum number of attempts is specified on the job, it will take precedence over the value provided on the command line:  ? php  namespace   App \\ Jobs ;  class   ProcessPodcast   implements   ShouldQueue  { \n     /**       * The number of times the job may be attempted.       *       * @var int       */ \n     public   $tries   =   5 ;  }", 
            "title": "Max Attempts"
        }, 
        {
            "location": "/queues/#timeout", 
            "text": "Likewise, the maximum number of seconds that jobs can run may be specified using the  --timeout  switch on the Artisan command line:  php artisan queue:work --timeout=30  However, you may also define the maximum number of seconds a job should be allowed to run on the job class itself. If the timeout is specified on the job, it will take precedence over any timeout specified on the command line:  ? php  namespace   App \\ Jobs ;  class   ProcessPodcast   implements   ShouldQueue  { \n     /**       * The number of seconds the job can run before timing out.       *       * @var int       */ \n     public   $timeout   =   120 ;  }", 
            "title": "Timeout"
        }, 
        {
            "location": "/queues/#error-handling", 
            "text": "If an exception is thrown while the job is being processed, the job will automatically be released back onto the queue so it may be attempted again. The job will continue to be released until it has been attempted the maximum number of times allowed by your application. The maximum number of attempts is defined by the  --tries  switch used on the  queue:work  Artisan command. Alternatively, the maximum number of attempts may be defined on the job class itself. More information on running the queue worker  can be found below .", 
            "title": "Error Handling"
        }, 
        {
            "location": "/queues/#running-the-queue-worker", 
            "text": "Laravel includes a queue worker that will process new jobs as they are pushed onto the queue. You may run the worker using the  queue:work  Artisan command. Note that once the  queue:work  command has started, it will continue to run until it is manually stopped or you close your terminal:  php artisan queue:work   {tip} To keep the  queue:work  process running permanently in the background, you should use a process monitor such as  Supervisor  to ensure that the queue worker does not stop running.   Remember, queue workers are long-lived processes and store the booted application state in memory. As a result, they will not notice changes in your code base after they have been started. So, during your deployment process, be sure to  restart your queue workers .", 
            "title": "Running The Queue Worker"
        }, 
        {
            "location": "/queues/#specifying-the-connection-queue", 
            "text": "You may also specify which queue connection the worker should utilize. The connection name passed to the  work  command should correspond to one of the connections defined in your  config/queue.php  configuration file:  php artisan queue:work redis  You may customize your queue worker even further by only processing particular queues for a given connection. For example, if all of your emails are processed in an  emails  queue on your  redis  queue connection, you may issue the following command to start a worker that only processes only that queue:  php artisan queue:work redis --queue=emails", 
            "title": "Specifying The Connection &amp; Queue"
        }, 
        {
            "location": "/queues/#resource-considerations", 
            "text": "Daemon queue workers do not \"reboot\" the framework before processing each job. Therefore, you should free any heavy resources after each job completes. For example, if you are doing image manipulation with the GD library, you should free the memory with  imagedestroy  when you are done.", 
            "title": "Resource Considerations"
        }, 
        {
            "location": "/queues/#queue-priorities", 
            "text": "Sometimes you may wish to prioritize how your queues are processed. For example, in your  config/queue.php  you may set the default  queue  for your  redis  connection to  low . However, occasionally you may wish to push a job to a  high  priority queue like so:  dispatch((new Job)- onQueue( high ));  To start a worker that verifies that all of the  high  queue jobs are processed before continuing to any jobs on the  low  queue, pass a comma-delimited list of queue names to the  work  command:  php artisan queue:work --queue=high,low", 
            "title": "Queue Priorities"
        }, 
        {
            "location": "/queues/#queue-workers-deployment", 
            "text": "Since queue workers are long-lived processes, they will not pick up changes to your code without being restarted. So, the simplest way to deploy an application using queue workers is to restart the workers during your deployment process. You may gracefully restart all of the workers by issuing the  queue:restart  command:  php artisan queue:restart  This command will instruct all queue workers to gracefully \"die\" after they finish processing their current job so that no existing jobs are lost. Since the queue workers will die when the  queue:restart  command is executed, you should be running a process manager such as  Supervisor  to automatically restart the queue workers.", 
            "title": "Queue Workers &amp; Deployment"
        }, 
        {
            "location": "/queues/#job-expirations-timeouts", 
            "text": "", 
            "title": "Job Expirations &amp; Timeouts"
        }, 
        {
            "location": "/queues/#job-expiration", 
            "text": "In your  config/queue.php  configuration file, each queue connection defines a  retry_after  option. This option specifies how many seconds the queue connection should wait before retrying a job that is being processed. For example, if the value of  retry_after  is set to  90 , the job will be released back onto the queue if it has been processing for 90 seconds without being deleted. Typically, you should set the  retry_after  value to the maximum number of seconds your jobs should reasonably take to complete processing.   {note} The only queue connection which does not contain a  retry_after  value is Amazon SQS. SQS will retry the job based on the  Default Visibility Timeout  which is managed within the AWS console.", 
            "title": "Job Expiration"
        }, 
        {
            "location": "/queues/#worker-timeouts", 
            "text": "The  queue:work  Artisan command exposes a  --timeout  option. The  --timeout  option specifies how long the Laravel queue master process will wait before killing off a child queue worker that is processing a job. Sometimes a child queue process can become \"frozen\" for various reasons, such as an external HTTP call that is not responding. The  --timeout  option removes frozen processes that have exceeded that specified time limit:  php artisan queue:work --timeout=60  The  retry_after  configuration option and the  --timeout  CLI option are different, but work together to ensure that jobs are not lost and that jobs are only successfully processed once.   {note} The  --timeout  value should always be at least several seconds shorter than your  retry_after  configuration value. This will ensure that a worker processing a given job is always killed before the job is retried. If your  --timeout  option is longer than your  retry_after  configuration value, your jobs may be processed twice.", 
            "title": "Worker Timeouts"
        }, 
        {
            "location": "/queues/#worker-sleep-duration", 
            "text": "When jobs are available on the queue, the worker will keep processing jobs with no delay in between them. However, the  sleep  option determines how long the worker will \"sleep\" if there are no new jobs available:  php artisan queue:work --sleep=3", 
            "title": "Worker Sleep Duration"
        }, 
        {
            "location": "/queues/#supervisor-configuration", 
            "text": "", 
            "title": "Supervisor Configuration"
        }, 
        {
            "location": "/queues/#installing-supervisor", 
            "text": "Supervisor is a process monitor for the Linux operating system, and will automatically restart your  queue:work  process if it fails. To install Supervisor on Ubuntu, you may use the following command:  sudo apt-get install supervisor   {tip} If configuring Supervisor yourself sounds overwhelming, consider using  Laravel Forge , which will automatically install and configure Supervisor for your Laravel projects.", 
            "title": "Installing Supervisor"
        }, 
        {
            "location": "/queues/#configuring-supervisor", 
            "text": "Supervisor configuration files are typically stored in the  /etc/supervisor/conf.d  directory. Within this directory, you may create any number of configuration files that instruct supervisor how your processes should be monitored. For example, let's create a  laravel-worker.conf  file that starts and monitors a  queue:work  process:  [program:laravel-worker]  process_name = %(program_name)s_%(process_num)02d  command = php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3  autostart = true  autorestart = true  user = forge  numprocs = 8  redirect_stderr = true  stdout_logfile = /home/forge/app.com/worker.log   In this example, the  numprocs  directive will instruct Supervisor to run 8  queue:work  processes and monitor all of them, automatically restarting them if they fail. Of course, you should change the  queue:work sqs  portion of the  command  directive to reflect your desired queue connection.", 
            "title": "Configuring Supervisor"
        }, 
        {
            "location": "/queues/#starting-supervisor", 
            "text": "Once the configuration file has been created, you may update the Supervisor configuration and start the processes using the following commands:  sudo supervisorctl reread\n\nsudo supervisorctl update\n\nsudo supervisorctl start laravel-worker:*  For more information on Supervisor, consult the  Supervisor documentation .", 
            "title": "Starting Supervisor"
        }, 
        {
            "location": "/queues/#dealing-with-failed-jobs", 
            "text": "Sometimes your queued jobs will fail. Don't worry, things don't always go as planned! Laravel includes a convenient way to specify the maximum number of times a job should be attempted. After a job has exceeded this amount of attempts, it will be inserted into the  failed_jobs  database table. To create a migration for the  failed_jobs  table, you may use the  queue:failed-table  command:  php artisan queue:failed-table\n\nphp artisan migrate  Then, when running your  queue worker , you should specify the maximum number of times a job should be attempted using the  --tries  switch on the  queue:work  command. If you do not specify a value for the  --tries  option, jobs will be attempted indefinitely:  php artisan queue:work redis --tries=3", 
            "title": "Dealing With Failed Jobs"
        }, 
        {
            "location": "/queues/#cleaning-up-after-failed-jobs", 
            "text": "You may define a  failed  method directly on your job class, allowing you to perform job specific clean-up when a failure occurs. This is the perfect location to send an alert to your users or revert any actions performed by the job. The  Exception  that caused the job to fail will be passed to the  failed  method:  ? php  namespace   App \\ Jobs ;  use   Exception ;  use   App \\ Podcast ;  use   App \\ AudioProcessor ;  use   Illuminate \\ Bus \\ Queueable ;  use   Illuminate \\ Queue \\ SerializesModels ;  use   Illuminate \\ Queue \\ InteractsWithQueue ;  use   Illuminate \\ Contracts \\ Queue \\ ShouldQueue ;  class   ProcessPodcast   implements   ShouldQueue  { \n     use   InteractsWithQueue ,   Queueable ,   SerializesModels ; \n\n     protected   $podcast ; \n\n     /**       * Create a new job instance.       *       * @param  Podcast  $podcast       * @return void       */ \n     public   function   __construct ( Podcast   $podcast ) \n     { \n         $this - podcast   =   $podcast ; \n     } \n\n     /**       * Execute the job.       *       * @param  AudioProcessor  $processor       * @return void       */ \n     public   function   handle ( AudioProcessor   $processor ) \n     { \n         // Process uploaded podcast... \n     } \n\n     /**       * The job failed to process.       *       * @param  Exception  $exception       * @return void       */ \n     public   function   failed ( Exception   $exception ) \n     { \n         // Send user notification of failure, etc... \n     }  }", 
            "title": "Cleaning Up After Failed Jobs"
        }, 
        {
            "location": "/queues/#failed-job-events", 
            "text": "If you would like to register an event that will be called when a job fails, you may use the  Queue::failing  method. This event is a great opportunity to notify your team via email or  HipChat . For example, we may attach a callback to this event from the  AppServiceProvider  that is included with Laravel:  ? php  namespace   App \\ Providers ;  use   Illuminate \\ Support \\ Facades \\ Queue ;  use   Illuminate \\ Queue \\ Events \\ JobFailed ;  use   Illuminate \\ Support \\ ServiceProvider ;  class   AppServiceProvider   extends   ServiceProvider  { \n     /**       * Bootstrap any application services.       *       * @return void       */ \n     public   function   boot () \n     { \n         Queue :: failing ( function   ( JobFailed   $event )   { \n             // $event- connectionName \n             // $event- job \n             // $event- exception \n         }); \n     } \n\n     /**       * Register the service provider.       *       * @return void       */ \n     public   function   register () \n     { \n         // \n     }  }", 
            "title": "Failed Job Events"
        }, 
        {
            "location": "/queues/#retrying-failed-jobs", 
            "text": "To view all of your failed jobs that have been inserted into your  failed_jobs  database table, you may use the  queue:failed  Artisan command:  php artisan queue:failed  The  queue:failed  command will list the job ID, connection, queue, and failure time. The job ID may be used to retry the failed job. For instance, to retry a failed job that has an ID of  5 , issue the following command:  php artisan queue:retry 5  To retry all of your failed jobs, execute the  queue:retry  command and pass  all  as the ID:  php artisan queue:retry all  If you would like to delete a failed job, you may use the  queue:forget  command:  php artisan queue:forget 5  To delete all of your failed jobs, you may use the  queue:flush  command:  php artisan queue:flush", 
            "title": "Retrying Failed Jobs"
        }, 
        {
            "location": "/queues/#job-events", 
            "text": "Using the  before  and  after  methods on the  Queue   facade , you may specify callbacks to be executed before or after a queued job is processed. These callbacks are a great opportunity to perform additional logging or increment statistics for a dashboard. Typically, you should call these methods from a  service provider . For example, we may use the  AppServiceProvider  that is included with Laravel:  ? php  namespace   App \\ Providers ;  use   Illuminate \\ Support \\ Facades \\ Queue ;  use   Illuminate \\ Support \\ ServiceProvider ;  use   Illuminate \\ Queue \\ Events \\ JobProcessed ;  use   Illuminate \\ Queue \\ Events \\ JobProcessing ;  class   AppServiceProvider   extends   ServiceProvider  { \n     /**       * Bootstrap any application services.       *       * @return void       */ \n     public   function   boot () \n     { \n         Queue :: before ( function   ( JobProcessing   $event )   { \n             // $event- connectionName \n             // $event- job \n             // $event- job- payload() \n         }); \n\n         Queue :: after ( function   ( JobProcessed   $event )   { \n             // $event- connectionName \n             // $event- job \n             // $event- job- payload() \n         }); \n     } \n\n     /**       * Register the service provider.       *       * @return void       */ \n     public   function   register () \n     { \n         // \n     }  }   Using the  looping  method on the  Queue   facade , you may specify callbacks that execute before the worker attempts to fetch a job from a queue. For example, you might register a Closure to rollback any transactions that were left open by a previously failed job:  Queue :: looping ( function   ()   { \n     while   ( DB : : transactionLevel ()     0 )   { \n         DB :: rollBack (); \n     }  } );", 
            "title": "Job Events"
        }, 
        {
            "location": "/redirects/", 
            "text": "HTTP Redirects\n\n\n\n\nCreating Redirects\n\n\nRedirecting To Named Routes\n\n\nRedirecting To Controller Actions\n\n\nRedirecting With Flashed Session Data\n\n\n\n\n\n\nCreating Redirects\n\n\nRedirect responses are instances of the \nIlluminate\\Http\\RedirectResponse\n class, and contain the proper headers needed to redirect the user to another URL. There are several ways to generate a \nRedirectResponse\n instance. The simplest method is to use the global \nredirect\n helper:\n\n\nRoute::get(\ndashboard\n, function () {\n    return redirect(\nhome/dashboard\n);\n});\n\n\n\n\n\nSometimes you may wish to redirect the user to their previous location, such as when a submitted form is invalid. You may do so by using the global \nback\n helper function. Since this feature utilizes the \nsession\n, make sure the route calling the \nback\n function is using the \nweb\n middleware group or has all of the session middleware applied:\n\n\nRoute::post(\nuser/profile\n, function () {\n    // Validate the request...\n\n    return back()-\nwithInput();\n});\n\n\n\n\n\n\n\nRedirecting To Named Routes\n\n\nWhen you call the \nredirect\n helper with no parameters, an instance of \nIlluminate\\Routing\\Redirector\n is returned, allowing you to call any method on the \nRedirector\n instance. For example, to generate a \nRedirectResponse\n to a named route, you may use the \nroute\n method:\n\n\nreturn redirect()-\nroute(\nlogin\n);\n\n\n\n\n\nIf your route has parameters, you may pass them as the second argument to the \nroute\n method:\n\n\n// For a route with the following URI: profile/{id}\n\nreturn redirect()-\nroute(\nprofile\n, [\nid\n =\n 1]);\n\n\n\n\n\nPopulating Parameters Via Eloquent Models\n\n\nIf you are redirecting to a route with an \"ID\" parameter that is being populated from an Eloquent model, you may simply pass the model itself. The ID will be extracted automatically:\n\n\n// For a route with the following URI: profile/{id}\n\nreturn redirect()-\nroute(\nprofile\n, [$user]);\n\n\n\n\n\nIf you would like to customize the value that is placed in the route parameter, you should override the \ngetRouteKey\n method on your Eloquent model:\n\n\n/**\n\n\n * Get the value of the model\ns route key.\n\n\n *\n\n\n * @return mixed\n\n\n */\n\npublic\n \nfunction\n \ngetRouteKey\n()\n\n\n{\n\n\n    \nreturn\n \n$\nthis\n-\nslug\n;\n\n\n}\n\n\n\n\n\n\n\n\nRedirecting To Controller Actions\n\n\nYou may also generate redirects to \ncontroller actions\n. To do so, pass the controller and action name to the \naction\n method. Remember, you do not need to specify the full namespace to the controller since Laravel's \nRouteServiceProvider\n will automatically set the base controller namespace:\n\n\nreturn redirect()-\naction(\nHomeController@index\n);\n\n\n\n\n\nIf your controller route requires parameters, you may pass them as the second argument to the \naction\n method:\n\n\nreturn redirect()-\naction(\n    \nUserController@profile\n, [\nid\n =\n 1]\n);\n\n\n\n\n\n\n\nRedirecting With Flashed Session Data\n\n\nRedirecting to a new URL and \nflashing data to the session\n are usually done at the same time. Typically, this is done after successfully performing an action when you flash a success message to the session. For convenience, you may create a \nRedirectResponse\n instance and flash data to the session in a single, fluent method chain:\n\n\nRoute::post(\nuser/profile\n, function () {\n    // Update the user\ns profile...\n\n    return redirect(\ndashboard\n)-\nwith(\nstatus\n, \nProfile updated!\n);\n});\n\n\n\n\n\nAfter the user is redirected, you may display the flashed message from the \nsession\n. For example, using \nBlade syntax\n:\n\n\n@\nif\n \n(\nsession\n(\nstatus\n))\n\n    \ndiv\n \nclass\n=\nalert alert-success\n\n        \n{{\n \nsession\n(\nstatus\n)\n \n}}\n\n    \n/\ndiv\n\n\n@\nendif", 
            "title": "Redirects"
        }, 
        {
            "location": "/redirects/#http-redirects", 
            "text": "Creating Redirects  Redirecting To Named Routes  Redirecting To Controller Actions  Redirecting With Flashed Session Data", 
            "title": "HTTP Redirects"
        }, 
        {
            "location": "/redirects/#creating-redirects", 
            "text": "Redirect responses are instances of the  Illuminate\\Http\\RedirectResponse  class, and contain the proper headers needed to redirect the user to another URL. There are several ways to generate a  RedirectResponse  instance. The simplest method is to use the global  redirect  helper:  Route::get( dashboard , function () {\n    return redirect( home/dashboard );\n});  Sometimes you may wish to redirect the user to their previous location, such as when a submitted form is invalid. You may do so by using the global  back  helper function. Since this feature utilizes the  session , make sure the route calling the  back  function is using the  web  middleware group or has all of the session middleware applied:  Route::post( user/profile , function () {\n    // Validate the request...\n\n    return back()- withInput();\n});", 
            "title": "Creating Redirects"
        }, 
        {
            "location": "/redirects/#redirecting-to-named-routes", 
            "text": "When you call the  redirect  helper with no parameters, an instance of  Illuminate\\Routing\\Redirector  is returned, allowing you to call any method on the  Redirector  instance. For example, to generate a  RedirectResponse  to a named route, you may use the  route  method:  return redirect()- route( login );  If your route has parameters, you may pass them as the second argument to the  route  method:  // For a route with the following URI: profile/{id}\n\nreturn redirect()- route( profile , [ id  =  1]);", 
            "title": "Redirecting To Named Routes"
        }, 
        {
            "location": "/redirects/#populating-parameters-via-eloquent-models", 
            "text": "If you are redirecting to a route with an \"ID\" parameter that is being populated from an Eloquent model, you may simply pass the model itself. The ID will be extracted automatically:  // For a route with the following URI: profile/{id}\n\nreturn redirect()- route( profile , [$user]);  If you would like to customize the value that is placed in the route parameter, you should override the  getRouteKey  method on your Eloquent model:  /**   * Get the value of the model s route key.   *   * @return mixed   */ \npublic   function   getRouteKey ()  {       return   $ this - slug ;  }", 
            "title": "Populating Parameters Via Eloquent Models"
        }, 
        {
            "location": "/redirects/#redirecting-to-controller-actions", 
            "text": "You may also generate redirects to  controller actions . To do so, pass the controller and action name to the  action  method. Remember, you do not need to specify the full namespace to the controller since Laravel's  RouteServiceProvider  will automatically set the base controller namespace:  return redirect()- action( HomeController@index );  If your controller route requires parameters, you may pass them as the second argument to the  action  method:  return redirect()- action(\n     UserController@profile , [ id  =  1]\n);", 
            "title": "Redirecting To Controller Actions"
        }, 
        {
            "location": "/redirects/#redirecting-with-flashed-session-data", 
            "text": "Redirecting to a new URL and  flashing data to the session  are usually done at the same time. Typically, this is done after successfully performing an action when you flash a success message to the session. For convenience, you may create a  RedirectResponse  instance and flash data to the session in a single, fluent method chain:  Route::post( user/profile , function () {\n    // Update the user s profile...\n\n    return redirect( dashboard )- with( status ,  Profile updated! );\n});  After the user is redirected, you may display the flashed message from the  session . For example, using  Blade syntax :  @ if   ( session ( status )) \n     div   class = alert alert-success \n         {{   session ( status )   }} \n     / div  @ endif", 
            "title": "Redirecting With Flashed Session Data"
        }, 
        {
            "location": "/redis/", 
            "text": "Redis\n\n\n\n\nIntroduction\n\n\nConfiguration\n\n\nPredis\n\n\nPhpRedis\n\n\n\n\n\n\nInteracting With Redis\n\n\nPipelining Commands\n\n\n\n\n\n\nPub / Sub\n\n\n\n\n\n\nIntroduction\n\n\nRedis\n is an open source, advanced key-value store. It is often referred to as a data structure server since keys can contain \nstrings\n, \nhashes\n, \nlists\n, \nsets\n, and \nsorted sets\n.\n\n\nBefore using Redis with Laravel, you will need to install the \npredis/predis\n package via Composer:\n\n\ncomposer require predis/predis\n\n\n\n\n\nAlternatively, you may install the \nPhpRedis\n PHP extension via PECL. The extension is more complex to install but may yield better performance for applications that make heavy use of Redis.\n\n\n\n\nConfiguration\n\n\nThe Redis configuration for your application is located in the \nconfig/database.php\n configuration file. Within this file, you will see a \nredis\n array containing the Redis servers utilized by your application:\n\n\nredis\n =\n [\n\n    \nclient\n =\n \npredis\n,\n\n    \ndefault\n =\n [\n        \nhost\n =\n env(\nREDIS_HOST\n, \nlocalhost\n),\n        \npassword\n =\n env(\nREDIS_PASSWORD\n, null),\n        \nport\n =\n env(\nREDIS_PORT\n, 6379),\n        \ndatabase\n =\n 0,\n    ],\n\n],\n\n\n\n\n\nThe default server configuration should suffice for development. However, you are free to modify this array based on your environment. Each Redis server defined in your configuration file is required to have a name, host, and port.\n\n\nConfiguring Clusters\n\n\nIf your application is utilizing a cluster of Redis servers, you should define these clusters within a \nclusters\n key of your Redis configuration:\n\n\nredis\n =\n [\n\n    \nclient\n =\n \npredis\n,\n\n    \nclusters\n =\n [\n        \ndefault\n =\n [\n            [\n                \nhost\n =\n env(\nREDIS_HOST\n, \nlocalhost\n),\n                \npassword\n =\n env(\nREDIS_PASSWORD\n, null),\n                \nport\n =\n env(\nREDIS_PORT\n, 6379),\n                \ndatabase\n =\n 0,\n            ],\n        ],\n    ],\n\n],\n\n\n\n\n\nBy default, clusters will perform client-side sharding across your nodes, allowing you to pool nodes and create a large amount of available RAM. However, note that client-side sharding does not handle failover; therefore, is primarily suited for cached data that is available from another primary data store. If you would like to use native Redis clustering, you should specify this in the \noptions\n key of your Redis configuration:\n\n\nredis\n =\n [\n\n    \nclient\n =\n \npredis\n,\n\n    \noptions\n =\n [\n        \ncluster\n =\n \nredis\n,\n    ],\n\n    \nclusters\n =\n [\n        // ...\n    ],\n\n],\n\n\n\n\n\n\n\nPredis\n\n\nIn addition to the default \nhost\n, \nport\n, \ndatabase\n, and \npassword\n server configuration options, Predis supports additional \nconnection parameters\n that may be defined for each of your Redis servers. To utilize these additional configuration options, simply add them to your Redis server configuration in the \nconfig/database.php\n configuration file:\n\n\ndefault\n =\n [\n    \nhost\n =\n env(\nREDIS_HOST\n, \nlocalhost\n),\n    \npassword\n =\n env(\nREDIS_PASSWORD\n, null),\n    \nport\n =\n env(\nREDIS_PORT\n, 6379),\n    \ndatabase\n =\n 0,\n    \nread_write_timeout\n =\n 60,\n],\n\n\n\n\n\n\n\nPhpRedis\n\n\n\n\n{note} If you have the PhpRedis PHP extension installed via PECL, you will need to rename the \nRedis\n alias in your \nconfig/app.php\n configuration file.\n\n\n\n\nTo utilize the PhpRedis extension, you should change the \nclient\n option of your Redis configuration to \nphpredis\n. This option is found in your \nconfig/database.php\n configuration file:\n\n\nredis\n =\n [\n\n    \nclient\n =\n \nphpredis\n,\n\n    // Rest of Redis configuration...\n],\n\n\n\n\n\nIn addition to the default \nhost\n, \nport\n, \ndatabase\n, and \npassword\n server configuration options, PhpRedis supports the following additional connection parameters: \npersistent\n, \nprefix\n, \nread_timeout\n and \ntimeout\n. You may add any of these options to your Redis server configuration in the \nconfig/database.php\n configuration file:\n\n\ndefault\n =\n [\n    \nhost\n =\n env(\nREDIS_HOST\n, \nlocalhost\n),\n    \npassword\n =\n env(\nREDIS_PASSWORD\n, null),\n    \nport\n =\n env(\nREDIS_PORT\n, 6379),\n    \ndatabase\n =\n 0,\n    \nread_timeout\n =\n 60,\n],\n\n\n\n\n\n\n\nInteracting With Redis\n\n\nYou may interact with Redis by calling various methods on the \nRedis\n \nfacade\n. The \nRedis\n facade supports dynamic methods, meaning you may call any \nRedis command\n on the facade and the command will be passed directly to Redis. In this example, we will call the Redis \nGET\n command by calling the \nget\n method on the \nRedis\n facade:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nRedis\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Show the profile for the given user.\n\n\n     *\n\n\n     * @param  int  $id\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nshowProfile\n(\n$id\n)\n\n    \n{\n\n        \n$user\n \n=\n \nRedis\n::\nget\n(\nuser:profile:\n.\n$id\n);\n\n\n        \nreturn\n \nview\n(\nuser.profile\n,\n \n[\nuser\n \n=\n \n$user\n]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOf course, as mentioned above, you may call any of the Redis commands on the \nRedis\n facade. Laravel uses magic methods to pass the commands to the Redis server, so simply pass the arguments the Redis command expects:\n\n\nRedis\n::\nset\n(\nname\n,\n \nTaylor\n);\n\n\n\n$\nvalues\n \n=\n \nRedis\n::\nlrange\n(\nnames\n,\n \n5\n,\n \n10\n);\n\n\n\n\n\n\nAlternatively, you may also pass commands to the server using the \ncommand\n method, which accepts the name of the command as its first argument, and an array of values as its second argument:\n\n\n$\nvalues\n \n=\n \nRedis\n::\ncommand\n(\nlrange\n,\n \n[\nname\n,\n \n5\n,\n \n10\n]\n);\n\n\n\n\n\n\nUsing Multiple Redis Connections\n\n\nYou may get a Redis instance by calling the \nRedis::connection\n method:\n\n\n$\nredis\n \n=\n \nRedis\n::\nconnection\n();\n\n\n\n\n\n\nThis will give you an instance of the default Redis server. You may also pass the connection or cluster name to the \nconnection\n method to get a specific server or cluster as defined in your Redis configuration:\n\n\n$\nredis\n \n=\n \nRedis\n::\nconnection\n(\nmy-connection\n);\n\n\n\n\n\n\n\n\nPipelining Commands\n\n\nPipelining should be used when you need to send many commands to the server in one operation. The \npipeline\n method accepts one argument: a \nClosure\n that receives a Redis instance. You may issue all of your commands to this Redis instance and they will all be executed within a single operation:\n\n\nRedis\n::\npipeline\n(\nfunction\n \n($\npipe\n)\n \n{\n\n    \nfor\n \n($i\n \n=\n \n0\n;\n \n$i\n \n \n1000\n;\n \n$i++)\n \n{\n\n        \n$pipe-\nset(\nkey\n:\n$\ni\n,\n \n$\ni\n);\n\n    \n}\n\n\n}\n);\n\n\n\n\n\n\n\n\nPub / Sub\n\n\nLaravel provides a convenient interface to the Redis \npublish\n and \nsubscribe\n commands. These Redis commands allow you to listen for messages on a given \"channel\". You may publish messages to the channel from another application, or even using another programming language, allowing easy communication between applications and processes.\n\n\nFirst, let's setup a channel listener using the \nsubscribe\n method. We'll place this method call within an \nArtisan command\n since calling the \nsubscribe\n method begins a long-running process:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nConsole\n\\\nCommands\n;\n\n\n\nuse\n \nIlluminate\n\\\nConsole\n\\\nCommand\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nRedis\n;\n\n\n\nclass\n \nRedisSubscribe\n \nextends\n \nCommand\n\n\n{\n\n    \n/**\n\n\n     * The name and signature of the console command.\n\n\n     *\n\n\n     * @var string\n\n\n     */\n\n    \nprotected\n \n$signature\n \n=\n \nredis:subscribe\n;\n\n\n    \n/**\n\n\n     * The console command description.\n\n\n     *\n\n\n     * @var string\n\n\n     */\n\n    \nprotected\n \n$description\n \n=\n \nSubscribe to a Redis channel\n;\n\n\n    \n/**\n\n\n     * Execute the console command.\n\n\n     *\n\n\n     * @return mixed\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandle\n()\n\n    \n{\n\n        \nRedis\n::\nsubscribe\n([\ntest-channel\n],\n \nfunction\n \n(\n$message\n)\n \n{\n\n            \necho\n \n$message\n;\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNow we may publish messages to the channel using the \npublish\n method:\n\n\nRoute\n::\nget\n(\npublish\n,\n \nfunction\n \n()\n \n{\n\n    \n//\n \nRoute\n \nlogic...\n\n\n    \nRedis\n:\n:\npublish\n(\ntest-channel\n,\n \njson_encode\n(\n[\nfoo\n \n=\n \nbar\n]\n));\n\n\n}\n);\n\n\n\n\n\n\nWildcard Subscriptions\n\n\nUsing the \npsubscribe\n method, you may subscribe to a wildcard channel, which may be useful for catching all messages on all channels. The \n$channel\n name will be passed as the second argument to the provided callback \nClosure\n:\n\n\nRedis::psubscribe([\n*\n], function ($message, $channel) {\n    echo $message;\n});\n\nRedis::psubscribe([\nusers.*\n], function ($message, $channel) {\n    echo $message;\n});", 
            "title": "Redis"
        }, 
        {
            "location": "/redis/#redis", 
            "text": "Introduction  Configuration  Predis  PhpRedis    Interacting With Redis  Pipelining Commands    Pub / Sub", 
            "title": "Redis"
        }, 
        {
            "location": "/redis/#introduction", 
            "text": "Redis  is an open source, advanced key-value store. It is often referred to as a data structure server since keys can contain  strings ,  hashes ,  lists ,  sets , and  sorted sets .  Before using Redis with Laravel, you will need to install the  predis/predis  package via Composer:  composer require predis/predis  Alternatively, you may install the  PhpRedis  PHP extension via PECL. The extension is more complex to install but may yield better performance for applications that make heavy use of Redis.", 
            "title": "Introduction"
        }, 
        {
            "location": "/redis/#configuration", 
            "text": "The Redis configuration for your application is located in the  config/database.php  configuration file. Within this file, you will see a  redis  array containing the Redis servers utilized by your application:  redis  =  [\n\n     client  =   predis ,\n\n     default  =  [\n         host  =  env( REDIS_HOST ,  localhost ),\n         password  =  env( REDIS_PASSWORD , null),\n         port  =  env( REDIS_PORT , 6379),\n         database  =  0,\n    ],\n\n],  The default server configuration should suffice for development. However, you are free to modify this array based on your environment. Each Redis server defined in your configuration file is required to have a name, host, and port.", 
            "title": "Configuration"
        }, 
        {
            "location": "/redis/#configuring-clusters", 
            "text": "If your application is utilizing a cluster of Redis servers, you should define these clusters within a  clusters  key of your Redis configuration:  redis  =  [\n\n     client  =   predis ,\n\n     clusters  =  [\n         default  =  [\n            [\n                 host  =  env( REDIS_HOST ,  localhost ),\n                 password  =  env( REDIS_PASSWORD , null),\n                 port  =  env( REDIS_PORT , 6379),\n                 database  =  0,\n            ],\n        ],\n    ],\n\n],  By default, clusters will perform client-side sharding across your nodes, allowing you to pool nodes and create a large amount of available RAM. However, note that client-side sharding does not handle failover; therefore, is primarily suited for cached data that is available from another primary data store. If you would like to use native Redis clustering, you should specify this in the  options  key of your Redis configuration:  redis  =  [\n\n     client  =   predis ,\n\n     options  =  [\n         cluster  =   redis ,\n    ],\n\n     clusters  =  [\n        // ...\n    ],\n\n],", 
            "title": "Configuring Clusters"
        }, 
        {
            "location": "/redis/#predis", 
            "text": "In addition to the default  host ,  port ,  database , and  password  server configuration options, Predis supports additional  connection parameters  that may be defined for each of your Redis servers. To utilize these additional configuration options, simply add them to your Redis server configuration in the  config/database.php  configuration file:  default  =  [\n     host  =  env( REDIS_HOST ,  localhost ),\n     password  =  env( REDIS_PASSWORD , null),\n     port  =  env( REDIS_PORT , 6379),\n     database  =  0,\n     read_write_timeout  =  60,\n],", 
            "title": "Predis"
        }, 
        {
            "location": "/redis/#phpredis", 
            "text": "{note} If you have the PhpRedis PHP extension installed via PECL, you will need to rename the  Redis  alias in your  config/app.php  configuration file.   To utilize the PhpRedis extension, you should change the  client  option of your Redis configuration to  phpredis . This option is found in your  config/database.php  configuration file:  redis  =  [\n\n     client  =   phpredis ,\n\n    // Rest of Redis configuration...\n],  In addition to the default  host ,  port ,  database , and  password  server configuration options, PhpRedis supports the following additional connection parameters:  persistent ,  prefix ,  read_timeout  and  timeout . You may add any of these options to your Redis server configuration in the  config/database.php  configuration file:  default  =  [\n     host  =  env( REDIS_HOST ,  localhost ),\n     password  =  env( REDIS_PASSWORD , null),\n     port  =  env( REDIS_PORT , 6379),\n     database  =  0,\n     read_timeout  =  60,\n],", 
            "title": "PhpRedis"
        }, 
        {
            "location": "/redis/#interacting-with-redis", 
            "text": "You may interact with Redis by calling various methods on the  Redis   facade . The  Redis  facade supports dynamic methods, meaning you may call any  Redis command  on the facade and the command will be passed directly to Redis. In this example, we will call the Redis  GET  command by calling the  get  method on the  Redis  facade:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Support \\ Facades \\ Redis ;  use   App \\ Http \\ Controllers \\ Controller ;  class   UserController   extends   Controller  { \n     /**       * Show the profile for the given user.       *       * @param  int  $id       * @return Response       */ \n     public   function   showProfile ( $id ) \n     { \n         $user   =   Redis :: get ( user:profile: . $id ); \n\n         return   view ( user.profile ,   [ user   =   $user ]); \n     }  }   Of course, as mentioned above, you may call any of the Redis commands on the  Redis  facade. Laravel uses magic methods to pass the commands to the Redis server, so simply pass the arguments the Redis command expects:  Redis :: set ( name ,   Taylor );  $ values   =   Redis :: lrange ( names ,   5 ,   10 );   Alternatively, you may also pass commands to the server using the  command  method, which accepts the name of the command as its first argument, and an array of values as its second argument:  $ values   =   Redis :: command ( lrange ,   [ name ,   5 ,   10 ] );", 
            "title": "Interacting With Redis"
        }, 
        {
            "location": "/redis/#using-multiple-redis-connections", 
            "text": "You may get a Redis instance by calling the  Redis::connection  method:  $ redis   =   Redis :: connection ();   This will give you an instance of the default Redis server. You may also pass the connection or cluster name to the  connection  method to get a specific server or cluster as defined in your Redis configuration:  $ redis   =   Redis :: connection ( my-connection );", 
            "title": "Using Multiple Redis Connections"
        }, 
        {
            "location": "/redis/#pipelining-commands", 
            "text": "Pipelining should be used when you need to send many commands to the server in one operation. The  pipeline  method accepts one argument: a  Closure  that receives a Redis instance. You may issue all of your commands to this Redis instance and they will all be executed within a single operation:  Redis :: pipeline ( function   ($ pipe )   { \n     for   ($i   =   0 ;   $i     1000 ;   $i++)   { \n         $pipe- set( key : $ i ,   $ i ); \n     }  } );", 
            "title": "Pipelining Commands"
        }, 
        {
            "location": "/redis/#pub-sub", 
            "text": "Laravel provides a convenient interface to the Redis  publish  and  subscribe  commands. These Redis commands allow you to listen for messages on a given \"channel\". You may publish messages to the channel from another application, or even using another programming language, allowing easy communication between applications and processes.  First, let's setup a channel listener using the  subscribe  method. We'll place this method call within an  Artisan command  since calling the  subscribe  method begins a long-running process:  ? php  namespace   App \\ Console \\ Commands ;  use   Illuminate \\ Console \\ Command ;  use   Illuminate \\ Support \\ Facades \\ Redis ;  class   RedisSubscribe   extends   Command  { \n     /**       * The name and signature of the console command.       *       * @var string       */ \n     protected   $signature   =   redis:subscribe ; \n\n     /**       * The console command description.       *       * @var string       */ \n     protected   $description   =   Subscribe to a Redis channel ; \n\n     /**       * Execute the console command.       *       * @return mixed       */ \n     public   function   handle () \n     { \n         Redis :: subscribe ([ test-channel ],   function   ( $message )   { \n             echo   $message ; \n         }); \n     }  }   Now we may publish messages to the channel using the  publish  method:  Route :: get ( publish ,   function   ()   { \n     //   Route   logic... \n\n     Redis : : publish ( test-channel ,   json_encode ( [ foo   =   bar ] ));  } );", 
            "title": "Pub / Sub"
        }, 
        {
            "location": "/redis/#wildcard-subscriptions", 
            "text": "Using the  psubscribe  method, you may subscribe to a wildcard channel, which may be useful for catching all messages on all channels. The  $channel  name will be passed as the second argument to the provided callback  Closure :  Redis::psubscribe([ * ], function ($message, $channel) {\n    echo $message;\n});\n\nRedis::psubscribe([ users.* ], function ($message, $channel) {\n    echo $message;\n});", 
            "title": "Wildcard Subscriptions"
        }, 
        {
            "location": "/releases/", 
            "text": "Release Notes\n\n\n\n\nSupport Policy\n\n\nLaravel 5.4\n\n\nLaravel 5.3\n\n\nLaravel 5.2\n\n\nLaravel 5.1.11\n\n\nLaravel 5.1.4\n\n\nLaravel 5.1\n\n\nLaravel 5.0\n\n\nLaravel 4.2\n\n\n\n\n\n\nSupport Policy\n\n\nFor LTS releases, such as Laravel 5.1, bug fixes are provided for 2 years and security fixes are provided for 3 years. These releases provide the longest window of support and maintenance. For general releases, bug fixes are provided for 6 months and security fixes are provided for 1 year.\n\n\n\n\nLaravel 5.4\n\n\nLaravel 5.4 continues the improvements made in Laravel 5.3 by adding support for \nMarkdown based emails and notifications\n, the \nLaravel Dusk\n browser automation and testing framework, Laravel Mix, Blade \"components\" and \"slots\", route model binding on broadcast channels, higher order messages for Collections, object-based Eloquent events, job-level \"retry\" and \"timeout\" settings, \"realtime\" facades, improved support for Redis Cluster, custom pivot table models, middleware for request input trimming and cleaning, and more. In addition, the entire codebase of the framework was reviewed and refactored for general cleanliness.\n\n\n\n\n{tip} This documentation summarizes the most notable improvements to the framework; however, more thorough change logs are always available \non GitHub\n.\n\n\n\n\nMarkdown Mail \n Notifications\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nMarkdown mailable messages allow you to take advantage of the pre-built templates and components of mail notifications in your mailables. Since the messages are written in Markdown, Laravel is able to render beautiful, responsive HTML templates for the messages while also automatically generating a plain-text counterpart. For example, a Markdown email might look something like the following:\n\n\n@\ncomponent\n(\nmail\n::\nmessage\n)\n\n\n# Order Shipped\n\n\n\nYour\n \norder\n \nhas\n \nbeen\n \nshipped\n!\n\n\n\n@\ncomponent\n(\nmail\n::\nbutton\n,\n \n[\nurl\n \n=\n \n$\nurl\n])\n\n\nView\n \nOrder\n\n\n@\nendcomponent\n\n\n\nNext\n \nSteps\n:\n\n\n\n-\n \nTrack\n \nYour\n \nOrder\n \nOn\n \nOur\n \nWebsite\n\n\n-\n \nPre\n-\nSign\n \nFor\n \nDelivery\n\n\n\nThanks\n,\nbr\n\n\n{{\n \nconfig\n(\napp\n.\nname\n)\n \n}}\n\n\n@\nendcomponent\n\n\n\n\n\n\nUsing this simple Markdown template, Laravel is able to generate a responsive HTML email and plain-text counterpart:\n\n\n\n\nTo read more about Markdown mail and notifications, check out the full \nmail\n and \nnotification\n documentation.\n\n\n\n\n{tip} You may export all of the Markdown mail components to your own application for customization. To export the components, use the \nvendor:publish\n Artisan command to publish the \nlaravel-mail\n asset tag.\n\n\n\n\nLaravel Dusk\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nLaravel Dusk provides an expressive, easy-to-use browser automation and testing API. By default, Dusk does not require you to install JDK or Selenium on your machine. Instead, Dusk uses a standalone \nChromeDriver\n installation. However, you are free to utilize any other Selenium compatible driver you wish.\n\n\nSince Dusk operates using a real browser, you are able to easily test and interact with your applications that heavily use JavaScript:\n\n\n/**\n\n\n * A basic browser test example.\n\n\n *\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \ntestBasicExample\n()\n\n\n{\n\n\n    \n$\nuser\n \n=\n \nfactory\n(\nUser\n:\n:\nclass\n)-\ncreate\n(\n[\n\n\n        \nemail\n \n=\n \ntaylor@laravel.com\n,\n\n\n    \n]\n)\n;\n\n\n\n    \n$\nthis\n-\nbrowse\n(\nfunction\n \n(\n$\nbrowser\n)\n \nuse\n \n(\n$\nuser\n)\n \n{\n\n\n        \n$\nbrowser\n-\nloginAs\n(\n$\nuser\n)\n\n\n                \n-\nvisit\n(\n/home\n)\n\n\n                \n-\npress\n(\nCreate Playlist\n)\n\n\n                \n-\nwhenAvailable\n(\n.playlist-modal\n,\n \nfunction\n \n(\n$\nmodal\n)\n \n{\n\n\n                    \n$\nmodal\n-\ntype\n(\nname\n,\n \nMy Playlist\n)\n\n\n                          \n-\npress\n(\nCreate\n)\n;\n\n\n                \n}\n)\n;\n\n\n\n        \n$\nbrowser\n-\nwaitForText\n(\nPlaylist Created\n)\n;\n\n\n    \n}\n)\n;\n\n\n}\n\n\n\n\n\n\nFor more information on Dusk, consult the full \nDusk documentation\n.\n\n\nLaravel Mix\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nLaravel Mix is the spiritual successor of Laravel Elixir, and its entirely based on Webpack instead of Gulp. Laravel Mix provides a fluent API for defining Webpack build steps for your Laravel application using several common CSS and JavaScript pre-processors. Through simple method chaining, you can fluently define your asset pipeline. For example:\n\n\nmix.js(\nresources/assets/js/app.js\n, \npublic/js\n)\n   .sass(\nresources/assets/sass/app.scss\n, \npublic/css\n);\n\n\n\n\n\nBlade Components \n Slots\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nBlade components and slots provide similar benefits to sections and layouts; however, some may find the mental model of components and slots easier to understand. First, let's imagine a reusable \"alert\" component we would like to reuse throughout our application:\n\n\n!-- /resources/views/alert.blade.php --\n\n\n\ndiv\n \nclass=\nalert alert-danger\n\n    \n{{\n \n$\nslot\n \n}}\n\n\n/div\n\n\n\n\n\n\nThe \n{{ $slot }}\n variable will contain the content we wish to inject into the component. Now, to construct this component, we can use the \n@component\n Blade directive:\n\n\n@\ncomponent\n(\nalert\n)\n\n    \nstrong\nWhoops\n!\n/\nstrong\n \nSomething\n \nwent\n \nwrong\n!\n\n\n@\nendcomponent\n\n\n\n\n\n\nNamed slots allow you to provide multiple slots into a single component:\n\n\n!-- /resources/views/alert.blade.php --\n\n\n\ndiv\n \nclass=\nalert alert-danger\n\n    \ndiv\n \nclass=\nalert-title\n{{\n \n$\ntitle\n \n}}\n/div\n\n\n    \n{{\n \n$\nslot\n \n}}\n\n\n/div\n\n\n\n\n\n\nNamed slots may be injected using the \n@slot\n directive. Any content is not within a \n@slot\n directive will be passed to the component in the \n$slot\n variable:\n\n\n@\ncomponent\n(\nalert\n)\n\n    \n@\nslot\n(\ntitle\n)\n\n        \nForbidden\n\n    \n@\nendslot\n\n\n    \nYou\n \nare\n \nnot\n \nallowed\n \nto\n \naccess\n \nthis\n \nresource\n!\n\n\n@\nendcomponent\n\n\n\n\n\n\nTo read more about components and slots, consult the full \nBlade documentation\n.\n\n\nBroadcast Model Binding\n\n\nJust like HTTP routes, channel routes may now take advantage of implicit and explicit \nroute model binding\n. For example, instead of receiving the string or numeric order ID, you may request an actual \nOrder\n model instance:\n\n\nuse App\\Order;\n\nBroadcast::channel(\norder.{order}\n, function ($user, Order $order) {\n    return $user-\nid === $order-\nuser_id;\n});\n\n\n\n\n\nTo read more about broadcast model binding, consult the full \nevent broadcasting\n documentation.\n\n\nCollection Higher Order Messages\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nCollections now provide support for \"higher order messages\", which are short-cuts for performing common actions on collections. The collection methods that provide higher order messages are: \ncontains\n, \neach\n, \nevery\n, \nfilter\n, \nfirst\n, \nmap\n, \npartition\n, \nreject\n, \nsortBy\n, \nsortByDesc\n, and \nsum\n.\n\n\nEach higher order message can be accessed as a dynamic property on a collection instance. For instance, let's use the \neach\n higher order message to call a method on each object within a collection:\n\n\n$\nusers\n \n=\n \nUser\n::\nwhere\n(\nvotes\n,\n \n,\n \n500\n)\n-\nget\n();\n\n\n\n$\nusers-\neach-\nmarkAsVip\n();\n\n\n\n\n\n\nLikewise, we can use the \nsum\n higher order message to gather the total number of \"votes\" for a collection of users:\n\n\n$\nusers\n \n=\n \nUser\n::\nwhere\n(\ngroup\n,\n \nDevelopment\n)\n-\nget\n();\n\n\n\nreturn\n \n$\nusers-\nsum-\nvotes\n;\n\n\n\n\n\n\nObject Based Eloquent Events\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nEloquent event handlers may now be mapped to event objects. This provides a more intuitive way of handling Eloquent events and makes it easier to test the events. To get started, define an \n$events\n property on your Eloquent model that maps various points of the Eloquent model's lifecycle to your own \nevent classes\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nApp\n\\\nEvents\n\\\nUserSaved\n;\n\n\nuse\n \nApp\n\\\nEvents\n\\\nUserDeleted\n;\n\n\nuse\n \nIlluminate\n\\\nNotifications\n\\\nNotifiable\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nAuth\n\\\nUser\n \nas\n \nAuthenticatable\n;\n\n\n\nclass\n \nUser\n \nextends\n \nAuthenticatable\n\n\n{\n\n    \nuse\n \nNotifiable\n;\n\n\n    \n/**\n\n\n     * The event map for the model.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$events\n \n=\n \n[\n\n        \nsaved\n \n=\n \nUserSaved\n::\nclass\n,\n\n        \ndeleted\n \n=\n \nUserDeleted\n::\nclass\n,\n\n    \n];\n\n\n}\n\n\n\n\n\n\nJob Level Retry \n Timeout\n\n\nPreviously, queue job \"retry\" and \"timeout\" settings could only be configured globally for all jobs on the command line. However, in Laravel 5.4, these settings may be configured on a per-job basis by defining them directly on the job class:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nJobs\n;\n\n\n\nclass\n \nProcessPodcast\n \nimplements\n \nShouldQueue\n\n\n{\n\n    \n/**\n\n\n     * The number of times the job may be attempted.\n\n\n     *\n\n\n     * @var int\n\n\n     */\n\n    \npublic\n \n$tries\n \n=\n \n5\n;\n\n\n    \n/**\n\n\n     * The number of seconds the job can run before timing out.\n\n\n     *\n\n\n     * @var int\n\n\n     */\n\n    \npublic\n \n$timeout\n \n=\n \n120\n;\n\n\n}\n\n\n\n\n\n\nFor more information about these settings, consult the full \nqueue documentation\n.\n\n\nRequest Sanitization Middleware\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nLaravel 5.4 includes two new middleware in the default middleware stack: \nTrimStrings\n and \nConvertEmptyStringsToNull\n:\n\n\n/**\n\n\n * The application\ns global HTTP middleware stack.\n\n\n *\n\n\n * These middleware are run during every request to your application.\n\n\n *\n\n\n * @var array\n\n\n */\n\nprotected\n \n$\nmiddleware\n \n=\n \n[\n\n\n    \n\\\nIlluminate\n\\\nFoundation\n\\\nHttp\n\\\nMiddleware\n\\\nCheckForMaintenanceMode\n:\n:\nclass\n,\n\n\n    \n\\\nIlluminate\n\\\nFoundation\n\\\nHttp\n\\\nMiddleware\n\\\nValidatePostSize\n:\n:\nclass\n,\n\n\n    \n\\\nApp\n\\\nHttp\n\\\nMiddleware\n\\\nTrimStrings\n:\n:\nclass\n,\n\n\n    \n\\\nIlluminate\n\\\nFoundation\n\\\nHttp\n\\\nMiddleware\n\\\nConvertEmptyStringsToNull\n:\n:\nclass\n,\n\n\n];\n\n\n\n\n\n\nThese middleware will automatically trim request input values and convert any empty strings to \nnull\n. This helps you normalize the input for every request entering into your application and not have to worry about continually calling the \ntrim\n function in every route and controller.\n\n\n\"Realtime\" Facades\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nPreviously, only Laravel's own built-in services exposed \nfacades\n, which provide quick, terse access to their methods via the service container. However, in Laravel 5.4, you may easily convert any of your application's classes into a facade in realtime simply by prefixing the imported class name with \nFacades\n. For example, imagine your application contains a class like the following:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nServices\n;\n\n\n\nclass\n \nPaymentGateway\n\n\n{\n\n    \nprotected\n \n$tax\n;\n\n\n    \n/**\n\n\n     * Create a new payment gateway instance.\n\n\n     *\n\n\n     * @param  TaxCalculator  $tax\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nTaxCalculator\n \n$tax\n)\n\n    \n{\n\n        \n$this\n-\ntax\n \n=\n \n$tax\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Pay the given amount.\n\n\n     *\n\n\n     * @param  int  $amount\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \npay\n(\n$amount\n)\n\n    \n{\n\n        \n// Pay an amount...\n\n    \n}\n\n\n}\n\n\n\n\n\n\nYou may easily use this class as a facade like so:\n\n\nuse\n \nFacades\n\\\n \n{\n\n    \nApp\\Services\\PaymentGateway\n\n\n}\n;\n\n\n\nRoute\n::\nget\n(\n/pay/{amount}\n,\n \nfunction\n \n($\namount\n)\n \n{\n\n    \nPaymentGateway\n:\n:\npay\n(\n$\namount\n);\n\n\n}\n);\n\n\n\n\n\n\nOf course, if you leverage a realtime facade in this way, you may easily write a test for the interaction using Laravel's \nfacade mocking capabilities\n:\n\n\nPaymentGateway\n::\nshouldReceive\n(\npay\n)\n-\nwith\n(\n100\n);\n\n\n\n\n\n\nCustom Pivot Table Models\n\n\nIn Laravel 5.3, all \"pivot\" table models for \nbelongsToMany\n relationships used the same built-in \nPivot\n model instance. In Laravel 5.4, you may define custom models for your pivot tables. If you would like to define a custom model to represent the intermediate table of your relationship, use the \nusing\n method when defining the relationship:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nRole\n \nextends\n \nModel\n\n\n{\n\n    \n/**\n\n\n     * The users that belong to the role.\n\n\n     */\n\n    \npublic\n \nfunction\n \nusers\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nbelongsToMany\n(\nApp\\User\n)\n-\nusing\n(\nApp\\UserRole\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nImproved Redis Cluster Support\n\n\nPreviously, it was not possible to define Redis connections to single hosts and to clusters in the same application. In Laravel 5.4, you may now define Redis connections to multiple single hosts and multiple clusters within the same application. For more information on Redis in Laravel, please consult the full \nRedis documentation\n.\n\n\n\n\nMigration Default String Length\n\n\nLaravel 5.4 uses the \nutf8mb4\n character set by default, which includes support for storing \"emojis\" in the database. If you are upgrading your application from Laravel 5.3, you are not required to switch to this character set.\n\n\nIf you choose to switch to this character set manually and are running a version of MySQL older than the 5.7.7 release, you may need to manually configure the default string length generated by migrations. You may configure this by calling the \nSchema::defaultStringLength\n method within your \nAppServiceProvider\n:\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nSchema\n;\n\n\n\n/**\n\n\n * Bootstrap any application services.\n\n\n *\n\n\n * @return void\n\n\n */\n\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n    \nSchema\n:\n:\ndefaultStringLength\n(\n191\n);\n\n\n}\n\n\n\n\n\n\n\n\nLaravel 5.3\n\n\nLaravel 5.3 continues the improvements made in Laravel 5.2 by adding a driver based \nnotification system\n, robust realtime support via \nLaravel Echo\n, painless OAuth2 servers via \nLaravel Passport\n, full-text model searching via \nLaravel Scout\n, Webpack support in Laravel Elixir, \"mailable\" objects, explicit separation of \nweb\n and \napi\n routes, Closure based console commands, convenient helpers for storing uploaded files, support for POPO and single-action controllers, improved default frontend scaffolding, and more.\n\n\nNotifications\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nLaravel Notifications provide a simple, expressive API for sending notifications across a variety of delivery channels such as email, Slack, SMS, and more. For example, you may define a notification that an invoice has been paid and deliver that notification via email and SMS. Then, you may send the notification using a single, simple method:\n\n\n$user-\nnotify(new InvoicePaid($invoice));\n\n\n\n\n\nThere is already a wide variety of \ncommunity written drivers\n for notifications, including support for iOS and Android notifications. To learn more about notifications, be sure to check out the \nfull notification documentation\n.\n\n\nWebSockets / Event Broadcasting\n\n\nWhile event broadcasting existed in previous versions of Laravel, the Laravel 5.3 release greatly improves this feature of the framework by adding channel-level authentication for private and presence WebSocket channels:\n\n\n/*\n\n\n * Authenticate the channel subscription...\n\n\n */\n\n\nBroadcast\n:\n:\nchannel\n(\norders.*\n,\n \nfunction\n \n(\n$\nuser\n,\n \n$\norderId\n)\n \n{\n\n\n    \nreturn\n \n$\nuser\n-\nplacedOrder\n(\n$\norderId\n)\n;\n\n\n}\n)\n;\n\n\n\n\n\n\nLaravel Echo, a new JavaScript package installable via NPM, has also been released to provide a simple, beautiful API for subscribing to channels and listening for your server-side events in your client-side JavaScript application. Echo includes support for \nPusher\n and \nSocket.io\n:\n\n\nEcho.channel(\norders.\n + orderId)\n    .listen(\nShippingStatusUpdated\n, (e) =\n {\n        console.log(e.description);\n    });\n\n\n\n\n\nIn addition to subscribing to traditional channels, Laravel Echo also makes it a breeze to subscribe to presence channels which provide information about who is listening on a given channel:\n\n\nEcho.join(\nchat.\n + roomId)\n    .here((users) =\n {\n        //\n    })\n    .joining((user) =\n {\n        console.log(user.name);\n    })\n    .leaving((user) =\n {\n        console.log(user.name);\n    });\n\n\n\n\n\nTo learn more about Echo and event broadcasting, check out the \nfull documentation\n.\n\n\nLaravel Passport (OAuth2 Server)\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nLaravel 5.3 makes API authentication a breeze using \nLaravel Passport\n, which provides a full OAuth2 server implementation for your Laravel application in a matter of minutes. Passport is built on top of the \nLeague OAuth2 server\n that is maintained by Alex Bilbie.\n\n\nPassport makes it painless to issue access tokens via OAuth2 authorization codes. You may also allow your users to create \"personal access tokens\" via your web UI. To get you started quickly, Passport includes \nVue components\n that can serve as a starting point for your OAuth2 dashboard, allowing users to create clients, revoke access tokens, and more:\n\n\npassport-clients\n/passport-clients\n\n\npassport-authorized-clients\n/passport-authorized-clients\n\n\npassport-personal-access-tokens\n/passport-personal-access-tokens\n\n\n\n\n\n\nIf you do not want to use the Vue components, you are welcome to provide your own frontend dashboard for managing clients and access tokens. Passport exposes a simple JSON API that you may use with any JavaScript framework you choose.\n\n\nOf course, Passport also makes it simple to define access token scopes that may be requested by application's consuming your API:\n\n\nPassport::tokensCan([\n    \nplace-orders\n =\n \nPlace new orders\n,\n    \ncheck-status\n =\n \nCheck order status\n,\n]);\n\n\n\n\n\nIn addition, Passport includes helpful middleware for verifying that an access token authenticated request contains the necessary token scopes:\n\n\nRoute\n::\nget\n(\n/orders/{order}/status\n,\n \nfunction\n \n(\nOrder\n \n$\norder\n)\n \n{\n\n    \n//\n \nAccess\n \ntoken\n \nhas\n \ncheck-status\n \nscope...\n\n\n}\n)\n-\nmiddleware\n(\nscope:check-status\n);\n\n\n\n\n\n\nLastly, Passport includes support for consuming your own API from your JavaScript application without worrying about passing access tokens. Passport achieves this through encrypted JWT cookies and synchronized CSRF tokens, allowing you to focus on what matters: your application. For more information on Passport, be sure to check out its \nfull documentation\n.\n\n\nSearch (Laravel Scout)\n\n\nLaravel Scout provides a simple, driver based solution for adding full-text search to your \nEloquent models\n. Using model observers, Scout will automatically keep your search indexes in sync with your Eloquent records. Currently, Scout ships with an \nAlgolia\n driver; however, writing custom drivers is simple and you are free to extend Scout with your own search implementations.\n\n\nMaking models searchable is as simple as adding a \nSearchable\n trait to the model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nLaravel\n\\\nScout\n\\\nSearchable\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nPost\n \nextends\n \nModel\n\n\n{\n\n    \nuse\n \nSearchable\n;\n\n\n}\n\n\n\n\n\n\nOnce the trait has been added to your model, its information will be kept in sync with your search indexes by simply saving the model:\n\n\n$order = new Order;\n\n// ...\n\n$order-\nsave();\n\n\n\n\n\nOnce your models have been indexed, its a breeze to perform full-text searches across all of your models. You may even paginate your search results:\n\n\nreturn\n \nOrder\n::\nsearch\n(\nStar Trek\n)\n-\nget\n();\n\n\n\nreturn\n \nOrder\n::\nsearch\n(\nStar Trek\n)\n-\nwhere\n(\nuser_id\n,\n \n1\n)\n-\npaginate\n();\n\n\n\n\n\n\nOf course, Scout has many more features which are covered in the \nfull documentation\n.\n\n\nMailable Objects\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nLaravel 5.3 ships with support for mailable objects. These objects allow you to represent your email messages as a simple objects instead of customizing mail messages within Closures. For example, you may define a simple mailable object for a \"welcome\" email:\n\n\nclass\n \nWelcomeMessage\n \nextends\n \nMailable\n\n\n{\n\n    \nuse\n \nQueueable\n,\n \nSerializesModels\n;\n\n\n    \n/**\n\n\n     * Build the message.\n\n\n     *\n\n\n     * @return $this\n\n\n     */\n\n    \npublic\n \nfunction\n \nbuild\n()\n\n    \n{\n\n        \nreturn\n \n$this\n-\nview\n(\nemails.welcome\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOnce the mailable object has been defined, you can send it to a user using a simple, expressive API. Mailable objects are great for discovering the intent of your messages while scanning your code:\n\n\nMail\n::\nto\n($\nuser\n)\n-\nsend\n(\nnew\n \nWelcomeMessage\n);\n\n\n\n\n\n\nOf course, you may also mark mailable objects as \"queueable\" so that they will be sent in the background by your queue workers:\n\n\nclass\n \nWelcomeMessage\n \nextends\n \nMailable\n \nimplements\n \nShouldQueue\n\n\n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\nFor more information on mailable objects, be sure to check out the \nmail documentation\n.\n\n\nStoring Uploaded Files\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nIn web applications, one of the most common use-cases for storing files is storing user uploaded files such as profile pictures, photos, and documents. Laravel 5.3 makes it very easy to store uploaded files using the new \nstore\n method on an uploaded file instance. Simply call the \nstore\n method with the path at which you wish to store the uploaded file:\n\n\n/**\n\n\n * Update the avatar for the user.\n\n\n *\n\n\n * @param  Request  $request\n\n\n * @return Response\n\n\n */\n\npublic\n \nfunction\n \nupdate\n(\nRequest\n \n$\nrequest\n)\n\n\n{\n\n\n    \n$\npath\n \n=\n \n$\nrequest\n-\nfile\n(\navatar\n)-\nstore\n(\navatars\n,\n \ns3\n)\n;\n\n\n\n    \nreturn\n \n$\npath\n;\n\n\n}\n\n\n\n\n\n\nFor more information on storing uploaded files, check out the \nfull documentation\n.\n\n\nWebpack \n Laravel Elixir\n\n\nAlong with Laravel 5.3, Laravel Elixir 6.0 has been released with baked-in support for the Webpack and Rollup JavaScript module bundlers. By default, the Laravel 5.3 \ngulpfile.js\n file now uses Webpack to compile your JavaScript. The \nfull Laravel Elixir documentation\n contains more information on both of these bundlers:\n\n\nelixir(mix =\n {\n    mix.sass(\napp.scss\n)\n       .webpack(\napp.js\n);\n});\n\n\n\n\n\nFrontend Structure\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nLaravel 5.3 ships with a more modern frontend structure. This primarily affects the \nmake:auth\n authentication scaffolding. Instead of loading frontend assets from a CDN, dependencies are specified in the default \npackage.json\n file.\n\n\nIn addition, support for single file \nVue components\n is now included out of the box. A sample \nExample.vue\n component is included in the \nresources/assets/js/components\n directory. In addition, the new \nresources/assets/js/app.js\n file bootstraps and configures your JavaScript libraries and, if applicable, Vue components.\n\n\nThis structure provides more guidance on how to begin developing modern, robust JavaScript applications, without requiring your application to use any given JavaScript or CSS framework. For more information on getting started with modern Laravel frontend development, check out the new \nintroductory frontend documentation\n.\n\n\nRoutes Files\n\n\nBy default, fresh Laravel 5.3 applications contain two HTTP route files in a new top-level \nroutes\n directory. The \nweb\n and \napi\n route files provide more explicit guidance in how to split the routes for your web interface and your API. The routes in the \napi\n route file are automatically assigned the \napi\n prefix by the \nRouteServiceProvider\n.\n\n\nClosure Console Commands\n\n\nIn addition to being defined as command classes, Artisan commands may now be defined as simple Closures in the \ncommands\n method of your \napp/Console/Kernel.php\n file. In fresh Laravel 5.3 applications, the \ncommands\n method loads a \nroutes/console.php\n file which allows you to define your Console commands as route-like, Closure based entry points into your application:\n\n\nArtisan::command(\nbuild {project}\n, function ($project) {\n    $this-\ninfo(\nBuilding project...\n);\n});\n\n\n\n\n\nFor more information on Closure commands, check out the \nfull Artisan documentation\n.\n\n\nThe \n$loop\n Variable\n\n\n\n\n{video} There is a free \nvideo tutorial\n for this feature available on Laracasts.\n\n\n\n\nWhen looping within a Blade template, a \n$loop\n variable will be available inside of your loop. This variable provides access to some useful bits of information such as the current loop index and whether this is the first or last iteration through the loop:\n\n\n@\nforeach\n \n(\n$\nusers\n \nas\n \n$\nuser\n)\n\n    \n@\nif\n \n(\n$\nloop\n-\nfirst\n)\n\n        \nThis\n \nis\n \nthe\n \nfirst\n \niteration\n.\n\n    \n@\nendif\n\n\n    \n@\nif\n \n(\n$\nloop\n-\nlast\n)\n\n        \nThis\n \nis\n \nthe\n \nlast\n \niteration\n.\n\n    \n@\nendif\n\n\n    \np\nThis\n \nis\n \nuser\n \n{{\n \n$\nuser\n-\nid\n \n}}\n/\np\n\n\n@\nendforeach\n\n\n\n\n\n\nFor more information, consult the \nfull Blade documentation\n.\n\n\n\n\nLaravel 5.2\n\n\nLaravel 5.2 continues the improvements made in Laravel 5.1 by adding multiple authentication driver support, implicit model binding, simplified Eloquent global scopes, opt-in authentication scaffolding, middleware groups, rate limiting middleware, array validation improvements, and more.\n\n\nAuthentication Drivers / \"Multi-Auth\"\n\n\nIn previous versions of Laravel, only the default, session-based authentication driver was supported out of the box, and you could not have more than one authenticatable model instance per application.\n\n\nHowever, in Laravel 5.2, you may define additional authentication drivers as well define multiple authenticatable models or user tables, and control their authentication process separately from each other. For example, if your application has one database table for \"admin\" users and one database table for \"student\" users, you may now use the \nAuth\n methods to authenticate against each of these tables separately.\n\n\nAuthentication Scaffolding\n\n\nLaravel already makes it easy to handle authentication on the back-end; however, Laravel 5.2 provides a convenient, lightning-fast way to scaffold the authentication views for your front-end. Simply execute the \nmake:auth\n command on your terminal:\n\n\nphp artisan make:auth\n\n\n\n\n\nThis command will generate plain, Bootstrap compatible views for user login, registration, and password reset. The command will also update your routes file with the appropriate routes.\n\n\n\n\n{note} This feature is only meant to be used on new applications, not during application upgrades.\n\n\n\n\nImplicit Model Binding\n\n\nImplicit model binding makes it painless to inject relevant models directly into your routes and controllers. For example, assume you have a route defined like the following:\n\n\nuse App\\User;\n\nRoute::get(\n/user/{user}\n, function (User $user) {\n    return $user;\n});\n\n\n\n\n\nIn Laravel 5.1, you would typically need to use the \nRoute::model\n method to instruct Laravel to inject the \nApp\\User\n instance that matches the \n{user}\n parameter in your route definition. However, in Laravel 5.2, the framework will \nautomatically\n inject this model based on the URI segment, allowing you to quickly gain access to the model instances you need.\n\n\nLaravel will automatically inject the model when the route parameter segment (\n{user}\n) matches the route Closure or controller method's corresponding variable name (\n$user\n) and the variable is type-hinting an Eloquent model class.\n\n\nMiddleware Groups\n\n\nMiddleware groups allow you to group several route middleware under a single, convenient key, allowing you to assign several middleware to a route at once. For example, this can be useful when building a web UI and an API within the same application. You may group the session and CSRF routes into a \nweb\n group, and perhaps the rate limiter in the \napi\n group.\n\n\nIn fact, the default Laravel 5.2 application structure takes exactly this approach. For example, in the default \nApp\\Http\\Kernel.php\n file you will find the following:\n\n\n/**\n\n\n * The application\ns route middleware groups.\n\n\n *\n\n\n * @var array\n\n\n */\n\nprotected\n \n$\nmiddlewareGroups\n \n=\n \n[\n\n\n    \nweb\n \n=\n \n[\n\n\n        \n\\\nApp\n\\\nHttp\n\\\nMiddleware\n\\\nEncryptCookies\n:\n:\nclass\n,\n\n\n        \n\\\nIlluminate\n\\\nCookie\n\\\nMiddleware\n\\\nAddQueuedCookiesToResponse\n:\n:\nclass\n,\n\n\n        \n\\\nIlluminate\n\\\nSession\n\\\nMiddleware\n\\\nStartSession\n:\n:\nclass\n,\n\n\n        \n\\\nIlluminate\n\\\nView\n\\\nMiddleware\n\\\nShareErrorsFromSession\n:\n:\nclass\n,\n\n\n        \n\\\nApp\n\\\nHttp\n\\\nMiddleware\n\\\nVerifyCsrfToken\n:\n:\nclass\n,\n\n\n    \n]\n,\n\n\n\n    \napi\n \n=\n \n[\n\n\n        \nthrottle:60,1\n,\n\n\n    \n]\n,\n\n\n];\n\n\n\n\n\n\nThen, the \nweb\n group may be assigned to routes like so:\n\n\nRoute::group([\nmiddleware\n =\n [\nweb\n]], function () {\n    //\n});\n\n\n\n\n\nHowever, keep in mind the \nweb\n middleware group is \nalready\n applied to your routes by default since the \nRouteServiceProvider\n includes it in the default middleware group.\n\n\nRate Limiting\n\n\nA new rate limiter middleware is now included with the framework, allowing you to easily limit the number of requests that a given IP address can make to a route over a specified number of minutes. For example, to limit a route to 60 requests every minute from a single IP address, you may do the following:\n\n\nRoute::get(\n/api/users\n, [\nmiddleware\n =\n \nthrottle:60,1\n, function () {\n    //\n}]);\n\n\n\n\n\nArray Validation\n\n\nValidating array form input fields is much easier in Laravel 5.2. For example, to validate that each e-mail in a given array input field is unique, you may do the following:\n\n\n$validator = Validator::make($request-\nall(), [\n    \nperson.*.email\n =\n \nemail|unique:users\n\n]);\n\n\n\n\n\nLikewise, you may use the \n*\n character when specifying your validation messages in your language files, making it a breeze to use a single validation message for array based fields:\n\n\ncustom\n =\n [\n    \nperson.*.email\n =\n [\n        \nunique\n =\n \nEach person must have a unique e-mail address\n,\n    ]\n],\n\n\n\n\n\nBail Validation Rule\n\n\nA new \nbail\n validation rule has been added, which instructs the validator to stop validating after the first validation failure for a given rule. For example, you may now prevent the validator from running a \nunique\n check if an attribute fails an \ninteger\n check:\n\n\n$this-\nvalidate($request, [\n    \nuser_id\n =\n \nbail|integer|unique:users\n\n]);\n\n\n\n\n\nEloquent Global Scope Improvements\n\n\nIn previous versions of Laravel, global Eloquent scopes were complicated and error-prone to implement; however, in Laravel 5.2, global query scopes only require you to implement a single, simple method: \napply\n.\n\n\nFor more information on writing global scopes, check out the full \nEloquent documentation\n.\n\n\n\n\nLaravel 5.1.11\n\n\nLaravel 5.1.11 introduces \nauthorization\n support out of the box! Conveniently organize your application's authorization logic using simple callbacks or policy classes, and authorize actions using simple, expressive methods.\n\n\nFor more information, please refer to the \nauthorization documentation\n.\n\n\n\n\nLaravel 5.1.4\n\n\nLaravel 5.1.4 introduces simple login throttling to the framework. Consult the \nauthentication documentation\n for more information.\n\n\n\n\nLaravel 5.1\n\n\nLaravel 5.1 continues the improvements made in Laravel 5.0 by adopting PSR-2 and adding event broadcasting, middleware parameters, Artisan improvements, and more.\n\n\nPHP 5.5.9+\n\n\nSince PHP 5.4 will enter \"end of life\" in September and will no longer receive security updates from the PHP development team, Laravel 5.1 requires PHP 5.5.9 or greater. PHP 5.5.9 allows compatibility with the latest versions of popular PHP libraries such as Guzzle and the AWS SDK.\n\n\nLTS\n\n\nLaravel 5.1 is the first release of Laravel to receive \nlong term support\n. Laravel 5.1 will receive bug fixes for 2 years and security fixes for 3 years. This support window is the largest ever provided for Laravel and provides stability and peace of mind for larger, enterprise clients and customers.\n\n\nPSR-2\n\n\nThe \nPSR-2 coding style guide\n has been adopted as the default style guide for the Laravel framework. Additionally, all generators have been updated to generate PSR-2 compatible syntax.\n\n\nDocumentation\n\n\nEvery page of the Laravel documentation has been meticulously reviewed and dramatically improved. All code examples have also been reviewed and expanded to provide more relevance and context.\n\n\nEvent Broadcasting\n\n\nIn many modern web applications, web sockets are used to implement realtime, live-updating user interfaces. When some data is updated on the server, a message is typically sent over a websocket connection to be handled by the client.\n\n\nTo assist you in building these types of applications, Laravel makes it easy to \"broadcast\" your events over a websocket connection. Broadcasting your Laravel events allows you to share the same event names between your server-side code and your client-side JavaScript framework.\n\n\nTo learn more about event broadcasting, check out the \nevent documentation\n.\n\n\nMiddleware Parameters\n\n\nMiddleware can now receive additional custom parameters. For example, if your application needs to verify that the authenticated user has a given \"role\" before performing a given action, you could create a \nRoleMiddleware\n that receives a role name as an additional argument:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nMiddleware\n;\n\n\n\nuse\n \nClosure\n;\n\n\n\nclass\n \nRoleMiddleware\n\n\n{\n\n    \n/**\n\n\n     * Run the request filter.\n\n\n     *\n\n\n     * @param  \\Illuminate\\Http\\Request  $request\n\n\n     * @param  \\Closure  $next\n\n\n     * @param  string  $role\n\n\n     * @return mixed\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandle\n(\n$request\n,\n \nClosure\n \n$next\n,\n \n$role\n)\n\n    \n{\n\n        \nif\n \n(\n!\n \n$request\n-\nuser\n()\n-\nhasRole\n(\n$role\n))\n \n{\n\n            \n// Redirect...\n\n        \n}\n\n\n        \nreturn\n \n$next\n(\n$request\n);\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\nMiddleware parameters may be specified when defining the route by separating the middleware name and parameters with a \n:\n. Multiple parameters should be delimited by commas:\n\n\nRoute::put(\npost/{id}\n, [\nmiddleware\n =\n \nrole:editor\n, function ($id) {\n    //\n}]);\n\n\n\n\n\nFor more information on middleware, check out the \nmiddleware documentation\n.\n\n\nTesting Overhaul\n\n\nThe built-in testing capabilities of Laravel have been dramatically improved. A variety of new methods provide a fluent, expressive interface for interacting with your application and examining its responses. For example, check out the following test:\n\n\npublic function testNewUserRegistration()\n{\n    $this-\nvisit(\n/register\n)\n         -\ntype(\nTaylor\n, \nname\n)\n         -\ncheck(\nterms\n)\n         -\npress(\nRegister\n)\n         -\nseePageIs(\n/dashboard\n);\n}\n\n\n\n\n\nFor more information on testing, check out the \ntesting documentation\n.\n\n\nModel Factories\n\n\nLaravel now ships with an easy way to create stub Eloquent models using \nmodel factories\n. Model factories allow you to easily define a set of \"default\" attributes for your Eloquent model, and then generate test model instances for your tests or database seeds. Model factories also take advantage of the powerful \nFaker\n PHP library for generating random attribute data:\n\n\n$factory-\ndefine(App\\User::class, function ($faker) {\n    return [\n        \nname\n =\n $faker-\nname,\n        \nemail\n =\n $faker-\nemail,\n        \npassword\n =\n str_random(10),\n        \nremember_token\n =\n str_random(10),\n    ];\n});\n\n\n\n\n\nFor more information on model factories, check out \nthe documentation\n.\n\n\nArtisan Improvements\n\n\nArtisan commands may now be defined using a simple, route-like \"signature\", which provides an extremely simple interface for defining command line arguments and options. For example, you may define a simple command and its options like so:\n\n\n/**\n\n\n * The name and signature of the console command.\n\n\n *\n\n\n * @var string\n\n\n */\n\n\nprotected\n \n$\nsignature\n \n=\n \nemail:send {user} {--force}\n;\n\n\n\n\n\n\nFor more information on defining Artisan commands, consult the \nArtisan documentation\n.\n\n\nFolder Structure\n\n\nTo better express intent, the \napp/Commands\n directory has been renamed to \napp/Jobs\n. Additionally, the \napp/Handlers\n directory has been consolidated into a single \napp/Listeners\n directory which simply contains event listeners. However, this is not a breaking change and you are not required to update to the new folder structure to use Laravel 5.1.\n\n\nEncryption\n\n\nIn previous versions of Laravel, encryption was handled by the \nmcrypt\n PHP extension. However, beginning in Laravel 5.1, encryption is handled by the \nopenssl\n extension, which is more actively maintained.\n\n\n\n\nLaravel 5.0\n\n\nLaravel 5.0 introduces a fresh application structure to the default Laravel project. This new structure serves as a better foundation for building a robust application in Laravel, as well as embraces new auto-loading standards (PSR-4) throughout the application. First, let's examine some of the major changes:\n\n\nNew Folder Structure\n\n\nThe old \napp/models\n directory has been entirely removed. Instead, all of your code lives directly within the \napp\n folder, and, by default, is organized to the \nApp\n namespace. This default namespace can be quickly changed using the new \napp:name\n Artisan command.\n\n\nControllers, middleware, and requests (a new type of class in Laravel 5.0) are now grouped under the \napp/Http\n directory, as they are all classes related to the HTTP transport layer of your application. Instead of a single, flat file of route filters, all middleware are now broken into their own class files.\n\n\nA new \napp/Providers\n directory replaces the \napp/start\n files from previous versions of Laravel 4.x. These service providers provide various bootstrapping functions to your application, such as error handling, logging, route loading, and more. Of course, you are free to create additional service providers for your application.\n\n\nApplication language files and views have been moved to the \nresources\n directory.\n\n\nContracts\n\n\nAll major Laravel components implement interfaces which are located in the \nilluminate/contracts\n repository. This repository has no external dependencies. Having a convenient, centrally located set of interfaces you may use for decoupling and dependency injection will serve as an easy alternative option to Laravel Facades.\n\n\nFor more information on contracts, consult the \nfull documentation\n.\n\n\nRoute Cache\n\n\nIf your application is made up entirely of controller routes, you may utilize the new \nroute:cache\n Artisan command to drastically speed up the registration of your routes. This is primarily useful on applications with 100+ routes and will \ndrastically\n speed up this portion of your application.\n\n\nRoute Middleware\n\n\nIn addition to Laravel 4 style route \"filters\", Laravel 5 now supports HTTP middleware, and the included authentication and CSRF \"filters\" have been converted to middleware. Middleware provides a single, consistent interface to replace all types of filters, allowing you to easily inspect, and even reject, requests before they enter your application.\n\n\nFor more information on middleware, check out \nthe documentation\n.\n\n\nController Method Injection\n\n\nIn addition to the existing constructor injection, you may now type-hint dependencies on controller methods. The \nservice container\n will automatically inject the dependencies, even if the route contains other parameters:\n\n\npublic function createPost(Request $request, PostRepository $posts)\n{\n    //\n}\n\n\n\n\n\nAuthentication Scaffolding\n\n\nUser registration, authentication, and password reset controllers are now included out of the box, as well as simple corresponding views, which are located at \nresources/views/auth\n. In addition, a \"users\" table migration has been included with the framework. Including these simple resources allows rapid development of application ideas without bogging down on authentication boilerplate. The authentication views may be accessed on the \nauth/login\n and \nauth/register\n routes. The \nApp\\Services\\Auth\\Registrar\n service is responsible for user validation and creation.\n\n\nEvent Objects\n\n\nYou may now define events as objects instead of simply using strings. For example, check out the following event:\n\n\n?\nphp\n\n\n\nclass\n \nPodcastWasPurchased\n\n\n{\n\n    \npublic\n \n$podcast\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n(\nPodcast\n \n$podcast\n)\n\n    \n{\n\n        \n$this\n-\npodcast\n \n=\n \n$podcast\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe event may be dispatched like normal:\n\n\nEvent\n::\nfire\n(\nnew\n \nPodcastWasPurchased\n($\npodcast\n));\n\n\n\n\n\n\nOf course, your event handler will receive the event object instead of a list of data:\n\n\n?\nphp\n\n\n\nclass\n \nReportPodcastPurchase\n\n\n{\n\n    \npublic\n \nfunction\n \nhandle\n(\nPodcastWasPurchased\n \n$event\n)\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nFor more information on working with events, check out the \nfull documentation\n.\n\n\nCommands / Queueing\n\n\nIn addition to the queue job format supported in Laravel 4, Laravel 5 allows you to represent your queued jobs as simple command objects. These commands live in the \napp/Commands\n directory. Here's a sample command:\n\n\n?\nphp\n\n\n\nclass\n \nPurchasePodcast\n \nextends\n \nCommand\n \nimplements\n \nSelfHandling\n,\n \nShouldBeQueued\n\n\n{\n\n    \nuse\n \nSerializesModels\n;\n\n\n    \nprotected\n \n$user\n,\n \n$podcast\n;\n\n\n    \n/**\n\n\n     * Create a new command instance.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nUser\n \n$user\n,\n \nPodcast\n \n$podcast\n)\n\n    \n{\n\n        \n$this\n-\nuser\n \n=\n \n$user\n;\n\n        \n$this\n-\npodcast\n \n=\n \n$podcast\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Execute the command.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nhandle\n()\n\n    \n{\n\n        \n// Handle the logic to purchase the podcast...\n\n\n        \nevent\n(\nnew\n \nPodcastWasPurchased\n(\n$this\n-\nuser\n,\n \n$this\n-\npodcast\n));\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe base Laravel controller utilizes the new \nDispatchesCommands\n trait, allowing you to easily dispatch your commands for execution:\n\n\n$this-\ndispatch(new PurchasePodcastCommand($user, $podcast));\n\n\n\n\n\nOf course, you may also use commands for tasks that are executed synchronously (are not queued). In fact, using commands is a great way to encapsulate complex tasks your application needs to perform. For more information, check out the \ncommand bus\n documentation.\n\n\nDatabase Queue\n\n\nA \ndatabase\n queue driver is now included in Laravel, providing a simple, local queue driver that requires no extra package installation beyond your database software.\n\n\nLaravel Scheduler\n\n\nIn the past, developers have generated a Cron entry for each console command they wished to schedule. However, this is a headache. Your console schedule is no longer in source control, and you must SSH into your server to add the Cron entries. Let's make our lives easier. The Laravel command scheduler allows you to fluently and expressively define your command schedule within Laravel itself, and only a single Cron entry is needed on your server.\n\n\nIt looks like this:\n\n\n$\nschedule-\ncommand\n(\nartisan:command\n)\n-\ndailyAt\n(\n15:00\n);\n\n\n\n\n\n\nOf course, check out the \nfull documentation\n to learn all about the scheduler!\n\n\nTinker / Psysh\n\n\nThe \nphp artisan tinker\n command now utilizes \nPsysh\n by Justin Hileman, a more robust REPL for PHP. If you liked Boris in Laravel 4, you're going to love Psysh. Even better, it works on Windows! To get started, just try:\n\n\nphp artisan tinker\n\n\n\n\n\nDotEnv\n\n\nInstead of a variety of confusing, nested environment configuration directories, Laravel 5 now utilizes \nDotEnv\n by Vance Lucas. This library provides a super simple way to manage your environment configuration, and makes environment detection in Laravel 5 a breeze. For more details, check out the full \nconfiguration documentation\n.\n\n\nLaravel Elixir\n\n\nLaravel Elixir, by Jeffrey Way, provides a fluent, expressive interface to compiling and concatenating your assets. If you've ever been intimidated by learning Grunt or Gulp, fear no more. Elixir makes it a cinch to get started using Gulp to compile your Less, Sass, and CoffeeScript. It can even run your tests for you!\n\n\nFor more information on Elixir, check out the \nfull documentation\n.\n\n\nLaravel Socialite\n\n\nLaravel Socialite is an optional, Laravel 5.0+ compatible package that provides totally painless authentication with OAuth providers. Currently, Socialite supports Facebook, Twitter, Google, and GitHub. Here's what it looks like:\n\n\npublic\n \nfunction\n \nredirectForAuth\n()\n\n\n{\n\n    \nreturn\n \nSocialize\n:\n:\nwith\n(\ntwitter\n)\n-\nredirect\n();\n\n\n}\n\n\n\npublic\n \nfunction\n \ngetUserFromProvider\n()\n\n\n{\n\n    \n$user\n \n=\n \nSocialize\n:\n:\nwith\n(\ntwitter\n)\n-\nuser\n();\n\n\n}\n\n\n\n\n\n\nNo more spending hours writing OAuth authentication flows. Get started in minutes! The \nfull documentation\n has all the details.\n\n\nFlysystem Integration\n\n\nLaravel now includes the powerful \nFlysystem\n filesystem abstraction library, providing pain free integration with local, Amazon S3, and Rackspace cloud storage - all with one, unified and elegant API! Storing a file in Amazon S3 is now as simple as:\n\n\nStorage\n::\nput\n(\nfile.txt\n,\n \ncontents\n);\n\n\n\n\n\n\nFor more information on the Laravel Flysystem integration, consult the \nfull documentation\n.\n\n\nForm Requests\n\n\nLaravel 5.0 introduces \nform requests\n, which extend the \nIlluminate\\Foundation\\Http\\FormRequest\n class. These request objects can be combined with controller method injection to provide a boiler-plate free method of validating user input. Let's dig in and look at a sample \nFormRequest\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nRequests\n;\n\n\n\nclass\n \nRegisterRequest\n \nextends\n \nFormRequest\n\n\n{\n\n    \npublic\n \nfunction\n \nrules\n()\n\n    \n{\n\n        \nreturn\n \n[\n\n            \nemail\n \n=\n \nrequired|email|unique:users\n,\n\n            \npassword\n \n=\n \nrequired|confirmed|min:8\n,\n\n        \n];\n\n    \n}\n\n\n    \npublic\n \nfunction\n \nauthorize\n()\n\n    \n{\n\n        \nreturn\n \ntrue\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOnce the class has been defined, we can type-hint it on our controller action:\n\n\npublic function register(RegisterRequest $request)\n{\n    var_dump($request-\ninput());\n}\n\n\n\n\n\nWhen the Laravel service container identifies that the class it is injecting is a \nFormRequest\n instance, the request will \nautomatically be validated\n. This means that if your controller action is called, you can safely assume the HTTP request input has been validated according to the rules you specified in your form request class. Even more, if the request is invalid, an HTTP redirect, which you may customize, will automatically be issued, and the error messages will be either flashed to the session or converted to JSON. \nForm validation has never been more simple.\n For more information on \nFormRequest\n validation, check out the \ndocumentation\n.\n\n\nSimple Controller Request Validation\n\n\nThe Laravel 5 base controller now includes a \nValidatesRequests\n trait. This trait provides a simple \nvalidate\n method to validate incoming requests. If \nFormRequests\n are a little too much for your application, check this out:\n\n\npublic function createPost(Request $request)\n{\n    $this-\nvalidate($request, [\n        \ntitle\n =\n \nrequired|max:255\n,\n        \nbody\n =\n \nrequired\n,\n    ]);\n}\n\n\n\n\n\nIf the validation fails, an exception will be thrown and the proper HTTP response will automatically be sent back to the browser. The validation errors will even be flashed to the session! If the request was an AJAX request, Laravel even takes care of sending a JSON representation of the validation errors back to you.\n\n\nFor more information on this new method, check out \nthe documentation\n.\n\n\nNew Generators\n\n\nTo complement the new default application structure, new Artisan generator commands have been added to the framework. See \nphp artisan list\n for more details.\n\n\nConfiguration Cache\n\n\nYou may now cache all of your configuration in a single file using the \nconfig:cache\n command.\n\n\nSymfony VarDumper\n\n\nThe popular \ndd\n helper function, which dumps variable debug information, has been upgraded to use the amazing Symfony VarDumper. This provides color-coded output and even collapsing of arrays. Just try the following in your project:\n\n\ndd([1, 2, 3]);\n\n\n\n\n\n\n\nLaravel 4.2\n\n\nThe full change list for this release by running the \nphp artisan changes\n command from a 4.2 installation, or by \nviewing the change file on Github\n. These notes only cover the major enhancements and changes for the release.\n\n\n\n\n{note} During the 4.2 release cycle, many small bug fixes and enhancements were incorporated into the various Laravel 4.1 point releases. So, be sure to check the change list for Laravel 4.1 as well!\n\n\n\n\nPHP 5.4 Requirement\n\n\nLaravel 4.2 requires PHP 5.4 or greater. This upgraded PHP requirement allows us to use new PHP features such as traits to provide more expressive interfaces for tools like \nLaravel Cashier\n. PHP 5.4 also brings significant speed and performance improvements over PHP 5.3.\n\n\nLaravel Forge\n\n\nLaravel Forge, a new web based application, provides a simple way to create and manage PHP servers on the cloud of your choice, including Linode, DigitalOcean, Rackspace, and Amazon EC2. Supporting automated Nginx configuration, SSH key access, Cron job automation, server monitoring via NewRelic \n Papertrail, \"Push To Deploy\", Laravel queue worker configuration, and more, Forge provides the simplest and most affordable way to launch all of your Laravel applications.\n\n\nThe default Laravel 4.2 installation's \napp/config/database.php\n configuration file is now configured for Forge usage by default, allowing for more convenient deployment of fresh applications onto the platform.\n\n\nMore information about Laravel Forge can be found on the \nofficial Forge website\n.\n\n\nLaravel Homestead\n\n\nLaravel Homestead is an official Vagrant environment for developing robust Laravel and PHP applications. The vast majority of the boxes' provisioning needs are handled before the box is packaged for distribution, allowing the box to boot extremely quickly. Homestead includes Nginx 1.6, PHP 5.6, MySQL, Postgres, Redis, Memcached, Beanstalk, Node, Gulp, Grunt, \n Bower. Homestead includes a simple \nHomestead.yaml\n configuration file for managing multiple Laravel applications on a single box.\n\n\nThe default Laravel 4.2 installation now includes an \napp/config/local/database.php\n configuration file that is configured to use the Homestead database out of the box, making Laravel initial installation and configuration more convenient.\n\n\nThe official documentation has also been updated to include \nHomestead documentation\n.\n\n\nLaravel Cashier\n\n\nLaravel Cashier is a simple, expressive library for managing subscription billing with Stripe. With the introduction of Laravel 4.2, we are including Cashier documentation along with the main Laravel documentation, though installation of the component itself is still optional. This release of Cashier brings numerous bug fixes, multi-currency support, and compatibility with the latest Stripe API.\n\n\nDaemon Queue Workers\n\n\nThe Artisan \nqueue:work\n command now supports a \n--daemon\n option to start a worker in \"daemon mode\", meaning the worker will continue to process jobs without ever re-booting the framework. This results in a significant reduction in CPU usage at the cost of a slightly more complex application deployment process.\n\n\nMore information about daemon queue workers can be found in the \nqueue documentation\n.\n\n\nMail API Drivers\n\n\nLaravel 4.2 introduces new Mailgun and Mandrill API drivers for the \nMail\n functions. For many applications, this provides a faster and more reliable method of sending e-mails than the SMTP options. The new drivers utilize the Guzzle 4 HTTP library.\n\n\nSoft Deleting Traits\n\n\nA much cleaner architecture for \"soft deletes\" and other \"global scopes\" has been introduced via PHP 5.4 traits. This new architecture allows for the easier construction of similar global traits, and a cleaner separation of concerns within the framework itself.\n\n\nMore information on the new \nSoftDeletingTrait\n may be found in the \nEloquent documentation\n.\n\n\nConvenient Auth \n Remindable Traits\n\n\nThe default Laravel 4.2 installation now uses simple traits for including the needed properties for the authentication and password reminder user interfaces. This provides a much cleaner default \nUser\n model file out of the box.\n\n\n\"Simple Paginate\"\n\n\nA new \nsimplePaginate\n method was added to the query and Eloquent builder which allows for more efficient queries when using simple \"Next\" and \"Previous\" links in your pagination view.\n\n\nMigration Confirmation\n\n\nIn production, destructive migration operations will now ask for confirmation. Commands may be forced to run without any prompts using the \n--force\n command.", 
            "title": "Releases"
        }, 
        {
            "location": "/releases/#release-notes", 
            "text": "Support Policy  Laravel 5.4  Laravel 5.3  Laravel 5.2  Laravel 5.1.11  Laravel 5.1.4  Laravel 5.1  Laravel 5.0  Laravel 4.2", 
            "title": "Release Notes"
        }, 
        {
            "location": "/releases/#support-policy", 
            "text": "For LTS releases, such as Laravel 5.1, bug fixes are provided for 2 years and security fixes are provided for 3 years. These releases provide the longest window of support and maintenance. For general releases, bug fixes are provided for 6 months and security fixes are provided for 1 year.", 
            "title": "Support Policy"
        }, 
        {
            "location": "/releases/#laravel-54", 
            "text": "Laravel 5.4 continues the improvements made in Laravel 5.3 by adding support for  Markdown based emails and notifications , the  Laravel Dusk  browser automation and testing framework, Laravel Mix, Blade \"components\" and \"slots\", route model binding on broadcast channels, higher order messages for Collections, object-based Eloquent events, job-level \"retry\" and \"timeout\" settings, \"realtime\" facades, improved support for Redis Cluster, custom pivot table models, middleware for request input trimming and cleaning, and more. In addition, the entire codebase of the framework was reviewed and refactored for general cleanliness.   {tip} This documentation summarizes the most notable improvements to the framework; however, more thorough change logs are always available  on GitHub .", 
            "title": "Laravel 5.4"
        }, 
        {
            "location": "/releases/#markdown-mail-notifications", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   Markdown mailable messages allow you to take advantage of the pre-built templates and components of mail notifications in your mailables. Since the messages are written in Markdown, Laravel is able to render beautiful, responsive HTML templates for the messages while also automatically generating a plain-text counterpart. For example, a Markdown email might look something like the following:  @ component ( mail :: message )  # Order Shipped  Your   order   has   been   shipped !  @ component ( mail :: button ,   [ url   =   $ url ])  View   Order  @ endcomponent  Next   Steps :  -   Track   Your   Order   On   Our   Website  -   Pre - Sign   For   Delivery  Thanks , br  {{   config ( app . name )   }}  @ endcomponent   Using this simple Markdown template, Laravel is able to generate a responsive HTML email and plain-text counterpart:   To read more about Markdown mail and notifications, check out the full  mail  and  notification  documentation.   {tip} You may export all of the Markdown mail components to your own application for customization. To export the components, use the  vendor:publish  Artisan command to publish the  laravel-mail  asset tag.", 
            "title": "Markdown Mail &amp; Notifications"
        }, 
        {
            "location": "/releases/#laravel-dusk", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   Laravel Dusk provides an expressive, easy-to-use browser automation and testing API. By default, Dusk does not require you to install JDK or Selenium on your machine. Instead, Dusk uses a standalone  ChromeDriver  installation. However, you are free to utilize any other Selenium compatible driver you wish.  Since Dusk operates using a real browser, you are able to easily test and interact with your applications that heavily use JavaScript:  /**   * A basic browser test example.   *   * @return void   */ \npublic   function   testBasicExample ()  {       $ user   =   factory ( User : : class )- create ( [           email   =   taylor@laravel.com ,       ] ) ;       $ this - browse ( function   ( $ browser )   use   ( $ user )   {           $ browser - loginAs ( $ user )                   - visit ( /home )                   - press ( Create Playlist )                   - whenAvailable ( .playlist-modal ,   function   ( $ modal )   {                       $ modal - type ( name ,   My Playlist )                             - press ( Create ) ;                   } ) ;           $ browser - waitForText ( Playlist Created ) ;       } ) ;  }   For more information on Dusk, consult the full  Dusk documentation .", 
            "title": "Laravel Dusk"
        }, 
        {
            "location": "/releases/#laravel-mix", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   Laravel Mix is the spiritual successor of Laravel Elixir, and its entirely based on Webpack instead of Gulp. Laravel Mix provides a fluent API for defining Webpack build steps for your Laravel application using several common CSS and JavaScript pre-processors. Through simple method chaining, you can fluently define your asset pipeline. For example:  mix.js( resources/assets/js/app.js ,  public/js )\n   .sass( resources/assets/sass/app.scss ,  public/css );", 
            "title": "Laravel Mix"
        }, 
        {
            "location": "/releases/#blade-components-slots", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   Blade components and slots provide similar benefits to sections and layouts; however, some may find the mental model of components and slots easier to understand. First, let's imagine a reusable \"alert\" component we would like to reuse throughout our application:  !-- /resources/views/alert.blade.php --  div   class= alert alert-danger \n     {{   $ slot   }}  /div   The  {{ $slot }}  variable will contain the content we wish to inject into the component. Now, to construct this component, we can use the  @component  Blade directive:  @ component ( alert ) \n     strong Whoops ! / strong   Something   went   wrong !  @ endcomponent   Named slots allow you to provide multiple slots into a single component:  !-- /resources/views/alert.blade.php --  div   class= alert alert-danger \n     div   class= alert-title {{   $ title   }} /div \n\n     {{   $ slot   }}  /div   Named slots may be injected using the  @slot  directive. Any content is not within a  @slot  directive will be passed to the component in the  $slot  variable:  @ component ( alert ) \n     @ slot ( title ) \n         Forbidden \n     @ endslot \n\n     You   are   not   allowed   to   access   this   resource !  @ endcomponent   To read more about components and slots, consult the full  Blade documentation .", 
            "title": "Blade Components &amp; Slots"
        }, 
        {
            "location": "/releases/#broadcast-model-binding", 
            "text": "Just like HTTP routes, channel routes may now take advantage of implicit and explicit  route model binding . For example, instead of receiving the string or numeric order ID, you may request an actual  Order  model instance:  use App\\Order;\n\nBroadcast::channel( order.{order} , function ($user, Order $order) {\n    return $user- id === $order- user_id;\n});  To read more about broadcast model binding, consult the full  event broadcasting  documentation.", 
            "title": "Broadcast Model Binding"
        }, 
        {
            "location": "/releases/#collection-higher-order-messages", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   Collections now provide support for \"higher order messages\", which are short-cuts for performing common actions on collections. The collection methods that provide higher order messages are:  contains ,  each ,  every ,  filter ,  first ,  map ,  partition ,  reject ,  sortBy ,  sortByDesc , and  sum .  Each higher order message can be accessed as a dynamic property on a collection instance. For instance, let's use the  each  higher order message to call a method on each object within a collection:  $ users   =   User :: where ( votes ,   ,   500 ) - get ();  $ users- each- markAsVip ();   Likewise, we can use the  sum  higher order message to gather the total number of \"votes\" for a collection of users:  $ users   =   User :: where ( group ,   Development ) - get ();  return   $ users- sum- votes ;", 
            "title": "Collection Higher Order Messages"
        }, 
        {
            "location": "/releases/#object-based-eloquent-events", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   Eloquent event handlers may now be mapped to event objects. This provides a more intuitive way of handling Eloquent events and makes it easier to test the events. To get started, define an  $events  property on your Eloquent model that maps various points of the Eloquent model's lifecycle to your own  event classes :  ? php  namespace   App ;  use   App \\ Events \\ UserSaved ;  use   App \\ Events \\ UserDeleted ;  use   Illuminate \\ Notifications \\ Notifiable ;  use   Illuminate \\ Foundation \\ Auth \\ User   as   Authenticatable ;  class   User   extends   Authenticatable  { \n     use   Notifiable ; \n\n     /**       * The event map for the model.       *       * @var array       */ \n     protected   $events   =   [ \n         saved   =   UserSaved :: class , \n         deleted   =   UserDeleted :: class , \n     ];  }", 
            "title": "Object Based Eloquent Events"
        }, 
        {
            "location": "/releases/#job-level-retry-timeout", 
            "text": "Previously, queue job \"retry\" and \"timeout\" settings could only be configured globally for all jobs on the command line. However, in Laravel 5.4, these settings may be configured on a per-job basis by defining them directly on the job class:  ? php  namespace   App \\ Jobs ;  class   ProcessPodcast   implements   ShouldQueue  { \n     /**       * The number of times the job may be attempted.       *       * @var int       */ \n     public   $tries   =   5 ; \n\n     /**       * The number of seconds the job can run before timing out.       *       * @var int       */ \n     public   $timeout   =   120 ;  }   For more information about these settings, consult the full  queue documentation .", 
            "title": "Job Level Retry &amp; Timeout"
        }, 
        {
            "location": "/releases/#request-sanitization-middleware", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   Laravel 5.4 includes two new middleware in the default middleware stack:  TrimStrings  and  ConvertEmptyStringsToNull :  /**   * The application s global HTTP middleware stack.   *   * These middleware are run during every request to your application.   *   * @var array   */ \nprotected   $ middleware   =   [       \\ Illuminate \\ Foundation \\ Http \\ Middleware \\ CheckForMaintenanceMode : : class ,       \\ Illuminate \\ Foundation \\ Http \\ Middleware \\ ValidatePostSize : : class ,       \\ App \\ Http \\ Middleware \\ TrimStrings : : class ,       \\ Illuminate \\ Foundation \\ Http \\ Middleware \\ ConvertEmptyStringsToNull : : class ,  ];   These middleware will automatically trim request input values and convert any empty strings to  null . This helps you normalize the input for every request entering into your application and not have to worry about continually calling the  trim  function in every route and controller.", 
            "title": "Request Sanitization Middleware"
        }, 
        {
            "location": "/releases/#realtime-facades", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   Previously, only Laravel's own built-in services exposed  facades , which provide quick, terse access to their methods via the service container. However, in Laravel 5.4, you may easily convert any of your application's classes into a facade in realtime simply by prefixing the imported class name with  Facades . For example, imagine your application contains a class like the following:  ? php  namespace   App \\ Services ;  class   PaymentGateway  { \n     protected   $tax ; \n\n     /**       * Create a new payment gateway instance.       *       * @param  TaxCalculator  $tax       * @return void       */ \n     public   function   __construct ( TaxCalculator   $tax ) \n     { \n         $this - tax   =   $tax ; \n     } \n\n     /**       * Pay the given amount.       *       * @param  int  $amount       * @return void       */ \n     public   function   pay ( $amount ) \n     { \n         // Pay an amount... \n     }  }   You may easily use this class as a facade like so:  use   Facades \\   { \n     App\\Services\\PaymentGateway  } ;  Route :: get ( /pay/{amount} ,   function   ($ amount )   { \n     PaymentGateway : : pay ( $ amount );  } );   Of course, if you leverage a realtime facade in this way, you may easily write a test for the interaction using Laravel's  facade mocking capabilities :  PaymentGateway :: shouldReceive ( pay ) - with ( 100 );", 
            "title": "\"Realtime\" Facades"
        }, 
        {
            "location": "/releases/#custom-pivot-table-models", 
            "text": "In Laravel 5.3, all \"pivot\" table models for  belongsToMany  relationships used the same built-in  Pivot  model instance. In Laravel 5.4, you may define custom models for your pivot tables. If you would like to define a custom model to represent the intermediate table of your relationship, use the  using  method when defining the relationship:  ? php  namespace   App ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Role   extends   Model  { \n     /**       * The users that belong to the role.       */ \n     public   function   users () \n     { \n         return   $this - belongsToMany ( App\\User ) - using ( App\\UserRole ); \n     }  }", 
            "title": "Custom Pivot Table Models"
        }, 
        {
            "location": "/releases/#improved-redis-cluster-support", 
            "text": "Previously, it was not possible to define Redis connections to single hosts and to clusters in the same application. In Laravel 5.4, you may now define Redis connections to multiple single hosts and multiple clusters within the same application. For more information on Redis in Laravel, please consult the full  Redis documentation .", 
            "title": "Improved Redis Cluster Support"
        }, 
        {
            "location": "/releases/#migration-default-string-length", 
            "text": "Laravel 5.4 uses the  utf8mb4  character set by default, which includes support for storing \"emojis\" in the database. If you are upgrading your application from Laravel 5.3, you are not required to switch to this character set.  If you choose to switch to this character set manually and are running a version of MySQL older than the 5.7.7 release, you may need to manually configure the default string length generated by migrations. You may configure this by calling the  Schema::defaultStringLength  method within your  AppServiceProvider :  use   Illuminate \\ Support \\ Facades \\ Schema ;  /**   * Bootstrap any application services.   *   * @return void   */  public   function   boot ()  { \n     Schema : : defaultStringLength ( 191 );  }", 
            "title": "Migration Default String Length"
        }, 
        {
            "location": "/releases/#laravel-53", 
            "text": "Laravel 5.3 continues the improvements made in Laravel 5.2 by adding a driver based  notification system , robust realtime support via  Laravel Echo , painless OAuth2 servers via  Laravel Passport , full-text model searching via  Laravel Scout , Webpack support in Laravel Elixir, \"mailable\" objects, explicit separation of  web  and  api  routes, Closure based console commands, convenient helpers for storing uploaded files, support for POPO and single-action controllers, improved default frontend scaffolding, and more.", 
            "title": "Laravel 5.3"
        }, 
        {
            "location": "/releases/#notifications", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   Laravel Notifications provide a simple, expressive API for sending notifications across a variety of delivery channels such as email, Slack, SMS, and more. For example, you may define a notification that an invoice has been paid and deliver that notification via email and SMS. Then, you may send the notification using a single, simple method:  $user- notify(new InvoicePaid($invoice));  There is already a wide variety of  community written drivers  for notifications, including support for iOS and Android notifications. To learn more about notifications, be sure to check out the  full notification documentation .", 
            "title": "Notifications"
        }, 
        {
            "location": "/releases/#websockets-event-broadcasting", 
            "text": "While event broadcasting existed in previous versions of Laravel, the Laravel 5.3 release greatly improves this feature of the framework by adding channel-level authentication for private and presence WebSocket channels:  /*   * Authenticate the channel subscription...   */  Broadcast : : channel ( orders.* ,   function   ( $ user ,   $ orderId )   {       return   $ user - placedOrder ( $ orderId ) ;  } ) ;   Laravel Echo, a new JavaScript package installable via NPM, has also been released to provide a simple, beautiful API for subscribing to channels and listening for your server-side events in your client-side JavaScript application. Echo includes support for  Pusher  and  Socket.io :  Echo.channel( orders.  + orderId)\n    .listen( ShippingStatusUpdated , (e) =  {\n        console.log(e.description);\n    });  In addition to subscribing to traditional channels, Laravel Echo also makes it a breeze to subscribe to presence channels which provide information about who is listening on a given channel:  Echo.join( chat.  + roomId)\n    .here((users) =  {\n        //\n    })\n    .joining((user) =  {\n        console.log(user.name);\n    })\n    .leaving((user) =  {\n        console.log(user.name);\n    });  To learn more about Echo and event broadcasting, check out the  full documentation .", 
            "title": "WebSockets / Event Broadcasting"
        }, 
        {
            "location": "/releases/#laravel-passport-oauth2-server", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   Laravel 5.3 makes API authentication a breeze using  Laravel Passport , which provides a full OAuth2 server implementation for your Laravel application in a matter of minutes. Passport is built on top of the  League OAuth2 server  that is maintained by Alex Bilbie.  Passport makes it painless to issue access tokens via OAuth2 authorization codes. You may also allow your users to create \"personal access tokens\" via your web UI. To get you started quickly, Passport includes  Vue components  that can serve as a starting point for your OAuth2 dashboard, allowing users to create clients, revoke access tokens, and more:  passport-clients /passport-clients  passport-authorized-clients /passport-authorized-clients  passport-personal-access-tokens /passport-personal-access-tokens   If you do not want to use the Vue components, you are welcome to provide your own frontend dashboard for managing clients and access tokens. Passport exposes a simple JSON API that you may use with any JavaScript framework you choose.  Of course, Passport also makes it simple to define access token scopes that may be requested by application's consuming your API:  Passport::tokensCan([\n     place-orders  =   Place new orders ,\n     check-status  =   Check order status ,\n]);  In addition, Passport includes helpful middleware for verifying that an access token authenticated request contains the necessary token scopes:  Route :: get ( /orders/{order}/status ,   function   ( Order   $ order )   { \n     //   Access   token   has   check-status   scope...  } ) - middleware ( scope:check-status );   Lastly, Passport includes support for consuming your own API from your JavaScript application without worrying about passing access tokens. Passport achieves this through encrypted JWT cookies and synchronized CSRF tokens, allowing you to focus on what matters: your application. For more information on Passport, be sure to check out its  full documentation .", 
            "title": "Laravel Passport (OAuth2 Server)"
        }, 
        {
            "location": "/releases/#search-laravel-scout", 
            "text": "Laravel Scout provides a simple, driver based solution for adding full-text search to your  Eloquent models . Using model observers, Scout will automatically keep your search indexes in sync with your Eloquent records. Currently, Scout ships with an  Algolia  driver; however, writing custom drivers is simple and you are free to extend Scout with your own search implementations.  Making models searchable is as simple as adding a  Searchable  trait to the model:  ? php  namespace   App ;  use   Laravel \\ Scout \\ Searchable ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Post   extends   Model  { \n     use   Searchable ;  }   Once the trait has been added to your model, its information will be kept in sync with your search indexes by simply saving the model:  $order = new Order;\n\n// ...\n\n$order- save();  Once your models have been indexed, its a breeze to perform full-text searches across all of your models. You may even paginate your search results:  return   Order :: search ( Star Trek ) - get ();  return   Order :: search ( Star Trek ) - where ( user_id ,   1 ) - paginate ();   Of course, Scout has many more features which are covered in the  full documentation .", 
            "title": "Search (Laravel Scout)"
        }, 
        {
            "location": "/releases/#mailable-objects", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   Laravel 5.3 ships with support for mailable objects. These objects allow you to represent your email messages as a simple objects instead of customizing mail messages within Closures. For example, you may define a simple mailable object for a \"welcome\" email:  class   WelcomeMessage   extends   Mailable  { \n     use   Queueable ,   SerializesModels ; \n\n     /**       * Build the message.       *       * @return $this       */ \n     public   function   build () \n     { \n         return   $this - view ( emails.welcome ); \n     }  }   Once the mailable object has been defined, you can send it to a user using a simple, expressive API. Mailable objects are great for discovering the intent of your messages while scanning your code:  Mail :: to ($ user ) - send ( new   WelcomeMessage );   Of course, you may also mark mailable objects as \"queueable\" so that they will be sent in the background by your queue workers:  class   WelcomeMessage   extends   Mailable   implements   ShouldQueue  { \n     //  }   For more information on mailable objects, be sure to check out the  mail documentation .", 
            "title": "Mailable Objects"
        }, 
        {
            "location": "/releases/#storing-uploaded-files", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   In web applications, one of the most common use-cases for storing files is storing user uploaded files such as profile pictures, photos, and documents. Laravel 5.3 makes it very easy to store uploaded files using the new  store  method on an uploaded file instance. Simply call the  store  method with the path at which you wish to store the uploaded file:  /**   * Update the avatar for the user.   *   * @param  Request  $request   * @return Response   */ \npublic   function   update ( Request   $ request )  {       $ path   =   $ request - file ( avatar )- store ( avatars ,   s3 ) ;       return   $ path ;  }   For more information on storing uploaded files, check out the  full documentation .", 
            "title": "Storing Uploaded Files"
        }, 
        {
            "location": "/releases/#webpack-laravel-elixir", 
            "text": "Along with Laravel 5.3, Laravel Elixir 6.0 has been released with baked-in support for the Webpack and Rollup JavaScript module bundlers. By default, the Laravel 5.3  gulpfile.js  file now uses Webpack to compile your JavaScript. The  full Laravel Elixir documentation  contains more information on both of these bundlers:  elixir(mix =  {\n    mix.sass( app.scss )\n       .webpack( app.js );\n});", 
            "title": "Webpack &amp; Laravel Elixir"
        }, 
        {
            "location": "/releases/#frontend-structure", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   Laravel 5.3 ships with a more modern frontend structure. This primarily affects the  make:auth  authentication scaffolding. Instead of loading frontend assets from a CDN, dependencies are specified in the default  package.json  file.  In addition, support for single file  Vue components  is now included out of the box. A sample  Example.vue  component is included in the  resources/assets/js/components  directory. In addition, the new  resources/assets/js/app.js  file bootstraps and configures your JavaScript libraries and, if applicable, Vue components.  This structure provides more guidance on how to begin developing modern, robust JavaScript applications, without requiring your application to use any given JavaScript or CSS framework. For more information on getting started with modern Laravel frontend development, check out the new  introductory frontend documentation .", 
            "title": "Frontend Structure"
        }, 
        {
            "location": "/releases/#routes-files", 
            "text": "By default, fresh Laravel 5.3 applications contain two HTTP route files in a new top-level  routes  directory. The  web  and  api  route files provide more explicit guidance in how to split the routes for your web interface and your API. The routes in the  api  route file are automatically assigned the  api  prefix by the  RouteServiceProvider .", 
            "title": "Routes Files"
        }, 
        {
            "location": "/releases/#closure-console-commands", 
            "text": "In addition to being defined as command classes, Artisan commands may now be defined as simple Closures in the  commands  method of your  app/Console/Kernel.php  file. In fresh Laravel 5.3 applications, the  commands  method loads a  routes/console.php  file which allows you to define your Console commands as route-like, Closure based entry points into your application:  Artisan::command( build {project} , function ($project) {\n    $this- info( Building project... );\n});  For more information on Closure commands, check out the  full Artisan documentation .", 
            "title": "Closure Console Commands"
        }, 
        {
            "location": "/releases/#the-loop-variable", 
            "text": "{video} There is a free  video tutorial  for this feature available on Laracasts.   When looping within a Blade template, a  $loop  variable will be available inside of your loop. This variable provides access to some useful bits of information such as the current loop index and whether this is the first or last iteration through the loop:  @ foreach   ( $ users   as   $ user ) \n     @ if   ( $ loop - first ) \n         This   is   the   first   iteration . \n     @ endif \n\n     @ if   ( $ loop - last ) \n         This   is   the   last   iteration . \n     @ endif \n\n     p This   is   user   {{   $ user - id   }} / p  @ endforeach   For more information, consult the  full Blade documentation .", 
            "title": "The $loop Variable"
        }, 
        {
            "location": "/releases/#laravel-52", 
            "text": "Laravel 5.2 continues the improvements made in Laravel 5.1 by adding multiple authentication driver support, implicit model binding, simplified Eloquent global scopes, opt-in authentication scaffolding, middleware groups, rate limiting middleware, array validation improvements, and more.", 
            "title": "Laravel 5.2"
        }, 
        {
            "location": "/releases/#authentication-drivers-multi-auth", 
            "text": "In previous versions of Laravel, only the default, session-based authentication driver was supported out of the box, and you could not have more than one authenticatable model instance per application.  However, in Laravel 5.2, you may define additional authentication drivers as well define multiple authenticatable models or user tables, and control their authentication process separately from each other. For example, if your application has one database table for \"admin\" users and one database table for \"student\" users, you may now use the  Auth  methods to authenticate against each of these tables separately.", 
            "title": "Authentication Drivers / \"Multi-Auth\""
        }, 
        {
            "location": "/releases/#authentication-scaffolding", 
            "text": "Laravel already makes it easy to handle authentication on the back-end; however, Laravel 5.2 provides a convenient, lightning-fast way to scaffold the authentication views for your front-end. Simply execute the  make:auth  command on your terminal:  php artisan make:auth  This command will generate plain, Bootstrap compatible views for user login, registration, and password reset. The command will also update your routes file with the appropriate routes.   {note} This feature is only meant to be used on new applications, not during application upgrades.", 
            "title": "Authentication Scaffolding"
        }, 
        {
            "location": "/releases/#implicit-model-binding", 
            "text": "Implicit model binding makes it painless to inject relevant models directly into your routes and controllers. For example, assume you have a route defined like the following:  use App\\User;\n\nRoute::get( /user/{user} , function (User $user) {\n    return $user;\n});  In Laravel 5.1, you would typically need to use the  Route::model  method to instruct Laravel to inject the  App\\User  instance that matches the  {user}  parameter in your route definition. However, in Laravel 5.2, the framework will  automatically  inject this model based on the URI segment, allowing you to quickly gain access to the model instances you need.  Laravel will automatically inject the model when the route parameter segment ( {user} ) matches the route Closure or controller method's corresponding variable name ( $user ) and the variable is type-hinting an Eloquent model class.", 
            "title": "Implicit Model Binding"
        }, 
        {
            "location": "/releases/#middleware-groups", 
            "text": "Middleware groups allow you to group several route middleware under a single, convenient key, allowing you to assign several middleware to a route at once. For example, this can be useful when building a web UI and an API within the same application. You may group the session and CSRF routes into a  web  group, and perhaps the rate limiter in the  api  group.  In fact, the default Laravel 5.2 application structure takes exactly this approach. For example, in the default  App\\Http\\Kernel.php  file you will find the following:  /**   * The application s route middleware groups.   *   * @var array   */ \nprotected   $ middlewareGroups   =   [       web   =   [           \\ App \\ Http \\ Middleware \\ EncryptCookies : : class ,           \\ Illuminate \\ Cookie \\ Middleware \\ AddQueuedCookiesToResponse : : class ,           \\ Illuminate \\ Session \\ Middleware \\ StartSession : : class ,           \\ Illuminate \\ View \\ Middleware \\ ShareErrorsFromSession : : class ,           \\ App \\ Http \\ Middleware \\ VerifyCsrfToken : : class ,       ] ,       api   =   [           throttle:60,1 ,       ] ,  ];   Then, the  web  group may be assigned to routes like so:  Route::group([ middleware  =  [ web ]], function () {\n    //\n});  However, keep in mind the  web  middleware group is  already  applied to your routes by default since the  RouteServiceProvider  includes it in the default middleware group.", 
            "title": "Middleware Groups"
        }, 
        {
            "location": "/releases/#rate-limiting", 
            "text": "A new rate limiter middleware is now included with the framework, allowing you to easily limit the number of requests that a given IP address can make to a route over a specified number of minutes. For example, to limit a route to 60 requests every minute from a single IP address, you may do the following:  Route::get( /api/users , [ middleware  =   throttle:60,1 , function () {\n    //\n}]);", 
            "title": "Rate Limiting"
        }, 
        {
            "location": "/releases/#array-validation", 
            "text": "Validating array form input fields is much easier in Laravel 5.2. For example, to validate that each e-mail in a given array input field is unique, you may do the following:  $validator = Validator::make($request- all(), [\n     person.*.email  =   email|unique:users \n]);  Likewise, you may use the  *  character when specifying your validation messages in your language files, making it a breeze to use a single validation message for array based fields:  custom  =  [\n     person.*.email  =  [\n         unique  =   Each person must have a unique e-mail address ,\n    ]\n],", 
            "title": "Array Validation"
        }, 
        {
            "location": "/releases/#bail-validation-rule", 
            "text": "A new  bail  validation rule has been added, which instructs the validator to stop validating after the first validation failure for a given rule. For example, you may now prevent the validator from running a  unique  check if an attribute fails an  integer  check:  $this- validate($request, [\n     user_id  =   bail|integer|unique:users \n]);", 
            "title": "Bail Validation Rule"
        }, 
        {
            "location": "/releases/#eloquent-global-scope-improvements", 
            "text": "In previous versions of Laravel, global Eloquent scopes were complicated and error-prone to implement; however, in Laravel 5.2, global query scopes only require you to implement a single, simple method:  apply .  For more information on writing global scopes, check out the full  Eloquent documentation .", 
            "title": "Eloquent Global Scope Improvements"
        }, 
        {
            "location": "/releases/#laravel-5111", 
            "text": "Laravel 5.1.11 introduces  authorization  support out of the box! Conveniently organize your application's authorization logic using simple callbacks or policy classes, and authorize actions using simple, expressive methods.  For more information, please refer to the  authorization documentation .", 
            "title": "Laravel 5.1.11"
        }, 
        {
            "location": "/releases/#laravel-514", 
            "text": "Laravel 5.1.4 introduces simple login throttling to the framework. Consult the  authentication documentation  for more information.", 
            "title": "Laravel 5.1.4"
        }, 
        {
            "location": "/releases/#laravel-51", 
            "text": "Laravel 5.1 continues the improvements made in Laravel 5.0 by adopting PSR-2 and adding event broadcasting, middleware parameters, Artisan improvements, and more.", 
            "title": "Laravel 5.1"
        }, 
        {
            "location": "/releases/#php-559", 
            "text": "Since PHP 5.4 will enter \"end of life\" in September and will no longer receive security updates from the PHP development team, Laravel 5.1 requires PHP 5.5.9 or greater. PHP 5.5.9 allows compatibility with the latest versions of popular PHP libraries such as Guzzle and the AWS SDK.", 
            "title": "PHP 5.5.9+"
        }, 
        {
            "location": "/releases/#lts", 
            "text": "Laravel 5.1 is the first release of Laravel to receive  long term support . Laravel 5.1 will receive bug fixes for 2 years and security fixes for 3 years. This support window is the largest ever provided for Laravel and provides stability and peace of mind for larger, enterprise clients and customers.", 
            "title": "LTS"
        }, 
        {
            "location": "/releases/#psr-2", 
            "text": "The  PSR-2 coding style guide  has been adopted as the default style guide for the Laravel framework. Additionally, all generators have been updated to generate PSR-2 compatible syntax.", 
            "title": "PSR-2"
        }, 
        {
            "location": "/releases/#documentation", 
            "text": "Every page of the Laravel documentation has been meticulously reviewed and dramatically improved. All code examples have also been reviewed and expanded to provide more relevance and context.", 
            "title": "Documentation"
        }, 
        {
            "location": "/releases/#event-broadcasting", 
            "text": "In many modern web applications, web sockets are used to implement realtime, live-updating user interfaces. When some data is updated on the server, a message is typically sent over a websocket connection to be handled by the client.  To assist you in building these types of applications, Laravel makes it easy to \"broadcast\" your events over a websocket connection. Broadcasting your Laravel events allows you to share the same event names between your server-side code and your client-side JavaScript framework.  To learn more about event broadcasting, check out the  event documentation .", 
            "title": "Event Broadcasting"
        }, 
        {
            "location": "/releases/#middleware-parameters", 
            "text": "Middleware can now receive additional custom parameters. For example, if your application needs to verify that the authenticated user has a given \"role\" before performing a given action, you could create a  RoleMiddleware  that receives a role name as an additional argument:  ? php  namespace   App \\ Http \\ Middleware ;  use   Closure ;  class   RoleMiddleware  { \n     /**       * Run the request filter.       *       * @param  \\Illuminate\\Http\\Request  $request       * @param  \\Closure  $next       * @param  string  $role       * @return mixed       */ \n     public   function   handle ( $request ,   Closure   $next ,   $role ) \n     { \n         if   ( !   $request - user () - hasRole ( $role ))   { \n             // Redirect... \n         } \n\n         return   $next ( $request ); \n     }  }   Middleware parameters may be specified when defining the route by separating the middleware name and parameters with a  : . Multiple parameters should be delimited by commas:  Route::put( post/{id} , [ middleware  =   role:editor , function ($id) {\n    //\n}]);  For more information on middleware, check out the  middleware documentation .", 
            "title": "Middleware Parameters"
        }, 
        {
            "location": "/releases/#testing-overhaul", 
            "text": "The built-in testing capabilities of Laravel have been dramatically improved. A variety of new methods provide a fluent, expressive interface for interacting with your application and examining its responses. For example, check out the following test:  public function testNewUserRegistration()\n{\n    $this- visit( /register )\n         - type( Taylor ,  name )\n         - check( terms )\n         - press( Register )\n         - seePageIs( /dashboard );\n}  For more information on testing, check out the  testing documentation .", 
            "title": "Testing Overhaul"
        }, 
        {
            "location": "/releases/#model-factories", 
            "text": "Laravel now ships with an easy way to create stub Eloquent models using  model factories . Model factories allow you to easily define a set of \"default\" attributes for your Eloquent model, and then generate test model instances for your tests or database seeds. Model factories also take advantage of the powerful  Faker  PHP library for generating random attribute data:  $factory- define(App\\User::class, function ($faker) {\n    return [\n         name  =  $faker- name,\n         email  =  $faker- email,\n         password  =  str_random(10),\n         remember_token  =  str_random(10),\n    ];\n});  For more information on model factories, check out  the documentation .", 
            "title": "Model Factories"
        }, 
        {
            "location": "/releases/#artisan-improvements", 
            "text": "Artisan commands may now be defined using a simple, route-like \"signature\", which provides an extremely simple interface for defining command line arguments and options. For example, you may define a simple command and its options like so:  /**   * The name and signature of the console command.   *   * @var string   */  protected   $ signature   =   email:send {user} {--force} ;   For more information on defining Artisan commands, consult the  Artisan documentation .", 
            "title": "Artisan Improvements"
        }, 
        {
            "location": "/releases/#folder-structure", 
            "text": "To better express intent, the  app/Commands  directory has been renamed to  app/Jobs . Additionally, the  app/Handlers  directory has been consolidated into a single  app/Listeners  directory which simply contains event listeners. However, this is not a breaking change and you are not required to update to the new folder structure to use Laravel 5.1.", 
            "title": "Folder Structure"
        }, 
        {
            "location": "/releases/#encryption", 
            "text": "In previous versions of Laravel, encryption was handled by the  mcrypt  PHP extension. However, beginning in Laravel 5.1, encryption is handled by the  openssl  extension, which is more actively maintained.", 
            "title": "Encryption"
        }, 
        {
            "location": "/releases/#laravel-50", 
            "text": "Laravel 5.0 introduces a fresh application structure to the default Laravel project. This new structure serves as a better foundation for building a robust application in Laravel, as well as embraces new auto-loading standards (PSR-4) throughout the application. First, let's examine some of the major changes:", 
            "title": "Laravel 5.0"
        }, 
        {
            "location": "/releases/#new-folder-structure", 
            "text": "The old  app/models  directory has been entirely removed. Instead, all of your code lives directly within the  app  folder, and, by default, is organized to the  App  namespace. This default namespace can be quickly changed using the new  app:name  Artisan command.  Controllers, middleware, and requests (a new type of class in Laravel 5.0) are now grouped under the  app/Http  directory, as they are all classes related to the HTTP transport layer of your application. Instead of a single, flat file of route filters, all middleware are now broken into their own class files.  A new  app/Providers  directory replaces the  app/start  files from previous versions of Laravel 4.x. These service providers provide various bootstrapping functions to your application, such as error handling, logging, route loading, and more. Of course, you are free to create additional service providers for your application.  Application language files and views have been moved to the  resources  directory.", 
            "title": "New Folder Structure"
        }, 
        {
            "location": "/releases/#contracts", 
            "text": "All major Laravel components implement interfaces which are located in the  illuminate/contracts  repository. This repository has no external dependencies. Having a convenient, centrally located set of interfaces you may use for decoupling and dependency injection will serve as an easy alternative option to Laravel Facades.  For more information on contracts, consult the  full documentation .", 
            "title": "Contracts"
        }, 
        {
            "location": "/releases/#route-cache", 
            "text": "If your application is made up entirely of controller routes, you may utilize the new  route:cache  Artisan command to drastically speed up the registration of your routes. This is primarily useful on applications with 100+ routes and will  drastically  speed up this portion of your application.", 
            "title": "Route Cache"
        }, 
        {
            "location": "/releases/#route-middleware", 
            "text": "In addition to Laravel 4 style route \"filters\", Laravel 5 now supports HTTP middleware, and the included authentication and CSRF \"filters\" have been converted to middleware. Middleware provides a single, consistent interface to replace all types of filters, allowing you to easily inspect, and even reject, requests before they enter your application.  For more information on middleware, check out  the documentation .", 
            "title": "Route Middleware"
        }, 
        {
            "location": "/releases/#controller-method-injection", 
            "text": "In addition to the existing constructor injection, you may now type-hint dependencies on controller methods. The  service container  will automatically inject the dependencies, even if the route contains other parameters:  public function createPost(Request $request, PostRepository $posts)\n{\n    //\n}", 
            "title": "Controller Method Injection"
        }, 
        {
            "location": "/releases/#authentication-scaffolding_1", 
            "text": "User registration, authentication, and password reset controllers are now included out of the box, as well as simple corresponding views, which are located at  resources/views/auth . In addition, a \"users\" table migration has been included with the framework. Including these simple resources allows rapid development of application ideas without bogging down on authentication boilerplate. The authentication views may be accessed on the  auth/login  and  auth/register  routes. The  App\\Services\\Auth\\Registrar  service is responsible for user validation and creation.", 
            "title": "Authentication Scaffolding"
        }, 
        {
            "location": "/releases/#event-objects", 
            "text": "You may now define events as objects instead of simply using strings. For example, check out the following event:  ? php  class   PodcastWasPurchased  { \n     public   $podcast ; \n\n     public   function   __construct ( Podcast   $podcast ) \n     { \n         $this - podcast   =   $podcast ; \n     }  }   The event may be dispatched like normal:  Event :: fire ( new   PodcastWasPurchased ($ podcast ));   Of course, your event handler will receive the event object instead of a list of data:  ? php  class   ReportPodcastPurchase  { \n     public   function   handle ( PodcastWasPurchased   $event ) \n     { \n         // \n     }  }   For more information on working with events, check out the  full documentation .", 
            "title": "Event Objects"
        }, 
        {
            "location": "/releases/#commands-queueing", 
            "text": "In addition to the queue job format supported in Laravel 4, Laravel 5 allows you to represent your queued jobs as simple command objects. These commands live in the  app/Commands  directory. Here's a sample command:  ? php  class   PurchasePodcast   extends   Command   implements   SelfHandling ,   ShouldBeQueued  { \n     use   SerializesModels ; \n\n     protected   $user ,   $podcast ; \n\n     /**       * Create a new command instance.       *       * @return void       */ \n     public   function   __construct ( User   $user ,   Podcast   $podcast ) \n     { \n         $this - user   =   $user ; \n         $this - podcast   =   $podcast ; \n     } \n\n     /**       * Execute the command.       *       * @return void       */ \n     public   function   handle () \n     { \n         // Handle the logic to purchase the podcast... \n\n         event ( new   PodcastWasPurchased ( $this - user ,   $this - podcast )); \n     }  }   The base Laravel controller utilizes the new  DispatchesCommands  trait, allowing you to easily dispatch your commands for execution:  $this- dispatch(new PurchasePodcastCommand($user, $podcast));  Of course, you may also use commands for tasks that are executed synchronously (are not queued). In fact, using commands is a great way to encapsulate complex tasks your application needs to perform. For more information, check out the  command bus  documentation.", 
            "title": "Commands / Queueing"
        }, 
        {
            "location": "/releases/#database-queue", 
            "text": "A  database  queue driver is now included in Laravel, providing a simple, local queue driver that requires no extra package installation beyond your database software.", 
            "title": "Database Queue"
        }, 
        {
            "location": "/releases/#laravel-scheduler", 
            "text": "In the past, developers have generated a Cron entry for each console command they wished to schedule. However, this is a headache. Your console schedule is no longer in source control, and you must SSH into your server to add the Cron entries. Let's make our lives easier. The Laravel command scheduler allows you to fluently and expressively define your command schedule within Laravel itself, and only a single Cron entry is needed on your server.  It looks like this:  $ schedule- command ( artisan:command ) - dailyAt ( 15:00 );   Of course, check out the  full documentation  to learn all about the scheduler!", 
            "title": "Laravel Scheduler"
        }, 
        {
            "location": "/releases/#tinker-psysh", 
            "text": "The  php artisan tinker  command now utilizes  Psysh  by Justin Hileman, a more robust REPL for PHP. If you liked Boris in Laravel 4, you're going to love Psysh. Even better, it works on Windows! To get started, just try:  php artisan tinker", 
            "title": "Tinker / Psysh"
        }, 
        {
            "location": "/releases/#dotenv", 
            "text": "Instead of a variety of confusing, nested environment configuration directories, Laravel 5 now utilizes  DotEnv  by Vance Lucas. This library provides a super simple way to manage your environment configuration, and makes environment detection in Laravel 5 a breeze. For more details, check out the full  configuration documentation .", 
            "title": "DotEnv"
        }, 
        {
            "location": "/releases/#laravel-elixir", 
            "text": "Laravel Elixir, by Jeffrey Way, provides a fluent, expressive interface to compiling and concatenating your assets. If you've ever been intimidated by learning Grunt or Gulp, fear no more. Elixir makes it a cinch to get started using Gulp to compile your Less, Sass, and CoffeeScript. It can even run your tests for you!  For more information on Elixir, check out the  full documentation .", 
            "title": "Laravel Elixir"
        }, 
        {
            "location": "/releases/#laravel-socialite", 
            "text": "Laravel Socialite is an optional, Laravel 5.0+ compatible package that provides totally painless authentication with OAuth providers. Currently, Socialite supports Facebook, Twitter, Google, and GitHub. Here's what it looks like:  public   function   redirectForAuth ()  { \n     return   Socialize : : with ( twitter ) - redirect ();  }  public   function   getUserFromProvider ()  { \n     $user   =   Socialize : : with ( twitter ) - user ();  }   No more spending hours writing OAuth authentication flows. Get started in minutes! The  full documentation  has all the details.", 
            "title": "Laravel Socialite"
        }, 
        {
            "location": "/releases/#flysystem-integration", 
            "text": "Laravel now includes the powerful  Flysystem  filesystem abstraction library, providing pain free integration with local, Amazon S3, and Rackspace cloud storage - all with one, unified and elegant API! Storing a file in Amazon S3 is now as simple as:  Storage :: put ( file.txt ,   contents );   For more information on the Laravel Flysystem integration, consult the  full documentation .", 
            "title": "Flysystem Integration"
        }, 
        {
            "location": "/releases/#form-requests", 
            "text": "Laravel 5.0 introduces  form requests , which extend the  Illuminate\\Foundation\\Http\\FormRequest  class. These request objects can be combined with controller method injection to provide a boiler-plate free method of validating user input. Let's dig in and look at a sample  FormRequest :  ? php  namespace   App \\ Http \\ Requests ;  class   RegisterRequest   extends   FormRequest  { \n     public   function   rules () \n     { \n         return   [ \n             email   =   required|email|unique:users , \n             password   =   required|confirmed|min:8 , \n         ]; \n     } \n\n     public   function   authorize () \n     { \n         return   true ; \n     }  }   Once the class has been defined, we can type-hint it on our controller action:  public function register(RegisterRequest $request)\n{\n    var_dump($request- input());\n}  When the Laravel service container identifies that the class it is injecting is a  FormRequest  instance, the request will  automatically be validated . This means that if your controller action is called, you can safely assume the HTTP request input has been validated according to the rules you specified in your form request class. Even more, if the request is invalid, an HTTP redirect, which you may customize, will automatically be issued, and the error messages will be either flashed to the session or converted to JSON.  Form validation has never been more simple.  For more information on  FormRequest  validation, check out the  documentation .", 
            "title": "Form Requests"
        }, 
        {
            "location": "/releases/#simple-controller-request-validation", 
            "text": "The Laravel 5 base controller now includes a  ValidatesRequests  trait. This trait provides a simple  validate  method to validate incoming requests. If  FormRequests  are a little too much for your application, check this out:  public function createPost(Request $request)\n{\n    $this- validate($request, [\n         title  =   required|max:255 ,\n         body  =   required ,\n    ]);\n}  If the validation fails, an exception will be thrown and the proper HTTP response will automatically be sent back to the browser. The validation errors will even be flashed to the session! If the request was an AJAX request, Laravel even takes care of sending a JSON representation of the validation errors back to you.  For more information on this new method, check out  the documentation .", 
            "title": "Simple Controller Request Validation"
        }, 
        {
            "location": "/releases/#new-generators", 
            "text": "To complement the new default application structure, new Artisan generator commands have been added to the framework. See  php artisan list  for more details.", 
            "title": "New Generators"
        }, 
        {
            "location": "/releases/#configuration-cache", 
            "text": "You may now cache all of your configuration in a single file using the  config:cache  command.", 
            "title": "Configuration Cache"
        }, 
        {
            "location": "/releases/#symfony-vardumper", 
            "text": "The popular  dd  helper function, which dumps variable debug information, has been upgraded to use the amazing Symfony VarDumper. This provides color-coded output and even collapsing of arrays. Just try the following in your project:  dd([1, 2, 3]);", 
            "title": "Symfony VarDumper"
        }, 
        {
            "location": "/releases/#laravel-42", 
            "text": "The full change list for this release by running the  php artisan changes  command from a 4.2 installation, or by  viewing the change file on Github . These notes only cover the major enhancements and changes for the release.   {note} During the 4.2 release cycle, many small bug fixes and enhancements were incorporated into the various Laravel 4.1 point releases. So, be sure to check the change list for Laravel 4.1 as well!", 
            "title": "Laravel 4.2"
        }, 
        {
            "location": "/releases/#php-54-requirement", 
            "text": "Laravel 4.2 requires PHP 5.4 or greater. This upgraded PHP requirement allows us to use new PHP features such as traits to provide more expressive interfaces for tools like  Laravel Cashier . PHP 5.4 also brings significant speed and performance improvements over PHP 5.3.", 
            "title": "PHP 5.4 Requirement"
        }, 
        {
            "location": "/releases/#laravel-forge", 
            "text": "Laravel Forge, a new web based application, provides a simple way to create and manage PHP servers on the cloud of your choice, including Linode, DigitalOcean, Rackspace, and Amazon EC2. Supporting automated Nginx configuration, SSH key access, Cron job automation, server monitoring via NewRelic   Papertrail, \"Push To Deploy\", Laravel queue worker configuration, and more, Forge provides the simplest and most affordable way to launch all of your Laravel applications.  The default Laravel 4.2 installation's  app/config/database.php  configuration file is now configured for Forge usage by default, allowing for more convenient deployment of fresh applications onto the platform.  More information about Laravel Forge can be found on the  official Forge website .", 
            "title": "Laravel Forge"
        }, 
        {
            "location": "/releases/#laravel-homestead", 
            "text": "Laravel Homestead is an official Vagrant environment for developing robust Laravel and PHP applications. The vast majority of the boxes' provisioning needs are handled before the box is packaged for distribution, allowing the box to boot extremely quickly. Homestead includes Nginx 1.6, PHP 5.6, MySQL, Postgres, Redis, Memcached, Beanstalk, Node, Gulp, Grunt,   Bower. Homestead includes a simple  Homestead.yaml  configuration file for managing multiple Laravel applications on a single box.  The default Laravel 4.2 installation now includes an  app/config/local/database.php  configuration file that is configured to use the Homestead database out of the box, making Laravel initial installation and configuration more convenient.  The official documentation has also been updated to include  Homestead documentation .", 
            "title": "Laravel Homestead"
        }, 
        {
            "location": "/releases/#laravel-cashier", 
            "text": "Laravel Cashier is a simple, expressive library for managing subscription billing with Stripe. With the introduction of Laravel 4.2, we are including Cashier documentation along with the main Laravel documentation, though installation of the component itself is still optional. This release of Cashier brings numerous bug fixes, multi-currency support, and compatibility with the latest Stripe API.", 
            "title": "Laravel Cashier"
        }, 
        {
            "location": "/releases/#daemon-queue-workers", 
            "text": "The Artisan  queue:work  command now supports a  --daemon  option to start a worker in \"daemon mode\", meaning the worker will continue to process jobs without ever re-booting the framework. This results in a significant reduction in CPU usage at the cost of a slightly more complex application deployment process.  More information about daemon queue workers can be found in the  queue documentation .", 
            "title": "Daemon Queue Workers"
        }, 
        {
            "location": "/releases/#mail-api-drivers", 
            "text": "Laravel 4.2 introduces new Mailgun and Mandrill API drivers for the  Mail  functions. For many applications, this provides a faster and more reliable method of sending e-mails than the SMTP options. The new drivers utilize the Guzzle 4 HTTP library.", 
            "title": "Mail API Drivers"
        }, 
        {
            "location": "/releases/#soft-deleting-traits", 
            "text": "A much cleaner architecture for \"soft deletes\" and other \"global scopes\" has been introduced via PHP 5.4 traits. This new architecture allows for the easier construction of similar global traits, and a cleaner separation of concerns within the framework itself.  More information on the new  SoftDeletingTrait  may be found in the  Eloquent documentation .", 
            "title": "Soft Deleting Traits"
        }, 
        {
            "location": "/releases/#convenient-auth-remindable-traits", 
            "text": "The default Laravel 4.2 installation now uses simple traits for including the needed properties for the authentication and password reminder user interfaces. This provides a much cleaner default  User  model file out of the box.", 
            "title": "Convenient Auth &amp; Remindable Traits"
        }, 
        {
            "location": "/releases/#simple-paginate", 
            "text": "A new  simplePaginate  method was added to the query and Eloquent builder which allows for more efficient queries when using simple \"Next\" and \"Previous\" links in your pagination view.", 
            "title": "\"Simple Paginate\""
        }, 
        {
            "location": "/releases/#migration-confirmation", 
            "text": "In production, destructive migration operations will now ask for confirmation. Commands may be forced to run without any prompts using the  --force  command.", 
            "title": "Migration Confirmation"
        }, 
        {
            "location": "/requests/", 
            "text": "HTTP Requests\n\n\n\n\nAccessing The Request\n\n\nRequest Path \n Method\n\n\nPSR-7 Requests\n\n\n\n\n\n\nInput Trimming \n Normalization\n\n\nRetrieving Input\n\n\nOld Input\n\n\nCookies\n\n\n\n\n\n\nFiles\n\n\nRetrieving Uploaded Files\n\n\nStoring Uploaded Files\n\n\n\n\n\n\n\n\n\n\nAccessing The Request\n\n\nTo obtain an instance of the current HTTP request via dependency injection, you should type-hint the \nIlluminate\\Http\\Request\n class on your controller method. The incoming request instance will automatically be injected by the \nservice container\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Store a new user.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nstore\n(\nRequest\n \n$request\n)\n\n    \n{\n\n        \n$name\n \n=\n \n$request\n-\ninput\n(\nname\n);\n\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDependency Injection \n Route Parameters\n\n\nIf your controller method is also expecting input from a route parameter you should list your route parameters after your other dependencies. For example, if your route is defined like so:\n\n\nRoute\n::\nput\n(\nuser/{id}\n,\n \nUserController@update\n);\n\n\n\n\n\n\nYou may still type-hint the \nIlluminate\\Http\\Request\n and access your route parameter \nid\n by defining your controller method as follows:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Update the specified user.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @param  string  $id\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nupdate\n(\nRequest\n \n$request\n,\n \n$id\n)\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAccessing The Request Via Route Closures\n\n\nYou may also type-hint the \nIlluminate\\Http\\Request\n class on a route Closure. The service container will automatically inject the incoming request into the Closure when it is executed:\n\n\nuse Illuminate\\Http\\Request;\n\nRoute::get(\n/\n, function (Request $request) {\n    //\n});\n\n\n\n\n\n\n\nRequest Path \n Method\n\n\nThe \nIlluminate\\Http\\Request\n instance provides a variety of methods for examining the HTTP request for your application and extends the \nSymfony\\Component\\HttpFoundation\\Request\n class. We will discuss a few of the most important methods below.\n\n\nRetrieving The Request Path\n\n\nThe \npath\n method returns the request's path information. So, if the incoming request is targeted at \nhttp://domain.com/foo/bar\n, the \npath\n method will return \nfoo/bar\n:\n\n\n$uri = $request-\npath();\n\n\n\n\n\nThe \nis\n method allows you to verify that the incoming request path matches a given pattern. You may use the \n*\n character as a wildcard when utilizing this method:\n\n\nif ($request-\nis(\nadmin/*\n)) {\n    //\n}\n\n\n\n\n\nRetrieving The Request URL\n\n\nTo retrieve the full URL for the incoming request you may use the \nurl\n or \nfullUrl\n methods. The \nurl\n method will return the URL without the query string, while the \nfullUrl\n method includes the query string:\n\n\n// Without Query String...\n$url = $request-\nurl();\n\n// With Query String...\n$url = $request-\nfullUrl();\n\n\n\n\n\nRetrieving The Request Method\n\n\nThe \nmethod\n method will return the HTTP verb for the request. You may use the \nisMethod\n method to verify that the HTTP verb matches a given string:\n\n\n$method = $request-\nmethod();\n\nif ($request-\nisMethod(\npost\n)) {\n    //\n}\n\n\n\n\n\n\n\nPSR-7 Requests\n\n\nThe \nPSR-7 standard\n specifies interfaces for HTTP messages, including requests and responses. If you would like to obtain an instance of a PSR-7 request instead of a Laravel request, you will first need to install a few libraries. Laravel uses the \nSymfony HTTP Message Bridge\n component to convert typical Laravel requests and responses into PSR-7 compatible implementations:\n\n\ncomposer require symfony/psr-http-message-bridge\ncomposer require zendframework/zend-diactoros\n\n\n\n\n\nOnce you have installed these libraries, you may obtain a PSR-7 request by type-hinting the request interface on your route Closure or controller method:\n\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nRoute::get(\n/\n, function (ServerRequestInterface $request) {\n    //\n});\n\n\n\n\n\n\n\n{tip} If you return a PSR-7 response instance from a route or controller, it will automatically be converted back to a Laravel response instance and be displayed by the framework.\n\n\n\n\n\n\nInput Trimming \n Normalization\n\n\nBy default, Laravel includes the \nTrimStrings\n and \nConvertEmptyStringsToNull\n middleware in your application's global middleware stack. These middleware are listed in the stack by the \nApp\\Http\\Kernel\n class. These middleware will automatically trim all incoming string fields on the request, as well as convert any empty string fields to \nnull\n. This allows you to not have to worry about these normalization concerns in your routes and controllers.\n\n\nIf you would like to disable this behavior, you may remove the two middleware from your application's middleware stack by removing them from the \n$middleware\n property of your \nApp\\Http\\Kernel\n class.\n\n\n\n\nRetrieving Input\n\n\nRetrieving All Input Data\n\n\nYou may also retrieve all of the input data as an \narray\n using the \nall\n method:\n\n\n$input = $request-\nall();\n\n\n\n\n\nRetrieving An Input Value\n\n\nUsing a few simple methods, you may access all of the user input from your \nIlluminate\\Http\\Request\n instance without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the \ninput\n method may be used to retrieve user input:\n\n\n$name = $request-\ninput(\nname\n);\n\n\n\n\n\nYou may pass a default value as the second argument to the \ninput\n method. This value will be returned if the requested input value is not present on the request:\n\n\n$name = $request-\ninput(\nname\n, \nSally\n);\n\n\n\n\n\nWhen working with forms that contain array inputs, use \"dot\" notation to access the arrays:\n\n\n$name = $request-\ninput(\nproducts.0.name\n);\n\n$names = $request-\ninput(\nproducts.*.name\n);\n\n\n\n\n\nRetrieving Input Via Dynamic Properties\n\n\nYou may also access user input using dynamic properties on the \nIlluminate\\Http\\Request\n instance. For example, if one of your application's forms contains a \nname\n field, you may access the value of the field like so:\n\n\n$name = $request-\nname;\n\n\n\n\n\nWhen using dynamic properties, Laravel will first look for the parameter's value in the request payload. If it is not present, Laravel will search for the field in the route parameters.\n\n\nRetrieving JSON Input Values\n\n\nWhen sending JSON requests to your application, you may access the JSON data via the \ninput\n method as long as the \nContent-Type\n header of the request is properly set to \napplication/json\n. You may even use \"dot\" syntax to dig into JSON arrays:\n\n\n$name = $request-\ninput(\nuser.name\n);\n\n\n\n\n\nRetrieving A Portion Of The Input Data\n\n\nIf you need to retrieve a subset of the input data, you may use the \nonly\n and \nexcept\n methods. Both of these methods accept a single \narray\n or a dynamic list of arguments:\n\n\n$input = $request-\nonly([\nusername\n, \npassword\n]);\n\n$input = $request-\nonly(\nusername\n, \npassword\n);\n\n$input = $request-\nexcept([\ncredit_card\n]);\n\n$input = $request-\nexcept(\ncredit_card\n);\n\n\n\n\n\nThe \nonly\n method returns all of the key / value pairs that you request, even if the key is not present on the incoming request. When the key is not present on the request, the value will be \nnull\n. If you would like to retrieve a portion of input data that is actually present on the request, you may use the \nintersect\n method:\n\n\n$input = $request-\nintersect([\nusername\n, \npassword\n]);\n\n\n\n\n\nDetermining If An Input Value Is Present\n\n\nYou should use the \nhas\n method to determine if a value is present on the request. The \nhas\n method returns \ntrue\n if the value is present and is not an empty string:\n\n\nif ($request-\nhas(\nname\n)) {\n    //\n}\n\n\n\n\n\n\n\nOld Input\n\n\nLaravel allows you to keep input from one request during the next request. This feature is particularly useful for re-populating forms after detecting validation errors. However, if you are using Laravel's included \nvalidation features\n, it is unlikely you will need to manually use these methods, as some of Laravel's built-in validation facilities will call them automatically.\n\n\nFlashing Input To The Session\n\n\nThe \nflash\n method on the \nIlluminate\\Http\\Request\n class will flash the current input to the \nsession\n so that it is available during the user's next request to the application:\n\n\n$request-\nflash();\n\n\n\n\n\nYou may also use the \nflashOnly\n and \nflashExcept\n methods to flash a subset of the request data to the session. These methods are useful for keeping sensitive information such as passwords out of the session:\n\n\n$request-\nflashOnly([\nusername\n, \nemail\n]);\n\n$request-\nflashExcept(\npassword\n);\n\n\n\n\n\nFlashing Input Then Redirecting\n\n\nSince you often will want to flash input to the session and then redirect to the previous page, you may easily chain input flashing onto a redirect using the \nwithInput\n method:\n\n\nreturn redirect(\nform\n)-\nwithInput();\n\nreturn redirect(\nform\n)-\nwithInput(\n    $request-\nexcept(\npassword\n)\n);\n\n\n\n\n\nRetrieving Old Input\n\n\nTo retrieve flashed input from the previous request, use the \nold\n method on the \nRequest\n instance. The \nold\n method will pull the previously flashed input data from the \nsession\n:\n\n\n$username = $request-\nold(\nusername\n);\n\n\n\n\n\nLaravel also provides a global \nold\n helper. If you are displaying old input within a \nBlade template\n, it is more convenient to use the \nold\n helper. If no old input exists for the given field, \nnull\n will be returned:\n\n\ninput type=\ntext\n name=\nusername\n value=\n{{\n \nold\n(\nusername\n)\n \n}}\n\n\n\n\n\n\n\n\nCookies\n\n\nRetrieving Cookies From Requests\n\n\nAll cookies created by the Laravel framework are encrypted and signed with an authentication code, meaning they will be considered invalid if they have been changed by the client. To retrieve a cookie value from the request, use the \ncookie\n method on a \nIlluminate\\Http\\Request\n instance:\n\n\n$value = $request-\ncookie(\nname\n);\n\n\n\n\n\nAttaching Cookies To Responses\n\n\nYou may attach a cookie to an outgoing \nIlluminate\\Http\\Response\n instance using the \ncookie\n method. You should pass the name, value, and number of minutes the cookie should be considered valid to this method:\n\n\nreturn response(\nHello World\n)-\ncookie(\n    \nname\n, \nvalue\n, $minutes\n);\n\n\n\n\n\nThe \ncookie\n method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native \nsetcookie\n method:\n\n\nreturn response(\nHello World\n)-\ncookie(\n    \nname\n, \nvalue\n, $minutes, $path, $domain, $secure, $httpOnly\n);\n\n\n\n\n\nGenerating Cookie Instances\n\n\nIf you would like to generate a \nSymfony\\Component\\HttpFoundation\\Cookie\n instance that can be given to a response instance at a later time, you may use the global \ncookie\n helper. This cookie will not be sent back to the client unless it is attached to a response instance:\n\n\n$cookie = cookie(\nname\n, \nvalue\n, $minutes);\n\nreturn response(\nHello World\n)-\ncookie($cookie);\n\n\n\n\n\n\n\nFiles\n\n\n\n\nRetrieving Uploaded Files\n\n\nYou may access uploaded files from a \nIlluminate\\Http\\Request\n instance using the \nfile\n method or using dynamic properties. The \nfile\n method returns an instance of the \nIlluminate\\Http\\UploadedFile\n class, which extends the PHP \nSplFileInfo\n class and provides a variety of methods for interacting with the file:\n\n\n$file = $request-\nfile(\nphoto\n);\n\n$file = $request-\nphoto;\n\n\n\n\n\nYou may determine if a file is present on the request using the \nhasFile\n method:\n\n\nif ($request-\nhasFile(\nphoto\n)) {\n    //\n}\n\n\n\n\n\nValidating Successful Uploads\n\n\nIn addition to checking if the file is present, you may verify that there were no problems uploading the file via the \nisValid\n method:\n\n\nif ($request-\nfile(\nphoto\n)-\nisValid()) {\n    //\n}\n\n\n\n\n\nFile Paths \n Extensions\n\n\nThe \nUploadedFile\n class also contains methods for accessing the file's fully-qualified path and its extension. The \nextension\n method will attempt to guess the file's extension based on its contents. This extension may be different from the extension that was supplied by the client:\n\n\n$path = $request-\nphoto-\npath();\n\n$extension = $request-\nphoto-\nextension();\n\n\n\n\n\nOther File Methods\n\n\nThere are a variety of other methods available on \nUploadedFile\n instances. Check out the \nAPI documentation for the class\n for more information regarding these methods.\n\n\n\n\nStoring Uploaded Files\n\n\nTo store an uploaded file, you will typically use one of your configured \nfilesystems\n. The \nUploadedFile\n class has a \nstore\n method which will move an uploaded file to one of your disks, which may be a location on your local filesystem or even a cloud storage location like Amazon S3.\n\n\nThe \nstore\n method accepts the path where the file should be stored relative to the filesystem's configured root directory. This path should not contain a file name, since a unique ID will automatically be generated to serve as the file name.\n\n\nThe \nstore\n method also accepts an optional second argument for the name of the disk that should be used to store the file. The method will return the path of the file relative to the disk's root:\n\n\n$path = $request-\nphoto-\nstore(\nimages\n);\n\n$path = $request-\nphoto-\nstore(\nimages\n, \ns3\n);\n\n\n\n\n\nIf you do not want a file name to be automatically generated, you may use the \nstoreAs\n method, which accepts the path, file name, and disk name as its arguments:\n\n\n$path = $request-\nphoto-\nstoreAs(\nimages\n, \nfilename.jpg\n);\n\n$path = $request-\nphoto-\nstoreAs(\nimages\n, \nfilename.jpg\n, \ns3\n);", 
            "title": "Requests"
        }, 
        {
            "location": "/requests/#http-requests", 
            "text": "Accessing The Request  Request Path   Method  PSR-7 Requests    Input Trimming   Normalization  Retrieving Input  Old Input  Cookies    Files  Retrieving Uploaded Files  Storing Uploaded Files", 
            "title": "HTTP Requests"
        }, 
        {
            "location": "/requests/#accessing-the-request", 
            "text": "To obtain an instance of the current HTTP request via dependency injection, you should type-hint the  Illuminate\\Http\\Request  class on your controller method. The incoming request instance will automatically be injected by the  service container :  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Http \\ Request ;  class   UserController   extends   Controller  { \n     /**       * Store a new user.       *       * @param  Request  $request       * @return Response       */ \n     public   function   store ( Request   $request ) \n     { \n         $name   =   $request - input ( name ); \n\n         // \n     }  }", 
            "title": "Accessing The Request"
        }, 
        {
            "location": "/requests/#dependency-injection-route-parameters", 
            "text": "If your controller method is also expecting input from a route parameter you should list your route parameters after your other dependencies. For example, if your route is defined like so:  Route :: put ( user/{id} ,   UserController@update );   You may still type-hint the  Illuminate\\Http\\Request  and access your route parameter  id  by defining your controller method as follows:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Http \\ Request ;  class   UserController   extends   Controller  { \n     /**       * Update the specified user.       *       * @param  Request  $request       * @param  string  $id       * @return Response       */ \n     public   function   update ( Request   $request ,   $id ) \n     { \n         // \n     }  }", 
            "title": "Dependency Injection &amp; Route Parameters"
        }, 
        {
            "location": "/requests/#accessing-the-request-via-route-closures", 
            "text": "You may also type-hint the  Illuminate\\Http\\Request  class on a route Closure. The service container will automatically inject the incoming request into the Closure when it is executed:  use Illuminate\\Http\\Request;\n\nRoute::get( / , function (Request $request) {\n    //\n});", 
            "title": "Accessing The Request Via Route Closures"
        }, 
        {
            "location": "/requests/#request-path-method", 
            "text": "The  Illuminate\\Http\\Request  instance provides a variety of methods for examining the HTTP request for your application and extends the  Symfony\\Component\\HttpFoundation\\Request  class. We will discuss a few of the most important methods below.", 
            "title": "Request Path &amp; Method"
        }, 
        {
            "location": "/requests/#retrieving-the-request-path", 
            "text": "The  path  method returns the request's path information. So, if the incoming request is targeted at  http://domain.com/foo/bar , the  path  method will return  foo/bar :  $uri = $request- path();  The  is  method allows you to verify that the incoming request path matches a given pattern. You may use the  *  character as a wildcard when utilizing this method:  if ($request- is( admin/* )) {\n    //\n}", 
            "title": "Retrieving The Request Path"
        }, 
        {
            "location": "/requests/#retrieving-the-request-url", 
            "text": "To retrieve the full URL for the incoming request you may use the  url  or  fullUrl  methods. The  url  method will return the URL without the query string, while the  fullUrl  method includes the query string:  // Without Query String...\n$url = $request- url();\n\n// With Query String...\n$url = $request- fullUrl();", 
            "title": "Retrieving The Request URL"
        }, 
        {
            "location": "/requests/#retrieving-the-request-method", 
            "text": "The  method  method will return the HTTP verb for the request. You may use the  isMethod  method to verify that the HTTP verb matches a given string:  $method = $request- method();\n\nif ($request- isMethod( post )) {\n    //\n}", 
            "title": "Retrieving The Request Method"
        }, 
        {
            "location": "/requests/#psr-7-requests", 
            "text": "The  PSR-7 standard  specifies interfaces for HTTP messages, including requests and responses. If you would like to obtain an instance of a PSR-7 request instead of a Laravel request, you will first need to install a few libraries. Laravel uses the  Symfony HTTP Message Bridge  component to convert typical Laravel requests and responses into PSR-7 compatible implementations:  composer require symfony/psr-http-message-bridge\ncomposer require zendframework/zend-diactoros  Once you have installed these libraries, you may obtain a PSR-7 request by type-hinting the request interface on your route Closure or controller method:  use Psr\\Http\\Message\\ServerRequestInterface;\n\nRoute::get( / , function (ServerRequestInterface $request) {\n    //\n});   {tip} If you return a PSR-7 response instance from a route or controller, it will automatically be converted back to a Laravel response instance and be displayed by the framework.", 
            "title": "PSR-7 Requests"
        }, 
        {
            "location": "/requests/#input-trimming-normalization", 
            "text": "By default, Laravel includes the  TrimStrings  and  ConvertEmptyStringsToNull  middleware in your application's global middleware stack. These middleware are listed in the stack by the  App\\Http\\Kernel  class. These middleware will automatically trim all incoming string fields on the request, as well as convert any empty string fields to  null . This allows you to not have to worry about these normalization concerns in your routes and controllers.  If you would like to disable this behavior, you may remove the two middleware from your application's middleware stack by removing them from the  $middleware  property of your  App\\Http\\Kernel  class.", 
            "title": "Input Trimming &amp; Normalization"
        }, 
        {
            "location": "/requests/#retrieving-input", 
            "text": "", 
            "title": "Retrieving Input"
        }, 
        {
            "location": "/requests/#retrieving-all-input-data", 
            "text": "You may also retrieve all of the input data as an  array  using the  all  method:  $input = $request- all();", 
            "title": "Retrieving All Input Data"
        }, 
        {
            "location": "/requests/#retrieving-an-input-value", 
            "text": "Using a few simple methods, you may access all of the user input from your  Illuminate\\Http\\Request  instance without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the  input  method may be used to retrieve user input:  $name = $request- input( name );  You may pass a default value as the second argument to the  input  method. This value will be returned if the requested input value is not present on the request:  $name = $request- input( name ,  Sally );  When working with forms that contain array inputs, use \"dot\" notation to access the arrays:  $name = $request- input( products.0.name );\n\n$names = $request- input( products.*.name );", 
            "title": "Retrieving An Input Value"
        }, 
        {
            "location": "/requests/#retrieving-input-via-dynamic-properties", 
            "text": "You may also access user input using dynamic properties on the  Illuminate\\Http\\Request  instance. For example, if one of your application's forms contains a  name  field, you may access the value of the field like so:  $name = $request- name;  When using dynamic properties, Laravel will first look for the parameter's value in the request payload. If it is not present, Laravel will search for the field in the route parameters.", 
            "title": "Retrieving Input Via Dynamic Properties"
        }, 
        {
            "location": "/requests/#retrieving-json-input-values", 
            "text": "When sending JSON requests to your application, you may access the JSON data via the  input  method as long as the  Content-Type  header of the request is properly set to  application/json . You may even use \"dot\" syntax to dig into JSON arrays:  $name = $request- input( user.name );", 
            "title": "Retrieving JSON Input Values"
        }, 
        {
            "location": "/requests/#retrieving-a-portion-of-the-input-data", 
            "text": "If you need to retrieve a subset of the input data, you may use the  only  and  except  methods. Both of these methods accept a single  array  or a dynamic list of arguments:  $input = $request- only([ username ,  password ]);\n\n$input = $request- only( username ,  password );\n\n$input = $request- except([ credit_card ]);\n\n$input = $request- except( credit_card );  The  only  method returns all of the key / value pairs that you request, even if the key is not present on the incoming request. When the key is not present on the request, the value will be  null . If you would like to retrieve a portion of input data that is actually present on the request, you may use the  intersect  method:  $input = $request- intersect([ username ,  password ]);", 
            "title": "Retrieving A Portion Of The Input Data"
        }, 
        {
            "location": "/requests/#determining-if-an-input-value-is-present", 
            "text": "You should use the  has  method to determine if a value is present on the request. The  has  method returns  true  if the value is present and is not an empty string:  if ($request- has( name )) {\n    //\n}", 
            "title": "Determining If An Input Value Is Present"
        }, 
        {
            "location": "/requests/#old-input", 
            "text": "Laravel allows you to keep input from one request during the next request. This feature is particularly useful for re-populating forms after detecting validation errors. However, if you are using Laravel's included  validation features , it is unlikely you will need to manually use these methods, as some of Laravel's built-in validation facilities will call them automatically.", 
            "title": "Old Input"
        }, 
        {
            "location": "/requests/#flashing-input-to-the-session", 
            "text": "The  flash  method on the  Illuminate\\Http\\Request  class will flash the current input to the  session  so that it is available during the user's next request to the application:  $request- flash();  You may also use the  flashOnly  and  flashExcept  methods to flash a subset of the request data to the session. These methods are useful for keeping sensitive information such as passwords out of the session:  $request- flashOnly([ username ,  email ]);\n\n$request- flashExcept( password );", 
            "title": "Flashing Input To The Session"
        }, 
        {
            "location": "/requests/#flashing-input-then-redirecting", 
            "text": "Since you often will want to flash input to the session and then redirect to the previous page, you may easily chain input flashing onto a redirect using the  withInput  method:  return redirect( form )- withInput();\n\nreturn redirect( form )- withInput(\n    $request- except( password )\n);", 
            "title": "Flashing Input Then Redirecting"
        }, 
        {
            "location": "/requests/#retrieving-old-input", 
            "text": "To retrieve flashed input from the previous request, use the  old  method on the  Request  instance. The  old  method will pull the previously flashed input data from the  session :  $username = $request- old( username );  Laravel also provides a global  old  helper. If you are displaying old input within a  Blade template , it is more convenient to use the  old  helper. If no old input exists for the given field,  null  will be returned:  input type= text  name= username  value= {{   old ( username )   }}", 
            "title": "Retrieving Old Input"
        }, 
        {
            "location": "/requests/#cookies", 
            "text": "", 
            "title": "Cookies"
        }, 
        {
            "location": "/requests/#retrieving-cookies-from-requests", 
            "text": "All cookies created by the Laravel framework are encrypted and signed with an authentication code, meaning they will be considered invalid if they have been changed by the client. To retrieve a cookie value from the request, use the  cookie  method on a  Illuminate\\Http\\Request  instance:  $value = $request- cookie( name );", 
            "title": "Retrieving Cookies From Requests"
        }, 
        {
            "location": "/requests/#attaching-cookies-to-responses", 
            "text": "You may attach a cookie to an outgoing  Illuminate\\Http\\Response  instance using the  cookie  method. You should pass the name, value, and number of minutes the cookie should be considered valid to this method:  return response( Hello World )- cookie(\n     name ,  value , $minutes\n);  The  cookie  method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native  setcookie  method:  return response( Hello World )- cookie(\n     name ,  value , $minutes, $path, $domain, $secure, $httpOnly\n);", 
            "title": "Attaching Cookies To Responses"
        }, 
        {
            "location": "/requests/#generating-cookie-instances", 
            "text": "If you would like to generate a  Symfony\\Component\\HttpFoundation\\Cookie  instance that can be given to a response instance at a later time, you may use the global  cookie  helper. This cookie will not be sent back to the client unless it is attached to a response instance:  $cookie = cookie( name ,  value , $minutes);\n\nreturn response( Hello World )- cookie($cookie);", 
            "title": "Generating Cookie Instances"
        }, 
        {
            "location": "/requests/#files", 
            "text": "", 
            "title": "Files"
        }, 
        {
            "location": "/requests/#retrieving-uploaded-files", 
            "text": "You may access uploaded files from a  Illuminate\\Http\\Request  instance using the  file  method or using dynamic properties. The  file  method returns an instance of the  Illuminate\\Http\\UploadedFile  class, which extends the PHP  SplFileInfo  class and provides a variety of methods for interacting with the file:  $file = $request- file( photo );\n\n$file = $request- photo;  You may determine if a file is present on the request using the  hasFile  method:  if ($request- hasFile( photo )) {\n    //\n}", 
            "title": "Retrieving Uploaded Files"
        }, 
        {
            "location": "/requests/#validating-successful-uploads", 
            "text": "In addition to checking if the file is present, you may verify that there were no problems uploading the file via the  isValid  method:  if ($request- file( photo )- isValid()) {\n    //\n}", 
            "title": "Validating Successful Uploads"
        }, 
        {
            "location": "/requests/#file-paths-extensions", 
            "text": "The  UploadedFile  class also contains methods for accessing the file's fully-qualified path and its extension. The  extension  method will attempt to guess the file's extension based on its contents. This extension may be different from the extension that was supplied by the client:  $path = $request- photo- path();\n\n$extension = $request- photo- extension();", 
            "title": "File Paths &amp; Extensions"
        }, 
        {
            "location": "/requests/#other-file-methods", 
            "text": "There are a variety of other methods available on  UploadedFile  instances. Check out the  API documentation for the class  for more information regarding these methods.", 
            "title": "Other File Methods"
        }, 
        {
            "location": "/requests/#storing-uploaded-files", 
            "text": "To store an uploaded file, you will typically use one of your configured  filesystems . The  UploadedFile  class has a  store  method which will move an uploaded file to one of your disks, which may be a location on your local filesystem or even a cloud storage location like Amazon S3.  The  store  method accepts the path where the file should be stored relative to the filesystem's configured root directory. This path should not contain a file name, since a unique ID will automatically be generated to serve as the file name.  The  store  method also accepts an optional second argument for the name of the disk that should be used to store the file. The method will return the path of the file relative to the disk's root:  $path = $request- photo- store( images );\n\n$path = $request- photo- store( images ,  s3 );  If you do not want a file name to be automatically generated, you may use the  storeAs  method, which accepts the path, file name, and disk name as its arguments:  $path = $request- photo- storeAs( images ,  filename.jpg );\n\n$path = $request- photo- storeAs( images ,  filename.jpg ,  s3 );", 
            "title": "Storing Uploaded Files"
        }, 
        {
            "location": "/responses/", 
            "text": "HTTP Responses\n\n\n\n\nCreating Responses\n\n\nAttaching Headers To Responses\n\n\nAttaching Cookies To Responses\n\n\nCookies \n Encryption\n\n\n\n\n\n\nRedirects\n\n\nRedirecting To Named Routes\n\n\nRedirecting To Controller Actions\n\n\nRedirecting With Flashed Session Data\n\n\n\n\n\n\nOther Response Types\n\n\nView Responses\n\n\nJSON Responses\n\n\nFile Downloads\n\n\nFile Responses\n\n\n\n\n\n\nResponse Macros\n\n\n\n\n\n\nCreating Responses\n\n\nStrings \n Arrays\n\n\nAll routes and controllers should return a response to be sent back to the user's browser. Laravel provides several different ways to return responses. The most basic response is simply returning a string from a route or controller. The framework will automatically convert the string into a full HTTP response:\n\n\nRoute::get(\n/\n, function () {\n    return \nHello World\n;\n});\n\n\n\n\n\nIn addition to returning strings from your routes and controllers, you may also return arrays. The framework will automatically convert the array into a JSON response:\n\n\nRoute::get(\n/\n, function () {\n    return [1, 2, 3];\n});\n\n\n\n\n\n\n\n{tip} Did you know you can also return \nEloquent collections\n from your routes or controllers? They will automatically be converted to JSON. Give it a shot!\n\n\n\n\nResponse Objects\n\n\nTypically, you won't just be returning simple strings or arrays from your route actions. Instead, you will be returning full \nIlluminate\\Http\\Response\n instances or \nviews\n.\n\n\nReturning a full \nResponse\n instance allows you to customize the response's HTTP status code and headers. A \nResponse\n instance inherits from the \nSymfony\\Component\\HttpFoundation\\Response\n class, which provides a variety of methods for building HTTP responses:\n\n\nRoute::get(\nhome\n, function () {\n    return response(\nHello World\n, 200)\n                  -\nheader(\nContent-Type\n, \ntext/plain\n);\n});\n\n\n\n\n\n\n\nAttaching Headers To Responses\n\n\nKeep in mind that most response methods are chainable, allowing for the fluent construction of response instances. For example, you may use the \nheader\n method to add a series of headers to the response before sending it back to the user:\n\n\nreturn response($content)\n            -\nheader(\nContent-Type\n, $type)\n            -\nheader(\nX-Header-One\n, \nHeader Value\n)\n            -\nheader(\nX-Header-Two\n, \nHeader Value\n);\n\n\n\n\n\nOr, you may use the \nwithHeaders\n method to specify an array of headers to be added to the response:\n\n\nreturn response($content)\n            -\nwithHeaders([\n                \nContent-Type\n =\n $type,\n                \nX-Header-One\n =\n \nHeader Value\n,\n                \nX-Header-Two\n =\n \nHeader Value\n,\n            ]);\n\n\n\n\n\n\n\nAttaching Cookies To Responses\n\n\nThe \ncookie\n method on response instances allows you to easily attach cookies to the response. For example, you may use the \ncookie\n method to generate a cookie and fluently attach it to the response instance like so:\n\n\nreturn response($content)\n                -\nheader(\nContent-Type\n, $type)\n                -\ncookie(\nname\n, \nvalue\n, $minutes);\n\n\n\n\n\nThe \ncookie\n method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native \nsetcookie\n method:\n\n\n-\ncookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly)\n\n\n\n\n\n\n\nCookies \n Encryption\n\n\nBy default, all cookies generated by Laravel are encrypted and signed so that they can't be modified or read by the client. If you would like to disable encryption for a subset of cookies generated by your application, you may use the \n$except\n property of the \nApp\\Http\\Middleware\\EncryptCookies\n middleware, which is located in the \napp/Http/Middleware\n directory:\n\n\n/**\n\n\n * The names of the cookies that should not be encrypted.\n\n\n *\n\n\n * @var array\n\n\n */\n\nprotected\n \n$\nexcept\n \n=\n \n[\n\n\n    \ncookie_name\n,\n\n\n];\n\n\n\n\n\n\n\n\nRedirects\n\n\nRedirect responses are instances of the \nIlluminate\\Http\\RedirectResponse\n class, and contain the proper headers needed to redirect the user to another URL. There are several ways to generate a \nRedirectResponse\n instance. The simplest method is to use the global \nredirect\n helper:\n\n\nRoute::get(\ndashboard\n, function () {\n    return redirect(\nhome/dashboard\n);\n});\n\n\n\n\n\nSometimes you may wish to redirect the user to their previous location, such as when a submitted form is invalid. You may do so by using the global \nback\n helper function. Since this feature utilizes the \nsession\n, make sure the route calling the \nback\n function is using the \nweb\n middleware group or has all of the session middleware applied:\n\n\nRoute::post(\nuser/profile\n, function () {\n    // Validate the request...\n\n    return back()-\nwithInput();\n});\n\n\n\n\n\n\n\nRedirecting To Named Routes\n\n\nWhen you call the \nredirect\n helper with no parameters, an instance of \nIlluminate\\Routing\\Redirector\n is returned, allowing you to call any method on the \nRedirector\n instance. For example, to generate a \nRedirectResponse\n to a named route, you may use the \nroute\n method:\n\n\nreturn redirect()-\nroute(\nlogin\n);\n\n\n\n\n\nIf your route has parameters, you may pass them as the second argument to the \nroute\n method:\n\n\n// For a route with the following URI: profile/{id}\n\nreturn redirect()-\nroute(\nprofile\n, [\nid\n =\n 1]);\n\n\n\n\n\nPopulating Parameters Via Eloquent Models\n\n\nIf you are redirecting to a route with an \"ID\" parameter that is being populated from an Eloquent model, you may simply pass the model itself. The ID will be extracted automatically:\n\n\n// For a route with the following URI: profile/{id}\n\nreturn redirect()-\nroute(\nprofile\n, [$user]);\n\n\n\n\n\nIf you would like to customize the value that is placed in the route parameter, you should override the \ngetRouteKey\n method on your Eloquent model:\n\n\n/**\n\n\n * Get the value of the model\ns route key.\n\n\n *\n\n\n * @return mixed\n\n\n */\n\npublic\n \nfunction\n \ngetRouteKey\n()\n\n\n{\n\n\n    \nreturn\n \n$\nthis\n-\nslug\n;\n\n\n}\n\n\n\n\n\n\n\n\nRedirecting To Controller Actions\n\n\nYou may also generate redirects to \ncontroller actions\n. To do so, pass the controller and action name to the \naction\n method. Remember, you do not need to specify the full namespace to the controller since Laravel's \nRouteServiceProvider\n will automatically set the base controller namespace:\n\n\nreturn redirect()-\naction(\nHomeController@index\n);\n\n\n\n\n\nIf your controller route requires parameters, you may pass them as the second argument to the \naction\n method:\n\n\nreturn redirect()-\naction(\n    \nUserController@profile\n, [\nid\n =\n 1]\n);\n\n\n\n\n\n\n\nRedirecting With Flashed Session Data\n\n\nRedirecting to a new URL and \nflashing data to the session\n are usually done at the same time. Typically, this is done after successfully performing an action when you flash a success message to the session. For convenience, you may create a \nRedirectResponse\n instance and flash data to the session in a single, fluent method chain:\n\n\nRoute::post(\nuser/profile\n, function () {\n    // Update the user\ns profile...\n\n    return redirect(\ndashboard\n)-\nwith(\nstatus\n, \nProfile updated!\n);\n});\n\n\n\n\n\nAfter the user is redirected, you may display the flashed message from the \nsession\n. For example, using \nBlade syntax\n:\n\n\n@\nif\n \n(\nsession\n(\nstatus\n))\n\n    \ndiv\n \nclass\n=\nalert alert-success\n\n        \n{{\n \nsession\n(\nstatus\n)\n \n}}\n\n    \n/\ndiv\n\n\n@\nendif\n\n\n\n\n\n\n\n\nOther Response Types\n\n\nThe \nresponse\n helper may be used to generate other types of response instances. When the \nresponse\n helper is called without arguments, an implementation of the \nIlluminate\\Contracts\\Routing\\ResponseFactory\n \ncontract\n is returned. This contract provides several helpful methods for generating responses.\n\n\n\n\nView Responses\n\n\nIf you need control over the response's status and headers but also need to return a \nview\n as the response's content, you should use the \nview\n method:\n\n\nreturn response()\n            -\nview(\nhello\n, $data, 200)\n            -\nheader(\nContent-Type\n, $type);\n\n\n\n\n\nOf course, if you do not need to pass a custom HTTP status code or custom headers, you should use the global \nview\n helper function.\n\n\n\n\nJSON Responses\n\n\nThe \njson\n method will automatically set the \nContent-Type\n header to \napplication/json\n, as well as convert the given array to JSON using the \njson_encode\n PHP function:\n\n\nreturn response()-\njson([\n    \nname\n =\n \nAbigail\n,\n    \nstate\n =\n \nCA\n\n]);\n\n\n\n\n\nIf you would like to create a JSONP response, you may use the \njson\n method in combination with the \nwithCallback\n method:\n\n\nreturn response()\n            -\njson([\nname\n =\n \nAbigail\n, \nstate\n =\n \nCA\n])\n            -\nwithCallback($request-\ninput(\ncallback\n));\n\n\n\n\n\n\n\nFile Downloads\n\n\nThe \ndownload\n method may be used to generate a response that forces the user's browser to download the file at the given path. The \ndownload\n method accepts a file name as the second argument to the method, which will determine the file name that is seen by the user downloading the file. Finally, you may pass an array of HTTP headers as the third argument to the method:\n\n\nreturn response()-\ndownload($pathToFile);\n\nreturn response()-\ndownload($pathToFile, $name, $headers);\n\n\n\n\n\n\n\n{note} Symfony HttpFoundation, which manages file downloads, requires the file being downloaded to have an ASCII file name.\n\n\n\n\n\n\nFile Responses\n\n\nThe \nfile\n method may be used to display a file, such as an image or PDF, directly in the user's browser instead of initiating a download. This method accepts the path to the file as its first argument and an array of headers as its second argument:\n\n\nreturn response()-\nfile($pathToFile);\n\nreturn response()-\nfile($pathToFile, $headers);\n\n\n\n\n\n\n\nResponse Macros\n\n\nIf you would like to define a custom response that you can re-use in a variety of your routes and controllers, you may use the \nmacro\n method on the \nResponse\n facade. For example, from a \nservice provider's\n \nboot\n method:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nResponse\n;\n\n\n\nclass\n \nResponseMacroServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Register the application\ns response macros.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nResponse\n::\nmacro\n(\ncaps\n,\n \nfunction\n \n(\n$value\n)\n \n{\n\n            \nreturn\n \nResponse\n::\nmake\n(\nstrtoupper\n(\n$value\n));\n\n        \n});\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe \nmacro\n function accepts a name as its first argument, and a Closure as its second. The macro's Closure will be executed when calling the macro name from a \nResponseFactory\n implementation or the \nresponse\n helper:\n\n\nreturn response()-\ncaps(\nfoo\n);", 
            "title": "Responses"
        }, 
        {
            "location": "/responses/#http-responses", 
            "text": "Creating Responses  Attaching Headers To Responses  Attaching Cookies To Responses  Cookies   Encryption    Redirects  Redirecting To Named Routes  Redirecting To Controller Actions  Redirecting With Flashed Session Data    Other Response Types  View Responses  JSON Responses  File Downloads  File Responses    Response Macros", 
            "title": "HTTP Responses"
        }, 
        {
            "location": "/responses/#creating-responses", 
            "text": "", 
            "title": "Creating Responses"
        }, 
        {
            "location": "/responses/#strings-arrays", 
            "text": "All routes and controllers should return a response to be sent back to the user's browser. Laravel provides several different ways to return responses. The most basic response is simply returning a string from a route or controller. The framework will automatically convert the string into a full HTTP response:  Route::get( / , function () {\n    return  Hello World ;\n});  In addition to returning strings from your routes and controllers, you may also return arrays. The framework will automatically convert the array into a JSON response:  Route::get( / , function () {\n    return [1, 2, 3];\n});   {tip} Did you know you can also return  Eloquent collections  from your routes or controllers? They will automatically be converted to JSON. Give it a shot!", 
            "title": "Strings &amp; Arrays"
        }, 
        {
            "location": "/responses/#response-objects", 
            "text": "Typically, you won't just be returning simple strings or arrays from your route actions. Instead, you will be returning full  Illuminate\\Http\\Response  instances or  views .  Returning a full  Response  instance allows you to customize the response's HTTP status code and headers. A  Response  instance inherits from the  Symfony\\Component\\HttpFoundation\\Response  class, which provides a variety of methods for building HTTP responses:  Route::get( home , function () {\n    return response( Hello World , 200)\n                  - header( Content-Type ,  text/plain );\n});", 
            "title": "Response Objects"
        }, 
        {
            "location": "/responses/#attaching-headers-to-responses", 
            "text": "Keep in mind that most response methods are chainable, allowing for the fluent construction of response instances. For example, you may use the  header  method to add a series of headers to the response before sending it back to the user:  return response($content)\n            - header( Content-Type , $type)\n            - header( X-Header-One ,  Header Value )\n            - header( X-Header-Two ,  Header Value );  Or, you may use the  withHeaders  method to specify an array of headers to be added to the response:  return response($content)\n            - withHeaders([\n                 Content-Type  =  $type,\n                 X-Header-One  =   Header Value ,\n                 X-Header-Two  =   Header Value ,\n            ]);", 
            "title": "Attaching Headers To Responses"
        }, 
        {
            "location": "/responses/#attaching-cookies-to-responses", 
            "text": "The  cookie  method on response instances allows you to easily attach cookies to the response. For example, you may use the  cookie  method to generate a cookie and fluently attach it to the response instance like so:  return response($content)\n                - header( Content-Type , $type)\n                - cookie( name ,  value , $minutes);  The  cookie  method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native  setcookie  method:  - cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly)", 
            "title": "Attaching Cookies To Responses"
        }, 
        {
            "location": "/responses/#cookies-encryption", 
            "text": "By default, all cookies generated by Laravel are encrypted and signed so that they can't be modified or read by the client. If you would like to disable encryption for a subset of cookies generated by your application, you may use the  $except  property of the  App\\Http\\Middleware\\EncryptCookies  middleware, which is located in the  app/Http/Middleware  directory:  /**   * The names of the cookies that should not be encrypted.   *   * @var array   */ \nprotected   $ except   =   [       cookie_name ,  ];", 
            "title": "Cookies &amp; Encryption"
        }, 
        {
            "location": "/responses/#redirects", 
            "text": "Redirect responses are instances of the  Illuminate\\Http\\RedirectResponse  class, and contain the proper headers needed to redirect the user to another URL. There are several ways to generate a  RedirectResponse  instance. The simplest method is to use the global  redirect  helper:  Route::get( dashboard , function () {\n    return redirect( home/dashboard );\n});  Sometimes you may wish to redirect the user to their previous location, such as when a submitted form is invalid. You may do so by using the global  back  helper function. Since this feature utilizes the  session , make sure the route calling the  back  function is using the  web  middleware group or has all of the session middleware applied:  Route::post( user/profile , function () {\n    // Validate the request...\n\n    return back()- withInput();\n});", 
            "title": "Redirects"
        }, 
        {
            "location": "/responses/#redirecting-to-named-routes", 
            "text": "When you call the  redirect  helper with no parameters, an instance of  Illuminate\\Routing\\Redirector  is returned, allowing you to call any method on the  Redirector  instance. For example, to generate a  RedirectResponse  to a named route, you may use the  route  method:  return redirect()- route( login );  If your route has parameters, you may pass them as the second argument to the  route  method:  // For a route with the following URI: profile/{id}\n\nreturn redirect()- route( profile , [ id  =  1]);", 
            "title": "Redirecting To Named Routes"
        }, 
        {
            "location": "/responses/#populating-parameters-via-eloquent-models", 
            "text": "If you are redirecting to a route with an \"ID\" parameter that is being populated from an Eloquent model, you may simply pass the model itself. The ID will be extracted automatically:  // For a route with the following URI: profile/{id}\n\nreturn redirect()- route( profile , [$user]);  If you would like to customize the value that is placed in the route parameter, you should override the  getRouteKey  method on your Eloquent model:  /**   * Get the value of the model s route key.   *   * @return mixed   */ \npublic   function   getRouteKey ()  {       return   $ this - slug ;  }", 
            "title": "Populating Parameters Via Eloquent Models"
        }, 
        {
            "location": "/responses/#redirecting-to-controller-actions", 
            "text": "You may also generate redirects to  controller actions . To do so, pass the controller and action name to the  action  method. Remember, you do not need to specify the full namespace to the controller since Laravel's  RouteServiceProvider  will automatically set the base controller namespace:  return redirect()- action( HomeController@index );  If your controller route requires parameters, you may pass them as the second argument to the  action  method:  return redirect()- action(\n     UserController@profile , [ id  =  1]\n);", 
            "title": "Redirecting To Controller Actions"
        }, 
        {
            "location": "/responses/#redirecting-with-flashed-session-data", 
            "text": "Redirecting to a new URL and  flashing data to the session  are usually done at the same time. Typically, this is done after successfully performing an action when you flash a success message to the session. For convenience, you may create a  RedirectResponse  instance and flash data to the session in a single, fluent method chain:  Route::post( user/profile , function () {\n    // Update the user s profile...\n\n    return redirect( dashboard )- with( status ,  Profile updated! );\n});  After the user is redirected, you may display the flashed message from the  session . For example, using  Blade syntax :  @ if   ( session ( status )) \n     div   class = alert alert-success \n         {{   session ( status )   }} \n     / div  @ endif", 
            "title": "Redirecting With Flashed Session Data"
        }, 
        {
            "location": "/responses/#other-response-types", 
            "text": "The  response  helper may be used to generate other types of response instances. When the  response  helper is called without arguments, an implementation of the  Illuminate\\Contracts\\Routing\\ResponseFactory   contract  is returned. This contract provides several helpful methods for generating responses.", 
            "title": "Other Response Types"
        }, 
        {
            "location": "/responses/#view-responses", 
            "text": "If you need control over the response's status and headers but also need to return a  view  as the response's content, you should use the  view  method:  return response()\n            - view( hello , $data, 200)\n            - header( Content-Type , $type);  Of course, if you do not need to pass a custom HTTP status code or custom headers, you should use the global  view  helper function.", 
            "title": "View Responses"
        }, 
        {
            "location": "/responses/#json-responses", 
            "text": "The  json  method will automatically set the  Content-Type  header to  application/json , as well as convert the given array to JSON using the  json_encode  PHP function:  return response()- json([\n     name  =   Abigail ,\n     state  =   CA \n]);  If you would like to create a JSONP response, you may use the  json  method in combination with the  withCallback  method:  return response()\n            - json([ name  =   Abigail ,  state  =   CA ])\n            - withCallback($request- input( callback ));", 
            "title": "JSON Responses"
        }, 
        {
            "location": "/responses/#file-downloads", 
            "text": "The  download  method may be used to generate a response that forces the user's browser to download the file at the given path. The  download  method accepts a file name as the second argument to the method, which will determine the file name that is seen by the user downloading the file. Finally, you may pass an array of HTTP headers as the third argument to the method:  return response()- download($pathToFile);\n\nreturn response()- download($pathToFile, $name, $headers);   {note} Symfony HttpFoundation, which manages file downloads, requires the file being downloaded to have an ASCII file name.", 
            "title": "File Downloads"
        }, 
        {
            "location": "/responses/#file-responses", 
            "text": "The  file  method may be used to display a file, such as an image or PDF, directly in the user's browser instead of initiating a download. This method accepts the path to the file as its first argument and an array of headers as its second argument:  return response()- file($pathToFile);\n\nreturn response()- file($pathToFile, $headers);", 
            "title": "File Responses"
        }, 
        {
            "location": "/responses/#response-macros", 
            "text": "If you would like to define a custom response that you can re-use in a variety of your routes and controllers, you may use the  macro  method on the  Response  facade. For example, from a  service provider's   boot  method:  ? php  namespace   App \\ Providers ;  use   Illuminate \\ Support \\ ServiceProvider ;  use   Illuminate \\ Support \\ Facades \\ Response ;  class   ResponseMacroServiceProvider   extends   ServiceProvider  { \n     /**       * Register the application s response macros.       *       * @return void       */ \n     public   function   boot () \n     { \n         Response :: macro ( caps ,   function   ( $value )   { \n             return   Response :: make ( strtoupper ( $value )); \n         }); \n     }  }   The  macro  function accepts a name as its first argument, and a Closure as its second. The macro's Closure will be executed when calling the macro name from a  ResponseFactory  implementation or the  response  helper:  return response()- caps( foo );", 
            "title": "Response Macros"
        }, 
        {
            "location": "/routing/", 
            "text": "Routing\n\n\n\n\nBasic Routing\n\n\nRoute Parameters\n\n\nRequired Parameters\n\n\nOptional Parameters\n\n\nRegular Expression Constraints\n\n\n\n\n\n\nNamed Routes\n\n\nRoute Groups\n\n\nMiddleware\n\n\nNamespaces\n\n\nSub-Domain Routing\n\n\nRoute Prefixes\n\n\n\n\n\n\nRoute Model Binding\n\n\nImplicit Binding\n\n\nExplicit Binding\n\n\n\n\n\n\nForm Method Spoofing\n\n\nAccessing The Current Route\n\n\n\n\n\n\nBasic Routing\n\n\nThe most basic Laravel routes simply accept a URI and a \nClosure\n, providing a very simple and expressive method of defining routes:\n\n\nRoute::get(\nfoo\n, function () {\n    return \nHello World\n;\n});\n\n\n\n\n\nThe Default Route Files\n\n\nAll Laravel routes are defined in your route files, which are located in the \nroutes\n directory. These files are automatically loaded by the framework. The \nroutes/web.php\n file defines routes that are for your web interface. These routes are assigned the \nweb\n middleware group, which provides features like session state and CSRF protection. The routes in \nroutes/api.php\n are stateless and are assigned the \napi\n middleware group.\n\n\nFor most applications, you will begin by defining routes in your \nroutes/web.php\n file.\n\n\nAvailable Router Methods\n\n\nThe router allows you to register routes that respond to any HTTP verb:\n\n\nRoute\n::\nget\n($\nuri\n,\n \n$\ncallback\n);\n\n\nRoute\n::\npost\n($\nuri\n,\n \n$\ncallback\n);\n\n\nRoute\n::\nput\n($\nuri\n,\n \n$\ncallback\n);\n\n\nRoute\n::\npatch\n($\nuri\n,\n \n$\ncallback\n);\n\n\nRoute\n::\ndelete\n($\nuri\n,\n \n$\ncallback\n);\n\n\nRoute\n::\noptions\n($\nuri\n,\n \n$\ncallback\n);\n\n\n\n\n\n\nSometimes you may need to register a route that responds to multiple HTTP verbs. You may do so using the \nmatch\n method. Or, you may even register a route that responds to all HTTP verbs using the \nany\n method:\n\n\nRoute::match([\nget\n, \npost\n], \n/\n, function () {\n    //\n});\n\nRoute::any(\nfoo\n, function () {\n    //\n});\n\n\n\n\n\nCSRF Protection\n\n\nAny HTML forms pointing to \nPOST\n, \nPUT\n, or \nDELETE\n routes that are defined in the \nweb\n routes file should include a CSRF token field. Otherwise, the request will be rejected. You can read more about CSRF protection in the \nCSRF documentation\n:\n\n\nform\n \nmethod=\nPOST\n \naction=\n/profile\n\n    \n{{\n \ncsrf_field\n()\n \n}}\n\n    ...\n\n/form\n\n\n\n\n\n\n\n\nRoute Parameters\n\n\n\n\nRequired Parameters\n\n\nOf course, sometimes you will need to capture segments of the URI within your route. For example, you may need to capture a user's ID from the URL. You may do so by defining route parameters:\n\n\nRoute::get(\nuser/{id}\n, function ($id) {\n    return \nUser \n.$id;\n});\n\n\n\n\n\nYou may define as many route parameters as required by your route:\n\n\nRoute::get(\nposts/{post}/comments/{comment}\n, function ($postId, $commentId) {\n    //\n});\n\n\n\n\n\nRoute parameters are always encased within \n{}\n braces and should consist of alphabetic characters. Route parameters may not contain a \n-\n character. Use an underscore (\n_\n) instead.\n\n\n\n\nOptional Parameters\n\n\nOccasionally you may need to specify a route parameter, but make the presence of that route parameter optional. You may do so by placing a \n?\n mark after the parameter name. Make sure to give the route's corresponding variable a default value:\n\n\nRoute::get(\nuser/{name?}\n, function ($name = null) {\n    return $name;\n});\n\nRoute::get(\nuser/{name?}\n, function ($name = \nJohn\n) {\n    return $name;\n});\n\n\n\n\n\n\n\nRegular Expression Constraints\n\n\nYou may constrain the format of your route parameters using the \nwhere\n method on a route instance. The \nwhere\n method accepts the name of the parameter and a regular expression defining how the parameter should be constrained:\n\n\nRoute::get(\nuser/{name}\n, function ($name) {\n    //\n})-\nwhere(\nname\n, \n[A-Za-z]+\n);\n\nRoute::get(\nuser/{id}\n, function ($id) {\n    //\n})-\nwhere(\nid\n, \n[0-9]+\n);\n\nRoute::get(\nuser/{id}/{name}\n, function ($id, $name) {\n    //\n})-\nwhere([\nid\n =\n \n[0-9]+\n, \nname\n =\n \n[a-z]+\n]);\n\n\n\n\n\n\n\nGlobal Constraints\n\n\nIf you would like a route parameter to always be constrained by a given regular expression, you may use the \npattern\n method. You should define these patterns in the \nboot\n method of your \nRouteServiceProvider\n:\n\n\n/**\n\n\n * Define your route model bindings, pattern filters, etc.\n\n\n *\n\n\n * @return void\n\n\n */\n\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n    \nRoute\n:\n:\npattern\n(\nid\n,\n \n[\n0\n-\n9\n]\n+\n);\n\n\n    \nparent\n:\n:\nboot\n();\n\n\n}\n\n\n\n\n\n\nOnce the pattern has been defined, it is automatically applied to all routes using that parameter name:\n\n\nRoute::get(\nuser/{id}\n, function ($id) {\n    // Only executed if {id} is numeric...\n});\n\n\n\n\n\n\n\nNamed Routes\n\n\nNamed routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the \nname\n method onto the route definition:\n\n\nRoute::get(\nuser/profile\n, function () {\n    //\n})-\nname(\nprofile\n);\n\n\n\n\n\nYou may also specify route names for controller actions:\n\n\nRoute\n::\nget\n(\nuser/profile\n,\n \nUserController@showProfile\n)\n-\nname\n(\nprofile\n);\n\n\n\n\n\n\nGenerating URLs To Named Routes\n\n\nOnce you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via the global \nroute\n function:\n\n\n// Generating URLs...\n$url = route(\nprofile\n);\n\n// Generating Redirects...\nreturn redirect()-\nroute(\nprofile\n);\n\n\n\n\n\nIf the named route defines parameters, you may pass the parameters as the second argument to the \nroute\n function. The given parameters will automatically be inserted into the URL in their correct positions:\n\n\nRoute::get(\nuser/{id}/profile\n, function ($id) {\n    //\n})-\nname(\nprofile\n);\n\n$url = route(\nprofile\n, [\nid\n =\n 1]);\n\n\n\n\n\n\n\nRoute Groups\n\n\nRoute groups allow you to share route attributes, such as middleware or namespaces, across a large number of routes without needing to define those attributes on each individual route. Shared attributes are specified in an array format as the first parameter to the \nRoute::group\n method.\n\n\n\n\nMiddleware\n\n\nTo assign middleware to all routes within a group, you may use the \nmiddleware\n key in the group attribute array. Middleware are executed in the order they are listed in the array:\n\n\nRoute::group([\nmiddleware\n =\n \nauth\n], function () {\n    Route::get(\n/\n, function ()    {\n        // Uses Auth Middleware\n    });\n\n    Route::get(\nuser/profile\n, function () {\n        // Uses Auth Middleware\n    });\n});\n\n\n\n\n\n\n\nNamespaces\n\n\nAnother common use-case for route groups is assigning the same PHP namespace to a group of controllers using the \nnamespace\n parameter in the group array:\n\n\nRoute::group([\nnamespace\n =\n \nAdmin\n], function () {\n    // Controllers Within The \nApp\\Http\\Controllers\\Admin\n Namespace\n});\n\n\n\n\n\nRemember, by default, the \nRouteServiceProvider\n includes your route files within a namespace group, allowing you to register controller routes without specifying the full \nApp\\Http\\Controllers\n namespace prefix. So, you only need to specify the portion of the namespace that comes after the base \nApp\\Http\\Controllers\n namespace.\n\n\n\n\nSub-Domain Routing\n\n\nRoute groups may also be used to handle sub-domain routing. Sub-domains may be assigned route parameters just like route URIs, allowing you to capture a portion of the sub-domain for usage in your route or controller. The sub-domain may be specified using the \ndomain\n key on the group attribute array:\n\n\nRoute::group([\ndomain\n =\n \n{account}.myapp.com\n], function () {\n    Route::get(\nuser/{id}\n, function ($account, $id) {\n        //\n    });\n});\n\n\n\n\n\n\n\nRoute Prefixes\n\n\nThe \nprefix\n group attribute may be used to prefix each route in the group with a given URI. For example, you may want to prefix all route URIs within the group with \nadmin\n:\n\n\nRoute::group([\nprefix\n =\n \nadmin\n], function () {\n    Route::get(\nusers\n, function ()    {\n        // Matches The \n/admin/users\n URL\n    });\n});\n\n\n\n\n\n\n\nRoute Model Binding\n\n\nWhen injecting a model ID to a route or controller action, you will often query to retrieve the model that corresponds to that ID. Laravel route model binding provides a convenient way to automatically inject the model instances directly into your routes. For example, instead of injecting a user's ID, you can inject the entire \nUser\n model instance that matches the given ID.\n\n\n\n\nImplicit Binding\n\n\nLaravel automatically resolves Eloquent models defined in routes or controller actions whose type-hinted variable names match a route segment name. For example:\n\n\nRoute::get(\napi/users/{user}\n, function (App\\User $user) {\n    return $user-\nemail;\n});\n\n\n\n\n\nSince the \n$user\n variable is type-hinted as the \nApp\\User\n Eloquent model and the variable name matches the \n{user}\n URI segment, Laravel will automatically inject the model instance that has an ID matching the corresponding value from the request URI. If a matching model instance is not found in the database, a 404 HTTP response will automatically be generated.\n\n\nCustomizing The Key Name\n\n\nIf you would like model binding to use a database column other than \nid\n when retrieving a given model class, you may override the \ngetRouteKeyName\n method on the Eloquent model:\n\n\n/**\n\n\n * Get the route key for the model.\n\n\n *\n\n\n * @return string\n\n\n */\n\npublic\n \nfunction\n \ngetRouteKeyName\n()\n\n\n{\n\n\n    \nreturn\n \nslug\n;\n\n\n}\n\n\n\n\n\n\n\n\nExplicit Binding\n\n\nTo register an explicit binding, use the router's \nmodel\n method to specify the class for a given parameter. You should define your explicit model bindings in the \nboot\n method of the \nRouteServiceProvider\n class:\n\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n    \nparent\n:\n:\nboot\n();\n\n\n    \nRoute\n:\n:\nmodel\n(\nuser\n,\n \nApp\n\\\nUser\n::\nclass\n);\n\n\n}\n\n\n\n\n\n\nNext, define a route that contains a \n{user}\n parameter:\n\n\nRoute::get(\nprofile/{user}\n, function (App\\User $user) {\n    //\n});\n\n\n\n\n\nSince we have bound all \n{user}\n parameters to the \nApp\\User\n model, a \nUser\n instance will be injected into the route. So, for example, a request to \nprofile/1\n will inject the \nUser\n instance from the database which has an ID of \n1\n.\n\n\nIf a matching model instance is not found in the database, a 404 HTTP response will be automatically generated.\n\n\nCustomizing The Resolution Logic\n\n\nIf you wish to use your own resolution logic, you may use the \nRoute::bind\n method. The \nClosure\n you pass to the \nbind\n method will receive the value of the URI segment and should return the instance of the class that should be injected into the route:\n\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n    \nparent\n:\n:\nboot\n();\n\n\n    \nRoute\n:\n:\nbind\n(\nuser\n,\n \nfunction\n \n($\nvalue\n)\n \n{\n\n        \nreturn\n \nApp\n\\\nUser\n::\nwhere\n(\nname\n,\n \n$\nvalue\n)\n-\nfirst\n();\n\n    \n}\n);\n\n\n}\n\n\n\n\n\n\n\n\nForm Method Spoofing\n\n\nHTML forms do not support \nPUT\n, \nPATCH\n or \nDELETE\n actions. So, when defining \nPUT\n, \nPATCH\n or \nDELETE\n routes that are called from an HTML form, you will need to add a hidden \n_method\n field to the form. The value sent with the \n_method\n field will be used as the HTTP request method:\n\n\nform\n \naction=\n/foo/bar\n \nmethod=\nPOST\n\n    \ninput\n \ntype=\nhidden\n \nname=\n_method\n \nvalue=\nPUT\n\n    \ninput\n \ntype=\nhidden\n \nname=\n_token\n \nvalue=\n{{\n \ncsrf_token\n()\n \n}}\n\n\n/form\n\n\n\n\n\n\nYou may use the \nmethod_field\n helper to generate the \n_method\n input:\n\n\n{{\n \nmethod_field\n(\nPUT\n)\n \n}}\n\n\n\n\n\n\n\n\nAccessing The Current Route\n\n\nYou may use the \ncurrent\n, \ncurrentRouteName\n, and \ncurrentRouteAction\n methods on the \nRoute\n facade to access information about the route handling the incoming request:\n\n\n$\nroute\n \n=\n \nRoute\n::\ncurrent\n();\n\n\n\n$\nname\n \n=\n \nRoute\n::\ncurrentRouteName\n();\n\n\n\n$\naction\n \n=\n \nRoute\n::\ncurrentRouteAction\n();\n\n\n\n\n\n\nRefer to the API documentation for both the \nunderlying class of the Route facade\n and \nRoute instance\n to review all accessible methods.", 
            "title": "Routing"
        }, 
        {
            "location": "/routing/#routing", 
            "text": "Basic Routing  Route Parameters  Required Parameters  Optional Parameters  Regular Expression Constraints    Named Routes  Route Groups  Middleware  Namespaces  Sub-Domain Routing  Route Prefixes    Route Model Binding  Implicit Binding  Explicit Binding    Form Method Spoofing  Accessing The Current Route", 
            "title": "Routing"
        }, 
        {
            "location": "/routing/#basic-routing", 
            "text": "The most basic Laravel routes simply accept a URI and a  Closure , providing a very simple and expressive method of defining routes:  Route::get( foo , function () {\n    return  Hello World ;\n});", 
            "title": "Basic Routing"
        }, 
        {
            "location": "/routing/#the-default-route-files", 
            "text": "All Laravel routes are defined in your route files, which are located in the  routes  directory. These files are automatically loaded by the framework. The  routes/web.php  file defines routes that are for your web interface. These routes are assigned the  web  middleware group, which provides features like session state and CSRF protection. The routes in  routes/api.php  are stateless and are assigned the  api  middleware group.  For most applications, you will begin by defining routes in your  routes/web.php  file.", 
            "title": "The Default Route Files"
        }, 
        {
            "location": "/routing/#available-router-methods", 
            "text": "The router allows you to register routes that respond to any HTTP verb:  Route :: get ($ uri ,   $ callback );  Route :: post ($ uri ,   $ callback );  Route :: put ($ uri ,   $ callback );  Route :: patch ($ uri ,   $ callback );  Route :: delete ($ uri ,   $ callback );  Route :: options ($ uri ,   $ callback );   Sometimes you may need to register a route that responds to multiple HTTP verbs. You may do so using the  match  method. Or, you may even register a route that responds to all HTTP verbs using the  any  method:  Route::match([ get ,  post ],  / , function () {\n    //\n});\n\nRoute::any( foo , function () {\n    //\n});", 
            "title": "Available Router Methods"
        }, 
        {
            "location": "/routing/#csrf-protection", 
            "text": "Any HTML forms pointing to  POST ,  PUT , or  DELETE  routes that are defined in the  web  routes file should include a CSRF token field. Otherwise, the request will be rejected. You can read more about CSRF protection in the  CSRF documentation :  form   method= POST   action= /profile \n     {{   csrf_field ()   }} \n    ... /form", 
            "title": "CSRF Protection"
        }, 
        {
            "location": "/routing/#route-parameters", 
            "text": "", 
            "title": "Route Parameters"
        }, 
        {
            "location": "/routing/#required-parameters", 
            "text": "Of course, sometimes you will need to capture segments of the URI within your route. For example, you may need to capture a user's ID from the URL. You may do so by defining route parameters:  Route::get( user/{id} , function ($id) {\n    return  User  .$id;\n});  You may define as many route parameters as required by your route:  Route::get( posts/{post}/comments/{comment} , function ($postId, $commentId) {\n    //\n});  Route parameters are always encased within  {}  braces and should consist of alphabetic characters. Route parameters may not contain a  -  character. Use an underscore ( _ ) instead.", 
            "title": "Required Parameters"
        }, 
        {
            "location": "/routing/#optional-parameters", 
            "text": "Occasionally you may need to specify a route parameter, but make the presence of that route parameter optional. You may do so by placing a  ?  mark after the parameter name. Make sure to give the route's corresponding variable a default value:  Route::get( user/{name?} , function ($name = null) {\n    return $name;\n});\n\nRoute::get( user/{name?} , function ($name =  John ) {\n    return $name;\n});", 
            "title": "Optional Parameters"
        }, 
        {
            "location": "/routing/#regular-expression-constraints", 
            "text": "You may constrain the format of your route parameters using the  where  method on a route instance. The  where  method accepts the name of the parameter and a regular expression defining how the parameter should be constrained:  Route::get( user/{name} , function ($name) {\n    //\n})- where( name ,  [A-Za-z]+ );\n\nRoute::get( user/{id} , function ($id) {\n    //\n})- where( id ,  [0-9]+ );\n\nRoute::get( user/{id}/{name} , function ($id, $name) {\n    //\n})- where([ id  =   [0-9]+ ,  name  =   [a-z]+ ]);", 
            "title": "Regular Expression Constraints"
        }, 
        {
            "location": "/routing/#global-constraints", 
            "text": "If you would like a route parameter to always be constrained by a given regular expression, you may use the  pattern  method. You should define these patterns in the  boot  method of your  RouteServiceProvider :  /**   * Define your route model bindings, pattern filters, etc.   *   * @return void   */  public   function   boot ()  { \n     Route : : pattern ( id ,   [ 0 - 9 ] + ); \n\n     parent : : boot ();  }   Once the pattern has been defined, it is automatically applied to all routes using that parameter name:  Route::get( user/{id} , function ($id) {\n    // Only executed if {id} is numeric...\n});", 
            "title": "Global Constraints"
        }, 
        {
            "location": "/routing/#named-routes", 
            "text": "Named routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the  name  method onto the route definition:  Route::get( user/profile , function () {\n    //\n})- name( profile );  You may also specify route names for controller actions:  Route :: get ( user/profile ,   UserController@showProfile ) - name ( profile );", 
            "title": "Named Routes"
        }, 
        {
            "location": "/routing/#generating-urls-to-named-routes", 
            "text": "Once you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via the global  route  function:  // Generating URLs...\n$url = route( profile );\n\n// Generating Redirects...\nreturn redirect()- route( profile );  If the named route defines parameters, you may pass the parameters as the second argument to the  route  function. The given parameters will automatically be inserted into the URL in their correct positions:  Route::get( user/{id}/profile , function ($id) {\n    //\n})- name( profile );\n\n$url = route( profile , [ id  =  1]);", 
            "title": "Generating URLs To Named Routes"
        }, 
        {
            "location": "/routing/#route-groups", 
            "text": "Route groups allow you to share route attributes, such as middleware or namespaces, across a large number of routes without needing to define those attributes on each individual route. Shared attributes are specified in an array format as the first parameter to the  Route::group  method.", 
            "title": "Route Groups"
        }, 
        {
            "location": "/routing/#middleware", 
            "text": "To assign middleware to all routes within a group, you may use the  middleware  key in the group attribute array. Middleware are executed in the order they are listed in the array:  Route::group([ middleware  =   auth ], function () {\n    Route::get( / , function ()    {\n        // Uses Auth Middleware\n    });\n\n    Route::get( user/profile , function () {\n        // Uses Auth Middleware\n    });\n});", 
            "title": "Middleware"
        }, 
        {
            "location": "/routing/#namespaces", 
            "text": "Another common use-case for route groups is assigning the same PHP namespace to a group of controllers using the  namespace  parameter in the group array:  Route::group([ namespace  =   Admin ], function () {\n    // Controllers Within The  App\\Http\\Controllers\\Admin  Namespace\n});  Remember, by default, the  RouteServiceProvider  includes your route files within a namespace group, allowing you to register controller routes without specifying the full  App\\Http\\Controllers  namespace prefix. So, you only need to specify the portion of the namespace that comes after the base  App\\Http\\Controllers  namespace.", 
            "title": "Namespaces"
        }, 
        {
            "location": "/routing/#sub-domain-routing", 
            "text": "Route groups may also be used to handle sub-domain routing. Sub-domains may be assigned route parameters just like route URIs, allowing you to capture a portion of the sub-domain for usage in your route or controller. The sub-domain may be specified using the  domain  key on the group attribute array:  Route::group([ domain  =   {account}.myapp.com ], function () {\n    Route::get( user/{id} , function ($account, $id) {\n        //\n    });\n});", 
            "title": "Sub-Domain Routing"
        }, 
        {
            "location": "/routing/#route-prefixes", 
            "text": "The  prefix  group attribute may be used to prefix each route in the group with a given URI. For example, you may want to prefix all route URIs within the group with  admin :  Route::group([ prefix  =   admin ], function () {\n    Route::get( users , function ()    {\n        // Matches The  /admin/users  URL\n    });\n});", 
            "title": "Route Prefixes"
        }, 
        {
            "location": "/routing/#route-model-binding", 
            "text": "When injecting a model ID to a route or controller action, you will often query to retrieve the model that corresponds to that ID. Laravel route model binding provides a convenient way to automatically inject the model instances directly into your routes. For example, instead of injecting a user's ID, you can inject the entire  User  model instance that matches the given ID.", 
            "title": "Route Model Binding"
        }, 
        {
            "location": "/routing/#implicit-binding", 
            "text": "Laravel automatically resolves Eloquent models defined in routes or controller actions whose type-hinted variable names match a route segment name. For example:  Route::get( api/users/{user} , function (App\\User $user) {\n    return $user- email;\n});  Since the  $user  variable is type-hinted as the  App\\User  Eloquent model and the variable name matches the  {user}  URI segment, Laravel will automatically inject the model instance that has an ID matching the corresponding value from the request URI. If a matching model instance is not found in the database, a 404 HTTP response will automatically be generated.", 
            "title": "Implicit Binding"
        }, 
        {
            "location": "/routing/#customizing-the-key-name", 
            "text": "If you would like model binding to use a database column other than  id  when retrieving a given model class, you may override the  getRouteKeyName  method on the Eloquent model:  /**   * Get the route key for the model.   *   * @return string   */ \npublic   function   getRouteKeyName ()  {       return   slug ;  }", 
            "title": "Customizing The Key Name"
        }, 
        {
            "location": "/routing/#explicit-binding", 
            "text": "To register an explicit binding, use the router's  model  method to specify the class for a given parameter. You should define your explicit model bindings in the  boot  method of the  RouteServiceProvider  class:  public   function   boot ()  { \n     parent : : boot (); \n\n     Route : : model ( user ,   App \\ User :: class );  }   Next, define a route that contains a  {user}  parameter:  Route::get( profile/{user} , function (App\\User $user) {\n    //\n});  Since we have bound all  {user}  parameters to the  App\\User  model, a  User  instance will be injected into the route. So, for example, a request to  profile/1  will inject the  User  instance from the database which has an ID of  1 .  If a matching model instance is not found in the database, a 404 HTTP response will be automatically generated.", 
            "title": "Explicit Binding"
        }, 
        {
            "location": "/routing/#customizing-the-resolution-logic", 
            "text": "If you wish to use your own resolution logic, you may use the  Route::bind  method. The  Closure  you pass to the  bind  method will receive the value of the URI segment and should return the instance of the class that should be injected into the route:  public   function   boot ()  { \n     parent : : boot (); \n\n     Route : : bind ( user ,   function   ($ value )   { \n         return   App \\ User :: where ( name ,   $ value ) - first (); \n     } );  }", 
            "title": "Customizing The Resolution Logic"
        }, 
        {
            "location": "/routing/#form-method-spoofing", 
            "text": "HTML forms do not support  PUT ,  PATCH  or  DELETE  actions. So, when defining  PUT ,  PATCH  or  DELETE  routes that are called from an HTML form, you will need to add a hidden  _method  field to the form. The value sent with the  _method  field will be used as the HTTP request method:  form   action= /foo/bar   method= POST \n     input   type= hidden   name= _method   value= PUT \n     input   type= hidden   name= _token   value= {{   csrf_token ()   }}  /form   You may use the  method_field  helper to generate the  _method  input:  {{   method_field ( PUT )   }}", 
            "title": "Form Method Spoofing"
        }, 
        {
            "location": "/routing/#accessing-the-current-route", 
            "text": "You may use the  current ,  currentRouteName , and  currentRouteAction  methods on the  Route  facade to access information about the route handling the incoming request:  $ route   =   Route :: current ();  $ name   =   Route :: currentRouteName ();  $ action   =   Route :: currentRouteAction ();   Refer to the API documentation for both the  underlying class of the Route facade  and  Route instance  to review all accessible methods.", 
            "title": "Accessing The Current Route"
        }, 
        {
            "location": "/scheduling/", 
            "text": "Task Scheduling\n\n\n\n\nIntroduction\n\n\nDefining Schedules\n\n\nSchedule Frequency Options\n\n\nPreventing Task Overlaps\n\n\nMaintenance Mode\n\n\n\n\n\n\nTask Output\n\n\nTask Hooks\n\n\n\n\n\n\nIntroduction\n\n\nIn the past, you may have generated a Cron entry for each task you needed to schedule on your server. However, this can quickly become a pain, because your task schedule is no longer in source control and you must SSH into your server to add additional Cron entries.\n\n\nLaravel's command scheduler allows you to fluently and expressively define your command schedule within Laravel itself. When using the scheduler, only a single Cron entry is needed on your server. Your task schedule is defined in the \napp/Console/Kernel.php\n file's \nschedule\n method. To help you get started, a simple example is defined within the method.\n\n\nStarting The Scheduler\n\n\nWhen using the scheduler, you only need to add the following Cron entry to your server. If you do not know how to add Cron entries to your server, consider using a service such as \nLaravel Forge\n which can manage the Cron entries for you:\n\n\n* * * * * php /path/to/artisan schedule:run \n /dev/null 2\n1\n\n\n\n\n\nThis Cron will call the Laravel command scheduler every minute. When the \nschedule:run\n command is executed, Laravel will evaluate your scheduled tasks and runs the tasks that are due.\n\n\n\n\nDefining Schedules\n\n\nYou may define all of your scheduled tasks in the \nschedule\n method of the \nApp\\Console\\Kernel\n class. To get started, let's look at an example of scheduling a task. In this example, we will schedule a \nClosure\n to be called every day at midnight. Within the \nClosure\n we will execute a database query to clear a table:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nConsole\n;\n\n\n\nuse\n \nDB\n;\n\n\nuse\n \nIlluminate\n\\\nConsole\n\\\nScheduling\n\\\nSchedule\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nConsole\n\\\nKernel\n \nas\n \nConsoleKernel\n;\n\n\n\nclass\n \nKernel\n \nextends\n \nConsoleKernel\n\n\n{\n\n    \n/**\n\n\n     * The Artisan commands provided by your application.\n\n\n     *\n\n\n     * @var array\n\n\n     */\n\n    \nprotected\n \n$commands\n \n=\n \n[\n\n        \n\\\nApp\n\\\nConsole\n\\\nCommands\n\\\nInspire\n::\nclass\n,\n\n    \n];\n\n\n    \n/**\n\n\n     * Define the application\ns command schedule.\n\n\n     *\n\n\n     * @param  \\Illuminate\\Console\\Scheduling\\Schedule  $schedule\n\n\n     * @return void\n\n\n     */\n\n    \nprotected\n \nfunction\n \nschedule\n(\nSchedule\n \n$schedule\n)\n\n    \n{\n\n        \n$schedule\n-\ncall\n(\nfunction\n \n()\n \n{\n\n            \nDB\n::\ntable\n(\nrecent_users\n)\n-\ndelete\n();\n\n        \n})\n-\ndaily\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nIn addition to scheduling \nClosure\n calls, you may also schedule \nArtisan commands\n and operating system commands. For example, you may use the \ncommand\n method to schedule an Artisan command using either the command's name or class:\n\n\n$\nschedule-\ncommand\n(\nemails:send --force\n)\n-\ndaily\n();\n\n\n\n$\nschedule-\ncommand\n(\nEmailsCommand\n::\nclass\n,\n \n[\n--force\n]\n)\n-\ndaily\n();\n\n\n\n\n\n\nThe \nexec\n command may be used to issue a command to the operating system:\n\n\n$schedule-\nexec(\nnode /home/forge/script.js\n)-\ndaily();\n\n\n\n\n\n\n\nSchedule Frequency Options\n\n\nOf course, there are a variety of schedules you may assign to your task:\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-\ncron('* * * * * *');\n\n\nRun the task on a custom Cron schedule\n\n\n\n\n\n\n-\neveryMinute();\n\n\nRun the task every minute\n\n\n\n\n\n\n-\neveryFiveMinutes();\n\n\nRun the task every five minutes\n\n\n\n\n\n\n-\neveryTenMinutes();\n\n\nRun the task every ten minutes\n\n\n\n\n\n\n-\neveryThirtyMinutes();\n\n\nRun the task every thirty minutes\n\n\n\n\n\n\n-\nhourly();\n\n\nRun the task every hour\n\n\n\n\n\n\n-\nhourlyAt(17);\n\n\nRun the task every hour at 17 mins past the hour\n\n\n\n\n\n\n-\ndaily();\n\n\nRun the task every day at midnight\n\n\n\n\n\n\n-\ndailyAt('13:00');\n\n\nRun the task every day at 13:00\n\n\n\n\n\n\n-\ntwiceDaily(1, 13);\n\n\nRun the task daily at 1:00 \n 13:00\n\n\n\n\n\n\n-\nweekly();\n\n\nRun the task every week\n\n\n\n\n\n\n-\nmonthly();\n\n\nRun the task every month\n\n\n\n\n\n\n-\nmonthlyOn(4, '15:00');\n\n\nRun the task every month on the 4th at 15:00\n\n\n\n\n\n\n-\nquarterly();\n\n\nRun the task every quarter\n\n\n\n\n\n\n-\nyearly();\n\n\nRun the task every year\n\n\n\n\n\n\n-\ntimezone('America/New_York');\n\n\nSet the timezone\n\n\n\n\n\n\n\n\nThese methods may be combined with additional constraints to create even more finely tuned schedules that only run on certain days of the week. For example, to schedule a command to run weekly on Monday:\n\n\n//\n \nRun\n \nonce\n \nper\n \nweek\n \non\n \nMonday\n \nat\n \n1\n \nPM\n...\n\n\n$\nschedule-\ncall\n(\nfunction\n \n()\n \n{\n\n    \n//\n\n\n}\n)\n-\nweekly\n()\n-\nmondays\n()\n-\nat\n(\n13:00\n);\n\n\n\n//\n \nRun\n \nhourly\n \nfrom\n \n8\n \nAM\n \nto\n \n5\n \nPM\n \non\n \nweekdays\n...\n\n\n$\nschedule-\ncommand\n(\nfoo\n)\n\n          \n-\nweekdays\n()\n\n          \n-\nhourly\n()\n\n          \n-\ntimezone\n(\nAmerica/Chicago\n)\n\n          \n-\nbetween\n(\n8:00\n,\n \n17:00\n);\n\n\n\n\n\n\nBelow is a list of the additional schedule constraints:\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-\nweekdays();\n\n\nLimit the task to weekdays\n\n\n\n\n\n\n-\nsundays();\n\n\nLimit the task to Sunday\n\n\n\n\n\n\n-\nmondays();\n\n\nLimit the task to Monday\n\n\n\n\n\n\n-\ntuesdays();\n\n\nLimit the task to Tuesday\n\n\n\n\n\n\n-\nwednesdays();\n\n\nLimit the task to Wednesday\n\n\n\n\n\n\n-\nthursdays();\n\n\nLimit the task to Thursday\n\n\n\n\n\n\n-\nfridays();\n\n\nLimit the task to Friday\n\n\n\n\n\n\n-\nsaturdays();\n\n\nLimit the task to Saturday\n\n\n\n\n\n\n-\nbetween($start, $end);\n\n\nLimit the task to run between start and end times\n\n\n\n\n\n\n-\nwhen(Closure);\n\n\nLimit the task based on a truth test\n\n\n\n\n\n\n\n\nBetween Time Constraints\n\n\nThe \nbetween\n method may be used to limit the execution of a task based on the time of day:\n\n\n$\nschedule-\ncommand\n(\nreminders:send\n)\n\n                    \n-\nhourly\n()\n\n                    \n-\nbetween\n(\n7:00\n,\n \n22:00\n);\n\n\n\n\n\n\nSimilarly, the \nunlessBetween\n method can be used to exclude the execution of a task for a period of time:\n\n\n$\nschedule-\ncommand\n(\nreminders:send\n)\n\n                    \n-\nhourly\n()\n\n                    \n-\nunlessBetween\n(\n23:00\n,\n \n4:00\n);\n\n\n\n\n\n\nTruth Test Constraints\n\n\nThe \nwhen\n method may be used to limit the execution of a task based on the result of a given truth test. In other words, if the given \nClosure\n returns \ntrue\n, the task will execute as long as no other constraining conditions prevent the task from running:\n\n\n$schedule-\ncommand(\nemails:send\n)-\ndaily()-\nwhen(function () {\n    return true;\n});\n\n\n\n\n\nThe \nskip\n method may be seen as the inverse of \nwhen\n. If the \nskip\n method returns \ntrue\n, the scheduled task will not be executed:\n\n\n$schedule-\ncommand(\nemails:send\n)-\ndaily()-\nskip(function () {\n    return true;\n});\n\n\n\n\n\nWhen using chained \nwhen\n methods, the scheduled command will only execute if all \nwhen\n conditions return \ntrue\n.\n\n\n\n\nPreventing Task Overlaps\n\n\nBy default, scheduled tasks will be run even if the previous instance of the task is still running. To prevent this, you may use the \nwithoutOverlapping\n method:\n\n\n$\nschedule-\ncommand\n(\nemails:send\n)\n-\nwithoutOverlapping\n();\n\n\n\n\n\n\nIn this example, the \nemails:send\n \nArtisan command\n will be run every minute if it is not already running. The \nwithoutOverlapping\n method is especially useful if you have tasks that vary drastically in their execution time, preventing you from predicting exactly how long a given task will take.\n\n\n\n\nMaintenance Mode\n\n\nLaravel's scheduled tasks will not run when Laravel is in \nmaintenance mode\n, since we don't want your tasks to interfere with any unfinished maintenance you may be performing on your server. However, if you would like to force a task to run even in maintenance mode, you may use the \nevenInMaintenanceMode\n method:\n\n\n$\nschedule-\ncommand\n(\nemails:send\n)\n-\nevenInMaintenanceMode\n();\n\n\n\n\n\n\n\n\nTask Output\n\n\nThe Laravel scheduler provides several convenient methods for working with the output generated by scheduled tasks. First, using the \nsendOutputTo\n method, you may send the output to a file for later inspection:\n\n\n$schedule-\ncommand(\nemails:send\n)\n         -\ndaily()\n         -\nsendOutputTo($filePath);\n\n\n\n\n\nIf you would like to append the output to a given file, you may use the \nappendOutputTo\n method:\n\n\n$schedule-\ncommand(\nemails:send\n)\n         -\ndaily()\n         -\nappendOutputTo($filePath);\n\n\n\n\n\nUsing the \nemailOutputTo\n method, you may e-mail the output to an e-mail address of your choice. Before e-mailing the output of a task, you should configure Laravel's \ne-mail services\n:\n\n\n$schedule-\ncommand(\nfoo\n)\n         -\ndaily()\n         -\nsendOutputTo($filePath)\n         -\nemailOutputTo(\nfoo@example.com\n);\n\n\n\n\n\n\n\n{note} The \nemailOutputTo\n, \nsendOutputTo\n and \nappendOutputTo\n methods are exclusive to the \ncommand\n method and are not supported for \ncall\n.\n\n\n\n\n\n\nTask Hooks\n\n\nUsing the \nbefore\n and \nafter\n methods, you may specify code to be executed before and after the scheduled task is complete:\n\n\n$schedule-\ncommand(\nemails:send\n)\n         -\ndaily()\n         -\nbefore(function () {\n             // Task is about to start...\n         })\n         -\nafter(function () {\n             // Task is complete...\n         });\n\n\n\n\n\nPinging URLs\n\n\nUsing the \npingBefore\n and \nthenPing\n methods, the scheduler can automatically ping a given URL before or after a task is complete. This method is useful for notifying an external service, such as \nLaravel Envoyer\n, that your scheduled task is commencing or has finished execution:\n\n\n$schedule-\ncommand(\nemails:send\n)\n         -\ndaily()\n         -\npingBefore($url)\n         -\nthenPing($url);\n\n\n\n\n\nUsing either the \npingBefore($url)\n or \nthenPing($url)\n feature requires the Guzzle HTTP library. You can add Guzzle to your project using the Composer package manager:\n\n\ncomposer require guzzlehttp/guzzle", 
            "title": "Scheduling"
        }, 
        {
            "location": "/scheduling/#task-scheduling", 
            "text": "Introduction  Defining Schedules  Schedule Frequency Options  Preventing Task Overlaps  Maintenance Mode    Task Output  Task Hooks", 
            "title": "Task Scheduling"
        }, 
        {
            "location": "/scheduling/#introduction", 
            "text": "In the past, you may have generated a Cron entry for each task you needed to schedule on your server. However, this can quickly become a pain, because your task schedule is no longer in source control and you must SSH into your server to add additional Cron entries.  Laravel's command scheduler allows you to fluently and expressively define your command schedule within Laravel itself. When using the scheduler, only a single Cron entry is needed on your server. Your task schedule is defined in the  app/Console/Kernel.php  file's  schedule  method. To help you get started, a simple example is defined within the method.", 
            "title": "Introduction"
        }, 
        {
            "location": "/scheduling/#starting-the-scheduler", 
            "text": "When using the scheduler, you only need to add the following Cron entry to your server. If you do not know how to add Cron entries to your server, consider using a service such as  Laravel Forge  which can manage the Cron entries for you:  * * * * * php /path/to/artisan schedule:run   /dev/null 2 1  This Cron will call the Laravel command scheduler every minute. When the  schedule:run  command is executed, Laravel will evaluate your scheduled tasks and runs the tasks that are due.", 
            "title": "Starting The Scheduler"
        }, 
        {
            "location": "/scheduling/#defining-schedules", 
            "text": "You may define all of your scheduled tasks in the  schedule  method of the  App\\Console\\Kernel  class. To get started, let's look at an example of scheduling a task. In this example, we will schedule a  Closure  to be called every day at midnight. Within the  Closure  we will execute a database query to clear a table:  ? php  namespace   App \\ Console ;  use   DB ;  use   Illuminate \\ Console \\ Scheduling \\ Schedule ;  use   Illuminate \\ Foundation \\ Console \\ Kernel   as   ConsoleKernel ;  class   Kernel   extends   ConsoleKernel  { \n     /**       * The Artisan commands provided by your application.       *       * @var array       */ \n     protected   $commands   =   [ \n         \\ App \\ Console \\ Commands \\ Inspire :: class , \n     ]; \n\n     /**       * Define the application s command schedule.       *       * @param  \\Illuminate\\Console\\Scheduling\\Schedule  $schedule       * @return void       */ \n     protected   function   schedule ( Schedule   $schedule ) \n     { \n         $schedule - call ( function   ()   { \n             DB :: table ( recent_users ) - delete (); \n         }) - daily (); \n     }  }   In addition to scheduling  Closure  calls, you may also schedule  Artisan commands  and operating system commands. For example, you may use the  command  method to schedule an Artisan command using either the command's name or class:  $ schedule- command ( emails:send --force ) - daily ();  $ schedule- command ( EmailsCommand :: class ,   [ --force ] ) - daily ();   The  exec  command may be used to issue a command to the operating system:  $schedule- exec( node /home/forge/script.js )- daily();", 
            "title": "Defining Schedules"
        }, 
        {
            "location": "/scheduling/#schedule-frequency-options", 
            "text": "Of course, there are a variety of schedules you may assign to your task:     Method  Description      - cron('* * * * * *');  Run the task on a custom Cron schedule    - everyMinute();  Run the task every minute    - everyFiveMinutes();  Run the task every five minutes    - everyTenMinutes();  Run the task every ten minutes    - everyThirtyMinutes();  Run the task every thirty minutes    - hourly();  Run the task every hour    - hourlyAt(17);  Run the task every hour at 17 mins past the hour    - daily();  Run the task every day at midnight    - dailyAt('13:00');  Run the task every day at 13:00    - twiceDaily(1, 13);  Run the task daily at 1:00   13:00    - weekly();  Run the task every week    - monthly();  Run the task every month    - monthlyOn(4, '15:00');  Run the task every month on the 4th at 15:00    - quarterly();  Run the task every quarter    - yearly();  Run the task every year    - timezone('America/New_York');  Set the timezone     These methods may be combined with additional constraints to create even more finely tuned schedules that only run on certain days of the week. For example, to schedule a command to run weekly on Monday:  //   Run   once   per   week   on   Monday   at   1   PM ...  $ schedule- call ( function   ()   { \n     //  } ) - weekly () - mondays () - at ( 13:00 );  //   Run   hourly   from   8   AM   to   5   PM   on   weekdays ...  $ schedule- command ( foo ) \n           - weekdays () \n           - hourly () \n           - timezone ( America/Chicago ) \n           - between ( 8:00 ,   17:00 );   Below is a list of the additional schedule constraints:     Method  Description      - weekdays();  Limit the task to weekdays    - sundays();  Limit the task to Sunday    - mondays();  Limit the task to Monday    - tuesdays();  Limit the task to Tuesday    - wednesdays();  Limit the task to Wednesday    - thursdays();  Limit the task to Thursday    - fridays();  Limit the task to Friday    - saturdays();  Limit the task to Saturday    - between($start, $end);  Limit the task to run between start and end times    - when(Closure);  Limit the task based on a truth test", 
            "title": "Schedule Frequency Options"
        }, 
        {
            "location": "/scheduling/#between-time-constraints", 
            "text": "The  between  method may be used to limit the execution of a task based on the time of day:  $ schedule- command ( reminders:send ) \n                     - hourly () \n                     - between ( 7:00 ,   22:00 );   Similarly, the  unlessBetween  method can be used to exclude the execution of a task for a period of time:  $ schedule- command ( reminders:send ) \n                     - hourly () \n                     - unlessBetween ( 23:00 ,   4:00 );", 
            "title": "Between Time Constraints"
        }, 
        {
            "location": "/scheduling/#truth-test-constraints", 
            "text": "The  when  method may be used to limit the execution of a task based on the result of a given truth test. In other words, if the given  Closure  returns  true , the task will execute as long as no other constraining conditions prevent the task from running:  $schedule- command( emails:send )- daily()- when(function () {\n    return true;\n});  The  skip  method may be seen as the inverse of  when . If the  skip  method returns  true , the scheduled task will not be executed:  $schedule- command( emails:send )- daily()- skip(function () {\n    return true;\n});  When using chained  when  methods, the scheduled command will only execute if all  when  conditions return  true .", 
            "title": "Truth Test Constraints"
        }, 
        {
            "location": "/scheduling/#preventing-task-overlaps", 
            "text": "By default, scheduled tasks will be run even if the previous instance of the task is still running. To prevent this, you may use the  withoutOverlapping  method:  $ schedule- command ( emails:send ) - withoutOverlapping ();   In this example, the  emails:send   Artisan command  will be run every minute if it is not already running. The  withoutOverlapping  method is especially useful if you have tasks that vary drastically in their execution time, preventing you from predicting exactly how long a given task will take.", 
            "title": "Preventing Task Overlaps"
        }, 
        {
            "location": "/scheduling/#maintenance-mode", 
            "text": "Laravel's scheduled tasks will not run when Laravel is in  maintenance mode , since we don't want your tasks to interfere with any unfinished maintenance you may be performing on your server. However, if you would like to force a task to run even in maintenance mode, you may use the  evenInMaintenanceMode  method:  $ schedule- command ( emails:send ) - evenInMaintenanceMode ();", 
            "title": "Maintenance Mode"
        }, 
        {
            "location": "/scheduling/#task-output", 
            "text": "The Laravel scheduler provides several convenient methods for working with the output generated by scheduled tasks. First, using the  sendOutputTo  method, you may send the output to a file for later inspection:  $schedule- command( emails:send )\n         - daily()\n         - sendOutputTo($filePath);  If you would like to append the output to a given file, you may use the  appendOutputTo  method:  $schedule- command( emails:send )\n         - daily()\n         - appendOutputTo($filePath);  Using the  emailOutputTo  method, you may e-mail the output to an e-mail address of your choice. Before e-mailing the output of a task, you should configure Laravel's  e-mail services :  $schedule- command( foo )\n         - daily()\n         - sendOutputTo($filePath)\n         - emailOutputTo( foo@example.com );   {note} The  emailOutputTo ,  sendOutputTo  and  appendOutputTo  methods are exclusive to the  command  method and are not supported for  call .", 
            "title": "Task Output"
        }, 
        {
            "location": "/scheduling/#task-hooks", 
            "text": "Using the  before  and  after  methods, you may specify code to be executed before and after the scheduled task is complete:  $schedule- command( emails:send )\n         - daily()\n         - before(function () {\n             // Task is about to start...\n         })\n         - after(function () {\n             // Task is complete...\n         });", 
            "title": "Task Hooks"
        }, 
        {
            "location": "/scheduling/#pinging-urls", 
            "text": "Using the  pingBefore  and  thenPing  methods, the scheduler can automatically ping a given URL before or after a task is complete. This method is useful for notifying an external service, such as  Laravel Envoyer , that your scheduled task is commencing or has finished execution:  $schedule- command( emails:send )\n         - daily()\n         - pingBefore($url)\n         - thenPing($url);  Using either the  pingBefore($url)  or  thenPing($url)  feature requires the Guzzle HTTP library. You can add Guzzle to your project using the Composer package manager:  composer require guzzlehttp/guzzle", 
            "title": "Pinging URLs"
        }, 
        {
            "location": "/scout/", 
            "text": "Laravel Scout\n\n\n\n\nIntroduction\n\n\nInstallation\n\n\nQueueing\n\n\nDriver Prerequisites\n\n\n\n\n\n\nConfiguration\n\n\nConfiguring Model Indexes\n\n\nConfiguring Searchable Data\n\n\n\n\n\n\nIndexing\n\n\nBatch Import\n\n\nAdding Records\n\n\nUpdating Records\n\n\nRemoving Records\n\n\nPausing Indexing\n\n\n\n\n\n\nSearching\n\n\nWhere Clauses\n\n\nPagination\n\n\n\n\n\n\nCustom Engines\n\n\n\n\n\n\nIntroduction\n\n\nLaravel Scout provides a simple, driver based solution for adding full-text search to your \nEloquent models\n. Using model observers, Scout will automatically keep your search indexes in sync with your Eloquent records.\n\n\nCurrently, Scout ships with an \nAlgolia\n driver; however, writing custom drivers is simple and you are free to extend Scout with your own search implementations.\n\n\n\n\nInstallation\n\n\nFirst, install the Scout via the Composer package manager:\n\n\ncomposer require laravel/scout\n\n\n\n\n\nNext, you should add the \nScoutServiceProvider\n to the \nproviders\n array of your \nconfig/app.php\n configuration file:\n\n\nLaravel\\Scout\\ScoutServiceProvider::class,\n\n\n\n\n\nAfter registering the Scout service provider, you should publish the Scout configuration using the \nvendor:publish\n Artisan command. This command will publish the \nscout.php\n configuration file to your \nconfig\n directory:\n\n\nphp artisan vendor:publish --provider=\nLaravel\\Scout\\ScoutServiceProvider\n\n\n\n\n\n\nFinally, add the \nLaravel\\Scout\\Searchable\n trait to the model you would like to make searchable. This trait will register a model observer to keep the model in sync with your search driver:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nLaravel\n\\\nScout\n\\\nSearchable\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nPost\n \nextends\n \nModel\n\n\n{\n\n    \nuse\n \nSearchable\n;\n\n\n}\n\n\n\n\n\n\n\n\nQueueing\n\n\nWhile not strictly required to use Scout, you should strongly consider configuring a \nqueue driver\n before using the library. Running a queue worker will allow Scout to queue all operations that sync your model information to your search indexes, providing much better response times for your application's web interface.\n\n\nOnce you have configured a queue driver, set the value of the \nqueue\n option in your \nconfig/scout.php\n configuration file to \ntrue\n:\n\n\nqueue\n =\n true,\n\n\n\n\n\n\n\nDriver Prerequisites\n\n\nAlgolia\n\n\nWhen using the Algolia driver, you should configure your Algolia \nid\n and \nsecret\n credentials in your \nconfig/scout.php\n configuration file. Once your credentials have been configured, you will also need to install the Algolia PHP SDK via the Composer package manager:\n\n\ncomposer require algolia/algoliasearch-client-php\n\n\n\n\n\n\n\nConfiguration\n\n\n\n\nConfiguring Model Indexes\n\n\nEach Eloquent model is synced with a given search \"index\", which contains all of the searchable records for that model. In other words, you can think of each index like a MySQL table. By default, each model will be persisted to an index matching the model's typical \"table\" name. Typically, this is the plural form of the model name; however, you are free to customize the model's index by overriding the \nsearchableAs\n method on the model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nLaravel\n\\\nScout\n\\\nSearchable\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nPost\n \nextends\n \nModel\n\n\n{\n\n    \nuse\n \nSearchable\n;\n\n\n    \n/**\n\n\n     * Get the index name for the model.\n\n\n     *\n\n\n     * @return string\n\n\n     */\n\n    \npublic\n \nfunction\n \nsearchableAs\n()\n\n    \n{\n\n        \nreturn\n \nposts_index\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nConfiguring Searchable Data\n\n\nBy default, the entire \ntoArray\n form of a given model will be persisted to its search index. If you would like to customize the data that is synchronized to the search index, you may override the \ntoSearchableArray\n method on the model:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n;\n\n\n\nuse\n \nLaravel\n\\\nScout\n\\\nSearchable\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nPost\n \nextends\n \nModel\n\n\n{\n\n    \nuse\n \nSearchable\n;\n\n\n    \n/**\n\n\n     * Get the indexable data array for the model.\n\n\n     *\n\n\n     * @return array\n\n\n     */\n\n    \npublic\n \nfunction\n \ntoSearchableArray\n()\n\n    \n{\n\n        \n$array\n \n=\n \n$this\n-\ntoArray\n();\n\n\n        \n// Customize array...\n\n\n        \nreturn\n \n$array\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nIndexing\n\n\n\n\nBatch Import\n\n\nIf you are installing Scout into an existing project, you may already have database records you need to import into your search driver. Scout provides an \nimport\n Artisan command that you may use to import all of your existing records into your search indexes:\n\n\nphp\n \nartisan\n \nscout\n:\nimport\n \nApp\\Post\n\n\n\n\n\n\n\n\nAdding Records\n\n\nOnce you have added the \nLaravel\\Scout\\Searchable\n trait to a model, all you need to do is \nsave\n a model instance and it will automatically be added to your search index. If you have configured Scout to \nuse queues\n this operation will be performed in the background by your queue worker:\n\n\n$order = new App\\Order;\n\n// ...\n\n$order-\nsave();\n\n\n\n\n\nAdding Via Query\n\n\nIf you would like to add a collection of models to your search index via an Eloquent query, you may chain the \nsearchable\n method onto an Eloquent query. The \nsearchable\n method will \nchunk the results\n of the query and add the records to your search index. Again, if you have configured Scout to use queues, all of the chunks will be added in the background by your queue workers:\n\n\n//\n \nAdding\n \nvia\n \nEloquent\n \nquery\n...\n\n\nApp\n\\\nOrder\n::\nwhere\n(\nprice\n,\n \n,\n \n100\n)\n-\nsearchable\n();\n\n\n\n//\n \nYou\n \nmay\n \nalso\n \nadd\n \nrecords\n \nvia\n \nrelationships\n...\n\n\n$\nuser-\norders\n()\n-\nsearchable\n();\n\n\n\n//\n \nYou\n \nmay\n \nalso\n \nadd\n \nrecords\n \nvia\n \ncollections\n...\n\n\n$\norders-\nsearchable\n();\n\n\n\n\n\n\nThe \nsearchable\n method can be considered an \"upsert\" operation. In other words, if the model record is already in your index, it will be updated. If it does not exist in the search index, it will be added to the index.\n\n\n\n\nUpdating Records\n\n\nTo update a searchable model, you only need to update the model instance's properties and \nsave\n the model to your database. Scout will automatically persist the changes to your search index:\n\n\n$\norder\n \n=\n \nApp\n\\\nOrder\n::\nfind\n(\n1\n);\n\n\n\n//\n \nUpdate\n \nthe\n \norder\n...\n\n\n\n$\norder-\nsave\n();\n\n\n\n\n\n\nYou may also use the \nsearchable\n method on an Eloquent query to update a collection of models. If the models do not exist in your search index, they will be created:\n\n\n//\n \nUpdating\n \nvia\n \nEloquent\n \nquery\n...\n\n\nApp\n\\\nOrder\n::\nwhere\n(\nprice\n,\n \n,\n \n100\n)\n-\nsearchable\n();\n\n\n\n//\n \nYou\n \nmay\n \nalso\n \nupdate\n \nvia\n \nrelationships\n...\n\n\n$\nuser-\norders\n()\n-\nsearchable\n();\n\n\n\n//\n \nYou\n \nmay\n \nalso\n \nupdate\n \nvia\n \ncollections\n...\n\n\n$\norders-\nsearchable\n();\n\n\n\n\n\n\n\n\nRemoving Records\n\n\nTo remove a record from your index, simply \ndelete\n the model from the database. This form of removal is even compatible with \nsoft deleted\n models:\n\n\n$\norder\n \n=\n \nApp\n\\\nOrder\n::\nfind\n(\n1\n);\n\n\n\n$\norder-\ndelete\n();\n\n\n\n\n\n\nIf you do not want to retrieve the model before deleting the record, you may use the \nunsearchable\n method on an Eloquent query instance or collection:\n\n\n//\n \nRemoving\n \nvia\n \nEloquent\n \nquery\n...\n\n\nApp\n\\\nOrder\n::\nwhere\n(\nprice\n,\n \n,\n \n100\n)\n-\nunsearchable\n();\n\n\n\n//\n \nYou\n \nmay\n \nalso\n \nremove\n \nvia\n \nrelationships\n...\n\n\n$\nuser-\norders\n()\n-\nunsearchable\n();\n\n\n\n//\n \nYou\n \nmay\n \nalso\n \nremove\n \nvia\n \ncollections\n...\n\n\n$\norders-\nunsearchable\n();\n\n\n\n\n\n\n\n\nPausing Indexing\n\n\nSometimes you may need to perform a batch of Eloquent operations on a model without syncing the model data to your search index. You may do this using the \nwithoutSyncingToSearch\n method. This method accepts a single callback which will be immediately executed. Any model operations that occur within the callback will not be synced to the model's index:\n\n\nApp\\Order::withoutSyncingToSearch(function () {\n    // Perform model actions...\n});\n\n\n\n\n\n\n\nSearching\n\n\nYou may begin searching a model using the \nsearch\n method. The search method accepts a single string that will be used to search your models. You should then chain the \nget\n method onto the search query to retrieve the Eloquent models that match the given search query:\n\n\n$\norders\n \n=\n \nApp\n\\\nOrder\n::\nsearch\n(\nStar Trek\n)\n-\nget\n();\n\n\n\n\n\n\nSince Scout searches return a collection of Eloquent models, you may even return the results directly from a route or controller and they will automatically be converted to JSON:\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\n\nRoute\n::\nget\n(\n/search\n,\n \nfunction\n \n(\nRequest\n \n$\nrequest\n)\n \n{\n\n    \nreturn\n \nApp\\\nOrder\n:\n:\nsearch\n(\n$\nrequest\n-\nsearch\n)\n-\nget\n();\n\n\n}\n);\n\n\n\n\n\n\n\n\nWhere Clauses\n\n\nScout allows you to add simple \"where\" clauses to your search queries. Currently, these clauses only support basic numeric equality checks, and are primarily useful for scoping search queries by a tenant ID. Since a search index is not a relational database, more advanced \"where\" clauses are not currently supported:\n\n\n$\norders\n \n=\n \nApp\n\\\nOrder\n::\nsearch\n(\nStar Trek\n)\n-\nwhere\n(\nuser_id\n,\n \n1\n)\n-\nget\n();\n\n\n\n\n\n\n\n\nPagination\n\n\nIn addition to retrieving a collection of models, you may paginate your search results using the \npaginate\n method. This method will return a \nPaginator\n instance just as if you had \npaginated a traditional Eloquent query\n:\n\n\n$\norders\n \n=\n \nApp\n\\\nOrder\n::\nsearch\n(\nStar Trek\n)\n-\npaginate\n();\n\n\n\n\n\n\nYou may specify how many models to retrieve per page by passing the amount as the first argument to the \npaginate\n method:\n\n\n$\norders\n \n=\n \nApp\n\\\nOrder\n::\nsearch\n(\nStar Trek\n)\n-\npaginate\n(\n15\n);\n\n\n\n\n\n\nOnce you have retrieved the results, you may display the results and render the page links using \nBlade\n just as if you had paginated a traditional Eloquent query:\n\n\ndiv\n \nclass\n=\ncontainer\n\n    \n@\nforeach\n \n(\n$\norders\n \nas\n \n$\norder\n)\n\n        \n{{\n \n$\norder\n-\nprice\n \n}}\n\n    \n@\nendforeach\n\n\n/\ndiv\n\n\n\n{{\n \n$\norders\n-\nlinks\n()\n \n}}\n\n\n\n\n\n\n\n\nCustom Engines\n\n\nWriting The Engine\n\n\nIf one of the built-in Scout search engines doesn't fit your needs, you may write your own custom engine and register it with Scout. Your engine should extend the \nLaravel\\Scout\\Engines\\Engine\n abstract class. This abstract class contains five methods your custom engine must implement:\n\n\nuse Laravel\\Scout\\Builder;\n\nabstract public function update($models);\nabstract public function delete($models);\nabstract public function search(Builder $builder);\nabstract public function paginate(Builder $builder, $perPage, $page);\nabstract public function map($results, $model);\n\n\n\n\n\nYou may find it helpful to review the implementations of these methods on the \nLaravel\\Scout\\Engines\\AlgoliaEngine\n class. This class will provide you with a good starting point for learning how to implement each of these methods in your own engine.\n\n\nRegistering The Engine\n\n\nOnce you have written your custom engine, you may register it with Scout using the \nextend\n method of the Scout engine manager. You should call the \nextend\n method from the \nboot\n method of your \nAppServiceProvider\n or any other service provider used by your application. For example, if you have written a \nMySqlSearchEngine\n, you may register it like so:\n\n\nuse Laravel\\Scout\\EngineManager;\n\n/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    resolve(EngineManager::class)-\nextend(\nmysql\n, function () {\n        return new MySqlSearchEngine;\n    });\n}\n\n\n\n\n\nOnce your engine has been registered, you may specify it as your default Scout \ndriver\n in your \nconfig/scout.php\n configuration file:\n\n\ndriver\n =\n \nmysql\n,", 
            "title": "Scout"
        }, 
        {
            "location": "/scout/#laravel-scout", 
            "text": "Introduction  Installation  Queueing  Driver Prerequisites    Configuration  Configuring Model Indexes  Configuring Searchable Data    Indexing  Batch Import  Adding Records  Updating Records  Removing Records  Pausing Indexing    Searching  Where Clauses  Pagination    Custom Engines", 
            "title": "Laravel Scout"
        }, 
        {
            "location": "/scout/#introduction", 
            "text": "Laravel Scout provides a simple, driver based solution for adding full-text search to your  Eloquent models . Using model observers, Scout will automatically keep your search indexes in sync with your Eloquent records.  Currently, Scout ships with an  Algolia  driver; however, writing custom drivers is simple and you are free to extend Scout with your own search implementations.", 
            "title": "Introduction"
        }, 
        {
            "location": "/scout/#installation", 
            "text": "First, install the Scout via the Composer package manager:  composer require laravel/scout  Next, you should add the  ScoutServiceProvider  to the  providers  array of your  config/app.php  configuration file:  Laravel\\Scout\\ScoutServiceProvider::class,  After registering the Scout service provider, you should publish the Scout configuration using the  vendor:publish  Artisan command. This command will publish the  scout.php  configuration file to your  config  directory:  php artisan vendor:publish --provider= Laravel\\Scout\\ScoutServiceProvider   Finally, add the  Laravel\\Scout\\Searchable  trait to the model you would like to make searchable. This trait will register a model observer to keep the model in sync with your search driver:  ? php  namespace   App ;  use   Laravel \\ Scout \\ Searchable ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Post   extends   Model  { \n     use   Searchable ;  }", 
            "title": "Installation"
        }, 
        {
            "location": "/scout/#queueing", 
            "text": "While not strictly required to use Scout, you should strongly consider configuring a  queue driver  before using the library. Running a queue worker will allow Scout to queue all operations that sync your model information to your search indexes, providing much better response times for your application's web interface.  Once you have configured a queue driver, set the value of the  queue  option in your  config/scout.php  configuration file to  true :  queue  =  true,", 
            "title": "Queueing"
        }, 
        {
            "location": "/scout/#driver-prerequisites", 
            "text": "", 
            "title": "Driver Prerequisites"
        }, 
        {
            "location": "/scout/#algolia", 
            "text": "When using the Algolia driver, you should configure your Algolia  id  and  secret  credentials in your  config/scout.php  configuration file. Once your credentials have been configured, you will also need to install the Algolia PHP SDK via the Composer package manager:  composer require algolia/algoliasearch-client-php", 
            "title": "Algolia"
        }, 
        {
            "location": "/scout/#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/scout/#configuring-model-indexes", 
            "text": "Each Eloquent model is synced with a given search \"index\", which contains all of the searchable records for that model. In other words, you can think of each index like a MySQL table. By default, each model will be persisted to an index matching the model's typical \"table\" name. Typically, this is the plural form of the model name; however, you are free to customize the model's index by overriding the  searchableAs  method on the model:  ? php  namespace   App ;  use   Laravel \\ Scout \\ Searchable ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Post   extends   Model  { \n     use   Searchable ; \n\n     /**       * Get the index name for the model.       *       * @return string       */ \n     public   function   searchableAs () \n     { \n         return   posts_index ; \n     }  }", 
            "title": "Configuring Model Indexes"
        }, 
        {
            "location": "/scout/#configuring-searchable-data", 
            "text": "By default, the entire  toArray  form of a given model will be persisted to its search index. If you would like to customize the data that is synchronized to the search index, you may override the  toSearchableArray  method on the model:  ? php  namespace   App ;  use   Laravel \\ Scout \\ Searchable ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   Post   extends   Model  { \n     use   Searchable ; \n\n     /**       * Get the indexable data array for the model.       *       * @return array       */ \n     public   function   toSearchableArray () \n     { \n         $array   =   $this - toArray (); \n\n         // Customize array... \n\n         return   $array ; \n     }  }", 
            "title": "Configuring Searchable Data"
        }, 
        {
            "location": "/scout/#indexing", 
            "text": "", 
            "title": "Indexing"
        }, 
        {
            "location": "/scout/#batch-import", 
            "text": "If you are installing Scout into an existing project, you may already have database records you need to import into your search driver. Scout provides an  import  Artisan command that you may use to import all of your existing records into your search indexes:  php   artisan   scout : import   App\\Post", 
            "title": "Batch Import"
        }, 
        {
            "location": "/scout/#adding-records", 
            "text": "Once you have added the  Laravel\\Scout\\Searchable  trait to a model, all you need to do is  save  a model instance and it will automatically be added to your search index. If you have configured Scout to  use queues  this operation will be performed in the background by your queue worker:  $order = new App\\Order;\n\n// ...\n\n$order- save();", 
            "title": "Adding Records"
        }, 
        {
            "location": "/scout/#adding-via-query", 
            "text": "If you would like to add a collection of models to your search index via an Eloquent query, you may chain the  searchable  method onto an Eloquent query. The  searchable  method will  chunk the results  of the query and add the records to your search index. Again, if you have configured Scout to use queues, all of the chunks will be added in the background by your queue workers:  //   Adding   via   Eloquent   query ...  App \\ Order :: where ( price ,   ,   100 ) - searchable ();  //   You   may   also   add   records   via   relationships ...  $ user- orders () - searchable ();  //   You   may   also   add   records   via   collections ...  $ orders- searchable ();   The  searchable  method can be considered an \"upsert\" operation. In other words, if the model record is already in your index, it will be updated. If it does not exist in the search index, it will be added to the index.", 
            "title": "Adding Via Query"
        }, 
        {
            "location": "/scout/#updating-records", 
            "text": "To update a searchable model, you only need to update the model instance's properties and  save  the model to your database. Scout will automatically persist the changes to your search index:  $ order   =   App \\ Order :: find ( 1 );  //   Update   the   order ...  $ order- save ();   You may also use the  searchable  method on an Eloquent query to update a collection of models. If the models do not exist in your search index, they will be created:  //   Updating   via   Eloquent   query ...  App \\ Order :: where ( price ,   ,   100 ) - searchable ();  //   You   may   also   update   via   relationships ...  $ user- orders () - searchable ();  //   You   may   also   update   via   collections ...  $ orders- searchable ();", 
            "title": "Updating Records"
        }, 
        {
            "location": "/scout/#removing-records", 
            "text": "To remove a record from your index, simply  delete  the model from the database. This form of removal is even compatible with  soft deleted  models:  $ order   =   App \\ Order :: find ( 1 );  $ order- delete ();   If you do not want to retrieve the model before deleting the record, you may use the  unsearchable  method on an Eloquent query instance or collection:  //   Removing   via   Eloquent   query ...  App \\ Order :: where ( price ,   ,   100 ) - unsearchable ();  //   You   may   also   remove   via   relationships ...  $ user- orders () - unsearchable ();  //   You   may   also   remove   via   collections ...  $ orders- unsearchable ();", 
            "title": "Removing Records"
        }, 
        {
            "location": "/scout/#pausing-indexing", 
            "text": "Sometimes you may need to perform a batch of Eloquent operations on a model without syncing the model data to your search index. You may do this using the  withoutSyncingToSearch  method. This method accepts a single callback which will be immediately executed. Any model operations that occur within the callback will not be synced to the model's index:  App\\Order::withoutSyncingToSearch(function () {\n    // Perform model actions...\n});", 
            "title": "Pausing Indexing"
        }, 
        {
            "location": "/scout/#searching", 
            "text": "You may begin searching a model using the  search  method. The search method accepts a single string that will be used to search your models. You should then chain the  get  method onto the search query to retrieve the Eloquent models that match the given search query:  $ orders   =   App \\ Order :: search ( Star Trek ) - get ();   Since Scout searches return a collection of Eloquent models, you may even return the results directly from a route or controller and they will automatically be converted to JSON:  use   Illuminate \\ Http \\ Request ;  Route :: get ( /search ,   function   ( Request   $ request )   { \n     return   App\\ Order : : search ( $ request - search ) - get ();  } );", 
            "title": "Searching"
        }, 
        {
            "location": "/scout/#where-clauses", 
            "text": "Scout allows you to add simple \"where\" clauses to your search queries. Currently, these clauses only support basic numeric equality checks, and are primarily useful for scoping search queries by a tenant ID. Since a search index is not a relational database, more advanced \"where\" clauses are not currently supported:  $ orders   =   App \\ Order :: search ( Star Trek ) - where ( user_id ,   1 ) - get ();", 
            "title": "Where Clauses"
        }, 
        {
            "location": "/scout/#pagination", 
            "text": "In addition to retrieving a collection of models, you may paginate your search results using the  paginate  method. This method will return a  Paginator  instance just as if you had  paginated a traditional Eloquent query :  $ orders   =   App \\ Order :: search ( Star Trek ) - paginate ();   You may specify how many models to retrieve per page by passing the amount as the first argument to the  paginate  method:  $ orders   =   App \\ Order :: search ( Star Trek ) - paginate ( 15 );   Once you have retrieved the results, you may display the results and render the page links using  Blade  just as if you had paginated a traditional Eloquent query:  div   class = container \n     @ foreach   ( $ orders   as   $ order ) \n         {{   $ order - price   }} \n     @ endforeach  / div  {{   $ orders - links ()   }}", 
            "title": "Pagination"
        }, 
        {
            "location": "/scout/#custom-engines", 
            "text": "", 
            "title": "Custom Engines"
        }, 
        {
            "location": "/scout/#writing-the-engine", 
            "text": "If one of the built-in Scout search engines doesn't fit your needs, you may write your own custom engine and register it with Scout. Your engine should extend the  Laravel\\Scout\\Engines\\Engine  abstract class. This abstract class contains five methods your custom engine must implement:  use Laravel\\Scout\\Builder;\n\nabstract public function update($models);\nabstract public function delete($models);\nabstract public function search(Builder $builder);\nabstract public function paginate(Builder $builder, $perPage, $page);\nabstract public function map($results, $model);  You may find it helpful to review the implementations of these methods on the  Laravel\\Scout\\Engines\\AlgoliaEngine  class. This class will provide you with a good starting point for learning how to implement each of these methods in your own engine.", 
            "title": "Writing The Engine"
        }, 
        {
            "location": "/scout/#registering-the-engine", 
            "text": "Once you have written your custom engine, you may register it with Scout using the  extend  method of the Scout engine manager. You should call the  extend  method from the  boot  method of your  AppServiceProvider  or any other service provider used by your application. For example, if you have written a  MySqlSearchEngine , you may register it like so:  use Laravel\\Scout\\EngineManager;\n\n/**\n * Bootstrap any application services.\n *\n * @return void\n */\npublic function boot()\n{\n    resolve(EngineManager::class)- extend( mysql , function () {\n        return new MySqlSearchEngine;\n    });\n}  Once your engine has been registered, you may specify it as your default Scout  driver  in your  config/scout.php  configuration file:  driver  =   mysql ,", 
            "title": "Registering The Engine"
        }, 
        {
            "location": "/seeding/", 
            "text": "Database: Seeding\n\n\n\n\nIntroduction\n\n\nWriting Seeders\n\n\nUsing Model Factories\n\n\nCalling Additional Seeders\n\n\n\n\n\n\nRunning Seeders\n\n\n\n\n\n\nIntroduction\n\n\nLaravel includes a simple method of seeding your database with test data using seed classes. All seed classes are stored in the \ndatabase/seeds\n directory. Seed classes may have any name you wish, but probably should follow some sensible convention, such as \nUsersTableSeeder\n, etc. By default, a \nDatabaseSeeder\n class is defined for you. From this class, you may use the \ncall\n method to run other seed classes, allowing you to control the seeding order.\n\n\n\n\nWriting Seeders\n\n\nTo generate a seeder, execute the \nmake:seeder\n \nArtisan command\n. All seeders generated by the framework will be placed in the \ndatabase/seeds\n directory:\n\n\nphp artisan make:seeder UsersTableSeeder\n\n\n\n\n\nA seeder class only contains one method by default: \nrun\n. This method is called when the \ndb:seed\n \nArtisan command\n is executed. Within the \nrun\n method, you may insert data into your database however you wish. You may use the \nquery builder\n to manually insert data or you may use \nEloquent model factories\n.\n\n\nAs an example, let's modify the default \nDatabaseSeeder\n class and add a database insert statement to the \nrun\n method:\n\n\n?\nphp\n\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nSeeder\n;\n\n\nuse\n \nIlluminate\n\\\nDatabase\n\\\nEloquent\n\\\nModel\n;\n\n\n\nclass\n \nDatabaseSeeder\n \nextends\n \nSeeder\n\n\n{\n\n    \n/**\n\n\n     * Run the database seeds.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nrun\n()\n\n    \n{\n\n        \nDB\n::\ntable\n(\nusers\n)\n-\ninsert\n([\n\n            \nname\n \n=\n \nstr_random\n(\n10\n),\n\n            \nemail\n \n=\n \nstr_random\n(\n10\n).\n@gmail.com\n,\n\n            \npassword\n \n=\n \nbcrypt\n(\nsecret\n),\n\n        \n]);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nUsing Model Factories\n\n\nOf course, manually specifying the attributes for each model seed is cumbersome. Instead, you can use \nmodel factories\n to conveniently generate large amounts of database records. First, review the \nmodel factory documentation\n to learn how to define your factories. Once you have defined your factories, you may use the \nfactory\n helper function to insert records into your database.\n\n\nFor example, let's create 50 users and attach a relationship to each user:\n\n\n/**\n\n\n * Run the database seeds.\n\n\n *\n\n\n * @return void\n\n\n */\n\n\npublic\n \nfunction\n \nrun\n()\n\n\n{\n\n    \nfactory(App\\\nUser\n:\n:\nclass\n,\n \n50\n)\n-\ncreate\n()\n-\neach\n(\nfunction\n \n($\nu\n)\n \n{\n\n        \n$\nu-\nposts\n()\n-\nsave\n(\nfactory\n(\nApp\n\\\nPost\n::\nclass\n)\n-\nmake\n());\n\n    \n}\n);\n\n\n}\n\n\n\n\n\n\n\n\nCalling Additional Seeders\n\n\nWithin the \nDatabaseSeeder\n class, you may use the \ncall\n method to execute additional seed classes. Using the \ncall\n method allows you to break up your database seeding into multiple files so that no single seeder class becomes overwhelmingly large. Simply pass the name of the seeder class you wish to run:\n\n\n/**\n\n\n * Run the database seeds.\n\n\n *\n\n\n * @return void\n\n\n */\n\n\npublic\n \nfunction\n \nrun\n()\n\n\n{\n\n    \n$this-\ncall(\nUsersTableSeeder\n:\n:\nclass\n);\n\n    \n$this-\ncall(\nPostsTableSeeder\n:\n:\nclass\n);\n\n    \n$this-\ncall(\nCommentsTableSeeder\n:\n:\nclass\n);\n\n\n}\n\n\n\n\n\n\n\n\nRunning Seeders\n\n\nOnce you have written your seeder classes, you may use the \ndb:seed\n Artisan command to seed your database. By default, the \ndb:seed\n command runs the \nDatabaseSeeder\n class, which may be used to call other seed classes. However, you may use the \n--class\n option to specify a specific seeder class to run individually:\n\n\nphp artisan db:seed\n\nphp artisan db:seed --class=UsersTableSeeder\n\n\n\n\n\nYou may also seed your database using the \nmigrate:refresh\n command, which will also rollback and re-run all of your migrations. This command is useful for completely re-building your database:\n\n\nphp artisan migrate:refresh --seed", 
            "title": "Seeding"
        }, 
        {
            "location": "/seeding/#database-seeding", 
            "text": "Introduction  Writing Seeders  Using Model Factories  Calling Additional Seeders    Running Seeders", 
            "title": "Database: Seeding"
        }, 
        {
            "location": "/seeding/#introduction", 
            "text": "Laravel includes a simple method of seeding your database with test data using seed classes. All seed classes are stored in the  database/seeds  directory. Seed classes may have any name you wish, but probably should follow some sensible convention, such as  UsersTableSeeder , etc. By default, a  DatabaseSeeder  class is defined for you. From this class, you may use the  call  method to run other seed classes, allowing you to control the seeding order.", 
            "title": "Introduction"
        }, 
        {
            "location": "/seeding/#writing-seeders", 
            "text": "To generate a seeder, execute the  make:seeder   Artisan command . All seeders generated by the framework will be placed in the  database/seeds  directory:  php artisan make:seeder UsersTableSeeder  A seeder class only contains one method by default:  run . This method is called when the  db:seed   Artisan command  is executed. Within the  run  method, you may insert data into your database however you wish. You may use the  query builder  to manually insert data or you may use  Eloquent model factories .  As an example, let's modify the default  DatabaseSeeder  class and add a database insert statement to the  run  method:  ? php  use   Illuminate \\ Database \\ Seeder ;  use   Illuminate \\ Database \\ Eloquent \\ Model ;  class   DatabaseSeeder   extends   Seeder  { \n     /**       * Run the database seeds.       *       * @return void       */ \n     public   function   run () \n     { \n         DB :: table ( users ) - insert ([ \n             name   =   str_random ( 10 ), \n             email   =   str_random ( 10 ). @gmail.com , \n             password   =   bcrypt ( secret ), \n         ]); \n     }  }", 
            "title": "Writing Seeders"
        }, 
        {
            "location": "/seeding/#using-model-factories", 
            "text": "Of course, manually specifying the attributes for each model seed is cumbersome. Instead, you can use  model factories  to conveniently generate large amounts of database records. First, review the  model factory documentation  to learn how to define your factories. Once you have defined your factories, you may use the  factory  helper function to insert records into your database.  For example, let's create 50 users and attach a relationship to each user:  /**   * Run the database seeds.   *   * @return void   */  public   function   run ()  { \n     factory(App\\ User : : class ,   50 ) - create () - each ( function   ($ u )   { \n         $ u- posts () - save ( factory ( App \\ Post :: class ) - make ()); \n     } );  }", 
            "title": "Using Model Factories"
        }, 
        {
            "location": "/seeding/#calling-additional-seeders", 
            "text": "Within the  DatabaseSeeder  class, you may use the  call  method to execute additional seed classes. Using the  call  method allows you to break up your database seeding into multiple files so that no single seeder class becomes overwhelmingly large. Simply pass the name of the seeder class you wish to run:  /**   * Run the database seeds.   *   * @return void   */  public   function   run ()  { \n     $this- call( UsersTableSeeder : : class ); \n     $this- call( PostsTableSeeder : : class ); \n     $this- call( CommentsTableSeeder : : class );  }", 
            "title": "Calling Additional Seeders"
        }, 
        {
            "location": "/seeding/#running-seeders", 
            "text": "Once you have written your seeder classes, you may use the  db:seed  Artisan command to seed your database. By default, the  db:seed  command runs the  DatabaseSeeder  class, which may be used to call other seed classes. However, you may use the  --class  option to specify a specific seeder class to run individually:  php artisan db:seed\n\nphp artisan db:seed --class=UsersTableSeeder  You may also seed your database using the  migrate:refresh  command, which will also rollback and re-run all of your migrations. This command is useful for completely re-building your database:  php artisan migrate:refresh --seed", 
            "title": "Running Seeders"
        }, 
        {
            "location": "/session/", 
            "text": "HTTP Session\n\n\n\n\nIntroduction\n\n\nConfiguration\n\n\nDriver Prerequisites\n\n\n\n\n\n\nUsing The Session\n\n\nRetrieving Data\n\n\nStoring Data\n\n\nFlash Data\n\n\nDeleting Data\n\n\nRegenerating The Session ID\n\n\n\n\n\n\nAdding Custom Session Drivers\n\n\nImplementing The Driver\n\n\nRegistering The Driver\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nSince HTTP driven applications are stateless, sessions provide a way to store information about the user across multiple requests. Laravel ships with a variety of session backends that are accessed through an expressive, unified API. Support for popular backends such as \nMemcached\n, \nRedis\n, and databases is included out of the box.\n\n\n\n\nConfiguration\n\n\nThe session configuration file is stored at \nconfig/session.php\n. Be sure to review the options available to you in this file. By default, Laravel is configured to use the \nfile\n session driver, which will work well for many applications. In production applications, you may consider using the \nmemcached\n or \nredis\n drivers for even faster session performance.\n\n\nThe session \ndriver\n configuration option defines where session data will be stored for each request. Laravel ships with several great drivers out of the box:\n\n\n\n- `file` - sessions are stored in `storage/framework/sessions`.\n- `cookie` - sessions are stored in secure, encrypted cookies.\n- `database` - sessions are stored in a relational database.\n- `memcached` / `redis` - sessions are stored in one of these fast, cache based stores.\n- `array` - sessions are stored in a PHP array and will not be persisted.\n\n\n\n\n\n\n{tip} The array driver is used during \ntesting\n and prevents the data stored in the session from being persisted.\n\n\n\n\n\n\nDriver Prerequisites\n\n\nDatabase\n\n\nWhen using the \ndatabase\n session driver, you will need to create a table to contain the session items. Below is an example \nSchema\n declaration for the table:\n\n\nSchema::create(\nsessions\n, function ($table) {\n    $table-\nstring(\nid\n)-\nunique();\n    $table-\ninteger(\nuser_id\n)-\nnullable();\n    $table-\nstring(\nip_address\n, 45)-\nnullable();\n    $table-\ntext(\nuser_agent\n)-\nnullable();\n    $table-\ntext(\npayload\n);\n    $table-\ninteger(\nlast_activity\n);\n});\n\n\n\n\n\nYou may use the \nsession:table\n Artisan command to generate this migration:\n\n\nphp artisan session:table\n\nphp artisan migrate\n\n\n\n\n\nRedis\n\n\nBefore using Redis sessions with Laravel, you will need to install the \npredis/predis\n package (~1.0) via Composer. You may configure your Redis connections in the \ndatabase\n configuration file. In the \nsession\n configuration file, the \nconnection\n option may be used to specify which Redis connection is used by the session.\n\n\n\n\nUsing The Session\n\n\n\n\nRetrieving Data\n\n\nThere are two primary ways of working with session data in Laravel: the global \nsession\n helper and via a \nRequest\n instance. First, let's look at accessing the session via a \nRequest\n instance, which can be type-hinted on a controller method. Remember, controller method dependencies are automatically injected via the Laravel \nservice container\n:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nUserController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Show the profile for the given user.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @param  int  $id\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nshow\n(\nRequest\n \n$request\n,\n \n$id\n)\n\n    \n{\n\n        \n$value\n \n=\n \n$request\n-\nsession\n()\n-\nget\n(\nkey\n);\n\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nWhen you retrieve a value from the session, you may also pass a default value as the second argument to the \nget\n method. This default value will be returned if the specified key does not exist in the session. If you pass a \nClosure\n as the default value to the \nget\n method and the requested key does not exist, the \nClosure\n will be executed and its result returned:\n\n\n$value = $request-\nsession()-\nget(\nkey\n, \ndefault\n);\n\n$value = $request-\nsession()-\nget(\nkey\n, function () {\n    return \ndefault\n;\n});\n\n\n\n\n\nThe Global Session Helper\n\n\nYou may also use the global \nsession\n PHP function to retrieve and store data in the session. When the \nsession\n helper is called with a single, string argument, it will return the value of that session key. When the helper is called with an array of key / value pairs, those values will be stored in the session:\n\n\nRoute::get(\nhome\n, function () {\n    // Retrieve a piece of data from the session...\n    $value = session(\nkey\n);\n\n    // Specifying a default value...\n    $value = session(\nkey\n, \ndefault\n);\n\n    // Store a piece of data in the session...\n    session([\nkey\n =\n \nvalue\n]);\n});\n\n\n\n\n\n\n\n{tip} There is little practical difference between using the session via an HTTP request instance versus using the global \nsession\n helper. Both methods are \ntestable\n via the \nassertSessionHas\n method which is available in all of your test cases.\n\n\n\n\nRetrieving All Session Data\n\n\nIf you would like to retrieve all the data in the session, you may use the \nall\n method:\n\n\n$data = $request-\nsession()-\nall();\n\n\n\n\n\nDetermining If An Item Exists In The Session\n\n\nTo determine if a value is present in the session, you may use the \nhas\n method. The \nhas\n method returns \ntrue\n if the value is present and is not \nnull\n:\n\n\nif ($request-\nsession()-\nhas(\nusers\n)) {\n    //\n}\n\n\n\n\n\nTo determine if a value is present in the session, even if its value is \nnull\n, you may use the \nexists\n method. The \nexists\n method returns \ntrue\n if the value is present:\n\n\nif ($request-\nsession()-\nexists(\nusers\n)) {\n    //\n}\n\n\n\n\n\n\n\nStoring Data\n\n\nTo store data in the session, you will typically use the \nput\n method or the \nsession\n helper:\n\n\n// Via a request instance...\n$request-\nsession()-\nput(\nkey\n, \nvalue\n);\n\n// Via the global helper...\nsession([\nkey\n =\n \nvalue\n]);\n\n\n\n\n\nPushing To Array Session Values\n\n\nThe \npush\n method may be used to push a new value onto a session value that is an array. For example, if the \nuser.teams\n key contains an array of team names, you may push a new value onto the array like so:\n\n\n$request-\nsession()-\npush(\nuser.teams\n, \ndevelopers\n);\n\n\n\n\n\nRetrieving \n Deleting An Item\n\n\nThe \npull\n method will retrieve and delete an item from the session in a single statement:\n\n\n$value = $request-\nsession()-\npull(\nkey\n, \ndefault\n);\n\n\n\n\n\n\n\nFlash Data\n\n\nSometimes you may wish to store items in the session only for the next request. You may do so using the \nflash\n method. Data stored in the session using this method will only be available during the subsequent HTTP request, and then will be deleted. Flash data is primarily useful for short-lived status messages:\n\n\n$request-\nsession()-\nflash(\nstatus\n, \nTask was successful!\n);\n\n\n\n\n\nIf you need to keep your flash data around for several requests, you may use the \nreflash\n method, which will keep all of the flash data for an additional request. If you only need to keep specific flash data, you may use the \nkeep\n method:\n\n\n$request-\nsession()-\nreflash();\n\n$request-\nsession()-\nkeep([\nusername\n, \nemail\n]);\n\n\n\n\n\n\n\nDeleting Data\n\n\nThe \nforget\n method will remove a piece of data from the session. If you would like to remove all data from the session, you may use the \nflush\n method:\n\n\n$request-\nsession()-\nforget(\nkey\n);\n\n$request-\nsession()-\nflush();\n\n\n\n\n\n\n\nRegenerating The Session ID\n\n\nRegenerating the session ID is often done in order to prevent malicious users from exploiting a \nsession fixation\n attack on your application.\n\n\nLaravel automatically regenerates the session ID during authentication if you are using the built-in \nLoginController\n; however, if you need to manually regenerate the session ID, you may use the \nregenerate\n method.\n\n\n$request-\nsession()-\nregenerate();\n\n\n\n\n\n\n\nAdding Custom Session Drivers\n\n\n\n\nImplementing The Driver\n\n\nYour custom session driver should implement the \nSessionHandlerInterface\n. This interface contains just a few simple methods we need to implement. A stubbed MongoDB implementation looks something like this:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nExtensions\n;\n\n\n\nclass\n \nMongoHandler\n \nimplements\n \nSessionHandlerInterface\n\n\n{\n\n    \npublic\n \nfunction\n \nopen\n(\n$savePath\n,\n \n$sessionName\n)\n \n{}\n\n    \npublic\n \nfunction\n \nclose() {\n}\n\n    \npublic\n \nfunction\n \nread\n(\n$sessionId\n)\n \n{}\n\n    \npublic\n \nfunction\n \nwrite\n(\n$sessionId\n,\n \n$data\n)\n \n{}\n\n    \npublic\n \nfunction\n \ndestroy\n(\n$sessionId\n)\n \n{}\n\n    \npublic\n \nfunction\n \ngc\n(\n$lifetime\n)\n \n{}\n\n\n}\n\n\n\n\n\n\n\n\n{tip} Laravel does not ship with a directory to contain your extensions. You are free to place them anywhere you like. In this example, we have created an \nExtensions\n directory to house the \nMongoHandler\n.\n\n\n\n\nSince the purpose of these methods is not readily understandable, let's quickly cover what each of the methods do:\n\n\n\n- The `open` method would typically be used in file based session store systems. Since Laravel ships with a `file` session driver, you will almost never need to put anything in this method. You can leave it as an empty stub. It is simply a fact of poor interface design (which we'll discuss later) that PHP requires us to implement this method.\n- The `close` method, like the `open` method, can also usually be disregarded. For most drivers, it is not needed.\n- The `read` method should return the string version of the session data associated with the given `$sessionId`. There is no need to do any serialization or other encoding when retrieving or storing session data in your driver, as Laravel will perform the serialization for you.\n- The `write` method should write the given `$data` string associated with the `$sessionId` to some persistent storage system, such as MongoDB, Dynamo, etc.  Again, you should not perform any serialization - Laravel will have already handled that for you.\n- The `destroy` method should remove the data associated with the `$sessionId` from persistent storage.\n- The `gc` method should destroy all session data that is older than the given `$lifetime`, which is a UNIX timestamp. For self-expiring systems like Memcached and Redis, this method may be left empty.\n\n\n\n\n\n\nRegistering The Driver\n\n\nOnce your driver has been implemented, you are ready to register it with the framework. To add additional drivers to Laravel's session backend, you may use the \nextend\n method on the \nSession\n \nfacade\n. You should call the \nextend\n method from the \nboot\n method of a \nservice provider\n. You may do this from the existing \nAppServiceProvider\n or create an entirely new provider:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nApp\n\\\nExtensions\n\\\nMongoSessionStore\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nSession\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\n\nclass\n \nSessionServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Perform post-registration booting of services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nSession\n::\nextend\n(\nmongo\n,\n \nfunction\n \n(\n$app\n)\n \n{\n\n            \n// Return implementation of SessionHandlerInterface...\n\n            \nreturn\n \nnew\n \nMongoSessionStore\n;\n\n        \n});\n\n    \n}\n\n\n    \n/**\n\n\n     * Register bindings in the container.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOnce the session driver has been registered, you may use the \nmongo\n driver in your \nconfig/session.php\n configuration file.", 
            "title": "Session"
        }, 
        {
            "location": "/session/#http-session", 
            "text": "Introduction  Configuration  Driver Prerequisites    Using The Session  Retrieving Data  Storing Data  Flash Data  Deleting Data  Regenerating The Session ID    Adding Custom Session Drivers  Implementing The Driver  Registering The Driver", 
            "title": "HTTP Session"
        }, 
        {
            "location": "/session/#introduction", 
            "text": "Since HTTP driven applications are stateless, sessions provide a way to store information about the user across multiple requests. Laravel ships with a variety of session backends that are accessed through an expressive, unified API. Support for popular backends such as  Memcached ,  Redis , and databases is included out of the box.", 
            "title": "Introduction"
        }, 
        {
            "location": "/session/#configuration", 
            "text": "The session configuration file is stored at  config/session.php . Be sure to review the options available to you in this file. By default, Laravel is configured to use the  file  session driver, which will work well for many applications. In production applications, you may consider using the  memcached  or  redis  drivers for even faster session performance.  The session  driver  configuration option defines where session data will be stored for each request. Laravel ships with several great drivers out of the box:  \n- `file` - sessions are stored in `storage/framework/sessions`.\n- `cookie` - sessions are stored in secure, encrypted cookies.\n- `database` - sessions are stored in a relational database.\n- `memcached` / `redis` - sessions are stored in one of these fast, cache based stores.\n- `array` - sessions are stored in a PHP array and will not be persisted.   {tip} The array driver is used during  testing  and prevents the data stored in the session from being persisted.", 
            "title": "Configuration"
        }, 
        {
            "location": "/session/#driver-prerequisites", 
            "text": "", 
            "title": "Driver Prerequisites"
        }, 
        {
            "location": "/session/#database", 
            "text": "When using the  database  session driver, you will need to create a table to contain the session items. Below is an example  Schema  declaration for the table:  Schema::create( sessions , function ($table) {\n    $table- string( id )- unique();\n    $table- integer( user_id )- nullable();\n    $table- string( ip_address , 45)- nullable();\n    $table- text( user_agent )- nullable();\n    $table- text( payload );\n    $table- integer( last_activity );\n});  You may use the  session:table  Artisan command to generate this migration:  php artisan session:table\n\nphp artisan migrate", 
            "title": "Database"
        }, 
        {
            "location": "/session/#redis", 
            "text": "Before using Redis sessions with Laravel, you will need to install the  predis/predis  package (~1.0) via Composer. You may configure your Redis connections in the  database  configuration file. In the  session  configuration file, the  connection  option may be used to specify which Redis connection is used by the session.", 
            "title": "Redis"
        }, 
        {
            "location": "/session/#using-the-session", 
            "text": "", 
            "title": "Using The Session"
        }, 
        {
            "location": "/session/#retrieving-data", 
            "text": "There are two primary ways of working with session data in Laravel: the global  session  helper and via a  Request  instance. First, let's look at accessing the session via a  Request  instance, which can be type-hinted on a controller method. Remember, controller method dependencies are automatically injected via the Laravel  service container :  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Http \\ Request ;  use   App \\ Http \\ Controllers \\ Controller ;  class   UserController   extends   Controller  { \n     /**       * Show the profile for the given user.       *       * @param  Request  $request       * @param  int  $id       * @return Response       */ \n     public   function   show ( Request   $request ,   $id ) \n     { \n         $value   =   $request - session () - get ( key ); \n\n         // \n     }  }   When you retrieve a value from the session, you may also pass a default value as the second argument to the  get  method. This default value will be returned if the specified key does not exist in the session. If you pass a  Closure  as the default value to the  get  method and the requested key does not exist, the  Closure  will be executed and its result returned:  $value = $request- session()- get( key ,  default );\n\n$value = $request- session()- get( key , function () {\n    return  default ;\n});", 
            "title": "Retrieving Data"
        }, 
        {
            "location": "/session/#the-global-session-helper", 
            "text": "You may also use the global  session  PHP function to retrieve and store data in the session. When the  session  helper is called with a single, string argument, it will return the value of that session key. When the helper is called with an array of key / value pairs, those values will be stored in the session:  Route::get( home , function () {\n    // Retrieve a piece of data from the session...\n    $value = session( key );\n\n    // Specifying a default value...\n    $value = session( key ,  default );\n\n    // Store a piece of data in the session...\n    session([ key  =   value ]);\n});   {tip} There is little practical difference between using the session via an HTTP request instance versus using the global  session  helper. Both methods are  testable  via the  assertSessionHas  method which is available in all of your test cases.", 
            "title": "The Global Session Helper"
        }, 
        {
            "location": "/session/#retrieving-all-session-data", 
            "text": "If you would like to retrieve all the data in the session, you may use the  all  method:  $data = $request- session()- all();", 
            "title": "Retrieving All Session Data"
        }, 
        {
            "location": "/session/#determining-if-an-item-exists-in-the-session", 
            "text": "To determine if a value is present in the session, you may use the  has  method. The  has  method returns  true  if the value is present and is not  null :  if ($request- session()- has( users )) {\n    //\n}  To determine if a value is present in the session, even if its value is  null , you may use the  exists  method. The  exists  method returns  true  if the value is present:  if ($request- session()- exists( users )) {\n    //\n}", 
            "title": "Determining If An Item Exists In The Session"
        }, 
        {
            "location": "/session/#storing-data", 
            "text": "To store data in the session, you will typically use the  put  method or the  session  helper:  // Via a request instance...\n$request- session()- put( key ,  value );\n\n// Via the global helper...\nsession([ key  =   value ]);", 
            "title": "Storing Data"
        }, 
        {
            "location": "/session/#pushing-to-array-session-values", 
            "text": "The  push  method may be used to push a new value onto a session value that is an array. For example, if the  user.teams  key contains an array of team names, you may push a new value onto the array like so:  $request- session()- push( user.teams ,  developers );", 
            "title": "Pushing To Array Session Values"
        }, 
        {
            "location": "/session/#retrieving-deleting-an-item", 
            "text": "The  pull  method will retrieve and delete an item from the session in a single statement:  $value = $request- session()- pull( key ,  default );", 
            "title": "Retrieving &amp; Deleting An Item"
        }, 
        {
            "location": "/session/#flash-data", 
            "text": "Sometimes you may wish to store items in the session only for the next request. You may do so using the  flash  method. Data stored in the session using this method will only be available during the subsequent HTTP request, and then will be deleted. Flash data is primarily useful for short-lived status messages:  $request- session()- flash( status ,  Task was successful! );  If you need to keep your flash data around for several requests, you may use the  reflash  method, which will keep all of the flash data for an additional request. If you only need to keep specific flash data, you may use the  keep  method:  $request- session()- reflash();\n\n$request- session()- keep([ username ,  email ]);", 
            "title": "Flash Data"
        }, 
        {
            "location": "/session/#deleting-data", 
            "text": "The  forget  method will remove a piece of data from the session. If you would like to remove all data from the session, you may use the  flush  method:  $request- session()- forget( key );\n\n$request- session()- flush();", 
            "title": "Deleting Data"
        }, 
        {
            "location": "/session/#regenerating-the-session-id", 
            "text": "Regenerating the session ID is often done in order to prevent malicious users from exploiting a  session fixation  attack on your application.  Laravel automatically regenerates the session ID during authentication if you are using the built-in  LoginController ; however, if you need to manually regenerate the session ID, you may use the  regenerate  method.  $request- session()- regenerate();", 
            "title": "Regenerating The Session ID"
        }, 
        {
            "location": "/session/#adding-custom-session-drivers", 
            "text": "", 
            "title": "Adding Custom Session Drivers"
        }, 
        {
            "location": "/session/#implementing-the-driver", 
            "text": "Your custom session driver should implement the  SessionHandlerInterface . This interface contains just a few simple methods we need to implement. A stubbed MongoDB implementation looks something like this:  ? php  namespace   App \\ Extensions ;  class   MongoHandler   implements   SessionHandlerInterface  { \n     public   function   open ( $savePath ,   $sessionName )   {} \n     public   function   close() { } \n     public   function   read ( $sessionId )   {} \n     public   function   write ( $sessionId ,   $data )   {} \n     public   function   destroy ( $sessionId )   {} \n     public   function   gc ( $lifetime )   {}  }    {tip} Laravel does not ship with a directory to contain your extensions. You are free to place them anywhere you like. In this example, we have created an  Extensions  directory to house the  MongoHandler .   Since the purpose of these methods is not readily understandable, let's quickly cover what each of the methods do:  \n- The `open` method would typically be used in file based session store systems. Since Laravel ships with a `file` session driver, you will almost never need to put anything in this method. You can leave it as an empty stub. It is simply a fact of poor interface design (which we'll discuss later) that PHP requires us to implement this method.\n- The `close` method, like the `open` method, can also usually be disregarded. For most drivers, it is not needed.\n- The `read` method should return the string version of the session data associated with the given `$sessionId`. There is no need to do any serialization or other encoding when retrieving or storing session data in your driver, as Laravel will perform the serialization for you.\n- The `write` method should write the given `$data` string associated with the `$sessionId` to some persistent storage system, such as MongoDB, Dynamo, etc.  Again, you should not perform any serialization - Laravel will have already handled that for you.\n- The `destroy` method should remove the data associated with the `$sessionId` from persistent storage.\n- The `gc` method should destroy all session data that is older than the given `$lifetime`, which is a UNIX timestamp. For self-expiring systems like Memcached and Redis, this method may be left empty.", 
            "title": "Implementing The Driver"
        }, 
        {
            "location": "/session/#registering-the-driver", 
            "text": "Once your driver has been implemented, you are ready to register it with the framework. To add additional drivers to Laravel's session backend, you may use the  extend  method on the  Session   facade . You should call the  extend  method from the  boot  method of a  service provider . You may do this from the existing  AppServiceProvider  or create an entirely new provider:  ? php  namespace   App \\ Providers ;  use   App \\ Extensions \\ MongoSessionStore ;  use   Illuminate \\ Support \\ Facades \\ Session ;  use   Illuminate \\ Support \\ ServiceProvider ;  class   SessionServiceProvider   extends   ServiceProvider  { \n     /**       * Perform post-registration booting of services.       *       * @return void       */ \n     public   function   boot () \n     { \n         Session :: extend ( mongo ,   function   ( $app )   { \n             // Return implementation of SessionHandlerInterface... \n             return   new   MongoSessionStore ; \n         }); \n     } \n\n     /**       * Register bindings in the container.       *       * @return void       */ \n     public   function   register () \n     { \n         // \n     }  }   Once the session driver has been registered, you may use the  mongo  driver in your  config/session.php  configuration file.", 
            "title": "Registering The Driver"
        }, 
        {
            "location": "/structure/", 
            "text": "Directory Structure\n\n\n\n\nIntroduction\n\n\nThe Root Directory\n\n\nThe \napp\n Directory\n\n\nThe \nbootstrap\n Directory\n\n\nThe \nconfig\n Directory\n\n\nThe \ndatabase\n Directory\n\n\nThe \npublic\n Directory\n\n\nThe \nresources\n Directory\n\n\nThe \nroutes\n Directory\n\n\nThe \nstorage\n Directory\n\n\nThe \ntests\n Directory\n\n\nThe \nvendor\n Directory\n\n\n\n\n\n\nThe App Directory\n\n\nThe \nConsole\n Directory\n\n\nThe \nEvents\n Directory\n\n\nThe \nExceptions\n Directory\n\n\nThe \nHttp\n Directory\n\n\nThe \nJobs\n Directory\n\n\nThe \nListeners\n Directory\n\n\nThe \nMail\n Directory\n\n\nThe \nNotifications\n Directory\n\n\nThe \nPolicies\n Directory\n\n\nThe \nProviders\n Directory\n\n\n\n\n\n\n\n\n\n\nIntroduction\n\n\nThe default Laravel application structure is intended to provide a great starting point for both large and small applications. Of course, you are free to organize your application however you like. Laravel imposes almost no restrictions on where any given class is located - as long as Composer can autoload the class.\n\n\nWhere Is The Models Directory?\n\n\nWhen getting started with Laravel, many developers are confused by the lack of a \nmodels\n directory. However, the lack of such a directory is intentional. We find the word \"models\" ambiguous since it means many different things to many different people. Some developers refer to an application's \"model\" as the totality of all of its business logic, while others refer to \"models\" as classes that interact with a relational database.\n\n\nFor this reason, we choose to place Eloquent models in the \napp\n directory by default, and allow the developer to place them somewhere else if they choose.\n\n\n\n\nThe Root Directory\n\n\n\n\nThe App Directory\n\n\nThe \napp\n directory, as you might expect, contains the core code of your application. We'll explore this directory in more detail soon; however, almost all of the classes in your application will be in this directory.\n\n\n\n\nThe Bootstrap Directory\n\n\nThe \nbootstrap\n directory contains files that bootstrap the framework and configure autoloading. This directory also houses a \ncache\n directory which contains framework generated files for performance optimization such as the route and services cache files.\n\n\n\n\nThe Config Directory\n\n\nThe \nconfig\n directory, as the name implies, contains all of your application's configuration files. It's a great idea to read through all of these files and familiarize yourself with all of the options available to you.\n\n\n\n\nThe Database Directory\n\n\nThe \ndatabase\n directory contains your database migration and seeds. If you wish, you may also use this directory to hold an SQLite database.\n\n\n\n\nThe Public Directory\n\n\nThe \npublic\n directory contains the \nindex.php\n file, which is the entry point for all requests entering your application. This directory also houses your assets such as images, JavaScript, and CSS.\n\n\n\n\nThe Resources Directory\n\n\nThe \nresources\n directory contains your views as well as your raw, un-compiled assets such as LESS, SASS, or JavaScript. This directory also houses all of your language files.\n\n\n\n\nThe Routes Directory\n\n\nThe \nroutes\n directory contains all of the route definitions for your application. By default, three route files are included with Laravel: \nweb.php\n, \napi.php\n, and \nconsole.php\n.\n\n\nThe \nweb.php\n file contains routes that the \nRouteServiceProvider\n places in the \nweb\n middleware group, which provides session state, CSRF protection, and cookie encryption. If your application does not offer a stateless, RESTful API, all of your routes will most likely be defined in the \nweb.php\n file.\n\n\nThe \napi.php\n file contains routes that the \nRouteServiceProvider\n places in the \napi\n middleware group, which provides rate limiting. These routes are intended to be stateless, so requests entering the application through these routes are intended to be authenticated via tokens and will not have access to session state.\n\n\nThe \nconsole.php\n file is where you may define all of your Closure based console commands. Each Closure is bound to a command instance allowing a simple approach to interacting with each command's IO methods. Even though this file does not define HTTP routes, it defines console based entry points (routes) into your application.\n\n\n\n\nThe Storage Directory\n\n\nThe \nstorage\n directory contains your compiled Blade templates, file based sessions, file caches, and other files generated by the framework. This directory is segregated into \napp\n, \nframework\n, and \nlogs\n directories. The \napp\n directory may be used to store any files generated by your application. The \nframework\n directory is used to store framework generated files and caches. Finally, the \nlogs\n directory contains your application's log files.\n\n\nThe \nstorage/app/public\n directory may be used to store user-generated files, such as profile avatars, that should be publicly accessible. You should create a symbolic link at \npublic/storage\n which points to this directory. You may create the link using the \nphp artisan storage:link\n command.\n\n\n\n\nThe Tests Directory\n\n\nThe \ntests\n directory contains your automated tests. An example \nPHPUnit\n is provided out of the box. Each test class should be suffixed with the word \nTest\n. You may run your tests using the \nphpunit\n or \nphp vendor/bin/phpunit\n commands.\n\n\n\n\nThe Vendor Directory\n\n\nThe \nvendor\n directory contains your \nComposer\n dependencies.\n\n\n\n\nThe App Directory\n\n\nThe majority of your application is housed in the \napp\n directory. By default, this directory is namespaced under \nApp\n and is autoloaded by Composer using the \nPSR-4 autoloading standard\n.\n\n\nThe \napp\n directory contains a variety of additional directories such as \nConsole\n, \nHttp\n, and \nProviders\n. Think of the \nConsole\n and \nHttp\n directories as providing an API into the core of your application. The HTTP protocol and CLI are both mechanisms to interact with your application, but do not actually contain application logic. In other words, they are simply two ways of issuing commands to your application. The \nConsole\n directory contains all of your Artisan commands, while the \nHttp\n directory contains your controllers, middleware, and requests.\n\n\nA variety of other directories will be generated inside the \napp\n directory as you use the \nmake\n Artisan commands to generate classes. So, for example, the \napp/Jobs\n directory will not exist until you execute the \nmake:job\n Artisan command to generate a job class.\n\n\n\n\n{tip} Many of the classes in the \napp\n directory can be generated by Artisan via commands. To review the available commands, run the \nphp artisan list make\n command in your terminal.\n\n\n\n\n\n\nThe Console Directory\n\n\nThe \nConsole\n directory contains all of the custom Artisan commands for your application. These commands may be generated using the \nmake:command\n command. This directory also houses your console kernel, which is where your custom Artisan commands are registered and your \nscheduled tasks\n are defined.\n\n\n\n\nThe Events Directory\n\n\nThis directory does not exist by default, but will be created for you by the \nevent:generate\n and \nmake:event\n Artisan commands. The \nEvents\n directory, as you might expect, houses \nevent classes\n. Events may be used to alert other parts of your application that a given action has occurred, providing a great deal of flexibility and decoupling.\n\n\n\n\nThe Exceptions Directory\n\n\nThe \nExceptions\n directory contains your application's exception handler and is also a good place to place any exceptions thrown by your application. If you would like to customize how your exceptions are logged or rendered, you should modify the \nHandler\n class in this directory.\n\n\n\n\nThe Http Directory\n\n\nThe \nHttp\n directory contains your controllers, middleware, and form requests. Almost all of the logic to handle requests entering your application will be placed in this directory.\n\n\n\n\nThe Jobs Directory\n\n\nThis directory does not exist by default, but will be created for you if you execute the \nmake:job\n Artisan command. The \nJobs\n directory houses the \nqueueable jobs\n for your application. Jobs may be queued by your application or run synchronously within the current request lifecycle. Jobs that run synchronously during the current request are sometimes referred to as \"commands\" since they are an implementation of the \ncommand pattern\n.\n\n\n\n\nThe Listeners Directory\n\n\nThis directory does not exist by default, but will be created for you if you execute the \nevent:generate\n or \nmake:listener\n Artisan commands. The \nListeners\n directory contains the classes that handle your \nevents\n. Event listeners receive an event instance and perform logic in response to the event being fired. For example, a \nUserRegistered\n event might be handled by a \nSendWelcomeEmail\n listener.\n\n\n\n\nThe Mail Directory\n\n\nThis directory does not exist by default, but will be created for you if you execute the \nmake:mail\n Artisan command. The \nMail\n directory contains all of your classes that represent emails sent by your application. Mail objects allow you to encapsulate all of the logic of building an email in a single, simple class that may be sent using the \nMail::send\n method.\n\n\n\n\nThe Notifications Directory\n\n\nThis directory does not exist by default, but will be created for you if you execute the \nmake:notification\n Artisan command. The \nNotifications\n directory contains all of the \"transactional\" notifications that are sent by your application, such as simple notifications about events that happen within your application. Laravel's notification features abstracts sending notifications over a variety of drivers such as email, Slack, SMS, or stored in a database.\n\n\n\n\nThe Policies Directory\n\n\nThis directory does not exist by default, but will be created for you if you execute the \nmake:policy\n Artisan command. The \nPolicies\n directory contains the authorization policy classes for your application. Policies are used to determine if a user can perform a given action against a resource. For more information, check out the \nauthorization documentation\n.\n\n\n\n\nThe Providers Directory\n\n\nThe \nProviders\n directory contains all of the \nservice providers\n for your application. Service providers bootstrap your application by binding services in the service container, registering events, or performing any other tasks to prepare your application for incoming requests.\n\n\nIn a fresh Laravel application, this directory will already contain several providers. You are free to add your own providers to this directory as needed.", 
            "title": "Structure"
        }, 
        {
            "location": "/structure/#directory-structure", 
            "text": "Introduction  The Root Directory  The  app  Directory  The  bootstrap  Directory  The  config  Directory  The  database  Directory  The  public  Directory  The  resources  Directory  The  routes  Directory  The  storage  Directory  The  tests  Directory  The  vendor  Directory    The App Directory  The  Console  Directory  The  Events  Directory  The  Exceptions  Directory  The  Http  Directory  The  Jobs  Directory  The  Listeners  Directory  The  Mail  Directory  The  Notifications  Directory  The  Policies  Directory  The  Providers  Directory", 
            "title": "Directory Structure"
        }, 
        {
            "location": "/structure/#introduction", 
            "text": "The default Laravel application structure is intended to provide a great starting point for both large and small applications. Of course, you are free to organize your application however you like. Laravel imposes almost no restrictions on where any given class is located - as long as Composer can autoload the class.", 
            "title": "Introduction"
        }, 
        {
            "location": "/structure/#where-is-the-models-directory", 
            "text": "When getting started with Laravel, many developers are confused by the lack of a  models  directory. However, the lack of such a directory is intentional. We find the word \"models\" ambiguous since it means many different things to many different people. Some developers refer to an application's \"model\" as the totality of all of its business logic, while others refer to \"models\" as classes that interact with a relational database.  For this reason, we choose to place Eloquent models in the  app  directory by default, and allow the developer to place them somewhere else if they choose.", 
            "title": "Where Is The Models Directory?"
        }, 
        {
            "location": "/structure/#the-root-directory", 
            "text": "", 
            "title": "The Root Directory"
        }, 
        {
            "location": "/structure/#the-app-directory", 
            "text": "The  app  directory, as you might expect, contains the core code of your application. We'll explore this directory in more detail soon; however, almost all of the classes in your application will be in this directory.", 
            "title": "The App Directory"
        }, 
        {
            "location": "/structure/#the-bootstrap-directory", 
            "text": "The  bootstrap  directory contains files that bootstrap the framework and configure autoloading. This directory also houses a  cache  directory which contains framework generated files for performance optimization such as the route and services cache files.", 
            "title": "The Bootstrap Directory"
        }, 
        {
            "location": "/structure/#the-config-directory", 
            "text": "The  config  directory, as the name implies, contains all of your application's configuration files. It's a great idea to read through all of these files and familiarize yourself with all of the options available to you.", 
            "title": "The Config Directory"
        }, 
        {
            "location": "/structure/#the-database-directory", 
            "text": "The  database  directory contains your database migration and seeds. If you wish, you may also use this directory to hold an SQLite database.", 
            "title": "The Database Directory"
        }, 
        {
            "location": "/structure/#the-public-directory", 
            "text": "The  public  directory contains the  index.php  file, which is the entry point for all requests entering your application. This directory also houses your assets such as images, JavaScript, and CSS.", 
            "title": "The Public Directory"
        }, 
        {
            "location": "/structure/#the-resources-directory", 
            "text": "The  resources  directory contains your views as well as your raw, un-compiled assets such as LESS, SASS, or JavaScript. This directory also houses all of your language files.", 
            "title": "The Resources Directory"
        }, 
        {
            "location": "/structure/#the-routes-directory", 
            "text": "The  routes  directory contains all of the route definitions for your application. By default, three route files are included with Laravel:  web.php ,  api.php , and  console.php .  The  web.php  file contains routes that the  RouteServiceProvider  places in the  web  middleware group, which provides session state, CSRF protection, and cookie encryption. If your application does not offer a stateless, RESTful API, all of your routes will most likely be defined in the  web.php  file.  The  api.php  file contains routes that the  RouteServiceProvider  places in the  api  middleware group, which provides rate limiting. These routes are intended to be stateless, so requests entering the application through these routes are intended to be authenticated via tokens and will not have access to session state.  The  console.php  file is where you may define all of your Closure based console commands. Each Closure is bound to a command instance allowing a simple approach to interacting with each command's IO methods. Even though this file does not define HTTP routes, it defines console based entry points (routes) into your application.", 
            "title": "The Routes Directory"
        }, 
        {
            "location": "/structure/#the-storage-directory", 
            "text": "The  storage  directory contains your compiled Blade templates, file based sessions, file caches, and other files generated by the framework. This directory is segregated into  app ,  framework , and  logs  directories. The  app  directory may be used to store any files generated by your application. The  framework  directory is used to store framework generated files and caches. Finally, the  logs  directory contains your application's log files.  The  storage/app/public  directory may be used to store user-generated files, such as profile avatars, that should be publicly accessible. You should create a symbolic link at  public/storage  which points to this directory. You may create the link using the  php artisan storage:link  command.", 
            "title": "The Storage Directory"
        }, 
        {
            "location": "/structure/#the-tests-directory", 
            "text": "The  tests  directory contains your automated tests. An example  PHPUnit  is provided out of the box. Each test class should be suffixed with the word  Test . You may run your tests using the  phpunit  or  php vendor/bin/phpunit  commands.", 
            "title": "The Tests Directory"
        }, 
        {
            "location": "/structure/#the-vendor-directory", 
            "text": "The  vendor  directory contains your  Composer  dependencies.", 
            "title": "The Vendor Directory"
        }, 
        {
            "location": "/structure/#the-app-directory_1", 
            "text": "The majority of your application is housed in the  app  directory. By default, this directory is namespaced under  App  and is autoloaded by Composer using the  PSR-4 autoloading standard .  The  app  directory contains a variety of additional directories such as  Console ,  Http , and  Providers . Think of the  Console  and  Http  directories as providing an API into the core of your application. The HTTP protocol and CLI are both mechanisms to interact with your application, but do not actually contain application logic. In other words, they are simply two ways of issuing commands to your application. The  Console  directory contains all of your Artisan commands, while the  Http  directory contains your controllers, middleware, and requests.  A variety of other directories will be generated inside the  app  directory as you use the  make  Artisan commands to generate classes. So, for example, the  app/Jobs  directory will not exist until you execute the  make:job  Artisan command to generate a job class.   {tip} Many of the classes in the  app  directory can be generated by Artisan via commands. To review the available commands, run the  php artisan list make  command in your terminal.", 
            "title": "The App Directory"
        }, 
        {
            "location": "/structure/#the-console-directory", 
            "text": "The  Console  directory contains all of the custom Artisan commands for your application. These commands may be generated using the  make:command  command. This directory also houses your console kernel, which is where your custom Artisan commands are registered and your  scheduled tasks  are defined.", 
            "title": "The Console Directory"
        }, 
        {
            "location": "/structure/#the-events-directory", 
            "text": "This directory does not exist by default, but will be created for you by the  event:generate  and  make:event  Artisan commands. The  Events  directory, as you might expect, houses  event classes . Events may be used to alert other parts of your application that a given action has occurred, providing a great deal of flexibility and decoupling.", 
            "title": "The Events Directory"
        }, 
        {
            "location": "/structure/#the-exceptions-directory", 
            "text": "The  Exceptions  directory contains your application's exception handler and is also a good place to place any exceptions thrown by your application. If you would like to customize how your exceptions are logged or rendered, you should modify the  Handler  class in this directory.", 
            "title": "The Exceptions Directory"
        }, 
        {
            "location": "/structure/#the-http-directory", 
            "text": "The  Http  directory contains your controllers, middleware, and form requests. Almost all of the logic to handle requests entering your application will be placed in this directory.", 
            "title": "The Http Directory"
        }, 
        {
            "location": "/structure/#the-jobs-directory", 
            "text": "This directory does not exist by default, but will be created for you if you execute the  make:job  Artisan command. The  Jobs  directory houses the  queueable jobs  for your application. Jobs may be queued by your application or run synchronously within the current request lifecycle. Jobs that run synchronously during the current request are sometimes referred to as \"commands\" since they are an implementation of the  command pattern .", 
            "title": "The Jobs Directory"
        }, 
        {
            "location": "/structure/#the-listeners-directory", 
            "text": "This directory does not exist by default, but will be created for you if you execute the  event:generate  or  make:listener  Artisan commands. The  Listeners  directory contains the classes that handle your  events . Event listeners receive an event instance and perform logic in response to the event being fired. For example, a  UserRegistered  event might be handled by a  SendWelcomeEmail  listener.", 
            "title": "The Listeners Directory"
        }, 
        {
            "location": "/structure/#the-mail-directory", 
            "text": "This directory does not exist by default, but will be created for you if you execute the  make:mail  Artisan command. The  Mail  directory contains all of your classes that represent emails sent by your application. Mail objects allow you to encapsulate all of the logic of building an email in a single, simple class that may be sent using the  Mail::send  method.", 
            "title": "The Mail Directory"
        }, 
        {
            "location": "/structure/#the-notifications-directory", 
            "text": "This directory does not exist by default, but will be created for you if you execute the  make:notification  Artisan command. The  Notifications  directory contains all of the \"transactional\" notifications that are sent by your application, such as simple notifications about events that happen within your application. Laravel's notification features abstracts sending notifications over a variety of drivers such as email, Slack, SMS, or stored in a database.", 
            "title": "The Notifications Directory"
        }, 
        {
            "location": "/structure/#the-policies-directory", 
            "text": "This directory does not exist by default, but will be created for you if you execute the  make:policy  Artisan command. The  Policies  directory contains the authorization policy classes for your application. Policies are used to determine if a user can perform a given action against a resource. For more information, check out the  authorization documentation .", 
            "title": "The Policies Directory"
        }, 
        {
            "location": "/structure/#the-providers-directory", 
            "text": "The  Providers  directory contains all of the  service providers  for your application. Service providers bootstrap your application by binding services in the service container, registering events, or performing any other tasks to prepare your application for incoming requests.  In a fresh Laravel application, this directory will already contain several providers. You are free to add your own providers to this directory as needed.", 
            "title": "The Providers Directory"
        }, 
        {
            "location": "/testing/", 
            "text": "Testing: Getting Started\n\n\n\n\nIntroduction\n\n\nEnvironment\n\n\nCreating \n Running Tests\n\n\n\n\n\n\nIntroduction\n\n\nLaravel is built with testing in mind. In fact, support for testing with PHPUnit is included out of the box and a \nphpunit.xml\n file is already setup for your application. The framework also ships with convenient helper methods that allow you to expressively test your applications.\n\n\nBy default, your application's \ntests\n directory contains two directories: \nFeature\n and \nUnit\n. Unit tests are tests that focus on a very small, isolated portion of your code. In fact, most unit tests probably focus on a single method. Feature tests may test a larger portion of your code, including how several objects interact with each other or even a full HTTP request to a JSON endpoint.\n\n\nAn \nExampleTest.php\n file is provided in both the \nFeature\n and \nUnit\n test directories. After installing a new Laravel application, simply run \nphpunit\n on the command line to run your tests.\n\n\n\n\nEnvironment\n\n\nWhen running tests via \nphpunit\n, Laravel will automatically set the configuration environment to \ntesting\n because of the environment variables defined in the \nphpunit.xml\n file. Laravel also automatically configures the session and cache to the \narray\n driver while testing, meaning no session or cache data will be persisted while testing.\n\n\nYou are free to define other testing environment configuration values as necessary. The \ntesting\n environment variables may be configured in the \nphpunit.xml\n file, but make sure to clear your configuration cache using the \nconfig:clear\n Artisan command before running your tests!\n\n\n\n\nCreating \n Running Tests\n\n\nTo create a new test case, use the \nmake:test\n Artisan command:\n\n\n// Create a test in the Feature directory...\nphp artisan make:test UserTest\n\n// Create a test in the Unit directory...\nphp artisan make:test UserTest --unit\n\n\n\n\n\nOnce the test has been generated, you may define test methods as you normally would using PHPUnit. To run your tests, simply execute the \nphpunit\n command from your terminal:\n\n\n?\nphp\n\n\n\nnamespace\n \nTests\n\\\nUnit\n;\n\n\n\nuse\n \nTests\n\\\nTestCase\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseMigrations\n;\n\n\nuse\n \nIlluminate\n\\\nFoundation\n\\\nTesting\n\\\nDatabaseTransactions\n;\n\n\n\nclass\n \nExampleTest\n \nextends\n \nTestCase\n\n\n{\n\n    \n/**\n\n\n     * A basic test example.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \ntestBasicTest\n()\n\n    \n{\n\n        \n$this\n-\nassertTrue\n(\ntrue\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n{note} If you define your own \nsetUp\n method within a test class, be sure to call \nparent::setUp()\n.", 
            "title": "Testing"
        }, 
        {
            "location": "/testing/#testing-getting-started", 
            "text": "Introduction  Environment  Creating   Running Tests", 
            "title": "Testing: Getting Started"
        }, 
        {
            "location": "/testing/#introduction", 
            "text": "Laravel is built with testing in mind. In fact, support for testing with PHPUnit is included out of the box and a  phpunit.xml  file is already setup for your application. The framework also ships with convenient helper methods that allow you to expressively test your applications.  By default, your application's  tests  directory contains two directories:  Feature  and  Unit . Unit tests are tests that focus on a very small, isolated portion of your code. In fact, most unit tests probably focus on a single method. Feature tests may test a larger portion of your code, including how several objects interact with each other or even a full HTTP request to a JSON endpoint.  An  ExampleTest.php  file is provided in both the  Feature  and  Unit  test directories. After installing a new Laravel application, simply run  phpunit  on the command line to run your tests.", 
            "title": "Introduction"
        }, 
        {
            "location": "/testing/#environment", 
            "text": "When running tests via  phpunit , Laravel will automatically set the configuration environment to  testing  because of the environment variables defined in the  phpunit.xml  file. Laravel also automatically configures the session and cache to the  array  driver while testing, meaning no session or cache data will be persisted while testing.  You are free to define other testing environment configuration values as necessary. The  testing  environment variables may be configured in the  phpunit.xml  file, but make sure to clear your configuration cache using the  config:clear  Artisan command before running your tests!", 
            "title": "Environment"
        }, 
        {
            "location": "/testing/#creating-running-tests", 
            "text": "To create a new test case, use the  make:test  Artisan command:  // Create a test in the Feature directory...\nphp artisan make:test UserTest\n\n// Create a test in the Unit directory...\nphp artisan make:test UserTest --unit  Once the test has been generated, you may define test methods as you normally would using PHPUnit. To run your tests, simply execute the  phpunit  command from your terminal:  ? php  namespace   Tests \\ Unit ;  use   Tests \\ TestCase ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseMigrations ;  use   Illuminate \\ Foundation \\ Testing \\ DatabaseTransactions ;  class   ExampleTest   extends   TestCase  { \n     /**       * A basic test example.       *       * @return void       */ \n     public   function   testBasicTest () \n     { \n         $this - assertTrue ( true ); \n     }  }    {note} If you define your own  setUp  method within a test class, be sure to call  parent::setUp() .", 
            "title": "Creating &amp; Running Tests"
        }, 
        {
            "location": "/upgrade/", 
            "text": "Upgrade Guide\n\n\n\n\nUpgrading To 5.4.0 From 5.3\n\n\n\n\n\n\nUpgrading To 5.4.0 From 5.3\n\n\nEstimated Upgrade Time: 1-2 Hours\n\n\n\n\n{note} We attempt to document every possible breaking change. Since some of these breaking changes are in obscure parts of the framework only a portion of these changes may actually affect your application.\n\n\n\n\nUpdating Dependencies\n\n\nUpdate your \nlaravel/framework\n dependency to \n5.4.*\n in your \ncomposer.json\n file. In addition, you should update your \nphpunit/phpunit\n dependency to \n~5.7\n.\n\n\nRemoving Compiled Services File\n\n\nIf it exists, you may delete the \nbootstrap/cache/compiled.php\n file. It is no longer used by the framework.\n\n\nFlushing The Cache\n\n\nAfter upgrading all packages, you should run \nphp artisan view:clear\n to avoid Blade errors related to the removal of \nIlluminate\\View\\Factory::getFirstLoop()\n. In addition, you may need to run \nphp artisan route:clear\n to flush the route cache.\n\n\nLaravel Cashier\n\n\nLaravel Cashier is already compatible with Laravel 5.4.\n\n\nLaravel Passport\n\n\nLaravel Passport \n2.0.0\n has been released to provide compatibility with Laravel 5.4 and the \nAxios\n JavaScript library. If you are upgrading from Laravel 5.3 and using the pre-built Passport Vue components, you should make sure the Axios library is globally available to your application as \naxios\n.\n\n\nLaravel Scout\n\n\nLaravel Scout \n3.0.0\n has been released to provide compatibility with Laravel 5.4.\n\n\nLaravel Socialite\n\n\nLaravel Socialite \n3.0.0\n has been released to provide compatibility with Laravel 5.4.\n\n\nLaravel Tinker\n\n\nIn order to continue using the \ntinker\n Artisan command, you should also install the \nlaravel/tinker\n package:\n\n\ncomposer require laravel/tinker\n\n\n\n\n\nOnce the package has been installed, you should add \nLaravel\\Tinker\\TinkerServiceProvider::class\n to the \nproviders\n array in your \nconfig/app.php\n configuration file.\n\n\nGuzzle\n\n\nLaravel 5.4 requires Guzzle 6.0 or greater.\n\n\nAuthorization\n\n\nThe \ngetPolicyFor\n Method\n\n\nPrevious, when calling the \nGate::getPolicyFor($class)\n method, an exception was thrown if no policy could be found. Now, the method will return \nnull\n if no policy is found for the given class. If you call this method directly, make sure you refactor your code to check for \nnull\n:\n\n\n$policy = Gate::getPolicyFor($class);\n\n\n\nif ($policy) {\n\n\n    // code that was previously in the try block\n\n\n} else {\n\n\n    // code that was previously in the catch block\n\n\n}\n\n\n\n\n\n\nBlade\n\n\n@section\n Escaping\n\n\nIn Laravel 5.4, inline content passed to a section is automatically escaped:\n\n\n@section(\ntitle\n, $content)\n\n\n\n\n\nIf you would like to render unescaped content in a section, you must declare the section using the traditional \"long form\" style:\n\n\n@section(\ntitle\n)\n    {!! $content !!}\n@stop\n\n\n\n\n\nBootstrappers\n\n\nIf you are manually overriding the \n$bootstrappers\n array on your HTTP or Console kernel, you should rename the \nDetectEnvironment\n entry to \nLoadEnvironmentVariables\n.\n\n\nBroadcasting\n\n\nChannel Model Binding\n\n\nWhen defining channel name placeholders in Laravel 5.3, the \n*\n character is used. In Laravel 5.4, you should define these placeholders using \n{foo}\n style placeholders, like routes:\n\n\nBroadcast::channel(\nApp.User.{userId}\n, function ($user, $userId) {\n    return (int) $user-\nid === (int) $userId;\n});\n\n\n\n\n\nCollections\n\n\nThe \nevery\n Method\n\n\nThe behavior of the \nevery\n method has been moved to the \nnth\n method to match the method name defined by Lodash.\n\n\nThe \nrandom\n Method\n\n\nCalling \n$collection-\nrandom(1)\n will now return a new collection instance with one item. Previously, this would return a single object. This method will only return a single object if no arguments are supplied.\n\n\nContainer\n\n\nAliasing Via \nbind\n / \ninstance\n\n\nIn previous Laravel releases, you could pass an array as the first parameter to the \nbind\n or \ninstance\n methods to register an alias:\n\n\n$container-\nbind([\nfoo\n =\n FooContract::class], function () {\n    return \nfoo\n;\n});\n\n\n\n\n\nHowever, this behavior has been removed in Laravel 5.4. To register an alias, you should now use the \nalias\n method:\n\n\n$\ncontainer-\nalias\n(\nFooContract\n::\nclass\n,\n \nfoo\n);\n\n\n\n\n\n\nBinding Classes With Leading Slashes\n\n\nBinding classes into the container with leading slashes is no longer supported. This feature required a significant amount of string formatting calls to be made within the container. Instead, simply register your bindings without a leading slash:\n\n\n$container-\nbind(\nClass\\Name\n, function () {\n    //\n});\n\n$container-\nbind(ClassName::class, function () {\n    //\n});\n\n\n\n\n\nmake\n Method Parameters\n\n\nThe container's \nmake\n method no longer accepts a second array of parameters. This feature typically indicates a code smell. Typically, you can always construct the object in another way that is more intuitive.\n\n\nResolving Callbacks\n\n\nThe container's \nresolving\n and \nafterResolving\n method now must be provided a class name or binding key as the first argument to the method:\n\n\n$container-\nresolving(\nClass\\Name\n, function ($instance) {\n    //\n});\n\n$container-\nafterResolving(\nClass\\Name\n, function ($instance) {\n    //\n});\n\n\n\n\n\nshare\n Method Removed\n\n\nThe \nshare\n method has been removed from the container. This was a legacy method that has not been documented in several years. If you are using this method, you should begin using the \nsingleton\n method instead:\n\n\n$container-\nsingleton(\nfoo\n, function () {\n    return \nfoo\n;\n});\n\n\n\n\n\nConsole\n\n\nThe \nIlluminate\\Console\\AppNamespaceDetectorTrait\n Trait\n\n\nIf you are directly referencing the \nIlluminate\\Console\\AppNamespaceDetectorTrait\n trait, update your code to reference \nIlluminate\\Console\\DetectsApplicationNamespace\n instead.\n\n\nDatabase\n\n\nCustom Connections\n\n\nIf you were previously binding a service container binding for a \ndb.connection.{driver-name}\n key in order to resolve a custom database connection instance, you should now use the \nIlluminate\\Database\\Connection::resolverFor\n method in the \nregister\n method of your \nAppServiceProvider\n:\n\n\nuse Illuminate\\Database\\Connection;\n\nConnection::resolverFor(\ndriver-name\n, function ($connection, $database, $prefix, $config) {\n    //\n});\n\n\n\n\n\nFetch Mode\n\n\nLaravel no longer includes the ability to customize the PDO \"fetch mode\" from your configuration files. Instead, \nPDO::FETCH_OBJ\n is always used. If you will still like to customize the fetch mode for your application you may listen for the new \nIlluminate\\Database\\Events\\StatementPrepared\n event:\n\n\nEvent::listen(StatementPrepared::class, function ($event) {\n    $event-\nstatement-\nsetFetchMode(...);\n});\n\n\n\n\n\nEloquent\n\n\nDate Casts\n\n\nThe \ndate\n cast now converts the column to a \nCarbon\n object and calls the \nstartOfDay\n method on the object. If you would like to preserve the time portion of the date, you should use the \ndatetime\n cast.\n\n\nForeign Key Conventions\n\n\nIf the foreign key is not explicitly specified when defining a relationship, Eloquent will now use the table name and primary key name for the related model to build the foreign key. For the vast majority of applications, this is not a change of behavior. For example:\n\n\npublic\n \nfunction\n \nuser\n()\n\n\n{\n\n    \nreturn\n \n$this-\nbelongsTo(\nUser\n:\n:\nclass\n);\n\n\n}\n\n\n\n\n\n\nJust like previous Laravel releases, this relationship will typically use \nuser_id\n as the foreign key. However, the behavior could be different from previous releases if you are overriding the \ngetKeyName\n method of the \nUser\n model. For example:\n\n\npublic function getKeyName()\n{\n    return \nkey\n;\n}\n\n\n\n\n\nWhen this is the case, Laravel will now respect your customization and determine the foreign key column name is \nuser_key\n instead of \nuser_id\n.\n\n\nHas One / Many \ncreateMany\n\n\nThe \ncreateMany\n method of a \nhasOne\n or \nhasMany\n relationship now returns a collection object instead of an array.\n\n\nRelated Model Connections\n\n\nRelated models will now use the same connection as the parent model. For example, if you execute a query like:\n\n\nUser\n::\non\n(\nexample\n)\n-\nwith\n(\nposts\n);\n\n\n\n\n\n\nEloquent will query the posts table on the \nexample\n connection instead of the default database connection. If you want to read the \nposts\n relationship from the default connection, you should to explicitly set the model's connection to your application's default connection.\n\n\nThe \ncreate\n \n \nforceCreate\n Methods\n\n\nThe \nModel::create\n \n \nModel:: forceCreate\n methods have been moved to the \nIlluminate\\Database\\Eloquent\\Builder\n class in order to provide better support for creating models on multiple connections. However, if you are extending these methods in your own models, you will need to modify your implementation to call the \ncreate\n method on the builder. For example:\n\n\npublic\n \nstatic\n \nfunction\n \ncreate\n(\narray\n \n$\nattributes\n \n=\n \n[]\n)\n\n\n{\n\n    \n$model\n \n=\n \nstatic\n:\n:\nquery\n()\n-\ncreate\n(\n$\nattributes\n);\n\n\n    \n//\n \n...\n\n\n    \nreturn\n \n$model\n;\n\n\n}\n\n\n\n\n\n\nThe \nhydrate\n Method\n\n\nIf you are currently passing a custom connection name to this method, you should now use the \non\n method:\n\n\nUser\n::\non\n(\nconnection\n)\n-\nhydrate\n($\nrecords\n);\n\n\n\n\n\n\nhydrateRaw\n Method\n\n\nThe \nModel::hydrateRaw\n method has been renamed to \nfromQuery\n. If you are passing a custom connection name to this method, you should now use the \non\n method:\n\n\nUser\n::\non\n(\nconnection\n)\n-\nfromQuery\n(\n...\n);\n\n\n\n\n\n\nThe \nwhereKey\n Method\n\n\nThe \nwhereKey($id)\n method will now add a \"where\" clause for the given primary key value. Previously, this would fall into the dynamic \"where\" clause builder and add a \"where\" clause for the \"key\" column. If you used the \nwhereKey\n method to dynamically add a condition for the \nkey\n column you should now use \nwhere('key', ...)\n instead.\n\n\nThe \nfactory\n Helper\n\n\nCalling \nfactory(User::class, 1)-\nmake()\n or \nfactory(User::class, 1)-\ncreate()\n will now return a collection with one item. Previously, this would return a single model. This method will only return a single model if the amount is not supplied.\n\n\nEvents\n\n\nContract Changes\n\n\nIf you are manually implementing the \nIlluminate\\Contracts\\Events\\Dispatcher\n interface in your application or package, you should rename the \nfire\n method to \ndispatch\n.\n\n\nEvent Priority\n\n\nSupport for event handler \"priorities\" has been removed. This undocumented feature typically indicates an abuse of the event feature. Instead, consider using a series of synchronous method calls. Alternatively, you may dispatch a new event from within the handler of another event in order to ensure that a given event's handler fires after an unrelated handler.\n\n\nWildcard Event Handler Signatures\n\n\nWildcard event handlers now receive the event name as their first argument and the array of event data as their second argument. The \nEvent::firing\n method has been removed:\n\n\nEvent::listen(\n*\n, function ($eventName, array $data) {\n    //\n});\n\n\n\n\n\nThe \nkernel.handled\n Event\n\n\nThe \nkernel.handled\n event is now an object based event using the \nIlluminate\\Foundation\\Http\\Events\\RequestHandled\n class.\n\n\nThe \nlocale.changed\n Event\n\n\nThe \nlocale.changed\n event is now an object based event using the \nIlluminate\\Foundation\\Events\\LocaleUpdated\n class.\n\n\nThe \nilluminate.log\n Event\n\n\nThe \nilluminate.log\n event is now an object based event using the \nIlluminate\\Log\\Events\\MessageLogged\n class.\n\n\nExceptions\n\n\nThe \nIlluminate\\Http\\Exception\\HttpResponseException\n has been renamed to \nIlluminate\\Http\\Exceptions\\HttpResponseException\n. Note that \nExceptions\n is now plural. Likewise, the \nIlluminate\\Http\\Exception\\PostTooLargeException\n has been renamed to \nIlluminate\\Http\\Exceptions\\PostTooLargeException\n.\n\n\nMail\n\n\nClass@method\n Syntax\n\n\nSending mail using \nClass@method\n syntax is no longer supported. For example:\n\n\nMail\n::\nsend\n(\nview.name\n,\n \n$\ndata\n,\n \nClass@send\n);\n\n\n\n\n\n\nIf you are sending mail in this way you should convert these calls to \nmailables\n.\n\n\nNew Configuration Options\n\n\nIn order to provide support for Laravel 5.4's new Markdown mail components, you should add the following block of configuration to the bottom of your \nmail\n configuration file:\n\n\nmarkdown\n =\n [\n    \ntheme\n =\n \ndefault\n,\n\n    \npaths\n =\n [\n        resource_path(\nviews/vendor/mail\n),\n    ],\n],\n\n\n\n\n\nQueueing Mail With Closures\n\n\nIn order to queue mail, you now must use a \nmailable\n. Queuing mail using the \nMail::queue\n and \nMail::later\n methods no longer supports using Closures to configure the mail message. This feature required the use of special libraries to serialize Closures since PHP does not natively support this feature.\n\n\nRedis\n\n\nImproved Clustering Support\n\n\nLaravel 5.4 introduces improved Redis cluster support. If you are using Redis clusters, you should place your cluster connections inside of a \nclusters\n configuration option in the Redis portion of your \nconfig/database.php\n configuration file:\n\n\nredis\n =\n [\n\n    \nclient\n =\n \npredis\n,\n\n    \noptions\n =\n [\n        \ncluster\n =\n \nredis\n,\n    ],\n\n    \nclusters\n =\n [\n        \ndefault\n =\n [\n            [\n                \nhost\n =\n env(\nREDIS_HOST\n, \n127.0.0.1\n),\n                \npassword\n =\n env(\nREDIS_PASSWORD\n, null),\n                \nport\n =\n env(\nREDIS_PORT\n, 6379),\n                \ndatabase\n =\n 0,\n            ],\n        ],\n    ],\n\n],\n\n\n\n\n\nRouting\n\n\nPost Size Middleware\n\n\nThe class \nIlluminate\\Foundation\\Http\\Middleware\\VerifyPostSize\n has been renamed to \nIlluminate\\Foundation\\Http\\Middleware\\ValidatePostSize\n.\n\n\nThe \nmiddleware\n Method\n\n\nThe \nmiddleware\n method of the \nIlluminate\\Routing\\Router\n class has been renamed to \naliasMiddleware()\n. It is likely that most applications never call this method manually, as it is typically only called by the HTTP kernel to register route-level middleware defined in the \n$routeMiddleware\n array.\n\n\nRoute\n Methods\n\n\nThe \ngetUri\n method of the \nIlluminate\\Routing\\Route\n class has been removed. You should use the \nuri\n method instead.\n\n\nThe \ngetMethods\n method of the \nIlluminate\\Routing\\Route\n class has been removed. You should use the \nmethods\n method instead.\n\n\nThe \ngetParameter\n method of the \nIlluminate\\Routing\\Route\n class has been removed. You should use the \nparameter\n method instead.\n\n\nSessions\n\n\nSymfony Compatibility\n\n\nLaravel's session handlers no longer implements Symfony's \nSessionInterface\n. Implementing this interface required us to implement extraneous features that were not needed by the framework. Instead, a new \nIlluminate\\Contracts\\Session\\Session\n interface has been defined and may be used instead. The following code changes should also be applied:\n\n\nAll calls to the \n-\nset()\n method should be changed to \n-\nput()\n. Typically, Laravel applications would never call the \nset\n method since it has never been documented within the Laravel documentation. However, it is included here out of caution.\n\n\nAll calls to the \n-\ngetToken()\n method should be changed to \n-\ntoken()\n.\n\n\nAll calls to the \n$request-\nsetSession()\n method should be changed to \nsetLaravelSession()\n.\n\n\nTesting\n\n\nLaravel 5.4's testing layer has been re-written to be simpler and lighter out of the box. If you would like to continue using the testing layer present in Laravel 5.3, you may install the \nlaravel/browser-kit-testing\n \npackage\n into your application. This package provides full compatibility with the Laravel 5.3 testing layer. In fact, you can run the Laravel 5.4 testing layer side-by-side with the Laravel 5.3 testing layer.\n\n\nRunning Laravel 5.3 \n 5.4 Tests In A Single Application\n\n\nBefore getting started, you should add the \nTests\n namespace to your \ncomposer.json\n file's \nautoload-dev\n block. This will allow Laravel to autoload any new tests you generate using the Laravel 5.4 test generators:\n\n\npsr-4\n: {\n    \nTests\\\\\n: \ntests/\n\n}\n\n\n\n\n\nNext, install the \nlaravel/browser-kit-testing\n package:\n\n\ncomposer require laravel/browser-kit-testing\n\n\n\n\n\nOnce the package has been installed, create a copy of your \ntests/TestCase.php\n file and save it to your \ntests\n directory as \nBrowserKitTestCase.php\n. Then, modify the file to extend the \nLaravel\\BrowserKitTesting\\TestCase\n class. Once you have done this, you should have two base test classes in your \ntests\n directory: \nTestCase.php\n and \nBrowserKitTestCase.php\n. In order for your \nBrowserKitTestCase\n class to be properly loaded, you may need to add it to your \ncomposer.json\n file:\n\n\nautoload-dev\n: {\n    \nclassmap\n: [\n        \ntests/TestCase.php\n,\n        \ntests/BrowserKitTestCase.php\n\n    ]\n},\n\n\n\n\n\nTests written on Laravel 5.3 will extend the \nBrowserKitTestCase\n class while any new tests that use the Laravel 5.4 testing layer will extend the \nTestCase\n class. Your \nBrowserKitTestCase\n class should look like the following:\n\n\n?php\n\n\n\nuse\n \nIlluminate\\Contracts\\Console\\Kernel\n;\n\n\nuse\n \nLaravel\\BrowserKitTesting\\TestCase\n \nas\n \nBaseTestCase\n;\n\n\n\nabstract\n \nclass\n \nBrowserKitTestCase\n \nextends\n \nBaseTestCase\n\n\n{\n\n    \n/**\n\n\n     * The base URL of the application.\n\n\n     *\n\n\n     * @var string\n\n\n     */\n\n    \npublic\n \n$baseUrl\n \n=\n \nhttp://localhost\n;\n\n\n    \n/**\n\n\n     * Creates the application.\n\n\n     *\n\n\n     * @return \\Illuminate\\Foundation\\Application\n\n\n     */\n\n    \npublic\n \nfunction\n \ncreateApplication\n()\n\n    \n{\n\n        \n$app\n \n=\n \nrequire\n \n__DIR__\n.\n/../bootstrap/app.php\n;\n\n\n        \n$app\n-\nmake\n(\nKernel\n::\nclass\n)\n-\nbootstrap\n();\n\n\n        \nreturn\n \n$app\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nOnce you have created this class, make sure to update all of your tests to extend your new \nBrowserKitTestCase\n class. This will allow all of your tests written on Laravel 5.3 to continue running on Laravel 5.4. If you choose, you can slowly begin to port them over to the new \nLaravel 5.4 test syntax\n or \nLaravel Dusk\n.\n\n\n\n\n{note} If you are writing new tests and want them to use the Laravel 5.4 testing layer, make sure to extend the \nTestCase\n class.\n\n\n\n\nInstalling Dusk In An Upgraded Application\n\n\nIf you would like to install Laravel Dusk into an application that has been upgraded from Laravel 5.3, first install it via Composer:\n\n\ncomposer require laravel/dusk\n\n\n\n\n\nNext, you will need to create a \nCreatesApplication\n trait in your \ntests\n directory. This trait is responsible for creating fresh application instances for test cases. The trait should look like the following:\n\n\n?php\n\n\n\nuse\n \nIlluminate\\Contracts\\Console\\Kernel\n;\n\n\n\ntrait\n \nCreatesApplication\n\n\n{\n\n    \n/**\n\n\n     * Creates the application.\n\n\n     *\n\n\n     * @return \\Illuminate\\Foundation\\Application\n\n\n     */\n\n    \npublic\n \nfunction\n \ncreateApplication\n()\n\n    \n{\n\n        \n$app\n \n=\n \nrequire\n \n__DIR__\n.\n/../bootstrap/app.php\n;\n\n\n        \n$app\n-\nmake\n(\nKernel\n::\nclass\n)\n-\nbootstrap\n();\n\n\n        \nreturn\n \n$app\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n{note} If you have namespaced your tests and are using the PSR-4 autoloading standard to load your \ntests\n directory, you should place the \nCreatesApplication\n trait under the appropriate namespace.\n\n\n\n\nOnce you have completed these preparatory steps, you can follow the normal \nDusk installation instructions\n.\n\n\nEnvironment\n\n\nThe Laravel 5.4 test class no longer manually forces \nputenv('APP_ENV=testing')\n for each test. Instead, the framework utilizes the \nAPP_ENV\n variable from the loaded \n.env\n file.\n\n\nEvent Fake\n\n\nThe \nEvent\n fake's \nassertFired\n method should be updated to \nassertDispatched\n, and the \nassertNotFired\n method should be updated to \nassertNotDispatched\n. The method's signatures have not been changed.\n\n\nMail Fake\n\n\nThe \nMail\n fake has been greatly simplified for the Laravel 5.4 release. Instead of using the \nassertSentTo\n method, you should now simply use the \nassertSent\n method and utilize the \nhasTo\n, \nhasCc\n, etc. helper methods within your callback:\n\n\nMail::assertSent(MailableName::class, function ($mailable) {\n    return $mailable-\nhasTo(\nemail@example.com\n);\n});\n\n\n\n\n\nTranslation\n\n\n{Inf}\n Placeholder\n\n\nIf you are using the \n{Inf}\n placeholder for pluralizing your translation strings, you should update your translation strings to use the \n*\n character instead:\n\n\n{0} First Message|{1,*} Second Message\n\n\n\n\n\nURL Generation\n\n\nThe \nforceSchema\n Method\n\n\nThe \nforceSchema\n method of the \nIlluminate\\Routing\\UrlGenerator\n class has been renamed to \nforceScheme\n.\n\n\nValidation\n\n\nDate Format Validation\n\n\nDate format validation is now more strict and supports the placeholders present within the documentation for the PHP \ndate function\n. In previous releases of Laravel, the timezone placeholder \nP\n would accept all timezone formats; however, in Laravel 5.4 each timezone format has a unique placeholder as per the PHP documentation.\n\n\nMethod Names\n\n\nThe \naddError\n method has been renamed to \naddFailure\n. In addition, the \ndoReplacements\n method has been renamed to \nmakeReplacements\n. Typically, these changes will only be relevant if you are extending the \nValidator\n class.\n\n\nMiscellaneous\n\n\nWe also encourage you to view the changes in the \nlaravel/laravel\n \nGitHub repository\n. While many of these changes are not required, you may wish to keep these files in sync with your application. Some of these changes will be covered in this upgrade guide, but others, such as changes to configuration files or comments, will not be. You can easily view the changes with the \nGithub comparison tool\n and choose which updates are important to you.", 
            "title": "Upgrade"
        }, 
        {
            "location": "/upgrade/#upgrade-guide", 
            "text": "Upgrading To 5.4.0 From 5.3", 
            "title": "Upgrade Guide"
        }, 
        {
            "location": "/upgrade/#upgrading-to-540-from-53", 
            "text": "", 
            "title": "Upgrading To 5.4.0 From 5.3"
        }, 
        {
            "location": "/upgrade/#estimated-upgrade-time-1-2-hours", 
            "text": "{note} We attempt to document every possible breaking change. Since some of these breaking changes are in obscure parts of the framework only a portion of these changes may actually affect your application.", 
            "title": "Estimated Upgrade Time: 1-2 Hours"
        }, 
        {
            "location": "/upgrade/#updating-dependencies", 
            "text": "Update your  laravel/framework  dependency to  5.4.*  in your  composer.json  file. In addition, you should update your  phpunit/phpunit  dependency to  ~5.7 .", 
            "title": "Updating Dependencies"
        }, 
        {
            "location": "/upgrade/#removing-compiled-services-file", 
            "text": "If it exists, you may delete the  bootstrap/cache/compiled.php  file. It is no longer used by the framework.", 
            "title": "Removing Compiled Services File"
        }, 
        {
            "location": "/upgrade/#flushing-the-cache", 
            "text": "After upgrading all packages, you should run  php artisan view:clear  to avoid Blade errors related to the removal of  Illuminate\\View\\Factory::getFirstLoop() . In addition, you may need to run  php artisan route:clear  to flush the route cache.", 
            "title": "Flushing The Cache"
        }, 
        {
            "location": "/upgrade/#laravel-cashier", 
            "text": "Laravel Cashier is already compatible with Laravel 5.4.", 
            "title": "Laravel Cashier"
        }, 
        {
            "location": "/upgrade/#laravel-passport", 
            "text": "Laravel Passport  2.0.0  has been released to provide compatibility with Laravel 5.4 and the  Axios  JavaScript library. If you are upgrading from Laravel 5.3 and using the pre-built Passport Vue components, you should make sure the Axios library is globally available to your application as  axios .", 
            "title": "Laravel Passport"
        }, 
        {
            "location": "/upgrade/#laravel-scout", 
            "text": "Laravel Scout  3.0.0  has been released to provide compatibility with Laravel 5.4.", 
            "title": "Laravel Scout"
        }, 
        {
            "location": "/upgrade/#laravel-socialite", 
            "text": "Laravel Socialite  3.0.0  has been released to provide compatibility with Laravel 5.4.", 
            "title": "Laravel Socialite"
        }, 
        {
            "location": "/upgrade/#laravel-tinker", 
            "text": "In order to continue using the  tinker  Artisan command, you should also install the  laravel/tinker  package:  composer require laravel/tinker  Once the package has been installed, you should add  Laravel\\Tinker\\TinkerServiceProvider::class  to the  providers  array in your  config/app.php  configuration file.", 
            "title": "Laravel Tinker"
        }, 
        {
            "location": "/upgrade/#guzzle", 
            "text": "Laravel 5.4 requires Guzzle 6.0 or greater.", 
            "title": "Guzzle"
        }, 
        {
            "location": "/upgrade/#authorization", 
            "text": "", 
            "title": "Authorization"
        }, 
        {
            "location": "/upgrade/#the-getpolicyfor-method", 
            "text": "Previous, when calling the  Gate::getPolicyFor($class)  method, an exception was thrown if no policy could be found. Now, the method will return  null  if no policy is found for the given class. If you call this method directly, make sure you refactor your code to check for  null :  $policy = Gate::getPolicyFor($class);  if ($policy) {      // code that was previously in the try block  } else {      // code that was previously in the catch block  }", 
            "title": "The getPolicyFor Method"
        }, 
        {
            "location": "/upgrade/#blade", 
            "text": "", 
            "title": "Blade"
        }, 
        {
            "location": "/upgrade/#section-escaping", 
            "text": "In Laravel 5.4, inline content passed to a section is automatically escaped:  @section( title , $content)  If you would like to render unescaped content in a section, you must declare the section using the traditional \"long form\" style:  @section( title )\n    {!! $content !!}\n@stop", 
            "title": "@section Escaping"
        }, 
        {
            "location": "/upgrade/#bootstrappers", 
            "text": "If you are manually overriding the  $bootstrappers  array on your HTTP or Console kernel, you should rename the  DetectEnvironment  entry to  LoadEnvironmentVariables .", 
            "title": "Bootstrappers"
        }, 
        {
            "location": "/upgrade/#broadcasting", 
            "text": "", 
            "title": "Broadcasting"
        }, 
        {
            "location": "/upgrade/#channel-model-binding", 
            "text": "When defining channel name placeholders in Laravel 5.3, the  *  character is used. In Laravel 5.4, you should define these placeholders using  {foo}  style placeholders, like routes:  Broadcast::channel( App.User.{userId} , function ($user, $userId) {\n    return (int) $user- id === (int) $userId;\n});", 
            "title": "Channel Model Binding"
        }, 
        {
            "location": "/upgrade/#collections", 
            "text": "", 
            "title": "Collections"
        }, 
        {
            "location": "/upgrade/#the-every-method", 
            "text": "The behavior of the  every  method has been moved to the  nth  method to match the method name defined by Lodash.", 
            "title": "The every Method"
        }, 
        {
            "location": "/upgrade/#the-random-method", 
            "text": "Calling  $collection- random(1)  will now return a new collection instance with one item. Previously, this would return a single object. This method will only return a single object if no arguments are supplied.", 
            "title": "The random Method"
        }, 
        {
            "location": "/upgrade/#container", 
            "text": "", 
            "title": "Container"
        }, 
        {
            "location": "/upgrade/#aliasing-via-bind-instance", 
            "text": "In previous Laravel releases, you could pass an array as the first parameter to the  bind  or  instance  methods to register an alias:  $container- bind([ foo  =  FooContract::class], function () {\n    return  foo ;\n});  However, this behavior has been removed in Laravel 5.4. To register an alias, you should now use the  alias  method:  $ container- alias ( FooContract :: class ,   foo );", 
            "title": "Aliasing Via bind / instance"
        }, 
        {
            "location": "/upgrade/#binding-classes-with-leading-slashes", 
            "text": "Binding classes into the container with leading slashes is no longer supported. This feature required a significant amount of string formatting calls to be made within the container. Instead, simply register your bindings without a leading slash:  $container- bind( Class\\Name , function () {\n    //\n});\n\n$container- bind(ClassName::class, function () {\n    //\n});", 
            "title": "Binding Classes With Leading Slashes"
        }, 
        {
            "location": "/upgrade/#make-method-parameters", 
            "text": "The container's  make  method no longer accepts a second array of parameters. This feature typically indicates a code smell. Typically, you can always construct the object in another way that is more intuitive.", 
            "title": "make Method Parameters"
        }, 
        {
            "location": "/upgrade/#resolving-callbacks", 
            "text": "The container's  resolving  and  afterResolving  method now must be provided a class name or binding key as the first argument to the method:  $container- resolving( Class\\Name , function ($instance) {\n    //\n});\n\n$container- afterResolving( Class\\Name , function ($instance) {\n    //\n});", 
            "title": "Resolving Callbacks"
        }, 
        {
            "location": "/upgrade/#share-method-removed", 
            "text": "The  share  method has been removed from the container. This was a legacy method that has not been documented in several years. If you are using this method, you should begin using the  singleton  method instead:  $container- singleton( foo , function () {\n    return  foo ;\n});", 
            "title": "share Method Removed"
        }, 
        {
            "location": "/upgrade/#console", 
            "text": "", 
            "title": "Console"
        }, 
        {
            "location": "/upgrade/#the-illuminateconsoleappnamespacedetectortrait-trait", 
            "text": "If you are directly referencing the  Illuminate\\Console\\AppNamespaceDetectorTrait  trait, update your code to reference  Illuminate\\Console\\DetectsApplicationNamespace  instead.", 
            "title": "The Illuminate\\Console\\AppNamespaceDetectorTrait Trait"
        }, 
        {
            "location": "/upgrade/#database", 
            "text": "", 
            "title": "Database"
        }, 
        {
            "location": "/upgrade/#custom-connections", 
            "text": "If you were previously binding a service container binding for a  db.connection.{driver-name}  key in order to resolve a custom database connection instance, you should now use the  Illuminate\\Database\\Connection::resolverFor  method in the  register  method of your  AppServiceProvider :  use Illuminate\\Database\\Connection;\n\nConnection::resolverFor( driver-name , function ($connection, $database, $prefix, $config) {\n    //\n});", 
            "title": "Custom Connections"
        }, 
        {
            "location": "/upgrade/#fetch-mode", 
            "text": "Laravel no longer includes the ability to customize the PDO \"fetch mode\" from your configuration files. Instead,  PDO::FETCH_OBJ  is always used. If you will still like to customize the fetch mode for your application you may listen for the new  Illuminate\\Database\\Events\\StatementPrepared  event:  Event::listen(StatementPrepared::class, function ($event) {\n    $event- statement- setFetchMode(...);\n});", 
            "title": "Fetch Mode"
        }, 
        {
            "location": "/upgrade/#eloquent", 
            "text": "", 
            "title": "Eloquent"
        }, 
        {
            "location": "/upgrade/#date-casts", 
            "text": "The  date  cast now converts the column to a  Carbon  object and calls the  startOfDay  method on the object. If you would like to preserve the time portion of the date, you should use the  datetime  cast.", 
            "title": "Date Casts"
        }, 
        {
            "location": "/upgrade/#foreign-key-conventions", 
            "text": "If the foreign key is not explicitly specified when defining a relationship, Eloquent will now use the table name and primary key name for the related model to build the foreign key. For the vast majority of applications, this is not a change of behavior. For example:  public   function   user ()  { \n     return   $this- belongsTo( User : : class );  }   Just like previous Laravel releases, this relationship will typically use  user_id  as the foreign key. However, the behavior could be different from previous releases if you are overriding the  getKeyName  method of the  User  model. For example:  public function getKeyName()\n{\n    return  key ;\n}  When this is the case, Laravel will now respect your customization and determine the foreign key column name is  user_key  instead of  user_id .", 
            "title": "Foreign Key Conventions"
        }, 
        {
            "location": "/upgrade/#has-one-many-createmany", 
            "text": "The  createMany  method of a  hasOne  or  hasMany  relationship now returns a collection object instead of an array.", 
            "title": "Has One / Many createMany"
        }, 
        {
            "location": "/upgrade/#related-model-connections", 
            "text": "Related models will now use the same connection as the parent model. For example, if you execute a query like:  User :: on ( example ) - with ( posts );   Eloquent will query the posts table on the  example  connection instead of the default database connection. If you want to read the  posts  relationship from the default connection, you should to explicitly set the model's connection to your application's default connection.", 
            "title": "Related Model Connections"
        }, 
        {
            "location": "/upgrade/#the-create-forcecreate-methods", 
            "text": "The  Model::create     Model:: forceCreate  methods have been moved to the  Illuminate\\Database\\Eloquent\\Builder  class in order to provide better support for creating models on multiple connections. However, if you are extending these methods in your own models, you will need to modify your implementation to call the  create  method on the builder. For example:  public   static   function   create ( array   $ attributes   =   [] )  { \n     $model   =   static : : query () - create ( $ attributes ); \n\n     //   ... \n\n     return   $model ;  }", 
            "title": "The create &amp; forceCreate Methods"
        }, 
        {
            "location": "/upgrade/#the-hydrate-method", 
            "text": "If you are currently passing a custom connection name to this method, you should now use the  on  method:  User :: on ( connection ) - hydrate ($ records );", 
            "title": "The hydrate Method"
        }, 
        {
            "location": "/upgrade/#hydrateraw-method", 
            "text": "The  Model::hydrateRaw  method has been renamed to  fromQuery . If you are passing a custom connection name to this method, you should now use the  on  method:  User :: on ( connection ) - fromQuery ( ... );", 
            "title": "hydrateRaw Method"
        }, 
        {
            "location": "/upgrade/#the-wherekey-method", 
            "text": "The  whereKey($id)  method will now add a \"where\" clause for the given primary key value. Previously, this would fall into the dynamic \"where\" clause builder and add a \"where\" clause for the \"key\" column. If you used the  whereKey  method to dynamically add a condition for the  key  column you should now use  where('key', ...)  instead.", 
            "title": "The whereKey Method"
        }, 
        {
            "location": "/upgrade/#the-factory-helper", 
            "text": "Calling  factory(User::class, 1)- make()  or  factory(User::class, 1)- create()  will now return a collection with one item. Previously, this would return a single model. This method will only return a single model if the amount is not supplied.", 
            "title": "The factory Helper"
        }, 
        {
            "location": "/upgrade/#events", 
            "text": "", 
            "title": "Events"
        }, 
        {
            "location": "/upgrade/#contract-changes", 
            "text": "If you are manually implementing the  Illuminate\\Contracts\\Events\\Dispatcher  interface in your application or package, you should rename the  fire  method to  dispatch .", 
            "title": "Contract Changes"
        }, 
        {
            "location": "/upgrade/#event-priority", 
            "text": "Support for event handler \"priorities\" has been removed. This undocumented feature typically indicates an abuse of the event feature. Instead, consider using a series of synchronous method calls. Alternatively, you may dispatch a new event from within the handler of another event in order to ensure that a given event's handler fires after an unrelated handler.", 
            "title": "Event Priority"
        }, 
        {
            "location": "/upgrade/#wildcard-event-handler-signatures", 
            "text": "Wildcard event handlers now receive the event name as their first argument and the array of event data as their second argument. The  Event::firing  method has been removed:  Event::listen( * , function ($eventName, array $data) {\n    //\n});", 
            "title": "Wildcard Event Handler Signatures"
        }, 
        {
            "location": "/upgrade/#the-kernelhandled-event", 
            "text": "The  kernel.handled  event is now an object based event using the  Illuminate\\Foundation\\Http\\Events\\RequestHandled  class.", 
            "title": "The kernel.handled Event"
        }, 
        {
            "location": "/upgrade/#the-localechanged-event", 
            "text": "The  locale.changed  event is now an object based event using the  Illuminate\\Foundation\\Events\\LocaleUpdated  class.", 
            "title": "The locale.changed Event"
        }, 
        {
            "location": "/upgrade/#the-illuminatelog-event", 
            "text": "The  illuminate.log  event is now an object based event using the  Illuminate\\Log\\Events\\MessageLogged  class.", 
            "title": "The illuminate.log Event"
        }, 
        {
            "location": "/upgrade/#exceptions", 
            "text": "The  Illuminate\\Http\\Exception\\HttpResponseException  has been renamed to  Illuminate\\Http\\Exceptions\\HttpResponseException . Note that  Exceptions  is now plural. Likewise, the  Illuminate\\Http\\Exception\\PostTooLargeException  has been renamed to  Illuminate\\Http\\Exceptions\\PostTooLargeException .", 
            "title": "Exceptions"
        }, 
        {
            "location": "/upgrade/#mail", 
            "text": "", 
            "title": "Mail"
        }, 
        {
            "location": "/upgrade/#classmethod-syntax", 
            "text": "Sending mail using  Class@method  syntax is no longer supported. For example:  Mail :: send ( view.name ,   $ data ,   Class@send );   If you are sending mail in this way you should convert these calls to  mailables .", 
            "title": "Class@method Syntax"
        }, 
        {
            "location": "/upgrade/#new-configuration-options", 
            "text": "In order to provide support for Laravel 5.4's new Markdown mail components, you should add the following block of configuration to the bottom of your  mail  configuration file:  markdown  =  [\n     theme  =   default ,\n\n     paths  =  [\n        resource_path( views/vendor/mail ),\n    ],\n],", 
            "title": "New Configuration Options"
        }, 
        {
            "location": "/upgrade/#queueing-mail-with-closures", 
            "text": "In order to queue mail, you now must use a  mailable . Queuing mail using the  Mail::queue  and  Mail::later  methods no longer supports using Closures to configure the mail message. This feature required the use of special libraries to serialize Closures since PHP does not natively support this feature.", 
            "title": "Queueing Mail With Closures"
        }, 
        {
            "location": "/upgrade/#redis", 
            "text": "", 
            "title": "Redis"
        }, 
        {
            "location": "/upgrade/#improved-clustering-support", 
            "text": "Laravel 5.4 introduces improved Redis cluster support. If you are using Redis clusters, you should place your cluster connections inside of a  clusters  configuration option in the Redis portion of your  config/database.php  configuration file:  redis  =  [\n\n     client  =   predis ,\n\n     options  =  [\n         cluster  =   redis ,\n    ],\n\n     clusters  =  [\n         default  =  [\n            [\n                 host  =  env( REDIS_HOST ,  127.0.0.1 ),\n                 password  =  env( REDIS_PASSWORD , null),\n                 port  =  env( REDIS_PORT , 6379),\n                 database  =  0,\n            ],\n        ],\n    ],\n\n],", 
            "title": "Improved Clustering Support"
        }, 
        {
            "location": "/upgrade/#routing", 
            "text": "", 
            "title": "Routing"
        }, 
        {
            "location": "/upgrade/#post-size-middleware", 
            "text": "The class  Illuminate\\Foundation\\Http\\Middleware\\VerifyPostSize  has been renamed to  Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize .", 
            "title": "Post Size Middleware"
        }, 
        {
            "location": "/upgrade/#the-middleware-method", 
            "text": "The  middleware  method of the  Illuminate\\Routing\\Router  class has been renamed to  aliasMiddleware() . It is likely that most applications never call this method manually, as it is typically only called by the HTTP kernel to register route-level middleware defined in the  $routeMiddleware  array.", 
            "title": "The middleware Method"
        }, 
        {
            "location": "/upgrade/#route-methods", 
            "text": "The  getUri  method of the  Illuminate\\Routing\\Route  class has been removed. You should use the  uri  method instead.  The  getMethods  method of the  Illuminate\\Routing\\Route  class has been removed. You should use the  methods  method instead.  The  getParameter  method of the  Illuminate\\Routing\\Route  class has been removed. You should use the  parameter  method instead.", 
            "title": "Route Methods"
        }, 
        {
            "location": "/upgrade/#sessions", 
            "text": "", 
            "title": "Sessions"
        }, 
        {
            "location": "/upgrade/#symfony-compatibility", 
            "text": "Laravel's session handlers no longer implements Symfony's  SessionInterface . Implementing this interface required us to implement extraneous features that were not needed by the framework. Instead, a new  Illuminate\\Contracts\\Session\\Session  interface has been defined and may be used instead. The following code changes should also be applied:  All calls to the  - set()  method should be changed to  - put() . Typically, Laravel applications would never call the  set  method since it has never been documented within the Laravel documentation. However, it is included here out of caution.  All calls to the  - getToken()  method should be changed to  - token() .  All calls to the  $request- setSession()  method should be changed to  setLaravelSession() .", 
            "title": "Symfony Compatibility"
        }, 
        {
            "location": "/upgrade/#testing", 
            "text": "Laravel 5.4's testing layer has been re-written to be simpler and lighter out of the box. If you would like to continue using the testing layer present in Laravel 5.3, you may install the  laravel/browser-kit-testing   package  into your application. This package provides full compatibility with the Laravel 5.3 testing layer. In fact, you can run the Laravel 5.4 testing layer side-by-side with the Laravel 5.3 testing layer.", 
            "title": "Testing"
        }, 
        {
            "location": "/upgrade/#running-laravel-53-54-tests-in-a-single-application", 
            "text": "Before getting started, you should add the  Tests  namespace to your  composer.json  file's  autoload-dev  block. This will allow Laravel to autoload any new tests you generate using the Laravel 5.4 test generators:  psr-4 : {\n     Tests\\\\ :  tests/ \n}  Next, install the  laravel/browser-kit-testing  package:  composer require laravel/browser-kit-testing  Once the package has been installed, create a copy of your  tests/TestCase.php  file and save it to your  tests  directory as  BrowserKitTestCase.php . Then, modify the file to extend the  Laravel\\BrowserKitTesting\\TestCase  class. Once you have done this, you should have two base test classes in your  tests  directory:  TestCase.php  and  BrowserKitTestCase.php . In order for your  BrowserKitTestCase  class to be properly loaded, you may need to add it to your  composer.json  file:  autoload-dev : {\n     classmap : [\n         tests/TestCase.php ,\n         tests/BrowserKitTestCase.php \n    ]\n},  Tests written on Laravel 5.3 will extend the  BrowserKitTestCase  class while any new tests that use the Laravel 5.4 testing layer will extend the  TestCase  class. Your  BrowserKitTestCase  class should look like the following:  ?php  use   Illuminate\\Contracts\\Console\\Kernel ;  use   Laravel\\BrowserKitTesting\\TestCase   as   BaseTestCase ;  abstract   class   BrowserKitTestCase   extends   BaseTestCase  { \n     /**       * The base URL of the application.       *       * @var string       */ \n     public   $baseUrl   =   http://localhost ; \n\n     /**       * Creates the application.       *       * @return \\Illuminate\\Foundation\\Application       */ \n     public   function   createApplication () \n     { \n         $app   =   require   __DIR__ . /../bootstrap/app.php ; \n\n         $app - make ( Kernel :: class ) - bootstrap (); \n\n         return   $app ; \n     }  }   Once you have created this class, make sure to update all of your tests to extend your new  BrowserKitTestCase  class. This will allow all of your tests written on Laravel 5.3 to continue running on Laravel 5.4. If you choose, you can slowly begin to port them over to the new  Laravel 5.4 test syntax  or  Laravel Dusk .   {note} If you are writing new tests and want them to use the Laravel 5.4 testing layer, make sure to extend the  TestCase  class.", 
            "title": "Running Laravel 5.3 &amp; 5.4 Tests In A Single Application"
        }, 
        {
            "location": "/upgrade/#installing-dusk-in-an-upgraded-application", 
            "text": "If you would like to install Laravel Dusk into an application that has been upgraded from Laravel 5.3, first install it via Composer:  composer require laravel/dusk  Next, you will need to create a  CreatesApplication  trait in your  tests  directory. This trait is responsible for creating fresh application instances for test cases. The trait should look like the following:  ?php  use   Illuminate\\Contracts\\Console\\Kernel ;  trait   CreatesApplication  { \n     /**       * Creates the application.       *       * @return \\Illuminate\\Foundation\\Application       */ \n     public   function   createApplication () \n     { \n         $app   =   require   __DIR__ . /../bootstrap/app.php ; \n\n         $app - make ( Kernel :: class ) - bootstrap (); \n\n         return   $app ; \n     }  }    {note} If you have namespaced your tests and are using the PSR-4 autoloading standard to load your  tests  directory, you should place the  CreatesApplication  trait under the appropriate namespace.   Once you have completed these preparatory steps, you can follow the normal  Dusk installation instructions .", 
            "title": "Installing Dusk In An Upgraded Application"
        }, 
        {
            "location": "/upgrade/#environment", 
            "text": "The Laravel 5.4 test class no longer manually forces  putenv('APP_ENV=testing')  for each test. Instead, the framework utilizes the  APP_ENV  variable from the loaded  .env  file.", 
            "title": "Environment"
        }, 
        {
            "location": "/upgrade/#event-fake", 
            "text": "The  Event  fake's  assertFired  method should be updated to  assertDispatched , and the  assertNotFired  method should be updated to  assertNotDispatched . The method's signatures have not been changed.", 
            "title": "Event Fake"
        }, 
        {
            "location": "/upgrade/#mail-fake", 
            "text": "The  Mail  fake has been greatly simplified for the Laravel 5.4 release. Instead of using the  assertSentTo  method, you should now simply use the  assertSent  method and utilize the  hasTo ,  hasCc , etc. helper methods within your callback:  Mail::assertSent(MailableName::class, function ($mailable) {\n    return $mailable- hasTo( email@example.com );\n});", 
            "title": "Mail Fake"
        }, 
        {
            "location": "/upgrade/#translation", 
            "text": "", 
            "title": "Translation"
        }, 
        {
            "location": "/upgrade/#inf-placeholder", 
            "text": "If you are using the  {Inf}  placeholder for pluralizing your translation strings, you should update your translation strings to use the  *  character instead:  {0} First Message|{1,*} Second Message", 
            "title": "{Inf} Placeholder"
        }, 
        {
            "location": "/upgrade/#url-generation", 
            "text": "", 
            "title": "URL Generation"
        }, 
        {
            "location": "/upgrade/#the-forceschema-method", 
            "text": "The  forceSchema  method of the  Illuminate\\Routing\\UrlGenerator  class has been renamed to  forceScheme .", 
            "title": "The forceSchema Method"
        }, 
        {
            "location": "/upgrade/#validation", 
            "text": "", 
            "title": "Validation"
        }, 
        {
            "location": "/upgrade/#date-format-validation", 
            "text": "Date format validation is now more strict and supports the placeholders present within the documentation for the PHP  date function . In previous releases of Laravel, the timezone placeholder  P  would accept all timezone formats; however, in Laravel 5.4 each timezone format has a unique placeholder as per the PHP documentation.", 
            "title": "Date Format Validation"
        }, 
        {
            "location": "/upgrade/#method-names", 
            "text": "The  addError  method has been renamed to  addFailure . In addition, the  doReplacements  method has been renamed to  makeReplacements . Typically, these changes will only be relevant if you are extending the  Validator  class.", 
            "title": "Method Names"
        }, 
        {
            "location": "/upgrade/#miscellaneous", 
            "text": "We also encourage you to view the changes in the  laravel/laravel   GitHub repository . While many of these changes are not required, you may wish to keep these files in sync with your application. Some of these changes will be covered in this upgrade guide, but others, such as changes to configuration files or comments, will not be. You can easily view the changes with the  Github comparison tool  and choose which updates are important to you.", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/valet/", 
            "text": "Laravel Valet\n\n\n\n\nIntroduction\n\n\nValet Or Homestead\n\n\n\n\n\n\nInstallation\n\n\nUpgrading\n\n\n\n\n\n\nServing Sites\n\n\nThe \"Park\" Command\n\n\nThe \"Link\" Command\n\n\nSecuring Sites With TLS\n\n\n\n\n\n\nSharing Sites\n\n\nCustom Valet Drivers\n\n\nOther Valet Commands\n\n\n\n\n\n\nIntroduction\n\n\nValet is a Laravel development environment for Mac minimalists. No Vagrant, no \n/etc/hosts\n file. You can even share your sites publicly using local tunnels. \nYeah, we like it too.\n\n\nLaravel Valet configures your Mac to always run \nNginx\n in the background when your machine starts. Then, using \nDnsMasq\n, Valet proxies all requests on the \n*.dev\n domain to point to sites installed on your local machine.\n\n\nIn other words, a blazing fast Laravel development environment that uses roughly 7 MB of RAM. Valet isn't a complete replacement for Vagrant or Homestead, but provides a great alternative if you want flexible basics, prefer extreme speed, or are working on a machine with a limited amount of RAM.\n\n\nOut of the box, Valet support includes, but is not limited to:\n\n\n\n- [Laravel](https://laravel.com)\n- [Lumen](https://lumen.laravel.com)\n- [Symfony](https://symfony.com)\n- [Zend](https://framework.zend.com)\n- [CakePHP 3](https://cakephp.org)\n- [WordPress](https://wordpress.org)\n- [Bedrock](https://roots.io/bedrock/)\n- [Craft](https://craftcms.com)\n- [Statamic](https://statamic.com)\n- [Jigsaw](http://jigsaw.tighten.co)\n- Static HTML\n\n\n\n\nHowever, you may extend Valet with your own \ncustom drivers\n.\n\n\n\n\nValet Or Homestead\n\n\nAs you may know, Laravel offers \nHomestead\n, another local Laravel development environment. Homestead and Valet differ in regards to their intended audience and their approach to local development. Homestead offers an entire Ubuntu virtual machine with automated Nginx configuration. Homestead is a wonderful choice if you want a fully virtualized Linux development environment or are on Windows / Linux.\n\n\nValet only supports Mac, and requires you to install PHP and a database server directly onto your local machine. This is easily achieved by using \nHomebrew\n with commands like \nbrew install php71\n and \nbrew install mysql\n. Valet provides a blazing fast local development environment with minimal resource consumption, so it's great for developers who only require PHP / MySQL and do not need a fully virtualized development environment.\n\n\nBoth Valet and Homestead are great choices for configuring your Laravel development environment. Which one you choose will depend on your personal taste and your team's needs.\n\n\n\n\nInstallation\n\n\nValet requires macOS and \nHomebrew\n. Before installation, you should make sure that no other programs such as Apache or Nginx are binding to your local machine's port 80.\n\n\n\n- Install or update [Homebrew](http://brew.sh/) to the latest version using `brew update`.\n- Install PHP 7.1 using Homebrew via `brew install homebrew/php/php71`.\n- Install Valet with Composer via `composer global require laravel/valet`. Make sure the `~/.composer/vendor/bin` directory is in your system's \"PATH\".\n- Run the `valet install` command. This will configure and install Valet and DnsMasq, and register Valet's daemon to launch when your system starts.\n\n\n\n\nOnce Valet is installed, try pinging any \n*.dev\n domain on your terminal using a command such as \nping foobar.dev\n. If Valet is installed correctly you should see this domain responding on \n127.0.0.1\n.\n\n\nValet will automatically start its daemon each time your machine boots. There is no need to run \nvalet start\n or \nvalet install\n ever again once the initial Valet installation is complete.\n\n\nUsing Another Domain\n\n\nBy default, Valet serves your projects using the \n.dev\n TLD. If you'd like to use another domain, you can do so using the \nvalet domain tld-name\n command.\n\n\nFor example, if you'd like to use \n.app\n instead of \n.dev\n, run \nvalet domain app\n and Valet will start serving your projects at \n*.app\n automatically.\n\n\nDatabase\n\n\nIf you need a database, try MySQL by running \nbrew install mysql\n on your command line. Once MySQL has been installed, you may start it using the \nbrew services start mysql\n command. You can then connect to the database at \n127.0.0.1\n using the \nroot\n username and an empty string for the password.\n\n\n\n\nUpgrading\n\n\nYou may update your Valet installation using the \ncomposer global update\n command in your terminal. After upgrading, it is good practice to run the \nvalet install\n command so Valet can make additional upgrades to your configuration files if necessary.\n\n\nUpgrading To Valet 2.0\n\n\nValet 2.0 transitions Valet's underlying web server from Caddy to Nginx. Before upgrading to this version you should run the following commands to stop and uninstall the existing Caddy daemon:\n\n\nvalet stop\nvalet uninstall\n\n\n\n\n\nNext, you should upgrade to the latest version of Valet. Depending on how you installed Valet, this is typically done through Git or Composer. If you installed Valet via Composer, you should use the following command to update to the latest major version:\n\n\ncomposer global require laravel/valet\n\n\n\n\n\nOnce the fresh Valet source code has been downloaded, you should run the \ninstall\n command:\n\n\nvalet install\nvalet restart\n\n\n\n\n\nAfter upgrading, it may be necessary to re-park or re-link your sites.\n\n\n\n\nServing Sites\n\n\nOnce Valet is installed, you're ready to start serving sites. Valet provides two commands to help you serve your Laravel sites: \npark\n and \nlink\n.\n\n\n\n\nThe \npark\n Command\n\n\n\n- Create a new directory on your Mac by running something like `mkdir ~/Sites`. Next, `cd ~/Sites` and run `valet park`. This command will register your current working directory as a path that Valet should search for sites.\n- Next, create a new Laravel site within this directory: `laravel new blog`.\n- Open `http://blog.dev` in your browser.\n\n\n\n\nThat's all there is to it.\n Now, any Laravel project you create within your \"parked\" directory will automatically be served using the \nhttp://folder-name.dev\n convention.\n\n\n\n\nThe \nlink\n Command\n\n\nThe \nlink\n command may also be used to serve your Laravel sites. This command is useful if you want to serve a single site in a directory and not the entire directory.\n\n\n\n- To use the command, navigate to one of your projects and run `valet link app-name` in your terminal. Valet will create a symbolic link in `~/.valet/Sites` which points to your current working directory.\n- After running the `link` command, you can access the site in your browser at `http://app-name.dev`.\n\n\n\n\nTo see a listing of all of your linked directories, run the \nvalet links\n command. You may use \nvalet unlink app-name\n to destroy the symbolic link.\n\n\n\n\n{tip} You can use \nvalet link\n to serve the same project from multiple (sub)domains. To add a subdomain or another domain to your project run \nvalet link subdomain.app-name\n from the project folder.\n\n\n\n\n\n\nSecuring Sites With TLS\n\n\nBy default, Valet serves sites over plain HTTP. However, if you would like to serve a site over encrypted TLS using HTTP/2, use the \nsecure\n command. For example, if your site is being served by Valet on the \nlaravel.dev\n domain, you should run the following command to secure it:\n\n\nvalet secure laravel\n\n\n\n\n\nTo \"unsecure\" a site and revert back to serving its traffic over plain HTTP, use the \nunsecure\n command. Like the \nsecure\n command, this command accepts the host name that you wish to unsecure:\n\n\nvalet unsecure laravel\n\n\n\n\n\n\n\nSharing Sites\n\n\nValet even includes a command to share your local sites with the world. No additional software installation is required once Valet is installed.\n\n\nTo share a site, navigate to the site's directory in your terminal and run the \nvalet share\n command. A publicly accessible URL will be inserted into your clipboard and is ready to paste directly into your browser. That's it.\n\n\nTo stop sharing your site, hit \nControl + C\n to cancel the process.\n\n\n\n\n{note} \nvalet share\n does not currently support sharing sites that have been secured using the \nvalet secure\n command.\n\n\n\n\n\n\nCustom Valet Drivers\n\n\nYou can write your own Valet \"driver\" to serve PHP applications running on another framework or CMS that is not natively supported by Valet. When you install Valet, a \n~/.valet/Drivers\n directory is created which contains a \nSampleValetDriver.php\n file. This file contains a sample driver implementation to demonstrate how to write a custom driver. Writing a driver only requires you to implement three methods: \nserves\n, \nisStaticFile\n, and \nfrontControllerPath\n.\n\n\nAll three methods receive the \n$sitePath\n, \n$siteName\n, and \n$uri\n values as their arguments. The \n$sitePath\n is the fully qualified path to the site being served on your machine, such as \n/Users/Lisa/Sites/my-project\n. The \n$siteName\n is the \"host\" / \"site name\" portion of the domain (\nmy-project\n). The \n$uri\n is the incoming request URI (\n/foo/bar\n).\n\n\nOnce you have completed your custom Valet driver, place it in the \n~/.valet/Drivers\n directory using the \nFrameworkValetDriver.php\n naming convention. For example, if you are writing a custom valet driver for WordPress, your file name should be \nWordPressValetDriver.php\n.\n\n\nLet's take a look at a sample implementation of each method your custom Valet driver should implement.\n\n\nThe \nserves\n Method\n\n\nThe \nserves\n method should return \ntrue\n if your driver should handle the incoming request. Otherwise, the method should return \nfalse\n. So, within this method you should attempt to determine if the given \n$sitePath\n contains a project of the type you are trying to serve.\n\n\nFor example, let's pretend we are writing a \nWordPressValetDriver\n. Our serve method might look something like this:\n\n\n/**\n\n\n * Determine if the driver serves the request.\n\n\n *\n\n\n * @param  string  $sitePath\n\n\n * @param  string  $siteName\n\n\n * @param  string  $uri\n\n\n * @return bool\n\n\n */\n\npublic\n \nfunction\n \nserves\n(\n$\nsitePath\n,\n \n$\nsiteName\n,\n \n$\nuri\n)\n\n\n{\n\n\n    \nreturn\n \nis_dir\n(\n$\nsitePath\n.\n/wp-admin\n)\n;\n\n\n}\n\n\n\n\n\n\nThe \nisStaticFile\n Method\n\n\nThe \nisStaticFile\n should determine if the incoming request is for a file that is \"static\", such as an image or a stylesheet. If the file is static, the method should return the fully qualified path to the static file on disk. If the incoming request is not for a static file, the method should return \nfalse\n:\n\n\n/**\n\n\n * Determine if the incoming request is for a static file.\n\n\n *\n\n\n * @param  string  $sitePath\n\n\n * @param  string  $siteName\n\n\n * @param  string  $uri\n\n\n * @return string|false\n\n\n */\n\npublic\n \nfunction\n \nisStaticFile\n(\n$\nsitePath\n,\n \n$\nsiteName\n,\n \n$\nuri\n)\n\n\n{\n\n\n    \nif\n \n(\nfile_exists\n(\n$\nstaticFilePath\n \n=\n \n$\nsitePath\n.\n/public/\n.\n$\nuri\n))\n \n{\n\n\n        \nreturn\n \n$\nstaticFilePath\n;\n\n\n    \n}\n\n\n\n    \nreturn\n \nfalse\n;\n\n\n}\n\n\n\n\n\n\n\n\n{note} The \nisStaticFile\n method will only be called if the \nserves\n method returns \ntrue\n for the incoming request and the request URI is not \n/\n.\n\n\n\n\nThe \nfrontControllerPath\n Method\n\n\nThe \nfrontControllerPath\n method should return the fully qualified path to your application's \"front controller\", which is typically your \"index.php\" file or equivalent:\n\n\n/**\n\n\n * Get the fully resolved path to the application\ns front controller.\n\n\n *\n\n\n * @param  string  $sitePath\n\n\n * @param  string  $siteName\n\n\n * @param  string  $uri\n\n\n * @return string\n\n\n */\n\npublic\n \nfunction\n \nfrontControllerPath\n(\n$\nsitePath\n,\n \n$\nsiteName\n,\n \n$\nuri\n)\n\n\n{\n\n\n    \nreturn\n \n$\nsitePath\n.\n/public/index.php\n;\n\n\n}\n\n\n\n\n\n\n\n\nOther Valet Commands\n\n\n\n\n\n\n\n\nCommand\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalet forget\n\n\nRun this command from a \"parked\" directory to remove it from the parked directory list.\n\n\n\n\n\n\nvalet paths\n\n\nView all of your \"parked\" paths.\n\n\n\n\n\n\nvalet restart\n\n\nRestart the Valet daemon.\n\n\n\n\n\n\nvalet start\n\n\nStart the Valet daemon.\n\n\n\n\n\n\nvalet stop\n\n\nStop the Valet daemon.\n\n\n\n\n\n\nvalet uninstall\n\n\nUninstall the Valet daemon entirely.", 
            "title": "Valet"
        }, 
        {
            "location": "/valet/#laravel-valet", 
            "text": "Introduction  Valet Or Homestead    Installation  Upgrading    Serving Sites  The \"Park\" Command  The \"Link\" Command  Securing Sites With TLS    Sharing Sites  Custom Valet Drivers  Other Valet Commands", 
            "title": "Laravel Valet"
        }, 
        {
            "location": "/valet/#introduction", 
            "text": "Valet is a Laravel development environment for Mac minimalists. No Vagrant, no  /etc/hosts  file. You can even share your sites publicly using local tunnels.  Yeah, we like it too.  Laravel Valet configures your Mac to always run  Nginx  in the background when your machine starts. Then, using  DnsMasq , Valet proxies all requests on the  *.dev  domain to point to sites installed on your local machine.  In other words, a blazing fast Laravel development environment that uses roughly 7 MB of RAM. Valet isn't a complete replacement for Vagrant or Homestead, but provides a great alternative if you want flexible basics, prefer extreme speed, or are working on a machine with a limited amount of RAM.  Out of the box, Valet support includes, but is not limited to:  \n- [Laravel](https://laravel.com)\n- [Lumen](https://lumen.laravel.com)\n- [Symfony](https://symfony.com)\n- [Zend](https://framework.zend.com)\n- [CakePHP 3](https://cakephp.org)\n- [WordPress](https://wordpress.org)\n- [Bedrock](https://roots.io/bedrock/)\n- [Craft](https://craftcms.com)\n- [Statamic](https://statamic.com)\n- [Jigsaw](http://jigsaw.tighten.co)\n- Static HTML  However, you may extend Valet with your own  custom drivers .", 
            "title": "Introduction"
        }, 
        {
            "location": "/valet/#valet-or-homestead", 
            "text": "As you may know, Laravel offers  Homestead , another local Laravel development environment. Homestead and Valet differ in regards to their intended audience and their approach to local development. Homestead offers an entire Ubuntu virtual machine with automated Nginx configuration. Homestead is a wonderful choice if you want a fully virtualized Linux development environment or are on Windows / Linux.  Valet only supports Mac, and requires you to install PHP and a database server directly onto your local machine. This is easily achieved by using  Homebrew  with commands like  brew install php71  and  brew install mysql . Valet provides a blazing fast local development environment with minimal resource consumption, so it's great for developers who only require PHP / MySQL and do not need a fully virtualized development environment.  Both Valet and Homestead are great choices for configuring your Laravel development environment. Which one you choose will depend on your personal taste and your team's needs.", 
            "title": "Valet Or Homestead"
        }, 
        {
            "location": "/valet/#installation", 
            "text": "Valet requires macOS and  Homebrew . Before installation, you should make sure that no other programs such as Apache or Nginx are binding to your local machine's port 80.  \n- Install or update [Homebrew](http://brew.sh/) to the latest version using `brew update`.\n- Install PHP 7.1 using Homebrew via `brew install homebrew/php/php71`.\n- Install Valet with Composer via `composer global require laravel/valet`. Make sure the `~/.composer/vendor/bin` directory is in your system's \"PATH\".\n- Run the `valet install` command. This will configure and install Valet and DnsMasq, and register Valet's daemon to launch when your system starts.  Once Valet is installed, try pinging any  *.dev  domain on your terminal using a command such as  ping foobar.dev . If Valet is installed correctly you should see this domain responding on  127.0.0.1 .  Valet will automatically start its daemon each time your machine boots. There is no need to run  valet start  or  valet install  ever again once the initial Valet installation is complete.", 
            "title": "Installation"
        }, 
        {
            "location": "/valet/#using-another-domain", 
            "text": "By default, Valet serves your projects using the  .dev  TLD. If you'd like to use another domain, you can do so using the  valet domain tld-name  command.  For example, if you'd like to use  .app  instead of  .dev , run  valet domain app  and Valet will start serving your projects at  *.app  automatically.", 
            "title": "Using Another Domain"
        }, 
        {
            "location": "/valet/#database", 
            "text": "If you need a database, try MySQL by running  brew install mysql  on your command line. Once MySQL has been installed, you may start it using the  brew services start mysql  command. You can then connect to the database at  127.0.0.1  using the  root  username and an empty string for the password.", 
            "title": "Database"
        }, 
        {
            "location": "/valet/#upgrading", 
            "text": "You may update your Valet installation using the  composer global update  command in your terminal. After upgrading, it is good practice to run the  valet install  command so Valet can make additional upgrades to your configuration files if necessary.", 
            "title": "Upgrading"
        }, 
        {
            "location": "/valet/#upgrading-to-valet-20", 
            "text": "Valet 2.0 transitions Valet's underlying web server from Caddy to Nginx. Before upgrading to this version you should run the following commands to stop and uninstall the existing Caddy daemon:  valet stop\nvalet uninstall  Next, you should upgrade to the latest version of Valet. Depending on how you installed Valet, this is typically done through Git or Composer. If you installed Valet via Composer, you should use the following command to update to the latest major version:  composer global require laravel/valet  Once the fresh Valet source code has been downloaded, you should run the  install  command:  valet install\nvalet restart  After upgrading, it may be necessary to re-park or re-link your sites.", 
            "title": "Upgrading To Valet 2.0"
        }, 
        {
            "location": "/valet/#serving-sites", 
            "text": "Once Valet is installed, you're ready to start serving sites. Valet provides two commands to help you serve your Laravel sites:  park  and  link .   The  park  Command  \n- Create a new directory on your Mac by running something like `mkdir ~/Sites`. Next, `cd ~/Sites` and run `valet park`. This command will register your current working directory as a path that Valet should search for sites.\n- Next, create a new Laravel site within this directory: `laravel new blog`.\n- Open `http://blog.dev` in your browser.  That's all there is to it.  Now, any Laravel project you create within your \"parked\" directory will automatically be served using the  http://folder-name.dev  convention.   The  link  Command  The  link  command may also be used to serve your Laravel sites. This command is useful if you want to serve a single site in a directory and not the entire directory.  \n- To use the command, navigate to one of your projects and run `valet link app-name` in your terminal. Valet will create a symbolic link in `~/.valet/Sites` which points to your current working directory.\n- After running the `link` command, you can access the site in your browser at `http://app-name.dev`.  To see a listing of all of your linked directories, run the  valet links  command. You may use  valet unlink app-name  to destroy the symbolic link.   {tip} You can use  valet link  to serve the same project from multiple (sub)domains. To add a subdomain or another domain to your project run  valet link subdomain.app-name  from the project folder.    Securing Sites With TLS  By default, Valet serves sites over plain HTTP. However, if you would like to serve a site over encrypted TLS using HTTP/2, use the  secure  command. For example, if your site is being served by Valet on the  laravel.dev  domain, you should run the following command to secure it:  valet secure laravel  To \"unsecure\" a site and revert back to serving its traffic over plain HTTP, use the  unsecure  command. Like the  secure  command, this command accepts the host name that you wish to unsecure:  valet unsecure laravel", 
            "title": "Serving Sites"
        }, 
        {
            "location": "/valet/#sharing-sites", 
            "text": "Valet even includes a command to share your local sites with the world. No additional software installation is required once Valet is installed.  To share a site, navigate to the site's directory in your terminal and run the  valet share  command. A publicly accessible URL will be inserted into your clipboard and is ready to paste directly into your browser. That's it.  To stop sharing your site, hit  Control + C  to cancel the process.   {note}  valet share  does not currently support sharing sites that have been secured using the  valet secure  command.", 
            "title": "Sharing Sites"
        }, 
        {
            "location": "/valet/#custom-valet-drivers", 
            "text": "You can write your own Valet \"driver\" to serve PHP applications running on another framework or CMS that is not natively supported by Valet. When you install Valet, a  ~/.valet/Drivers  directory is created which contains a  SampleValetDriver.php  file. This file contains a sample driver implementation to demonstrate how to write a custom driver. Writing a driver only requires you to implement three methods:  serves ,  isStaticFile , and  frontControllerPath .  All three methods receive the  $sitePath ,  $siteName , and  $uri  values as their arguments. The  $sitePath  is the fully qualified path to the site being served on your machine, such as  /Users/Lisa/Sites/my-project . The  $siteName  is the \"host\" / \"site name\" portion of the domain ( my-project ). The  $uri  is the incoming request URI ( /foo/bar ).  Once you have completed your custom Valet driver, place it in the  ~/.valet/Drivers  directory using the  FrameworkValetDriver.php  naming convention. For example, if you are writing a custom valet driver for WordPress, your file name should be  WordPressValetDriver.php .  Let's take a look at a sample implementation of each method your custom Valet driver should implement.", 
            "title": "Custom Valet Drivers"
        }, 
        {
            "location": "/valet/#the-serves-method", 
            "text": "The  serves  method should return  true  if your driver should handle the incoming request. Otherwise, the method should return  false . So, within this method you should attempt to determine if the given  $sitePath  contains a project of the type you are trying to serve.  For example, let's pretend we are writing a  WordPressValetDriver . Our serve method might look something like this:  /**   * Determine if the driver serves the request.   *   * @param  string  $sitePath   * @param  string  $siteName   * @param  string  $uri   * @return bool   */ \npublic   function   serves ( $ sitePath ,   $ siteName ,   $ uri )  {       return   is_dir ( $ sitePath . /wp-admin ) ;  }", 
            "title": "The serves Method"
        }, 
        {
            "location": "/valet/#the-isstaticfile-method", 
            "text": "The  isStaticFile  should determine if the incoming request is for a file that is \"static\", such as an image or a stylesheet. If the file is static, the method should return the fully qualified path to the static file on disk. If the incoming request is not for a static file, the method should return  false :  /**   * Determine if the incoming request is for a static file.   *   * @param  string  $sitePath   * @param  string  $siteName   * @param  string  $uri   * @return string|false   */ \npublic   function   isStaticFile ( $ sitePath ,   $ siteName ,   $ uri )  {       if   ( file_exists ( $ staticFilePath   =   $ sitePath . /public/ . $ uri ))   {           return   $ staticFilePath ;       }       return   false ;  }    {note} The  isStaticFile  method will only be called if the  serves  method returns  true  for the incoming request and the request URI is not  / .", 
            "title": "The isStaticFile Method"
        }, 
        {
            "location": "/valet/#the-frontcontrollerpath-method", 
            "text": "The  frontControllerPath  method should return the fully qualified path to your application's \"front controller\", which is typically your \"index.php\" file or equivalent:  /**   * Get the fully resolved path to the application s front controller.   *   * @param  string  $sitePath   * @param  string  $siteName   * @param  string  $uri   * @return string   */ \npublic   function   frontControllerPath ( $ sitePath ,   $ siteName ,   $ uri )  {       return   $ sitePath . /public/index.php ;  }", 
            "title": "The frontControllerPath Method"
        }, 
        {
            "location": "/valet/#other-valet-commands", 
            "text": "Command  Description      valet forget  Run this command from a \"parked\" directory to remove it from the parked directory list.    valet paths  View all of your \"parked\" paths.    valet restart  Restart the Valet daemon.    valet start  Start the Valet daemon.    valet stop  Stop the Valet daemon.    valet uninstall  Uninstall the Valet daemon entirely.", 
            "title": "Other Valet Commands"
        }, 
        {
            "location": "/validation/", 
            "text": "Validation\n\n\n\n\nIntroduction\n\n\nValidation Quickstart\n\n\nDefining The Routes\n\n\nCreating The Controller\n\n\nWriting The Validation Logic\n\n\nDisplaying The Validation Errors\n\n\nA Note On Optional Fields\n\n\n\n\n\n\nForm Request Validation\n\n\nCreating Form Requests\n\n\nAuthorizing Form Requests\n\n\nCustomizing The Error Format\n\n\nCustomizing The Error Messages\n\n\n\n\n\n\nManually Creating Validators\n\n\nAutomatic Redirection\n\n\nNamed Error Bags\n\n\nAfter Validation Hook\n\n\n\n\n\n\nWorking With Error Messages\n\n\nCustom Error Messages\n\n\n\n\n\n\nAvailable Validation Rules\n\n\nConditionally Adding Rules\n\n\nValidating Arrays\n\n\nCustom Validation Rules\n\n\n\n\n\n\nIntroduction\n\n\nLaravel provides several different approaches to validate your application's incoming data. By default, Laravel's base controller class uses a \nValidatesRequests\n trait which provides a convenient method to validate incoming HTTP request with a variety of powerful validation rules.\n\n\n\n\nValidation Quickstart\n\n\nTo learn about Laravel's powerful validation features, let's look at a complete example of validating a form and displaying the error messages back to the user.\n\n\n\n\nDefining The Routes\n\n\nFirst, let's assume we have the following routes defined in our \nroutes/web.php\n file:\n\n\nRoute\n::\nget\n(\npost/create\n,\n \nPostController@create\n);\n\n\n\nRoute\n::\npost\n(\npost\n,\n \nPostController@store\n);\n\n\n\n\n\n\nOf course, the \nGET\n route will display a form for the user to create a new blog post, while the \nPOST\n route will store the new blog post in the database.\n\n\n\n\nCreating The Controller\n\n\nNext, let's take a look at a simple controller that handles these routes. We'll leave the \nstore\n method empty for now:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nPostController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Show the form to create a new blog post.\n\n\n     *\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \ncreate\n()\n\n    \n{\n\n        \nreturn\n \nview\n(\npost.create\n);\n\n    \n}\n\n\n    \n/**\n\n\n     * Store a new blog post.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nstore\n(\nRequest\n \n$request\n)\n\n    \n{\n\n        \n// Validate and store the blog post...\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nWriting The Validation Logic\n\n\nNow we are ready to fill in our \nstore\n method with the logic to validate the new blog post. If you examine your application's base controller (\nApp\\Http\\Controllers\\Controller\n) class, you will see that the class uses a \nValidatesRequests\n trait. This trait provides a convenient \nvalidate\n method to all of your controllers.\n\n\nThe \nvalidate\n method accepts an incoming HTTP request and a set of validation rules. If the validation rules pass, your code will keep executing normally; however, if validation fails, an exception will be thrown and the proper error response will automatically be sent back to the user. In the case of a traditional HTTP request, a redirect response will be generated, while a JSON response will be sent for AJAX requests.\n\n\nTo get a better understanding of the \nvalidate\n method, let's jump back into the \nstore\n method:\n\n\n/**\n\n\n * Store a new blog post.\n\n\n *\n\n\n * @param  Request  $request\n\n\n * @return Response\n\n\n */\n\npublic\n \nfunction\n \nstore\n(\nRequest\n \n$\nrequest\n)\n\n\n{\n\n\n    \n$\nthis\n-\nvalidate\n(\n$\nrequest\n,\n \n[\n\n\n        \ntitle\n \n=\n \nrequired|unique:posts|max:255\n,\n\n\n        \nbody\n \n=\n \nrequired\n,\n\n\n    \n]\n)\n;\n\n\n\n    \n//\n \nThe\n \nblog\n \npost\n \nis\n \nvalid\n,\n \nstore\n \nin\n \ndatabase\n...\n\n\n}\n\n\n\n\n\n\nAs you can see, we simply pass the incoming HTTP request and desired validation rules into the \nvalidate\n method. Again, if the validation fails, the proper response will automatically be generated. If the validation passes, our controller will continue executing normally.\n\n\nStopping On First Validation Failure\n\n\nSometimes you may wish to stop running validation rules on an attribute after the first validation failure. To do so, assign the \nbail\n rule to the attribute:\n\n\n$this-\nvalidate($request, [\n    \ntitle\n =\n \nbail|required|unique:posts|max:255\n,\n    \nbody\n =\n \nrequired\n,\n]);\n\n\n\n\n\nIn this example, if the \nrequired\n rule on the \ntitle\n attribute fails, the \nunique\n rule will not be checked. Rules will be validated in the order they are assigned.\n\n\nA Note On Nested Attributes\n\n\nIf your HTTP request contains \"nested\" parameters, you may specify them in your validation rules using \"dot\" syntax:\n\n\n$this-\nvalidate($request, [\n    \ntitle\n =\n \nrequired|unique:posts|max:255\n,\n    \nauthor.name\n =\n \nrequired\n,\n    \nauthor.description\n =\n \nrequired\n,\n]);\n\n\n\n\n\n\n\nDisplaying The Validation Errors\n\n\nSo, what if the incoming request parameters do not pass the given validation rules? As mentioned previously, Laravel will automatically redirect the user back to their previous location. In addition, all of the validation errors will automatically be \nflashed to the session\n.\n\n\nAgain, notice that we did not have to explicitly bind the error messages to the view in our \nGET\n route. This is because Laravel will check for errors in the session data, and automatically bind them to the view if they are available. The \n$errors\n variable will be an instance of \nIlluminate\\Support\\MessageBag\n. For more information on working with this object, \ncheck out its documentation\n.\n\n\n\n\n{tip} The \n$errors\n variable is bound to the view by the \nIlluminate\\View\\Middleware\\ShareErrorsFromSession\n middleware, which is provided by the \nweb\n middleware group. \nWhen this middleware is applied an \n$errors\n variable will always be available in your views\n, allowing you to conveniently assume the \n$errors\n variable is always defined and can be safely used.\n\n\n\n\nSo, in our example, the user will be redirected to our controller's \ncreate\n method when validation fails, allowing us to display the error messages in the view:\n\n\n!--\n \n/\nresources\n/\nviews\n/\npost\n/\ncreate\n.\nblade\n.\nphp\n \n--\n\n\n\nh1\nCreate\n \nPost\n/\nh1\n\n\n\n@\nif\n \n(\ncount\n(\n$\nerrors\n)\n \n \n0\n)\n\n    \ndiv\n \nclass\n=\nalert alert-danger\n\n        \nul\n\n            \n@\nforeach\n \n(\n$\nerrors\n-\nall\n()\n \nas\n \n$\nerror\n)\n\n                \nli\n{{\n \n$\nerror\n \n}}\n/\nli\n\n            \n@\nendforeach\n\n        \n/\nul\n\n    \n/\ndiv\n\n\n@\nendif\n\n\n\n!--\n \nCreate\n \nPost\n \nForm\n \n--\n\n\n\n\n\n\n\n\nA Note On Optional Fields\n\n\nBy default, Laravel includes the \nTrimStrings\n and \nConvertEmptyStringsToNull\n middleware in your application's global middleware stack. These middleware are listed in the stack by the \nApp\\Http\\Kernel\n class. Because of this, you will often need to mark your \"optional\" request fields as \nnullable\n if you do not want the validator to consider \nnull\n values as invalid. For example:\n\n\n$this-\nvalidate($request, [\n    \ntitle\n =\n \nrequired|unique:posts|max:255\n,\n    \nbody\n =\n \nrequired\n,\n    \npublish_at\n =\n \nnullable|date\n,\n]);\n\n\n\n\n\nIn this example, we are specifying that the \npublish_at\n field may be either \nnull\n or a valid date representation. If the \nnullable\n modifier is not added to the rule definition, the validator would consider \nnull\n an invalid date.\n\n\n\n\nCustomizing The Flashed Error Format\n\n\nIf you wish to customize the format of the validation errors that are flashed to the session when validation fails, override the \nformatValidationErrors\n on your base controller. Don't forget to import the \nIlluminate\\Contracts\\Validation\\Validator\n class at the top of the file:\n\n\n?php\n\n\n\nnamespace\n \nApp\\Http\\Controllers\n;\n\n\n\nuse\n \nIlluminate\\Foundation\\Bus\\DispatchesJobs\n;\n\n\nuse\n \nIlluminate\\Contracts\\Validation\\Validator\n;\n\n\nuse\n \nIlluminate\\Routing\\Controller\n \nas\n \nBaseController\n;\n\n\nuse\n \nIlluminate\\Foundation\\Validation\\ValidatesRequests\n;\n\n\n\nabstract\n \nclass\n \nController\n \nextends\n \nBaseController\n\n\n{\n\n    \nuse\n \nDispatchesJobs\n,\n \nValidatesRequests\n;\n\n\n    \n/**\n\n\n     * {@inheritdoc}\n\n\n     */\n\n    \nprotected\n \nfunction\n \nformatValidationErrors\n(\nValidator\n \n$validator\n)\n\n    \n{\n\n        \nreturn\n \n$validator\n-\nerrors\n()\n-\nall\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nAJAX Requests \n Validation\n\n\nIn this example, we used a traditional form to send data to the application. However, many applications use AJAX requests. When using the \nvalidate\n method during an AJAX request, Laravel will not generate a redirect response. Instead, Laravel generates a JSON response containing all of the validation errors. This JSON response will be sent with a 422 HTTP status code.\n\n\n\n\nForm Request Validation\n\n\n\n\nCreating Form Requests\n\n\nFor more complex validation scenarios, you may wish to create a \"form request\". Form requests are custom request classes that contain validation logic. To create a form request class, use the \nmake:request\n Artisan CLI command:\n\n\nphp artisan make:request StoreBlogPost\n\n\n\n\n\nThe generated class will be placed in the \napp/Http/Requests\n directory. If this directory does not exist, it will be created when you run the \nmake:request\n command. Let's add a few validation rules to the \nrules\n method:\n\n\n/**\n\n\n * Get the validation rules that apply to the request.\n\n\n *\n\n\n * @return array\n\n\n */\n\npublic\n \nfunction\n \nrules\n()\n\n\n{\n\n\n    \nreturn\n \n[\n\n\n        \ntitle\n \n=\n \nrequired|unique:posts|max:255\n,\n\n\n        \nbody\n \n=\n \nrequired\n,\n\n\n    \n];\n\n\n}\n\n\n\n\n\n\nSo, how are the validation rules evaluated? All you need to do is type-hint the request on your controller method. The incoming form request is validated before the controller method is called, meaning you do not need to clutter your controller with any validation logic:\n\n\n/**\n\n\n * Store the incoming blog post.\n\n\n *\n\n\n * @param  StoreBlogPost  $request\n\n\n * @return Response\n\n\n */\n\npublic\n \nfunction\n \nstore\n(\nStoreBlogPost\n \n$\nrequest\n)\n\n\n{\n\n\n    \n//\n \nThe\n \nincoming\n \nrequest\n \nis\n \nvalid\n...\n\n\n}\n\n\n\n\n\n\nIf validation fails, a redirect response will be generated to send the user back to their previous location. The errors will also be flashed to the session so they are available for display. If the request was an AJAX request, a HTTP response with a 422 status code will be returned to the user including a JSON representation of the validation errors.\n\n\nAdding After Hooks To Form Requests\n\n\nIf you would like to add an \"after\" hook to a form request, you may use the \nwithValidator\n method. This method receives the fully constructed validator, allowing you to call any of its methods before the validation rules are actually evaluated:\n\n\n/**\n\n\n * Configure the validator instance.\n\n\n *\n\n\n * @param  \\Illuminate\\Validation\\Validator  $validator\n\n\n * @return void\n\n\n */\n\npublic\n \nfunction\n \nwithValidator\n(\n$\nvalidator\n)\n\n\n{\n\n\n    \n$\nvalidator\n-\nafter\n(\nfunction\n \n(\n$\nvalidator\n)\n \n{\n\n\n        \nif\n \n(\n$\nthis\n-\nsomethingElseIsInvalid\n())\n \n{\n\n\n            \n$\nvalidator\n-\nerrors\n()-\nadd\n(\nfield\n,\n \nSomething is wrong with this field!\n)\n;\n\n\n        \n}\n\n\n    \n}\n)\n;\n\n\n}\n\n\n\n\n\n\n\n\nAuthorizing Form Requests\n\n\nThe form request class also contains an \nauthorize\n method. Within this method, you may check if the authenticated user actually has the authority to update a given resource. For example, you may determine if a user actually owns a blog comment they are attempting to update:\n\n\n/**\n\n\n * Determine if the user is authorized to make this request.\n\n\n *\n\n\n * @return bool\n\n\n */\n\n\npublic\n \nfunction\n \nauthorize\n()\n\n\n{\n\n    \n$comment\n \n=\n \nComment\n:\n:\nfind\n(\n$\nthis\n-\nroute\n(\ncomment\n));\n\n\n    \nreturn\n \n$comment\n \n \n$this-\nuser()-\ncan(\nupdate\n,\n \n$comment)\n;\n\n\n}\n\n\n\n\n\n\nSince all form requests extend the base Laravel request class, we may use the \nuser\n method to access the currently authenticated user. Also note the call to the \nroute\n method in the example above. This method grants you access to the URI parameters defined on the route being called, such as the \n{comment}\n parameter in the example below:\n\n\nRoute\n::\npost\n(\ncomment/{comment}\n);\n\n\n\n\n\n\nIf the \nauthorize\n method returns \nfalse\n, a HTTP response with a 403 status code will automatically be returned and your controller method will not execute.\n\n\nIf you plan to have authorization logic in another part of your application, simply return \ntrue\n from the \nauthorize\n method:\n\n\n/**\n\n\n * Determine if the user is authorized to make this request.\n\n\n *\n\n\n * @return bool\n\n\n */\n\npublic\n \nfunction\n \nauthorize\n()\n\n\n{\n\n\n    \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\n\n\nCustomizing The Error Format\n\n\nIf you wish to customize the format of the validation errors that are flashed to the session when validation fails, override the \nformatErrors\n on your base request (\nApp\\Http\\Requests\\Request\n). Don't forget to import the \nIlluminate\\Contracts\\Validation\\Validator\n class at the top of the file:\n\n\n/**\n\n\n * {@inheritdoc}\n\n\n */\n\nprotected\n \nfunction\n \nformatErrors\n(\nValidator\n \n$\nvalidator\n)\n\n\n{\n\n\n    \nreturn\n \n$\nvalidator\n-\nerrors\n()-\nall\n()\n;\n\n\n}\n\n\n\n\n\n\n\n\nCustomizing The Error Messages\n\n\nYou may customize the error messages used by the form request by overriding the \nmessages\n method. This method should return an array of attribute / rule pairs and their corresponding error messages:\n\n\n/**\n\n\n * Get the error messages for the defined validation rules.\n\n\n *\n\n\n * @return array\n\n\n */\n\npublic\n \nfunction\n \nmessages\n()\n\n\n{\n\n\n    \nreturn\n \n[\n\n\n        \ntitle.required\n \n=\n \nA title is required\n,\n\n\n        \nbody.required\n  \n=\n \nA message is required\n,\n\n\n    \n];\n\n\n}\n\n\n\n\n\n\n\n\nManually Creating Validators\n\n\nIf you do not want to use the \nValidatesRequests\n trait's \nvalidate\n method, you may create a validator instance manually using the \nValidator\n \nfacade\n. The \nmake\n method on the facade generates a new validator instance:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nControllers\n;\n\n\n\nuse\n \nValidator\n;\n\n\nuse\n \nIlluminate\n\\\nHttp\n\\\nRequest\n;\n\n\nuse\n \nApp\n\\\nHttp\n\\\nControllers\n\\\nController\n;\n\n\n\nclass\n \nPostController\n \nextends\n \nController\n\n\n{\n\n    \n/**\n\n\n     * Store a new blog post.\n\n\n     *\n\n\n     * @param  Request  $request\n\n\n     * @return Response\n\n\n     */\n\n    \npublic\n \nfunction\n \nstore\n(\nRequest\n \n$request\n)\n\n    \n{\n\n        \n$validator\n \n=\n \nValidator\n::\nmake\n(\n$request\n-\nall\n(),\n \n[\n\n            \ntitle\n \n=\n \nrequired|unique:posts|max:255\n,\n\n            \nbody\n \n=\n \nrequired\n,\n\n        \n]);\n\n\n        \nif\n \n(\n$validator\n-\nfails\n())\n \n{\n\n            \nreturn\n \nredirect\n(\npost/create\n)\n\n                        \n-\nwithErrors\n(\n$validator\n)\n\n                        \n-\nwithInput\n();\n\n        \n}\n\n\n        \n// Store the blog post...\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe first argument passed to the \nmake\n method is the data under validation. The second argument is the validation rules that should be applied to the data.\n\n\nAfter checking if the request validation failed, you may use the \nwithErrors\n method to flash the error messages to the session. When using this method, the \n$errors\n variable will automatically be shared with your views after redirection, allowing you to easily display them back to the user. The \nwithErrors\n method accepts a validator, a \nMessageBag\n, or a PHP \narray\n.\n\n\n\n\nAutomatic Redirection\n\n\nIf you would like to create a validator instance manually but still take advantage of the automatic redirection offered by the \nValidatesRequest\n trait, you may call the \nvalidate\n method on an existing validator instance. If validation fails, the user will automatically be redirected or, in the case of an AJAX request, a JSON response will be returned:\n\n\nValidator::make($request-\nall(), [\n    \ntitle\n =\n \nrequired|unique:posts|max:255\n,\n    \nbody\n =\n \nrequired\n,\n])-\nvalidate();\n\n\n\n\n\n\n\nNamed Error Bags\n\n\nIf you have multiple forms on a single page, you may wish to name the \nMessageBag\n of errors, allowing you to retrieve the error messages for a specific form. Simply pass a name as the second argument to \nwithErrors\n:\n\n\nreturn redirect(\nregister\n)\n            -\nwithErrors($validator, \nlogin\n);\n\n\n\n\n\nYou may then access the named \nMessageBag\n instance from the \n$errors\n variable:\n\n\n{{\n \n$\nerrors-\nlogin-\nfirst\n(\nemail\n)\n \n}}\n\n\n\n\n\n\n\n\nAfter Validation Hook\n\n\nThe validator also allows you to attach callbacks to be run after validation is completed. This allows you to easily perform further validation and even add more error messages to the message collection. To get started, use the \nafter\n method on a validator instance:\n\n\n$\nvalidator\n \n=\n \nValidator\n::\nmake\n(...);\n\n\n\n$\nvalidator-\nafter\n(\nfunction\n \n($\nvalidator\n)\n \n{\n\n    \nif\n \n($this-\nsomethingElseIsInvalid())\n \n{\n\n        \n$validator-\nerrors()-\nadd(\nfield\n,\n \nSomething\n \nis\n \nwrong\n \nwith\n \nthis\n \nfield!\n)\n;\n\n    \n}\n\n\n}\n);\n\n\n\nif\n \n($\nvalidator-\nfails\n())\n \n{\n\n    \n//\n\n\n}\n\n\n\n\n\n\n\n\nWorking With Error Messages\n\n\nAfter calling the \nerrors\n method on a \nValidator\n instance, you will receive an \nIlluminate\\Support\\MessageBag\n instance, which has a variety of convenient methods for working with error messages. The \n$errors\n variable that is automatically made available to all views is also an instance of the \nMessageBag\n class.\n\n\nRetrieving The First Error Message For A Field\n\n\nTo retrieve the first error message for a given field, use the \nfirst\n method:\n\n\n$errors = $validator-\nerrors();\n\necho $errors-\nfirst(\nemail\n);\n\n\n\n\n\nRetrieving All Error Messages For A Field\n\n\nIf you need to retrieve an array of all the messages for a given field, use the \nget\n method:\n\n\nforeach ($errors-\nget(\nemail\n) as $message) {\n    //\n}\n\n\n\n\n\nIf you are validating an array form field, you may retrieve all of the messages for each of the array elements using the \n*\n character:\n\n\nforeach ($errors-\nget(\nattachments.*\n) as $message) {\n    //\n}\n\n\n\n\n\nRetrieving All Error Messages For All Fields\n\n\nTo retrieve an array of all messages for all fields, use the \nall\n method:\n\n\nforeach ($errors-\nall() as $message) {\n    //\n}\n\n\n\n\n\nDetermining If Messages Exist For A Field\n\n\nThe \nhas\n method may be used to determine if any error messages exist for a given field:\n\n\nif ($errors-\nhas(\nemail\n)) {\n    //\n}\n\n\n\n\n\n\n\nCustom Error Messages\n\n\nIf needed, you may use custom error messages for validation instead of the defaults. There are several ways to specify custom messages. First, you may pass the custom messages as the third argument to the \nValidator::make\n method:\n\n\n$\nmessages\n \n=\n \n[\n\n    \nrequired\n \n=\n \nThe :attribute field is required.\n,\n\n\n]\n;\n\n\n\n$\nvalidator\n \n=\n \nValidator\n::\nmake\n($\ninput\n,\n \n$\nrules\n,\n \n$\nmessages\n);\n\n\n\n\n\n\nIn this example, the \n:attribute\n place-holder will be replaced by the actual name of the field under validation. You may also utilize other place-holders in validation messages. For example:\n\n\n$messages = [\n    \nsame\n    =\n \nThe :attribute and :other must match.\n,\n    \nsize\n    =\n \nThe :attribute must be exactly :size.\n,\n    \nbetween\n =\n \nThe :attribute must be between :min - :max.\n,\n    \nin\n      =\n \nThe :attribute must be one of the following types: :values\n,\n];\n\n\n\n\n\nSpecifying A Custom Message For A Given Attribute\n\n\nSometimes you may wish to specify a custom error messages only for a specific field. You may do so using \"dot\" notation. Specify the attribute's name first, followed by the rule:\n\n\n$messages = [\n    \nemail.required\n =\n \nWe need to know your e-mail address!\n,\n];\n\n\n\n\n\n\n\nSpecifying Custom Messages In Language Files\n\n\nIn most cases, you will probably specify your custom messages in a language file instead of passing them directly to the \nValidator\n. To do so, add your messages to \ncustom\n array in the \nresources/lang/xx/validation.php\n language file.\n\n\ncustom\n =\n [\n    \nemail\n =\n [\n        \nrequired\n =\n \nWe need to know your e-mail address!\n,\n    ],\n],\n\n\n\n\n\nSpecifying Custom Attributes In Language Files\n\n\nIf you would like the \n:attribute\n portion of your validation message to be replaced with a custom attribute name, you may specify the custom name in the \nattributes\n array of your \nresources/lang/xx/validation.php\n language file:\n\n\nattributes\n =\n [\n    \nemail\n =\n \nemail address\n,\n],\n\n\n\n\n\n\n\nAvailable Validation Rules\n\n\nBelow is a list of all available validation rules and their function:\n\n\n\n    .collection-method-list > p {\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    .collection-method-list a {\n        display: block;\n    }\n\n\n\n\n\n\n[Accepted](#rule-accepted)\n[Active URL](#rule-active-url)\n[After (Date)](#rule-after)\n[After Or Equal (Date)](#rule-after-or-equal)\n[Alpha](#rule-alpha)\n[Alpha Dash](#rule-alpha-dash)\n[Alpha Numeric](#rule-alpha-num)\n[Array](#rule-array)\n[Before (Date)](#rule-before)\n[Before Or Equal (Date)](#rule-before-or-equal)\n[Between](#rule-between)\n[Boolean](#rule-boolean)\n[Confirmed](#rule-confirmed)\n[Date](#rule-date)\n[Date Format](#rule-date-format)\n[Different](#rule-different)\n[Digits](#rule-digits)\n[Digits Between](#rule-digits-between)\n[Dimensions (Image Files)](#rule-dimensions)\n[Distinct](#rule-distinct)\n[E-Mail](#rule-email)\n[Exists (Database)](#rule-exists)\n[File](#rule-file)\n[Filled](#rule-filled)\n[Image (File)](#rule-image)\n[In](#rule-in)\n[In Array](#rule-in-array)\n[Integer](#rule-integer)\n[IP Address](#rule-ip)\n[JSON](#rule-json)\n[Max](#rule-max)\n[MIME Types](#rule-mimetypes)\n[MIME Type By File Extension](#rule-mimes)\n[Min](#rule-min)\n[Nullable](#rule-nullable)\n[Not In](#rule-not-in)\n[Numeric](#rule-numeric)\n[Present](#rule-present)\n[Regular Expression](#rule-regex)\n[Required](#rule-required)\n[Required If](#rule-required-if)\n[Required Unless](#rule-required-unless)\n[Required With](#rule-required-with)\n[Required With All](#rule-required-with-all)\n[Required Without](#rule-required-without)\n[Required Without All](#rule-required-without-all)\n[Same](#rule-same)\n[Size](#rule-size)\n[String](#rule-string)\n[Timezone](#rule-timezone)\n[Unique (Database)](#rule-unique)\n[URL](#rule-url)\n\n\n\n\n\n\n\naccepted\n\n\nThe field under validation must be \nyes\n, \non\n, \n1\n, or \ntrue\n. This is useful for validating \"Terms of Service\" acceptance.\n\n\n\n\nactive_url\n\n\nThe field under validation must have a valid A or AAAA record according to the \ndns_get_record\n PHP function.\n\n\n\n\nafter:\ndate\n\n\nThe field under validation must be a value after a given date. The dates will be passed into the \nstrtotime\n PHP function:\n\n\nstart_date\n =\n \nrequired|date|after:tomorrow\n\n\n\n\n\n\nInstead of passing a date string to be evaluated by \nstrtotime\n, you may specify another field to compare against the date:\n\n\nfinish_date\n =\n \nrequired|date|after:start_date\n\n\n\n\n\n\n\n\nafter_or_equal:\ndate\n\n\nThe field under validation must be a value after or equal to the given date. For more information, see the \nafter\n rule.\n\n\n\n\nalpha\n\n\nThe field under validation must be entirely alphabetic characters.\n\n\n\n\nalpha_dash\n\n\nThe field under validation may have alpha-numeric characters, as well as dashes and underscores.\n\n\n\n\nalpha_num\n\n\nThe field under validation must be entirely alpha-numeric characters.\n\n\n\n\narray\n\n\nThe field under validation must be a PHP \narray\n.\n\n\n\n\nbefore:\ndate\n\n\nThe field under validation must be a value preceding the given date. The dates will be passed into the PHP \nstrtotime\n function.\n\n\n\n\nbefore_or_equal:\ndate\n\n\nThe field under validation must be a value preceding or equal to the given date. The dates will be passed into the PHP \nstrtotime\n function.\n\n\n\n\nbetween:\nmin\n,\nmax\n\n\nThe field under validation must have a size between the given \nmin\n and \nmax\n. Strings, numerics, and files are evaluated in the same fashion as the \nsize\n rule.\n\n\n\n\nboolean\n\n\nThe field under validation must be able to be cast as a boolean. Accepted input are \ntrue\n, \nfalse\n, \n1\n, \n0\n, \n\"1\"\n, and \n\"0\"\n.\n\n\n\n\nconfirmed\n\n\nThe field under validation must have a matching field of \nfoo_confirmation\n. For example, if the field under validation is \npassword\n, a matching \npassword_confirmation\n field must be present in the input.\n\n\n\n\ndate\n\n\nThe field under validation must be a valid date according to the \nstrtotime\n PHP function.\n\n\n\n\ndate_format:\nformat\n\n\nThe field under validation must match the given \nformat\n. You should use \neither\n \ndate\n or \ndate_format\n when validating a field, not both.\n\n\n\n\ndifferent:\nfield\n\n\nThe field under validation must have a different value than \nfield\n.\n\n\n\n\ndigits:\nvalue\n\n\nThe field under validation must be \nnumeric\n and must have an exact length of \nvalue\n.\n\n\n\n\ndigits_between:\nmin\n,\nmax\n\n\nThe field under validation must have a length between the given \nmin\n and \nmax\n.\n\n\n\n\ndimensions\n\n\nThe file under validation must be an image meeting the dimension constraints as specified by the rule's parameters:\n\n\navatar\n =\n \ndimensions:min_width=100,min_height=200\n\n\n\n\n\n\nAvailable constraints are: \nmin_width\n, \nmax_width\n, \nmin_height\n, \nmax_height\n, \nwidth\n, \nheight\n, \nratio\n.\n\n\nA \nratio\n constraint should be represented as width divided by height. This can be specified either by a statement like \n3/2\n or a float like \n1.5\n:\n\n\navatar\n =\n \ndimensions:ratio=3/2\n\n\n\n\n\n\nSince this rule requires several arguments, you may use the \nRule::dimensions\n method to fluently construct the rule:\n\n\nuse Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n    \navatar\n =\n [\n        \nrequired\n,\n        Rule::dimensions()-\nmaxWidth(1000)-\nmaxHeight(500)-\nratio(3 / 2),\n    ],\n]);\n\n\n\n\n\n\n\ndistinct\n\n\nWhen working with arrays, the field under validation must not have any duplicate values.\n\n\nfoo.*.id\n =\n \ndistinct\n\n\n\n\n\n\n\n\nemail\n\n\nThe field under validation must be formatted as an e-mail address.\n\n\n\n\nexists:\ntable\n,\ncolumn\n\n\nThe field under validation must exist on a given database table.\n\n\nBasic Usage Of Exists Rule\n\n\nstate\n =\n \nexists:states\n\n\n\n\n\n\nSpecifying A Custom Column Name\n\n\nstate\n =\n \nexists:states,abbreviation\n\n\n\n\n\n\nOccasionally, you may need to specify a specific database connection to be used for the \nexists\n query. You can accomplish this by prepending the connection name to the table name using \"dot\" syntax:\n\n\nemail\n =\n \nexists:connection.staff,email\n\n\n\n\n\n\nIf you would like to customize the query executed by the validation rule, you may use the \nRule\n class to fluently define the rule. In this example, we'll also specify the validation rules as an array instead of using the \n|\n character to delimit them:\n\n\nuse Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n    \nemail\n =\n [\n        \nrequired\n,\n        Rule::exists(\nstaff\n)-\nwhere(function ($query) {\n            $query-\nwhere(\naccount_id\n, 1);\n        }),\n    ],\n]);\n\n\n\n\n\n\n\nfile\n\n\nThe field under validation must be a successfully uploaded file.\n\n\n\n\nfilled\n\n\nThe field under validation must not be empty when it is present.\n\n\n\n\nimage\n\n\nThe file under validation must be an image (jpeg, png, bmp, gif, or svg)\n\n\n\n\nin:\nfoo\n,\nbar\n,...\n\n\nThe field under validation must be included in the given list of values. Since this rule often requires you to \nimplode\n an array, the \nRule::in\n method may be used to fluently construct the rule:\n\n\nuse Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n    \nzones\n =\n [\n        \nrequired\n,\n        Rule::in([\nfirst-zone\n, \nsecond-zone\n]),\n    ],\n]);\n\n\n\n\n\n\n\nin_array:\nanotherfield\n\n\nThe field under validation must exist in \nanotherfield\n's values.\n\n\n\n\ninteger\n\n\nThe field under validation must be an integer.\n\n\n\n\nip\n\n\nThe field under validation must be an IP address.\n\n\nipv4\n\n\nThe field under validation must be an IPv4 address.\n\n\nipv6\n\n\nThe field under validation must be an IPv6 address.\n\n\n\n\njson\n\n\nThe field under validation must be a valid JSON string.\n\n\n\n\nmax:\nvalue\n\n\nThe field under validation must be less than or equal to a maximum \nvalue\n. Strings, numerics, and files are evaluated in the same fashion as the \nsize\n rule.\n\n\n\n\nmimetypes:\ntext/plain\n,...\n\n\nThe file under validation must match one of the given MIME types:\n\n\nvideo\n =\n \nmimetypes:video/avi,video/mpeg,video/quicktime\n\n\n\n\n\n\nTo determine the MIME type of the uploaded file, the file's contents will be read and the framework will attempt to guess the MIME type, which may be different from the client provided MIME type.\n\n\n\n\nmimes:\nfoo\n,\nbar\n,...\n\n\nThe file under validation must have a MIME type corresponding to one of the listed extensions.\n\n\nBasic Usage Of MIME Rule\n\n\nphoto\n =\n \nmimes:jpeg,bmp,png\n\n\n\n\n\n\nEven though you only need to specify the extensions, this rule actually validates against the MIME type of the file by reading the file's contents and guessing its MIME type.\n\n\nA full listing of MIME types and their corresponding extensions may be found at the following location: \nhttps://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types\n\n\n\n\nmin:\nvalue\n\n\nThe field under validation must have a minimum \nvalue\n. Strings, numerics, and files are evaluated in the same fashion as the \nsize\n rule.\n\n\n\n\nnullable\n\n\nThe field under validation may be \nnull\n. This is particularly useful when validating primitive such as strings and integers that can contain \nnull\n values.\n\n\n\n\nnot_in:\nfoo\n,\nbar\n,...\n\n\nThe field under validation must not be included in the given list of values.\n\n\n\n\nnumeric\n\n\nThe field under validation must be numeric.\n\n\n\n\npresent\n\n\nThe field under validation must be present in the input data but can be empty.\n\n\n\n\nregex:\npattern\n\n\nThe field under validation must match the given regular expression.\n\n\nNote:\n When using the \nregex\n pattern, it may be necessary to specify rules in an array instead of using pipe delimiters, especially if the regular expression contains a pipe character.\n\n\n\n\nrequired\n\n\nThe field under validation must be present in the input data and not empty. A field is considered \"empty\" if one of the following conditions are true:\n\n\n\n\n- The value is `null`.\n- The value is an empty string.\n- The value is an empty array or empty `Countable` object.\n- The value is an uploaded file with no path.\n\n\n\n\n\n\n\nrequired_if:\nanotherfield\n,\nvalue\n,...\n\n\nThe field under validation must be present and not empty if the \nanotherfield\n field is equal to any \nvalue\n.\n\n\n\n\nrequired_unless:\nanotherfield\n,\nvalue\n,...\n\n\nThe field under validation must be present and not empty unless the \nanotherfield\n field is equal to any \nvalue\n.\n\n\n\n\nrequired_with:\nfoo\n,\nbar\n,...\n\n\nThe field under validation must be present and not empty \nonly if\n any of the other specified fields are present.\n\n\n\n\nrequired_with_all:\nfoo\n,\nbar\n,...\n\n\nThe field under validation must be present and not empty \nonly if\n all of the other specified fields are present.\n\n\n\n\nrequired_without:\nfoo\n,\nbar\n,...\n\n\nThe field under validation must be present and not empty \nonly when\n any of the other specified fields are not present.\n\n\n\n\nrequired_without_all:\nfoo\n,\nbar\n,...\n\n\nThe field under validation must be present and not empty \nonly when\n all of the other specified fields are not present.\n\n\n\n\nsame:\nfield\n\n\nThe given \nfield\n must match the field under validation.\n\n\n\n\nsize:\nvalue\n\n\nThe field under validation must have a size matching the given \nvalue\n. For string data, \nvalue\n corresponds to the number of characters. For numeric data, \nvalue\n corresponds to a given integer value. For an array, \nsize\n corresponds to the \ncount\n of the array. For files, \nsize\n corresponds to the file size in kilobytes.\n\n\n\n\nstring\n\n\nThe field under validation must be a string. If you would like to allow the field to also be \nnull\n, you should assign the \nnullable\n rule to the field.\n\n\n\n\ntimezone\n\n\nThe field under validation must be a valid timezone identifier according to the \ntimezone_identifiers_list\n PHP function.\n\n\n\n\nunique:\ntable\n,\ncolumn\n,\nexcept\n,\nidColumn\n\n\nThe field under validation must be unique in a given database table. If the \ncolumn\n option is not specified, the field name will be used.\n\n\nSpecifying A Custom Column Name:\n\n\nemail\n =\n \nunique:users,email_address\n\n\n\n\n\n\nCustom Database Connection\n\n\nOccasionally, you may need to set a custom connection for database queries made by the Validator. As seen above, setting \nunique:users\n as a validation rule will use the default database connection to query the database. To override this, specify the connection and the table name using \"dot\" syntax:\n\n\nemail\n =\n \nunique:connection.users,email_address\n\n\n\n\n\n\nForcing A Unique Rule To Ignore A Given ID:\n\n\nSometimes, you may wish to ignore a given ID during the unique check. For example, consider an \"update profile\" screen that includes the user's name, e-mail address, and location. Of course, you will want to verify that the e-mail address is unique. However, if the user only changes the name field and not the e-mail field, you do not want a validation error to be thrown because the user is already the owner of the e-mail address.\n\n\nTo instruct the validator to ignore the user's ID, we'll use the \nRule\n class to fluently define the rule. In this example, we'll also specify the validation rules as an array instead of using the \n|\n character to delimit the rules:\n\n\nuse Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n    \nemail\n =\n [\n        \nrequired\n,\n        Rule::unique(\nusers\n)-\nignore($user-\nid),\n    ],\n]);\n\n\n\n\n\nIf your table uses a primary key column name other than \nid\n, you may specify the name of the column when calling the \nignore\n method:\n\n\nemail\n =\n Rule::unique(\nusers\n)-\nignore($user-\nid, \nuser_id\n)\n\n\n\n\n\nAdding Additional Where Clauses:\n\n\nYou may also specify additional query constraints by customizing the query using the \nwhere\n method. For example, let's add a constraint that verifies the \naccount_id\n is \n1\n:\n\n\nemail\n =\n Rule::unique(\nusers\n)-\nwhere(function ($query) {\n    $query-\nwhere(\naccount_id\n, 1);\n})\n\n\n\n\n\n\n\nurl\n\n\nThe field under validation must be a valid URL.\n\n\n\n\nConditionally Adding Rules\n\n\nValidating When Present\n\n\nIn some situations, you may wish to run validation checks against a field \nonly\n if that field is present in the input array. To quickly accomplish this, add the \nsometimes\n rule to your rule list:\n\n\n$v = Validator::make($data, [\n    \nemail\n =\n \nsometimes|required|email\n,\n]);\n\n\n\n\n\nIn the example above, the \nemail\n field will only be validated if it is present in the \n$data\n array.\n\n\nComplex Conditional Validation\n\n\nSometimes you may wish to add validation rules based on more complex conditional logic. For example, you may wish to require a given field only if another field has a greater value than 100. Or, you may need two fields to have a given value only when another field is present. Adding these validation rules doesn't have to be a pain. First, create a \nValidator\n instance with your \nstatic rules\n that never change:\n\n\n$v = Validator::make($data, [\n    \nemail\n =\n \nrequired|email\n,\n    \ngames\n =\n \nrequired|numeric\n,\n]);\n\n\n\n\n\nLet's assume our web application is for game collectors. If a game collector registers with our application and they own more than 100 games, we want them to explain why they own so many games. For example, perhaps they run a game resale shop, or maybe they just enjoy collecting. To conditionally add this requirement, we can use the \nsometimes\n method on the \nValidator\n instance.\n\n\n$v-\nsometimes(\nreason\n, \nrequired|max:500\n, function ($input) {\n    return $input-\ngames \n= 100;\n});\n\n\n\n\n\nThe first argument passed to the \nsometimes\n method is the name of the field we are conditionally validating. The second argument is the rules we want to add. If the \nClosure\n passed as the third argument returns \ntrue\n, the rules will be added. This method makes it a breeze to build complex conditional validations. You may even add conditional validations for several fields at once:\n\n\n$v-\nsometimes([\nreason\n, \ncost\n], \nrequired\n, function ($input) {\n    return $input-\ngames \n= 100;\n});\n\n\n\n\n\n\n\n{tip} The \n$input\n parameter passed to your \nClosure\n will be an instance of \nIlluminate\\Support\\Fluent\n and may be used to access your input and files.\n\n\n\n\n\n\nValidating Arrays\n\n\nValidating array based form input fields doesn't have to be a pain. For example, to validate that each e-mail in a given array input field is unique, you may do the following:\n\n\n$validator = Validator::make($request-\nall(), [\n    \nperson.*.email\n =\n \nemail|unique:users\n,\n    \nperson.*.first_name\n =\n \nrequired_with:person.*.last_name\n,\n]);\n\n\n\n\n\nLikewise, you may use the \n*\n character when specifying your validation messages in your language files, making it a breeze to use a single validation message for array based fields:\n\n\ncustom\n =\n [\n    \nperson.*.email\n =\n [\n        \nunique\n =\n \nEach person must have a unique e-mail address\n,\n    ]\n],\n\n\n\n\n\n\n\nCustom Validation Rules\n\n\nLaravel provides a variety of helpful validation rules; however, you may wish to specify some of your own. One method of registering custom validation rules is using the \nextend\n method on the \nValidator\n \nfacade\n. Let's use this method within a \nservice provider\n to register a custom validation rule:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nValidator\n;\n\n\n\nclass\n \nAppServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Bootstrap any application services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nValidator\n::\nextend\n(\nfoo\n,\n \nfunction\n \n(\n$attribute\n,\n \n$value\n,\n \n$parameters\n,\n \n$validator\n)\n \n{\n\n            \nreturn\n \n$value\n \n==\n \nfoo\n;\n\n        \n});\n\n    \n}\n\n\n    \n/**\n\n\n     * Register the service provider.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe custom validator Closure receives four arguments: the name of the \n$attribute\n being validated, the \n$value\n of the attribute, an array of \n$parameters\n passed to the rule, and the \nValidator\n instance.\n\n\nYou may also pass a class and method to the \nextend\n method instead of a Closure:\n\n\nValidator\n::\nextend\n(\nfoo\n,\n \nFooValidator@validate\n);\n\n\n\n\n\n\nDefining The Error Message\n\n\nYou will also need to define an error message for your custom rule. You can do so either using an inline custom message array or by adding an entry in the validation language file. This message should be placed in the first level of the array, not within the \ncustom\n array, which is only for attribute-specific error messages:\n\n\nfoo\n =\n \nYour input was invalid!\n,\n\n\naccepted\n =\n \nThe :attribute must be accepted.\n,\n\n// The rest of the validation error messages...\n\n\n\n\n\nWhen creating a custom validation rule, you may sometimes need to define custom place-holder replacements for error messages. You may do so by creating a custom Validator as described above then making a call to the \nreplacer\n method on the \nValidator\n facade. You may do this within the \nboot\n method of a \nservice provider\n:\n\n\n/**\n\n\n * Bootstrap any application services.\n\n\n *\n\n\n * @return void\n\n\n */\n\n\npublic\n \nfunction\n \nboot\n()\n\n\n{\n\n    \nValidator\n:\n:\nextend\n(\n...\n);\n\n\n    \nValidator\n:\n:\nreplacer\n(\nfoo\n,\n \nfunction\n \n($\nmessage\n,\n \n$\nattribute\n,\n \n$\nrule\n,\n \n$\nparameters\n)\n \n{\n\n        \nreturn\n \nstr_replace\n(\n...\n);\n\n    \n}\n);\n\n\n}\n\n\n\n\n\n\nImplicit Extensions\n\n\nBy default, when an attribute being validated is not present or contains an empty value as defined by the \nrequired\n rule, normal validation rules, including custom extensions, are not run. For example, the \nunique\n rule will not be run against a \nnull\n value:\n\n\n$\nrules\n \n=\n \n[\nname\n \n=\n \nunique\n]\n;\n\n\n\n$\ninput\n \n=\n \n[\nname\n \n=\n \nnull\n]\n;\n\n\n\nValidator\n::\nmake\n($\ninput\n,\n \n$\nrules\n)\n-\npasses\n();\n \n//\n \ntrue\n\n\n\n\n\n\nFor a rule to run even when an attribute is empty, the rule must imply that the attribute is required. To create such an \"implicit\" extension, use the \nValidator::extendImplicit()\n method:\n\n\nValidator::extendImplicit(\nfoo\n, function ($attribute, $value, $parameters, $validator) {\n    return $value == \nfoo\n;\n});\n\n\n\n\n\n\n\n{note} An \"implicit\" extension only \nimplies\n that the attribute is required. Whether it actually invalidates a missing or empty attribute is up to you.", 
            "title": "Validation"
        }, 
        {
            "location": "/validation/#validation", 
            "text": "Introduction  Validation Quickstart  Defining The Routes  Creating The Controller  Writing The Validation Logic  Displaying The Validation Errors  A Note On Optional Fields    Form Request Validation  Creating Form Requests  Authorizing Form Requests  Customizing The Error Format  Customizing The Error Messages    Manually Creating Validators  Automatic Redirection  Named Error Bags  After Validation Hook    Working With Error Messages  Custom Error Messages    Available Validation Rules  Conditionally Adding Rules  Validating Arrays  Custom Validation Rules", 
            "title": "Validation"
        }, 
        {
            "location": "/validation/#introduction", 
            "text": "Laravel provides several different approaches to validate your application's incoming data. By default, Laravel's base controller class uses a  ValidatesRequests  trait which provides a convenient method to validate incoming HTTP request with a variety of powerful validation rules.", 
            "title": "Introduction"
        }, 
        {
            "location": "/validation/#validation-quickstart", 
            "text": "To learn about Laravel's powerful validation features, let's look at a complete example of validating a form and displaying the error messages back to the user.", 
            "title": "Validation Quickstart"
        }, 
        {
            "location": "/validation/#defining-the-routes", 
            "text": "First, let's assume we have the following routes defined in our  routes/web.php  file:  Route :: get ( post/create ,   PostController@create );  Route :: post ( post ,   PostController@store );   Of course, the  GET  route will display a form for the user to create a new blog post, while the  POST  route will store the new blog post in the database.", 
            "title": "Defining The Routes"
        }, 
        {
            "location": "/validation/#creating-the-controller", 
            "text": "Next, let's take a look at a simple controller that handles these routes. We'll leave the  store  method empty for now:  ? php  namespace   App \\ Http \\ Controllers ;  use   Illuminate \\ Http \\ Request ;  use   App \\ Http \\ Controllers \\ Controller ;  class   PostController   extends   Controller  { \n     /**       * Show the form to create a new blog post.       *       * @return Response       */ \n     public   function   create () \n     { \n         return   view ( post.create ); \n     } \n\n     /**       * Store a new blog post.       *       * @param  Request  $request       * @return Response       */ \n     public   function   store ( Request   $request ) \n     { \n         // Validate and store the blog post... \n     }  }", 
            "title": "Creating The Controller"
        }, 
        {
            "location": "/validation/#writing-the-validation-logic", 
            "text": "Now we are ready to fill in our  store  method with the logic to validate the new blog post. If you examine your application's base controller ( App\\Http\\Controllers\\Controller ) class, you will see that the class uses a  ValidatesRequests  trait. This trait provides a convenient  validate  method to all of your controllers.  The  validate  method accepts an incoming HTTP request and a set of validation rules. If the validation rules pass, your code will keep executing normally; however, if validation fails, an exception will be thrown and the proper error response will automatically be sent back to the user. In the case of a traditional HTTP request, a redirect response will be generated, while a JSON response will be sent for AJAX requests.  To get a better understanding of the  validate  method, let's jump back into the  store  method:  /**   * Store a new blog post.   *   * @param  Request  $request   * @return Response   */ \npublic   function   store ( Request   $ request )  {       $ this - validate ( $ request ,   [           title   =   required|unique:posts|max:255 ,           body   =   required ,       ] ) ;       //   The   blog   post   is   valid ,   store   in   database ...  }   As you can see, we simply pass the incoming HTTP request and desired validation rules into the  validate  method. Again, if the validation fails, the proper response will automatically be generated. If the validation passes, our controller will continue executing normally.", 
            "title": "Writing The Validation Logic"
        }, 
        {
            "location": "/validation/#stopping-on-first-validation-failure", 
            "text": "Sometimes you may wish to stop running validation rules on an attribute after the first validation failure. To do so, assign the  bail  rule to the attribute:  $this- validate($request, [\n     title  =   bail|required|unique:posts|max:255 ,\n     body  =   required ,\n]);  In this example, if the  required  rule on the  title  attribute fails, the  unique  rule will not be checked. Rules will be validated in the order they are assigned.", 
            "title": "Stopping On First Validation Failure"
        }, 
        {
            "location": "/validation/#a-note-on-nested-attributes", 
            "text": "If your HTTP request contains \"nested\" parameters, you may specify them in your validation rules using \"dot\" syntax:  $this- validate($request, [\n     title  =   required|unique:posts|max:255 ,\n     author.name  =   required ,\n     author.description  =   required ,\n]);", 
            "title": "A Note On Nested Attributes"
        }, 
        {
            "location": "/validation/#displaying-the-validation-errors", 
            "text": "So, what if the incoming request parameters do not pass the given validation rules? As mentioned previously, Laravel will automatically redirect the user back to their previous location. In addition, all of the validation errors will automatically be  flashed to the session .  Again, notice that we did not have to explicitly bind the error messages to the view in our  GET  route. This is because Laravel will check for errors in the session data, and automatically bind them to the view if they are available. The  $errors  variable will be an instance of  Illuminate\\Support\\MessageBag . For more information on working with this object,  check out its documentation .   {tip} The  $errors  variable is bound to the view by the  Illuminate\\View\\Middleware\\ShareErrorsFromSession  middleware, which is provided by the  web  middleware group.  When this middleware is applied an  $errors  variable will always be available in your views , allowing you to conveniently assume the  $errors  variable is always defined and can be safely used.   So, in our example, the user will be redirected to our controller's  create  method when validation fails, allowing us to display the error messages in the view:  !--   / resources / views / post / create . blade . php   --  h1 Create   Post / h1  @ if   ( count ( $ errors )     0 ) \n     div   class = alert alert-danger \n         ul \n             @ foreach   ( $ errors - all ()   as   $ error ) \n                 li {{   $ error   }} / li \n             @ endforeach \n         / ul \n     / div  @ endif  !--   Create   Post   Form   --", 
            "title": "Displaying The Validation Errors"
        }, 
        {
            "location": "/validation/#a-note-on-optional-fields", 
            "text": "By default, Laravel includes the  TrimStrings  and  ConvertEmptyStringsToNull  middleware in your application's global middleware stack. These middleware are listed in the stack by the  App\\Http\\Kernel  class. Because of this, you will often need to mark your \"optional\" request fields as  nullable  if you do not want the validator to consider  null  values as invalid. For example:  $this- validate($request, [\n     title  =   required|unique:posts|max:255 ,\n     body  =   required ,\n     publish_at  =   nullable|date ,\n]);  In this example, we are specifying that the  publish_at  field may be either  null  or a valid date representation. If the  nullable  modifier is not added to the rule definition, the validator would consider  null  an invalid date.", 
            "title": "A Note On Optional Fields"
        }, 
        {
            "location": "/validation/#customizing-the-flashed-error-format", 
            "text": "If you wish to customize the format of the validation errors that are flashed to the session when validation fails, override the  formatValidationErrors  on your base controller. Don't forget to import the  Illuminate\\Contracts\\Validation\\Validator  class at the top of the file:  ?php  namespace   App\\Http\\Controllers ;  use   Illuminate\\Foundation\\Bus\\DispatchesJobs ;  use   Illuminate\\Contracts\\Validation\\Validator ;  use   Illuminate\\Routing\\Controller   as   BaseController ;  use   Illuminate\\Foundation\\Validation\\ValidatesRequests ;  abstract   class   Controller   extends   BaseController  { \n     use   DispatchesJobs ,   ValidatesRequests ; \n\n     /**       * {@inheritdoc}       */ \n     protected   function   formatValidationErrors ( Validator   $validator ) \n     { \n         return   $validator - errors () - all (); \n     }  }", 
            "title": "Customizing The Flashed Error Format"
        }, 
        {
            "location": "/validation/#ajax-requests-validation", 
            "text": "In this example, we used a traditional form to send data to the application. However, many applications use AJAX requests. When using the  validate  method during an AJAX request, Laravel will not generate a redirect response. Instead, Laravel generates a JSON response containing all of the validation errors. This JSON response will be sent with a 422 HTTP status code.", 
            "title": "AJAX Requests &amp; Validation"
        }, 
        {
            "location": "/validation/#form-request-validation", 
            "text": "", 
            "title": "Form Request Validation"
        }, 
        {
            "location": "/validation/#creating-form-requests", 
            "text": "For more complex validation scenarios, you may wish to create a \"form request\". Form requests are custom request classes that contain validation logic. To create a form request class, use the  make:request  Artisan CLI command:  php artisan make:request StoreBlogPost  The generated class will be placed in the  app/Http/Requests  directory. If this directory does not exist, it will be created when you run the  make:request  command. Let's add a few validation rules to the  rules  method:  /**   * Get the validation rules that apply to the request.   *   * @return array   */ \npublic   function   rules ()  {       return   [           title   =   required|unique:posts|max:255 ,           body   =   required ,       ];  }   So, how are the validation rules evaluated? All you need to do is type-hint the request on your controller method. The incoming form request is validated before the controller method is called, meaning you do not need to clutter your controller with any validation logic:  /**   * Store the incoming blog post.   *   * @param  StoreBlogPost  $request   * @return Response   */ \npublic   function   store ( StoreBlogPost   $ request )  {       //   The   incoming   request   is   valid ...  }   If validation fails, a redirect response will be generated to send the user back to their previous location. The errors will also be flashed to the session so they are available for display. If the request was an AJAX request, a HTTP response with a 422 status code will be returned to the user including a JSON representation of the validation errors.", 
            "title": "Creating Form Requests"
        }, 
        {
            "location": "/validation/#adding-after-hooks-to-form-requests", 
            "text": "If you would like to add an \"after\" hook to a form request, you may use the  withValidator  method. This method receives the fully constructed validator, allowing you to call any of its methods before the validation rules are actually evaluated:  /**   * Configure the validator instance.   *   * @param  \\Illuminate\\Validation\\Validator  $validator   * @return void   */ \npublic   function   withValidator ( $ validator )  {       $ validator - after ( function   ( $ validator )   {           if   ( $ this - somethingElseIsInvalid ())   {               $ validator - errors ()- add ( field ,   Something is wrong with this field! ) ;           }       } ) ;  }", 
            "title": "Adding After Hooks To Form Requests"
        }, 
        {
            "location": "/validation/#authorizing-form-requests", 
            "text": "The form request class also contains an  authorize  method. Within this method, you may check if the authenticated user actually has the authority to update a given resource. For example, you may determine if a user actually owns a blog comment they are attempting to update:  /**   * Determine if the user is authorized to make this request.   *   * @return bool   */  public   function   authorize ()  { \n     $comment   =   Comment : : find ( $ this - route ( comment )); \n\n     return   $comment     $this- user()- can( update ,   $comment) ;  }   Since all form requests extend the base Laravel request class, we may use the  user  method to access the currently authenticated user. Also note the call to the  route  method in the example above. This method grants you access to the URI parameters defined on the route being called, such as the  {comment}  parameter in the example below:  Route :: post ( comment/{comment} );   If the  authorize  method returns  false , a HTTP response with a 403 status code will automatically be returned and your controller method will not execute.  If you plan to have authorization logic in another part of your application, simply return  true  from the  authorize  method:  /**   * Determine if the user is authorized to make this request.   *   * @return bool   */ \npublic   function   authorize ()  {       return   true ;  }", 
            "title": "Authorizing Form Requests"
        }, 
        {
            "location": "/validation/#customizing-the-error-format", 
            "text": "If you wish to customize the format of the validation errors that are flashed to the session when validation fails, override the  formatErrors  on your base request ( App\\Http\\Requests\\Request ). Don't forget to import the  Illuminate\\Contracts\\Validation\\Validator  class at the top of the file:  /**   * {@inheritdoc}   */ \nprotected   function   formatErrors ( Validator   $ validator )  {       return   $ validator - errors ()- all () ;  }", 
            "title": "Customizing The Error Format"
        }, 
        {
            "location": "/validation/#customizing-the-error-messages", 
            "text": "You may customize the error messages used by the form request by overriding the  messages  method. This method should return an array of attribute / rule pairs and their corresponding error messages:  /**   * Get the error messages for the defined validation rules.   *   * @return array   */ \npublic   function   messages ()  {       return   [           title.required   =   A title is required ,           body.required    =   A message is required ,       ];  }", 
            "title": "Customizing The Error Messages"
        }, 
        {
            "location": "/validation/#manually-creating-validators", 
            "text": "If you do not want to use the  ValidatesRequests  trait's  validate  method, you may create a validator instance manually using the  Validator   facade . The  make  method on the facade generates a new validator instance:  ? php  namespace   App \\ Http \\ Controllers ;  use   Validator ;  use   Illuminate \\ Http \\ Request ;  use   App \\ Http \\ Controllers \\ Controller ;  class   PostController   extends   Controller  { \n     /**       * Store a new blog post.       *       * @param  Request  $request       * @return Response       */ \n     public   function   store ( Request   $request ) \n     { \n         $validator   =   Validator :: make ( $request - all (),   [ \n             title   =   required|unique:posts|max:255 , \n             body   =   required , \n         ]); \n\n         if   ( $validator - fails ())   { \n             return   redirect ( post/create ) \n                         - withErrors ( $validator ) \n                         - withInput (); \n         } \n\n         // Store the blog post... \n     }  }   The first argument passed to the  make  method is the data under validation. The second argument is the validation rules that should be applied to the data.  After checking if the request validation failed, you may use the  withErrors  method to flash the error messages to the session. When using this method, the  $errors  variable will automatically be shared with your views after redirection, allowing you to easily display them back to the user. The  withErrors  method accepts a validator, a  MessageBag , or a PHP  array .", 
            "title": "Manually Creating Validators"
        }, 
        {
            "location": "/validation/#automatic-redirection", 
            "text": "If you would like to create a validator instance manually but still take advantage of the automatic redirection offered by the  ValidatesRequest  trait, you may call the  validate  method on an existing validator instance. If validation fails, the user will automatically be redirected or, in the case of an AJAX request, a JSON response will be returned:  Validator::make($request- all(), [\n     title  =   required|unique:posts|max:255 ,\n     body  =   required ,\n])- validate();", 
            "title": "Automatic Redirection"
        }, 
        {
            "location": "/validation/#named-error-bags", 
            "text": "If you have multiple forms on a single page, you may wish to name the  MessageBag  of errors, allowing you to retrieve the error messages for a specific form. Simply pass a name as the second argument to  withErrors :  return redirect( register )\n            - withErrors($validator,  login );  You may then access the named  MessageBag  instance from the  $errors  variable:  {{   $ errors- login- first ( email )   }}", 
            "title": "Named Error Bags"
        }, 
        {
            "location": "/validation/#after-validation-hook", 
            "text": "The validator also allows you to attach callbacks to be run after validation is completed. This allows you to easily perform further validation and even add more error messages to the message collection. To get started, use the  after  method on a validator instance:  $ validator   =   Validator :: make (...);  $ validator- after ( function   ($ validator )   { \n     if   ($this- somethingElseIsInvalid())   { \n         $validator- errors()- add( field ,   Something   is   wrong   with   this   field! ) ; \n     }  } );  if   ($ validator- fails ())   { \n     //  }", 
            "title": "After Validation Hook"
        }, 
        {
            "location": "/validation/#working-with-error-messages", 
            "text": "After calling the  errors  method on a  Validator  instance, you will receive an  Illuminate\\Support\\MessageBag  instance, which has a variety of convenient methods for working with error messages. The  $errors  variable that is automatically made available to all views is also an instance of the  MessageBag  class.", 
            "title": "Working With Error Messages"
        }, 
        {
            "location": "/validation/#retrieving-the-first-error-message-for-a-field", 
            "text": "To retrieve the first error message for a given field, use the  first  method:  $errors = $validator- errors();\n\necho $errors- first( email );", 
            "title": "Retrieving The First Error Message For A Field"
        }, 
        {
            "location": "/validation/#retrieving-all-error-messages-for-a-field", 
            "text": "If you need to retrieve an array of all the messages for a given field, use the  get  method:  foreach ($errors- get( email ) as $message) {\n    //\n}  If you are validating an array form field, you may retrieve all of the messages for each of the array elements using the  *  character:  foreach ($errors- get( attachments.* ) as $message) {\n    //\n}", 
            "title": "Retrieving All Error Messages For A Field"
        }, 
        {
            "location": "/validation/#retrieving-all-error-messages-for-all-fields", 
            "text": "To retrieve an array of all messages for all fields, use the  all  method:  foreach ($errors- all() as $message) {\n    //\n}", 
            "title": "Retrieving All Error Messages For All Fields"
        }, 
        {
            "location": "/validation/#determining-if-messages-exist-for-a-field", 
            "text": "The  has  method may be used to determine if any error messages exist for a given field:  if ($errors- has( email )) {\n    //\n}", 
            "title": "Determining If Messages Exist For A Field"
        }, 
        {
            "location": "/validation/#custom-error-messages", 
            "text": "If needed, you may use custom error messages for validation instead of the defaults. There are several ways to specify custom messages. First, you may pass the custom messages as the third argument to the  Validator::make  method:  $ messages   =   [ \n     required   =   The :attribute field is required. ,  ] ;  $ validator   =   Validator :: make ($ input ,   $ rules ,   $ messages );   In this example, the  :attribute  place-holder will be replaced by the actual name of the field under validation. You may also utilize other place-holders in validation messages. For example:  $messages = [\n     same     =   The :attribute and :other must match. ,\n     size     =   The :attribute must be exactly :size. ,\n     between  =   The :attribute must be between :min - :max. ,\n     in       =   The :attribute must be one of the following types: :values ,\n];", 
            "title": "Custom Error Messages"
        }, 
        {
            "location": "/validation/#specifying-a-custom-message-for-a-given-attribute", 
            "text": "Sometimes you may wish to specify a custom error messages only for a specific field. You may do so using \"dot\" notation. Specify the attribute's name first, followed by the rule:  $messages = [\n     email.required  =   We need to know your e-mail address! ,\n];", 
            "title": "Specifying A Custom Message For A Given Attribute"
        }, 
        {
            "location": "/validation/#specifying-custom-messages-in-language-files", 
            "text": "In most cases, you will probably specify your custom messages in a language file instead of passing them directly to the  Validator . To do so, add your messages to  custom  array in the  resources/lang/xx/validation.php  language file.  custom  =  [\n     email  =  [\n         required  =   We need to know your e-mail address! ,\n    ],\n],", 
            "title": "Specifying Custom Messages In Language Files"
        }, 
        {
            "location": "/validation/#specifying-custom-attributes-in-language-files", 
            "text": "If you would like the  :attribute  portion of your validation message to be replaced with a custom attribute name, you may specify the custom name in the  attributes  array of your  resources/lang/xx/validation.php  language file:  attributes  =  [\n     email  =   email address ,\n],", 
            "title": "Specifying Custom Attributes In Language Files"
        }, 
        {
            "location": "/validation/#available-validation-rules", 
            "text": "Below is a list of all available validation rules and their function:  \n    .collection-method-list > p {\n        column-count: 3; -moz-column-count: 3; -webkit-column-count: 3;\n        column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em;\n    }\n\n    .collection-method-list a {\n        display: block;\n    }  \n\n[Accepted](#rule-accepted)\n[Active URL](#rule-active-url)\n[After (Date)](#rule-after)\n[After Or Equal (Date)](#rule-after-or-equal)\n[Alpha](#rule-alpha)\n[Alpha Dash](#rule-alpha-dash)\n[Alpha Numeric](#rule-alpha-num)\n[Array](#rule-array)\n[Before (Date)](#rule-before)\n[Before Or Equal (Date)](#rule-before-or-equal)\n[Between](#rule-between)\n[Boolean](#rule-boolean)\n[Confirmed](#rule-confirmed)\n[Date](#rule-date)\n[Date Format](#rule-date-format)\n[Different](#rule-different)\n[Digits](#rule-digits)\n[Digits Between](#rule-digits-between)\n[Dimensions (Image Files)](#rule-dimensions)\n[Distinct](#rule-distinct)\n[E-Mail](#rule-email)\n[Exists (Database)](#rule-exists)\n[File](#rule-file)\n[Filled](#rule-filled)\n[Image (File)](#rule-image)\n[In](#rule-in)\n[In Array](#rule-in-array)\n[Integer](#rule-integer)\n[IP Address](#rule-ip)\n[JSON](#rule-json)\n[Max](#rule-max)\n[MIME Types](#rule-mimetypes)\n[MIME Type By File Extension](#rule-mimes)\n[Min](#rule-min)\n[Nullable](#rule-nullable)\n[Not In](#rule-not-in)\n[Numeric](#rule-numeric)\n[Present](#rule-present)\n[Regular Expression](#rule-regex)\n[Required](#rule-required)\n[Required If](#rule-required-if)\n[Required Unless](#rule-required-unless)\n[Required With](#rule-required-with)\n[Required With All](#rule-required-with-all)\n[Required Without](#rule-required-without)\n[Required Without All](#rule-required-without-all)\n[Same](#rule-same)\n[Size](#rule-size)\n[String](#rule-string)\n[Timezone](#rule-timezone)\n[Unique (Database)](#rule-unique)\n[URL](#rule-url)", 
            "title": "Available Validation Rules"
        }, 
        {
            "location": "/validation/#accepted", 
            "text": "The field under validation must be  yes ,  on ,  1 , or  true . This is useful for validating \"Terms of Service\" acceptance.", 
            "title": "accepted"
        }, 
        {
            "location": "/validation/#active_url", 
            "text": "The field under validation must have a valid A or AAAA record according to the  dns_get_record  PHP function.", 
            "title": "active_url"
        }, 
        {
            "location": "/validation/#afterdate", 
            "text": "The field under validation must be a value after a given date. The dates will be passed into the  strtotime  PHP function:  start_date  =   required|date|after:tomorrow   Instead of passing a date string to be evaluated by  strtotime , you may specify another field to compare against the date:  finish_date  =   required|date|after:start_date", 
            "title": "after:date"
        }, 
        {
            "location": "/validation/#after95or95equaldate", 
            "text": "The field under validation must be a value after or equal to the given date. For more information, see the  after  rule.", 
            "title": "after_or_equal:date"
        }, 
        {
            "location": "/validation/#alpha", 
            "text": "The field under validation must be entirely alphabetic characters.", 
            "title": "alpha"
        }, 
        {
            "location": "/validation/#alpha_dash", 
            "text": "The field under validation may have alpha-numeric characters, as well as dashes and underscores.", 
            "title": "alpha_dash"
        }, 
        {
            "location": "/validation/#alpha_num", 
            "text": "The field under validation must be entirely alpha-numeric characters.", 
            "title": "alpha_num"
        }, 
        {
            "location": "/validation/#array", 
            "text": "The field under validation must be a PHP  array .", 
            "title": "array"
        }, 
        {
            "location": "/validation/#beforedate", 
            "text": "The field under validation must be a value preceding the given date. The dates will be passed into the PHP  strtotime  function.", 
            "title": "before:date"
        }, 
        {
            "location": "/validation/#before95or95equaldate", 
            "text": "The field under validation must be a value preceding or equal to the given date. The dates will be passed into the PHP  strtotime  function.", 
            "title": "before_or_equal:date"
        }, 
        {
            "location": "/validation/#betweenminmax", 
            "text": "The field under validation must have a size between the given  min  and  max . Strings, numerics, and files are evaluated in the same fashion as the  size  rule.", 
            "title": "between:min,max"
        }, 
        {
            "location": "/validation/#boolean", 
            "text": "The field under validation must be able to be cast as a boolean. Accepted input are  true ,  false ,  1 ,  0 ,  \"1\" , and  \"0\" .", 
            "title": "boolean"
        }, 
        {
            "location": "/validation/#confirmed", 
            "text": "The field under validation must have a matching field of  foo_confirmation . For example, if the field under validation is  password , a matching  password_confirmation  field must be present in the input.", 
            "title": "confirmed"
        }, 
        {
            "location": "/validation/#date", 
            "text": "The field under validation must be a valid date according to the  strtotime  PHP function.", 
            "title": "date"
        }, 
        {
            "location": "/validation/#date_formatformat", 
            "text": "The field under validation must match the given  format . You should use  either   date  or  date_format  when validating a field, not both.", 
            "title": "date_format:format"
        }, 
        {
            "location": "/validation/#differentfield", 
            "text": "The field under validation must have a different value than  field .", 
            "title": "different:field"
        }, 
        {
            "location": "/validation/#digitsvalue", 
            "text": "The field under validation must be  numeric  and must have an exact length of  value .", 
            "title": "digits:value"
        }, 
        {
            "location": "/validation/#digits_betweenminmax", 
            "text": "The field under validation must have a length between the given  min  and  max .", 
            "title": "digits_between:min,max"
        }, 
        {
            "location": "/validation/#dimensions", 
            "text": "The file under validation must be an image meeting the dimension constraints as specified by the rule's parameters:  avatar  =   dimensions:min_width=100,min_height=200   Available constraints are:  min_width ,  max_width ,  min_height ,  max_height ,  width ,  height ,  ratio .  A  ratio  constraint should be represented as width divided by height. This can be specified either by a statement like  3/2  or a float like  1.5 :  avatar  =   dimensions:ratio=3/2   Since this rule requires several arguments, you may use the  Rule::dimensions  method to fluently construct the rule:  use Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n     avatar  =  [\n         required ,\n        Rule::dimensions()- maxWidth(1000)- maxHeight(500)- ratio(3 / 2),\n    ],\n]);", 
            "title": "dimensions"
        }, 
        {
            "location": "/validation/#distinct", 
            "text": "When working with arrays, the field under validation must not have any duplicate values.  foo.*.id  =   distinct", 
            "title": "distinct"
        }, 
        {
            "location": "/validation/#email", 
            "text": "The field under validation must be formatted as an e-mail address.", 
            "title": "email"
        }, 
        {
            "location": "/validation/#existstablecolumn", 
            "text": "The field under validation must exist on a given database table.", 
            "title": "exists:table,column"
        }, 
        {
            "location": "/validation/#basic-usage-of-exists-rule", 
            "text": "state  =   exists:states", 
            "title": "Basic Usage Of Exists Rule"
        }, 
        {
            "location": "/validation/#specifying-a-custom-column-name", 
            "text": "state  =   exists:states,abbreviation   Occasionally, you may need to specify a specific database connection to be used for the  exists  query. You can accomplish this by prepending the connection name to the table name using \"dot\" syntax:  email  =   exists:connection.staff,email   If you would like to customize the query executed by the validation rule, you may use the  Rule  class to fluently define the rule. In this example, we'll also specify the validation rules as an array instead of using the  |  character to delimit them:  use Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n     email  =  [\n         required ,\n        Rule::exists( staff )- where(function ($query) {\n            $query- where( account_id , 1);\n        }),\n    ],\n]);", 
            "title": "Specifying A Custom Column Name"
        }, 
        {
            "location": "/validation/#file", 
            "text": "The field under validation must be a successfully uploaded file.", 
            "title": "file"
        }, 
        {
            "location": "/validation/#filled", 
            "text": "The field under validation must not be empty when it is present.", 
            "title": "filled"
        }, 
        {
            "location": "/validation/#image", 
            "text": "The file under validation must be an image (jpeg, png, bmp, gif, or svg)", 
            "title": "image"
        }, 
        {
            "location": "/validation/#infoobar", 
            "text": "The field under validation must be included in the given list of values. Since this rule often requires you to  implode  an array, the  Rule::in  method may be used to fluently construct the rule:  use Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n     zones  =  [\n         required ,\n        Rule::in([ first-zone ,  second-zone ]),\n    ],\n]);", 
            "title": "in:foo,bar,..."
        }, 
        {
            "location": "/validation/#in_arrayanotherfield", 
            "text": "The field under validation must exist in  anotherfield 's values.", 
            "title": "in_array:anotherfield"
        }, 
        {
            "location": "/validation/#integer", 
            "text": "The field under validation must be an integer.", 
            "title": "integer"
        }, 
        {
            "location": "/validation/#ip", 
            "text": "The field under validation must be an IP address.", 
            "title": "ip"
        }, 
        {
            "location": "/validation/#ipv4", 
            "text": "The field under validation must be an IPv4 address.", 
            "title": "ipv4"
        }, 
        {
            "location": "/validation/#ipv6", 
            "text": "The field under validation must be an IPv6 address.", 
            "title": "ipv6"
        }, 
        {
            "location": "/validation/#json", 
            "text": "The field under validation must be a valid JSON string.", 
            "title": "json"
        }, 
        {
            "location": "/validation/#maxvalue", 
            "text": "The field under validation must be less than or equal to a maximum  value . Strings, numerics, and files are evaluated in the same fashion as the  size  rule.", 
            "title": "max:value"
        }, 
        {
            "location": "/validation/#mimetypestextplain", 
            "text": "The file under validation must match one of the given MIME types:  video  =   mimetypes:video/avi,video/mpeg,video/quicktime   To determine the MIME type of the uploaded file, the file's contents will be read and the framework will attempt to guess the MIME type, which may be different from the client provided MIME type.", 
            "title": "mimetypes:text/plain,..."
        }, 
        {
            "location": "/validation/#mimesfoobar", 
            "text": "The file under validation must have a MIME type corresponding to one of the listed extensions.", 
            "title": "mimes:foo,bar,..."
        }, 
        {
            "location": "/validation/#basic-usage-of-mime-rule", 
            "text": "photo  =   mimes:jpeg,bmp,png   Even though you only need to specify the extensions, this rule actually validates against the MIME type of the file by reading the file's contents and guessing its MIME type.  A full listing of MIME types and their corresponding extensions may be found at the following location:  https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types", 
            "title": "Basic Usage Of MIME Rule"
        }, 
        {
            "location": "/validation/#minvalue", 
            "text": "The field under validation must have a minimum  value . Strings, numerics, and files are evaluated in the same fashion as the  size  rule.", 
            "title": "min:value"
        }, 
        {
            "location": "/validation/#nullable", 
            "text": "The field under validation may be  null . This is particularly useful when validating primitive such as strings and integers that can contain  null  values.", 
            "title": "nullable"
        }, 
        {
            "location": "/validation/#not_infoobar", 
            "text": "The field under validation must not be included in the given list of values.", 
            "title": "not_in:foo,bar,..."
        }, 
        {
            "location": "/validation/#numeric", 
            "text": "The field under validation must be numeric.", 
            "title": "numeric"
        }, 
        {
            "location": "/validation/#present", 
            "text": "The field under validation must be present in the input data but can be empty.", 
            "title": "present"
        }, 
        {
            "location": "/validation/#regexpattern", 
            "text": "The field under validation must match the given regular expression.  Note:  When using the  regex  pattern, it may be necessary to specify rules in an array instead of using pipe delimiters, especially if the regular expression contains a pipe character.", 
            "title": "regex:pattern"
        }, 
        {
            "location": "/validation/#required", 
            "text": "The field under validation must be present in the input data and not empty. A field is considered \"empty\" if one of the following conditions are true:  \n\n- The value is `null`.\n- The value is an empty string.\n- The value is an empty array or empty `Countable` object.\n- The value is an uploaded file with no path.", 
            "title": "required"
        }, 
        {
            "location": "/validation/#required_ifanotherfieldvalue", 
            "text": "The field under validation must be present and not empty if the  anotherfield  field is equal to any  value .", 
            "title": "required_if:anotherfield,value,..."
        }, 
        {
            "location": "/validation/#required_unlessanotherfieldvalue", 
            "text": "The field under validation must be present and not empty unless the  anotherfield  field is equal to any  value .", 
            "title": "required_unless:anotherfield,value,..."
        }, 
        {
            "location": "/validation/#required_withfoobar", 
            "text": "The field under validation must be present and not empty  only if  any of the other specified fields are present.", 
            "title": "required_with:foo,bar,..."
        }, 
        {
            "location": "/validation/#required_with_allfoobar", 
            "text": "The field under validation must be present and not empty  only if  all of the other specified fields are present.", 
            "title": "required_with_all:foo,bar,..."
        }, 
        {
            "location": "/validation/#required_withoutfoobar", 
            "text": "The field under validation must be present and not empty  only when  any of the other specified fields are not present.", 
            "title": "required_without:foo,bar,..."
        }, 
        {
            "location": "/validation/#required_without_allfoobar", 
            "text": "The field under validation must be present and not empty  only when  all of the other specified fields are not present.", 
            "title": "required_without_all:foo,bar,..."
        }, 
        {
            "location": "/validation/#samefield", 
            "text": "The given  field  must match the field under validation.", 
            "title": "same:field"
        }, 
        {
            "location": "/validation/#sizevalue", 
            "text": "The field under validation must have a size matching the given  value . For string data,  value  corresponds to the number of characters. For numeric data,  value  corresponds to a given integer value. For an array,  size  corresponds to the  count  of the array. For files,  size  corresponds to the file size in kilobytes.", 
            "title": "size:value"
        }, 
        {
            "location": "/validation/#string", 
            "text": "The field under validation must be a string. If you would like to allow the field to also be  null , you should assign the  nullable  rule to the field.", 
            "title": "string"
        }, 
        {
            "location": "/validation/#timezone", 
            "text": "The field under validation must be a valid timezone identifier according to the  timezone_identifiers_list  PHP function.", 
            "title": "timezone"
        }, 
        {
            "location": "/validation/#uniquetablecolumnexceptidcolumn", 
            "text": "The field under validation must be unique in a given database table. If the  column  option is not specified, the field name will be used.  Specifying A Custom Column Name:  email  =   unique:users,email_address   Custom Database Connection  Occasionally, you may need to set a custom connection for database queries made by the Validator. As seen above, setting  unique:users  as a validation rule will use the default database connection to query the database. To override this, specify the connection and the table name using \"dot\" syntax:  email  =   unique:connection.users,email_address   Forcing A Unique Rule To Ignore A Given ID:  Sometimes, you may wish to ignore a given ID during the unique check. For example, consider an \"update profile\" screen that includes the user's name, e-mail address, and location. Of course, you will want to verify that the e-mail address is unique. However, if the user only changes the name field and not the e-mail field, you do not want a validation error to be thrown because the user is already the owner of the e-mail address.  To instruct the validator to ignore the user's ID, we'll use the  Rule  class to fluently define the rule. In this example, we'll also specify the validation rules as an array instead of using the  |  character to delimit the rules:  use Illuminate\\Validation\\Rule;\n\nValidator::make($data, [\n     email  =  [\n         required ,\n        Rule::unique( users )- ignore($user- id),\n    ],\n]);  If your table uses a primary key column name other than  id , you may specify the name of the column when calling the  ignore  method:  email  =  Rule::unique( users )- ignore($user- id,  user_id )  Adding Additional Where Clauses:  You may also specify additional query constraints by customizing the query using the  where  method. For example, let's add a constraint that verifies the  account_id  is  1 :  email  =  Rule::unique( users )- where(function ($query) {\n    $query- where( account_id , 1);\n})", 
            "title": "unique:table,column,except,idColumn"
        }, 
        {
            "location": "/validation/#url", 
            "text": "The field under validation must be a valid URL.", 
            "title": "url"
        }, 
        {
            "location": "/validation/#conditionally-adding-rules", 
            "text": "", 
            "title": "Conditionally Adding Rules"
        }, 
        {
            "location": "/validation/#validating-when-present", 
            "text": "In some situations, you may wish to run validation checks against a field  only  if that field is present in the input array. To quickly accomplish this, add the  sometimes  rule to your rule list:  $v = Validator::make($data, [\n     email  =   sometimes|required|email ,\n]);  In the example above, the  email  field will only be validated if it is present in the  $data  array.", 
            "title": "Validating When Present"
        }, 
        {
            "location": "/validation/#complex-conditional-validation", 
            "text": "Sometimes you may wish to add validation rules based on more complex conditional logic. For example, you may wish to require a given field only if another field has a greater value than 100. Or, you may need two fields to have a given value only when another field is present. Adding these validation rules doesn't have to be a pain. First, create a  Validator  instance with your  static rules  that never change:  $v = Validator::make($data, [\n     email  =   required|email ,\n     games  =   required|numeric ,\n]);  Let's assume our web application is for game collectors. If a game collector registers with our application and they own more than 100 games, we want them to explain why they own so many games. For example, perhaps they run a game resale shop, or maybe they just enjoy collecting. To conditionally add this requirement, we can use the  sometimes  method on the  Validator  instance.  $v- sometimes( reason ,  required|max:500 , function ($input) {\n    return $input- games  = 100;\n});  The first argument passed to the  sometimes  method is the name of the field we are conditionally validating. The second argument is the rules we want to add. If the  Closure  passed as the third argument returns  true , the rules will be added. This method makes it a breeze to build complex conditional validations. You may even add conditional validations for several fields at once:  $v- sometimes([ reason ,  cost ],  required , function ($input) {\n    return $input- games  = 100;\n});   {tip} The  $input  parameter passed to your  Closure  will be an instance of  Illuminate\\Support\\Fluent  and may be used to access your input and files.", 
            "title": "Complex Conditional Validation"
        }, 
        {
            "location": "/validation/#validating-arrays", 
            "text": "Validating array based form input fields doesn't have to be a pain. For example, to validate that each e-mail in a given array input field is unique, you may do the following:  $validator = Validator::make($request- all(), [\n     person.*.email  =   email|unique:users ,\n     person.*.first_name  =   required_with:person.*.last_name ,\n]);  Likewise, you may use the  *  character when specifying your validation messages in your language files, making it a breeze to use a single validation message for array based fields:  custom  =  [\n     person.*.email  =  [\n         unique  =   Each person must have a unique e-mail address ,\n    ]\n],", 
            "title": "Validating Arrays"
        }, 
        {
            "location": "/validation/#custom-validation-rules", 
            "text": "Laravel provides a variety of helpful validation rules; however, you may wish to specify some of your own. One method of registering custom validation rules is using the  extend  method on the  Validator   facade . Let's use this method within a  service provider  to register a custom validation rule:  ? php  namespace   App \\ Providers ;  use   Illuminate \\ Support \\ ServiceProvider ;  use   Illuminate \\ Support \\ Facades \\ Validator ;  class   AppServiceProvider   extends   ServiceProvider  { \n     /**       * Bootstrap any application services.       *       * @return void       */ \n     public   function   boot () \n     { \n         Validator :: extend ( foo ,   function   ( $attribute ,   $value ,   $parameters ,   $validator )   { \n             return   $value   ==   foo ; \n         }); \n     } \n\n     /**       * Register the service provider.       *       * @return void       */ \n     public   function   register () \n     { \n         // \n     }  }   The custom validator Closure receives four arguments: the name of the  $attribute  being validated, the  $value  of the attribute, an array of  $parameters  passed to the rule, and the  Validator  instance.  You may also pass a class and method to the  extend  method instead of a Closure:  Validator :: extend ( foo ,   FooValidator@validate );", 
            "title": "Custom Validation Rules"
        }, 
        {
            "location": "/validation/#defining-the-error-message", 
            "text": "You will also need to define an error message for your custom rule. You can do so either using an inline custom message array or by adding an entry in the validation language file. This message should be placed in the first level of the array, not within the  custom  array, which is only for attribute-specific error messages:  foo  =   Your input was invalid! , accepted  =   The :attribute must be accepted. ,\n\n// The rest of the validation error messages...  When creating a custom validation rule, you may sometimes need to define custom place-holder replacements for error messages. You may do so by creating a custom Validator as described above then making a call to the  replacer  method on the  Validator  facade. You may do this within the  boot  method of a  service provider :  /**   * Bootstrap any application services.   *   * @return void   */  public   function   boot ()  { \n     Validator : : extend ( ... ); \n\n     Validator : : replacer ( foo ,   function   ($ message ,   $ attribute ,   $ rule ,   $ parameters )   { \n         return   str_replace ( ... ); \n     } );  }", 
            "title": "Defining The Error Message"
        }, 
        {
            "location": "/validation/#implicit-extensions", 
            "text": "By default, when an attribute being validated is not present or contains an empty value as defined by the  required  rule, normal validation rules, including custom extensions, are not run. For example, the  unique  rule will not be run against a  null  value:  $ rules   =   [ name   =   unique ] ;  $ input   =   [ name   =   null ] ;  Validator :: make ($ input ,   $ rules ) - passes ();   //   true   For a rule to run even when an attribute is empty, the rule must imply that the attribute is required. To create such an \"implicit\" extension, use the  Validator::extendImplicit()  method:  Validator::extendImplicit( foo , function ($attribute, $value, $parameters, $validator) {\n    return $value ==  foo ;\n});   {note} An \"implicit\" extension only  implies  that the attribute is required. Whether it actually invalidates a missing or empty attribute is up to you.", 
            "title": "Implicit Extensions"
        }, 
        {
            "location": "/views/", 
            "text": "Views\n\n\n\n\nCreating Views\n\n\nPassing Data To Views\n\n\nSharing Data With All Views\n\n\n\n\n\n\nView Composers\n\n\n\n\n\n\nCreating Views\n\n\nViews contain the HTML served by your application and separate your controller / application logic from your presentation logic. Views are stored in the \nresources/views\n directory. A simple view might look something like this:\n\n\n!-- View stored in resources/views/greeting.blade.php --\n\n\n\nhtml\n\n    \nbody\n\n        \nh1\nHello, \n{{\n \n$\nname\n \n}}\n/h1\n\n    \n/body\n\n\n/html\n\n\n\n\n\n\nSince this view is stored at \nresources/views/greeting.blade.php\n, we may return it using the global \nview\n helper like so:\n\n\nRoute::get(\n/\n, function () {\n    return view(\ngreeting\n, [\nname\n =\n \nJames\n]);\n});\n\n\n\n\n\nAs you can see, the first argument passed to the \nview\n helper corresponds to the name of the view file in the \nresources/views\n directory. The second argument is an array of data that should be made available to the view. In this case, we are passing the \nname\n variable, which is displayed in the view using \nBlade syntax\n.\n\n\nOf course, views may also be nested within sub-directories of the \nresources/views\n directory. \"Dot\" notation may be used to reference nested views. For example, if your view is stored at \nresources/views/admin/profile.blade.php\n, you may reference it like so:\n\n\nreturn view(\nadmin.profile\n, $data);\n\n\n\n\n\nDetermining If A View Exists\n\n\nIf you need to determine if a view exists, you may use the \nView\n facade. The \nexists\n method will return \ntrue\n if the view exists:\n\n\nuse Illuminate\\Support\\Facades\\View;\n\nif (View::exists(\nemails.customer\n)) {\n    //\n}\n\n\n\n\n\n\n\nPassing Data To Views\n\n\nAs you saw in the previous examples, you may pass an array of data to views:\n\n\nreturn view(\ngreetings\n, [\nname\n =\n \nVictoria\n]);\n\n\n\n\n\nWhen passing information in this manner, \n$data\n should be an array with key/value pairs. Inside your view, you can then access each value using its corresponding key, such as \n?php echo $key; ?\n. As an alternative to passing a complete array of data to the \nview\n helper function, you may use the \nwith\n method to add individual pieces of data to the view:\n\n\nreturn view(\ngreeting\n)-\nwith(\nname\n, \nVictoria\n);\n\n\n\n\n\n\n\nSharing Data With All Views\n\n\nOccasionally, you may need to share a piece of data with all views that are rendered by your application. You may do so using the view facade's \nshare\n method. Typically, you should place calls to \nshare\n within a service provider's \nboot\n method. You are free to add them to the \nAppServiceProvider\n or generate a separate service provider to house them:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nView\n;\n\n\n\nclass\n \nAppServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Bootstrap any application services.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \nView\n::\nshare\n(\nkey\n,\n \nvalue\n);\n\n    \n}\n\n\n    \n/**\n\n\n     * Register the service provider.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\nView Composers\n\n\nView composers are callbacks or class methods that are called when a view is rendered. If you have data that you want to be bound to a view each time that view is rendered, a view composer can help you organize that logic into a single location.\n\n\nFor this example, let's register the view composers within a \nservice provider\n. We'll use the \nView\n facade to access the underlying \nIlluminate\\Contracts\\View\\Factory\n contract implementation. Remember, Laravel does not include a default directory for view composers. You are free to organize them however you wish. For example, you could create an \nApp\\Http\\ViewComposers\n directory:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nProviders\n;\n\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nFacades\n\\\nView\n;\n\n\nuse\n \nIlluminate\n\\\nSupport\n\\\nServiceProvider\n;\n\n\n\nclass\n \nComposerServiceProvider\n \nextends\n \nServiceProvider\n\n\n{\n\n    \n/**\n\n\n     * Register bindings in the container.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nboot\n()\n\n    \n{\n\n        \n// Using class based composers...\n\n        \nView\n::\ncomposer\n(\n\n            \nprofile\n,\n \nApp\\Http\\ViewComposers\\ProfileComposer\n\n        \n);\n\n\n        \n// Using Closure based composers...\n\n        \nView\n::\ncomposer\n(\ndashboard\n,\n \nfunction\n \n(\n$view\n)\n \n{\n\n            \n//\n\n        \n});\n\n    \n}\n\n\n    \n/**\n\n\n     * Register the service provider.\n\n\n     *\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \nregister\n()\n\n    \n{\n\n        \n//\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n{note} Remember, if you create a new service provider to contain your view composer registrations, you will need to add the service provider to the \nproviders\n array in the \nconfig/app.php\n configuration file.\n\n\n\n\nNow that we have registered the composer, the \nProfileComposer@compose\n method will be executed each time the \nprofile\n view is being rendered. So, let's define the composer class:\n\n\n?\nphp\n\n\n\nnamespace\n \nApp\n\\\nHttp\n\\\nViewComposers\n;\n\n\n\nuse\n \nIlluminate\n\\\nView\n\\\nView\n;\n\n\nuse\n \nApp\n\\\nRepositories\n\\\nUserRepository\n;\n\n\n\nclass\n \nProfileComposer\n\n\n{\n\n    \n/**\n\n\n     * The user repository implementation.\n\n\n     *\n\n\n     * @var UserRepository\n\n\n     */\n\n    \nprotected\n \n$users\n;\n\n\n    \n/**\n\n\n     * Create a new profile composer.\n\n\n     *\n\n\n     * @param  UserRepository  $users\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n(\nUserRepository\n \n$users\n)\n\n    \n{\n\n        \n// Dependencies automatically resolved by service container...\n\n        \n$this\n-\nusers\n \n=\n \n$users\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Bind data to the view.\n\n\n     *\n\n\n     * @param  View  $view\n\n\n     * @return void\n\n\n     */\n\n    \npublic\n \nfunction\n \ncompose\n(\nView\n \n$view\n)\n\n    \n{\n\n        \n$view\n-\nwith\n(\ncount\n,\n \n$this\n-\nusers\n-\ncount\n());\n\n    \n}\n\n\n}\n\n\n\n\n\n\nJust before the view is rendered, the composer's \ncompose\n method is called with the \nIlluminate\\View\\View\n instance. You may use the \nwith\n method to bind data to the view.\n\n\n\n\n{tip} All view composers are resolved via the \nservice container\n, so you may type-hint any dependencies you need within a composer's constructor.\n\n\n\n\nAttaching A Composer To Multiple Views\n\n\nYou may attach a view composer to multiple views at once by passing an array of views as the first argument to the \ncomposer\n method:\n\n\nView::composer(\n    [\nprofile\n, \ndashboard\n],\n    \nApp\\Http\\ViewComposers\\MyViewComposer\n\n);\n\n\n\n\n\nThe \ncomposer\n method also accepts the \n*\n character as a wildcard, allowing you to attach a composer to all views:\n\n\nView::composer(\n*\n, function ($view) {\n    //\n});\n\n\n\n\n\nView Creators\n\n\nView \ncreators\n are very similar to view composers; however, they are executed immediately after the view is instantiated instead of waiting until the view is about to render. To register a view creator, use the \ncreator\n method:\n\n\nView\n::\ncreator\n(\nprofile\n,\n \nApp\\Http\\ViewCreators\\ProfileCreator\n);", 
            "title": "Views"
        }, 
        {
            "location": "/views/#views", 
            "text": "Creating Views  Passing Data To Views  Sharing Data With All Views    View Composers", 
            "title": "Views"
        }, 
        {
            "location": "/views/#creating-views", 
            "text": "Views contain the HTML served by your application and separate your controller / application logic from your presentation logic. Views are stored in the  resources/views  directory. A simple view might look something like this:  !-- View stored in resources/views/greeting.blade.php --  html \n     body \n         h1 Hello,  {{   $ name   }} /h1 \n     /body  /html   Since this view is stored at  resources/views/greeting.blade.php , we may return it using the global  view  helper like so:  Route::get( / , function () {\n    return view( greeting , [ name  =   James ]);\n});  As you can see, the first argument passed to the  view  helper corresponds to the name of the view file in the  resources/views  directory. The second argument is an array of data that should be made available to the view. In this case, we are passing the  name  variable, which is displayed in the view using  Blade syntax .  Of course, views may also be nested within sub-directories of the  resources/views  directory. \"Dot\" notation may be used to reference nested views. For example, if your view is stored at  resources/views/admin/profile.blade.php , you may reference it like so:  return view( admin.profile , $data);", 
            "title": "Creating Views"
        }, 
        {
            "location": "/views/#determining-if-a-view-exists", 
            "text": "If you need to determine if a view exists, you may use the  View  facade. The  exists  method will return  true  if the view exists:  use Illuminate\\Support\\Facades\\View;\n\nif (View::exists( emails.customer )) {\n    //\n}", 
            "title": "Determining If A View Exists"
        }, 
        {
            "location": "/views/#passing-data-to-views", 
            "text": "As you saw in the previous examples, you may pass an array of data to views:  return view( greetings , [ name  =   Victoria ]);  When passing information in this manner,  $data  should be an array with key/value pairs. Inside your view, you can then access each value using its corresponding key, such as  ?php echo $key; ? . As an alternative to passing a complete array of data to the  view  helper function, you may use the  with  method to add individual pieces of data to the view:  return view( greeting )- with( name ,  Victoria );", 
            "title": "Passing Data To Views"
        }, 
        {
            "location": "/views/#sharing-data-with-all-views", 
            "text": "Occasionally, you may need to share a piece of data with all views that are rendered by your application. You may do so using the view facade's  share  method. Typically, you should place calls to  share  within a service provider's  boot  method. You are free to add them to the  AppServiceProvider  or generate a separate service provider to house them:  ? php  namespace   App \\ Providers ;  use   Illuminate \\ Support \\ Facades \\ View ;  class   AppServiceProvider   extends   ServiceProvider  { \n     /**       * Bootstrap any application services.       *       * @return void       */ \n     public   function   boot () \n     { \n         View :: share ( key ,   value ); \n     } \n\n     /**       * Register the service provider.       *       * @return void       */ \n     public   function   register () \n     { \n         // \n     }  }", 
            "title": "Sharing Data With All Views"
        }, 
        {
            "location": "/views/#view-composers", 
            "text": "View composers are callbacks or class methods that are called when a view is rendered. If you have data that you want to be bound to a view each time that view is rendered, a view composer can help you organize that logic into a single location.  For this example, let's register the view composers within a  service provider . We'll use the  View  facade to access the underlying  Illuminate\\Contracts\\View\\Factory  contract implementation. Remember, Laravel does not include a default directory for view composers. You are free to organize them however you wish. For example, you could create an  App\\Http\\ViewComposers  directory:  ? php  namespace   App \\ Providers ;  use   Illuminate \\ Support \\ Facades \\ View ;  use   Illuminate \\ Support \\ ServiceProvider ;  class   ComposerServiceProvider   extends   ServiceProvider  { \n     /**       * Register bindings in the container.       *       * @return void       */ \n     public   function   boot () \n     { \n         // Using class based composers... \n         View :: composer ( \n             profile ,   App\\Http\\ViewComposers\\ProfileComposer \n         ); \n\n         // Using Closure based composers... \n         View :: composer ( dashboard ,   function   ( $view )   { \n             // \n         }); \n     } \n\n     /**       * Register the service provider.       *       * @return void       */ \n     public   function   register () \n     { \n         // \n     }  }    {note} Remember, if you create a new service provider to contain your view composer registrations, you will need to add the service provider to the  providers  array in the  config/app.php  configuration file.   Now that we have registered the composer, the  ProfileComposer@compose  method will be executed each time the  profile  view is being rendered. So, let's define the composer class:  ? php  namespace   App \\ Http \\ ViewComposers ;  use   Illuminate \\ View \\ View ;  use   App \\ Repositories \\ UserRepository ;  class   ProfileComposer  { \n     /**       * The user repository implementation.       *       * @var UserRepository       */ \n     protected   $users ; \n\n     /**       * Create a new profile composer.       *       * @param  UserRepository  $users       * @return void       */ \n     public   function   __construct ( UserRepository   $users ) \n     { \n         // Dependencies automatically resolved by service container... \n         $this - users   =   $users ; \n     } \n\n     /**       * Bind data to the view.       *       * @param  View  $view       * @return void       */ \n     public   function   compose ( View   $view ) \n     { \n         $view - with ( count ,   $this - users - count ()); \n     }  }   Just before the view is rendered, the composer's  compose  method is called with the  Illuminate\\View\\View  instance. You may use the  with  method to bind data to the view.   {tip} All view composers are resolved via the  service container , so you may type-hint any dependencies you need within a composer's constructor.", 
            "title": "View Composers"
        }, 
        {
            "location": "/views/#attaching-a-composer-to-multiple-views", 
            "text": "You may attach a view composer to multiple views at once by passing an array of views as the first argument to the  composer  method:  View::composer(\n    [ profile ,  dashboard ],\n     App\\Http\\ViewComposers\\MyViewComposer \n);  The  composer  method also accepts the  *  character as a wildcard, allowing you to attach a composer to all views:  View::composer( * , function ($view) {\n    //\n});", 
            "title": "Attaching A Composer To Multiple Views"
        }, 
        {
            "location": "/views/#view-creators", 
            "text": "View  creators  are very similar to view composers; however, they are executed immediately after the view is instantiated instead of waiting until the view is about to render. To register a view creator, use the  creator  method:  View :: creator ( profile ,   App\\Http\\ViewCreators\\ProfileCreator );", 
            "title": "View Creators"
        }
    ]
}